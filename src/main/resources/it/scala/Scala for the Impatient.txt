The evolution of Java and C++ has slowed down considerably, and programmers who are eager to use more modern language features are looking elsewhere.
Scala is an attractive choice; in fact, I think it is by far the most attractive choice for programmers who want to move beyond Java or C++
Scala has a concise syntax that is refreshing after the Java boilerplate.
It runs on the Java virtual machine, providing access to a huge set of libraries and tools.
It embraces the functional programming style without abandoning object-orientation, giving you an incremental learning path to a new paradigm.
The Scala interpreter lets you run quick experiments, which makes learning Scala very enjoyable.
And, last but not least, Scala is statically typed, enabling the compiler to find errors, so that you don't waste time finding them later in running programs (or worse, don't find them)
I wrote this book for impatient readers who want to start programming with Scala right away.
I won't exhaustively list all features of the language, I won't lecture you about the superiority of one paradigm over another, and I won't make you suffer through long and contrived examples.
Instead, you will get the information that you need in compact chunks that you can read and review as needed.
Scala is a big language, but you can use it effectively without knowing all of its details intimately.
Martin Odersky, the creator of Scala, has identified the following levels of expertise for application programmers and library designers:
For each chapter (and occasionally for individual sections), I indicate the experience level.
Even if you don't want to design your own libraries, knowing about the tools that Scala provides for library designers can make you a more effective library user.
If you find errors or have suggestions for improvement, please visit http://horstmann.com/scala and leave a comment.
On that page, you will also find a link to an archive file containing all code examples from the book.
I am very grateful to Dmitry Kirsanov and Alina Kirsanova who turned my manuscript from XHTML into a beautiful book, allowing me to concentrate on the content instead of fussing with the format.
Finally, as always, my gratitude goes to my editor, Greg Doench, for encouraging me to write this book and for his insights during the development process.
In this chapter, you will learn how to use Scala as an industrial-strength pocket calculator, working interactively with numbers and arithmetic operations.
We introduce a number of important Scala concepts and idioms along the way.
You will also learn how to browse the Scaladoc documentation at a beginner’s level.
Make sure that the scala/bin directory is on the PATH.
As you can see, the interpreter also displays the type of the result—in our examples, Int, Double, and java.lang.String.
Depending on how you launched the interpreter, you may be able to use tab completion for method names.
If you can’t use tab completion in your environment, you’ll have to type the complete method name yourself.)
In most implementations, you will see the previously issued commands, and you can edit them.
As you can see, the Scala interpreter reads an expression, evaluates it, prints it, and reads the next expression.
Behind the scenes, your input is quickly compiled into bytecode, and the bytecode is executed by.
Instant feedback encourages experimenting, and you will feel good whenever something works.
It is a good idea to keep an editor window open at the same time, so you can copy and paste successful code snippets for later use.
Also, as you try more complex examples, you may want to compose them in the editor and then paste them into the REPL.
A value declared with val is actually a constant—you can’t change its contents:
To declare a variable whose contents can vary, use a var:
In Scala, you are encouraged to use a val unless you really need to change the contents.
Perhaps surprisingly for Java or C++ programmers, most programs don’t need many var variables.
Note that you need not specify the type of a value or variable.
It is inferred from the type of the expression with which you initialize it.
It is an error to declare a value or variable without initializing it.)
NOTE: In Scala, the type of a variable or function is always written after the name of the variable or function.
This makes it easier to read declarations with complex types.
As I move back and forth between Scala and Java, I ﬁnd that my ﬁngers write Java declarations such as String greeting on autopilot, so I have to rewrite them as greeting: String.This is a bit annoying, but when I work with complex Scala programs, I really appreciate that I don’t have to decrypt C-style type declarations.
NOTE: You may have noticed that there were no semicolons after variable declarations or assignments.
In Scala, semicolons are only required if you have multiple statements on the same line.
You have already seen some of the data types of the Scala language, such as Int and Double.
There is no distinction between primitive types and class types in Scala.
For now, just view it as a collection of numbers.)
It is the job of the Scala compiler to convert between primitive types and wrappers.
For example, if you make an array of Int, you get an int[] array in the virtual machine.
However, it augments that class with well over a hundred operations in the StringOps class.
For example, the intersect method yields the characters that are common to two strings:
In this expression, the java.lang.String object "Hello" is implicitly converted to a StringOps object, and then the intersect method of the StringOps class is applied.
Similarly, there are classes RichInt, RichDouble, RichChar, and so on.
Each of them has a small set of convenience methods for acting on their poor cousins—Int, Double, or Char.
The to method that you saw above is actually a method of the RichInt class.
Finally, there are classes BigInt and BigDecimal for computations with an arbitrary (but ﬁnite) number of digits.
These are backed by the java.math.BigInteger and java.math.BigDecimal classes, but, as you will see in the next section, they are much more convenient because you can use them with the usual mathematical operators.
NOTE: In Scala, you use methods, not casts, to convert between numeric types.
Of course, as in Java, the toString method converts any object to a string.
To convert a string containing a number into the number, use toInt or toDouble.
Arithmetic operators in Scala work just as you would expect in Java or C++:
There is just one surprising aspect: These operators are actually methods.
Scala has no silly prejudice against nonalphanumeric characters in method names.
For example, the BigInt class deﬁnes a method called /% that returns a pair containing the quotient and remainder of a division.
Beginning Scala programmers tend to stick to the Java syntax, and that is just ﬁne.
There is one notable difference between Scala and Java or C++
Some people wonder if there is any deep reason for Scala’s refusal to provide a ++ operator.
Note that you can’t simply implement a method called ++
Since the Int class is immutable, such a method cannot change an integer value.) The Scala designers decided it wasn’t worth having yet another special rule just to save one keystroke.
You can use the usual mathematical operators with BigInt and BigDecimal objects:
That’s much better than Java, where you would have had to call x.multiply(x).multiply(x)
NOTE: In Java, you cannot overload operators, and the Java designers claimed this is a good thing because it stops you from inventing crazy operators like !@$&* that would make your program impossible to read.
Of course, that’s silly; you can make your programs just as hard to read by using crazy method names like qxywz.
Scala allows you to deﬁne operators, leaving it up to you to use this feature with restraint and good taste.
It is simpler to use mathematical functions such as min or pow in Scala than in Java—you need not call static methods from a class.
NOTE: To use a package that starts with scala., you can omit the scala preﬁx.
We discuss the import statement in more detail in Chapter 7
Scala doesn’t have static methods, but it has a similar feature, called singleton objects, which we will discuss in detail in Chapter 6
Often, a class has a companion object whose methods act just like static methods do in Java.
For example, the BigInt companion object to the BigInt class has a method probablePrime that generates a random prime number with a given number of bits:
Try this in the REPL; you’ll get a number such as 1039447980491200275486540240713
Note that the call BigInt.probablePrime is similar to a static method call in Java.
NOTE: Here, Random is a singleton random number generator object, deﬁned in the scala.util package.
This is one of the few situations where a singleton object is better than a class.
In Java, it is a common error to construct a new java.util.Random object for each random number.
The rule of thumb is that a parameterless method that doesn’t modify the object has no parentheses.
In Scala, it is common to use a syntax that looks like a function call.
For example, if s is a string, then s(i) is the ith character of the string.
For example, in the documentation of the StringOps class, you will ﬁnd a method.
When you look at the documentation for the BigInt companion object, you will see apply methods that let you convert strings or numbers to BigInt objects.
It yields a new BigInt object, without having to use new.
Using the apply method of a companion object is a common Scala idiom for constructing objects.
Scala has its own variant, called Scaladoc (see Figure 1–1)
Scala classes tend to have many more convenience methods than Java classes.
Finally, some features are exposed as they are implemented, not as they are used.
The Scala team is working on improving the Scaladoc presentation, so that it can be more approachable to beginners in the future.)
Here are some tips for navigating Scaladoc, for a newcomer to the language.
You can browse Scaladoc online at www.scala-lang.org/api, but it is a good idea to download a copy from www.scala-lang.org/downloads#api and install it locally.
Unlike Javadoc, which presents an alphabetical listing of classes, Scaladoc’s class list is sorted by packages.
If you know the class name but not the package name, use the ﬁlter in the top left corner (see Figure 1–2)
Note the O and C symbols next to each class name.
They let you navigate to the class (C) or the companion object (O)
Remember to look into RichInt, RichDouble, and so on, if you want to know how to work with numeric types.
The mathematical functions are in the package scala.math, not in any class.
As you will see in Chapter 11, this is how you deﬁne the preﬁx negation operator -x.
For example, the BigInt object has conversions from int and long to BigInt that are automatically called when needed.
For example, the count method in StringOps requires a function that returns true or false for a Char, specifying which characters should be counted:
You supply a function, often in a very compact notation, when you call the method.
As an example, the call s.count(_.isUpper) counts the number of uppercase characters.
We will discuss this style of programming in much more detail in Chapter 12
You’ll occasionally run into classes such as Range or Seq[Char]
They mean what your intuition tells you—a range of numbers, a sequence of characters.
You will learn all about these classes as you delve more deeply into Scala.
It’s the Scala way to provide lots of methods for every conceivable use case.
When you need to solve a particular problem, just look for a method that is useful.
More often than not, there is one that addresses your task, which means you don’t have to write so much code yourself.
Finally, don’t worry if you run into the occasional indecipherable incantation, such as this one in the StringOps class:
There is another version of patch that looks more reasonable:
And it’s easy to try it out in the REPL:
In the Scala REPL, compute the square root of 3, and then square that value.
By how much does the result differ from 3? (Hint: The res variables are your friend.)
Poke around Scaladoc to ﬁnd a way of doing this in Scala.
In this chapter, you will learn how to implement conditions, loops, and functions in Scala.
You will encounter a fundamental difference between Scala and other programming languages.
An expression has a value; a statement carries out an action.
This feature can make programs more concise and easier to read.
A block has a value—the value of its last expression.
The Scala for loop is like an “enhanced” Java for loop.
Scala has an if/else construct with the same syntax as in Java or C++
However, in Scala, an if/else has a value, namely the value of the expression that follows the if or else.
However, the ﬁrst form is better because it can be used to initialize a val.
In the second form, s needs to be a var.
In this example, one branch is a java.lang.String, and the other an Int.
However, in Scala, every expression is supposed to have some value.
NOTE: Scala has no switch statement, but it has a much more powerful pattern matching mechanism that we will discuss in Chapter 14
CAUTION: The REPL is more nearsighted than the compiler—it only sees one line of code at a time.
If you want to break the line before the else, use braces:
In a compiled program, the parser will ﬁnd the else on the next line.
TIP: If you want to paste a block of code into the REPL without worrying about its nearsightedness, use paste mode.
The REPL will then analyze the block in its entirety.
In Java and C++, every statement ends with a semicolon.
A semicolon is also optional before an }, an else, and similar locations where it is clear from context that the end of a statement has been reached.
However, if you want to have more than one statement on a single line, you need to separate them with semicolons.
If you want to continue a long statement over two lines, you need to make sure that the ﬁrst line ends in a symbol that cannot be the end of a statement.
In practice, long expressions usually involve function or method calls, and then you don’t need to worry much—after an opening (, the compiler won’t infer the end of a statement until it has seen the matching )
In the same spirit, Scala programmers favor the Kernighan & Ritchie brace style:
The line ending with a { sends a clear signal that there is more to come.
Many programmers coming from Java or C++ are initially uncomfortable about omitting semicolons.
If you prefer to have them, just put them in—they do no harm.
You use a block statement whenever you need to put multiple actions in the body of a branch or loop statement.
The value of the block is the value of the last expression.
This feature can be useful if the initialization of a val takes more than one step.
The variables dx and dy, which were only needed as intermediate values in the computation, are neatly hidden from the rest of the program.
In Scala, assignments have no value—or, strictly speaking, they have a value of type Unit.
Recall that the Unit type is the equivalent of the void type in Java and.
A block that ends with an assignment statement, such as.
In contrast, in Java and C++, the value of an assignment is the value that is being assigned.
To print a value, use the print or println function.
There is also a printf function with a C-style format string:
You can read a line of input from the console with the readLine function.
To read a numeric, Boolean, or character value, use readInt, readDouble, readByte, readShort, readLong, readFloat, readBoolean, or readChar.
The readLine method, but not the other ones, take a prompt string:
Scala has the same while and do loops as Java and C++
Scala has no direct analog of the for (initialize; test; update) loop.
If you need such a loop, you have two choices.
You saw the to method of the RichInt class in Chapter 1
Exactly how that traversal works depends on the type of the expression.
For a Scala collection, such as a Range, the loop makes i assume each value in turn.
NOTE: There is no val or var before the variable in the for loop.
The type of the variable is the element type of the collection.The scope of the loop variable extends until the end of the loop.
In that case, use the until method instead of the to method.
It returns a range that doesn’t include the upper bound.
In this example, there is actually no need to use indexes.
In Scala, loops are not used as often as in other languages.
As you will see in Chapter 12, you can often process the values in a sequence by applying a function to all of them, which can be done with a single method call.
NOTE: Scala has no break or continue statements to break out of a loop.What to do if you need a break? Here are a few options:
Use nested functions—you can return from the middle of a function.
Here, the control transfer is done by throwing and catching an exception, so you should avoid this mechanism when time is of the essence.
In the preceding section, you saw the basic form of the for loop.
However, this construct is much richer in Scala than in Java or C++
You can have multiple generators of the form variable <- expression.
Each generator can have a guard, a Boolean condition preceded by if:
You can have any number of deﬁnitions, introducing variables that can be used inside the loop:
When the body of the for loop starts with yield, then the loop constructs a collection of values, one for each iteration:
NOTE: If you prefer, you can enclose the generators, guards, and deﬁnitions of a for loop inside braces, and you can use newlines instead of semicolons to separate them:
A method operates on an object, but a function doesn’t.
C++ has functions as well, but in Java, you have to imitate them with static methods.
To deﬁne a function, you specify the function’s name, parameters, and body like this:
If the body of the function requires more than one expression, use a block.
The last expression of the block becomes the value that the function returns.
For example, the following function returns the value of r after the for loop.
There is no need for the return keyword in this example.
It is possible to use return as in Java or C++, to exit a function immediately, but that is not commonly done in Scala.
TIP: While there is nothing wrong with using return in a named function (except the waste of seven keystrokes), it is a good idea to get used to life without return.
Pretty soon, you will be using lots of anonymous functions, and there, return doesn’t return a value to the caller.
It breaks out to the enclosing named function.Think of return as a kind of break statement for functions, and only use it when you want that breakout functionality.
With a recursive function, you must specify the return type.
NOTE: Some programming languages (such as ML and Haskell) can infer the type of a recursive function, using the Hindley-Milner algorithm.
Extending the Hindley-Milner algorithm so it can handle subtypes is still a research problem.
If you supply fewer arguments than there are parameters, the defaults are applied from the end.
You can also specify the parameter names when you supply the arguments.
Note that the named arguments need not be in the same order as the parameters.
They are also useful if a function has many default parameters.
You can mix unnamed and named arguments, provided the unnamed ones come ﬁrst:
You can call this function with as many arguments as you like.
The function receives a single parameter of type Seq, which we will discuss in Chapter 13
For now, all you need to know is that you can use a for loop to visit each element.
If you already have a sequence of values, you cannot pass it directly to such a function.
If the sum function is called with one argument, that must be a single integer, not a range of integers.
The remedy is to tell the compiler that you want the parameter to be considered an argument sequence.
Here, the head of a sequence is its initial element, and tail is a sequence of all other elements.
That’s again a Seq, and we have to use : _* to convert it to an argument sequence.
CAUTION: When you call a Java method with variable arguments of type Object, such as PrintStream.printf or MessageFormat.format, you need to convert any primitive types by hand.
This is the case for any Object parameter, but I mention it here because it is most common with varargs methods.
Scala has a special notation for a function that returns no value.
If the function Such a function is called a procedure.
A procedure returns no value, and you only call it for its side effect.
For example, the following procedure prints a string inside a box, like.
Some people (not me) dislike this concise syntax for procedures and suggest that you always use an explicit return type of Unit:
CAUTION: The concise procedure syntax can be a surprise for Java and C++ deﬁnition.You then get an error message at the point where the function is called, and you are told that Unit is not acceptable at that location.
For now, just take it for granted that this call reads all characters from a ﬁle into a string.)
If the program never accesses words, the ﬁle is never opened.
To verify this, try it out in the REPL, but misspell the ﬁle name.
There will be no error when the initialization statement is executed.
However, when you access words, you will get an error message that the ﬁle is not found.
They can also deal with other initialization issues, such as circular dependencies.
You can think of lazy values as halfway between val and def.
Evaluated as soon as words is deﬁned // Evaluated the ﬁrst time words is used // Evaluated every time words is used.
Every time a lazy value is accessed, a method is called that checks, in a threadsafe manner, whether the value has already been initialized.
Scala exceptions work the same way as in Java or C++
As in Java, the objects that you throw need to belong to a subclass of java.lang.Throwable.
NOTE: In Java, “checked” exceptions are checked at compile time.
If your method might throw an IOException, you must declare it.
This forces programmers to think where those exceptions should be handled, which is a laudable goal.
Unfortunately, it can also give rise to monstrous method ClassNotFoundException.
Many Java programmers detest this feature and end up defeating it by either catching exceptions too early or using excessively general exception classes.
The Scala designers decided against checked exceptions, recognizing that thorough compile-time checking isn’t always a good thing.
If one branch has type Nothing, the type of the if/else expression is the type of the other branch.
The ﬁrst branch has type Double, the second has type Nothing.
The syntax for catching exceptions is modeled after the pattern-matching syntax (see Chapter 14)
As in Java or C++, the more general exception types should come after the more speciﬁc ones.
Note that you can use _ for the variable name if you don’t need it.
The try/finally statement lets you dispose of a resource whether or not an exception has occurred.
The finally clause is executed whether or not the process function throws an exception.
This code is a bit subtle, and it raises several issues.
What if the URL constructor or the openStream method throws an exception? Then the try block is never entered, and neither is the finally clause.
That’s just as well—in was never initialized, so it makes no sense to invoke close on it.
This is just like in Java, and it isn’t very nice.
Ideally, the old exception would stay attached to the new one.)
The try/catch statement handles exceptions, and the try/finally statement takes some action (usually cleanup) when an exception is not handled.
It is possible to combine them into a single try/catch/finally statement:
Write a procedure countdown(n: Int) that prints the numbers from n to 0
Write a for loop for computing the product of the Unicode codes of all letters in a string.
For example, the product of the characters in "Hello" is 825152896
Write a function product(s : String) that computes the product, as described in the preceding exercises.
Make the function of the preceding exercise a recursive function.
Write a function that computes xn, where n is an integer.
In this chapter, you will learn how to work with arrays in Scala.
Java and C++ programmers usually choose an array or its close relation (such as array lists or vectors) when they need to collect a bunch of elements.
In Scala, there are other choices (see Chapter 13), but for now, I’ll assume you are impatient and just want to get going with arrays.
Use an Array if the length is ﬁxed, and an ArrayBuffer if the length can vary.
Scala and Java arrays are interoperable; with ArrayBuffer, use scala.collection.
If you need an array whose length doesn’t change, use the Array type in Scala.
The arrays in the preceding example have the type java.lang.String[] inside the JVM.
An array of Int, Double, or another equivalent of the Java primitive types is a primitive type array.
Java has ArrayList and C++ has vector for arrays that grow and shrink on demand.
You can also insert and remove elements at an arbitrary location, but those operations are not as efﬁcient—all elements after that location must be shifted.
Sometimes, you want to build up an Array, but you don’t yet know how many elements you will need.
In that case, ﬁrst make an array buffer, then call.
Conversely, call a.toBuffer to convert the array a to an array buffer.
In Java and C++, there are several syntactical differences between arrays and array lists/vectors.
Most of the time, you can use the same code for both.
Here is how you traverse an array or array buffer with a for loop:
The until method belongs to the RichInt class, and it returns all numbers up to (but not including) the upper bound.
To visit the elements starting from the end of the array, traverse.
If you don’t need the array index in the loop body, visit the array elements directly, like this:
In the preceding sections, you saw how to work with arrays just like you would in Java or C++
It is very easy to take an array (or array buffer) and transform it in some way.
Such transformations don’t modify the original array, but they yield a new one.
The for (...) yield loop creates a new collection of the same type as the original collection.
If you started with an array, you get another array.
If you started with an array buffer, that’s what you get from for (...) yield.
The result contains the expressions after the yield, one for each iteration of the loop.
Oftentimes, when you traverse a collection, you only want to process the elements that match a particular condition.
This is achieved with a guard: an if inside the for.
Here we double every even element, dropping the odd ones:
Keep in mind that the result is a new collection—the original collection is not affected.
Some programmers with experience in functional programming prefer filter and map to guards and yield.
That’s just a matter of style—the for loop does exactly the same work.
Given a sequence of integers, we want to remove all but the ﬁrst negative number.
A traditional sequential solution would set a ﬂag when the ﬁrst negative number is called, then remove all elements beyond.
We should start from the back after ﬁnding the ﬁrst match.
First, let’s use a for/yield loop to ﬁnd all matching index values.
Then we visit the indexes in reverse, except for indexes(0)
The key observation is that it is better to have all index values together instead of seeing them one by one.
It is often said that a large percentage of business computations are nothing but computing sums and sorting.
In order to use the sum method, the element type must be a numeric type: either an integral or ﬂoating-point type or BigInteger/BigDecimal.
Similarly, the min and max methods yield the smallest and largest element in an array or array buffer.
The sorted method sorts an array or array buffer and returns the sorted array or array buffer, without modifying the original:
You can sort an array, but not an array buffer, in place:
For the min, max, and quickSort methods, the element type must have a comparison operation.
This is the case for numbers, strings, and other types with the Ordered trait.
Finally, if you want to display the contents of an array or array buffer, the mkString method lets you specify the separator between elements.
A second variant has parameters for the preﬁx and sufﬁx.
There are lots of useful methods on arrays and array buffers, and it is a good idea to browse the Scala documentation to get an idea of what’s there.
NOTE: The methods for the Array class are listed under ArrayOps.
Technically, an array is converted to an ArrayOps object before any of the operations is applied.
Because Scala has a richer type system than Java, you may encounter some strange-looking syntax as you browse the Scala documentation.
Fortunately, you don’t have to understand all nuances of the type system to do useful work.
This method takes a predicate, a function from A to Boolean.
It counts for how many elements the function is true.
This method takes zero or more arguments of type A.
The xs parameter can be any collection with the TraversableOnce trait, the most general trait in the Scala collections hierarchy.
Other common traits that you may encounter in Scaladoc are Traversable and Iterable.
All Scala collections implement these traits, and the difference between them is academic for library users.
However, the Seq trait requires element access by an integer index.
When you work with an ArrayBuffer[A], you can just think of the method as.
Here, B is allowed to be a supertype of A.
Such an ordering exists for numbers, strings, and other types with the Ordered trait, as well as for classes that implement the Java Comparable interface.
This declaration happens when the method creates a new collection.
Skip it and look for the simpler alternative, in this case.
Like in Java, multidimensional arrays are implemented as arrays of arrays.
For example, a two-dimensional array of Double values has the type Array[Array[Double]]
Since Scala arrays are implemented as Java arrays, you can pass them back and forth between Java and Scala.
If you call a Java method that receives or returns a java.util.List, you could, of course, use a Java ArrayList in your Scala code—but that is unattractive.
Instead, you can use Scala buffers in your code, and they automatically get wrapped into Java lists when calling a Java method.
For example, the java.lang.ProcessBuilder class has a constructor with a List<String> parameter.
The Scala buffer is wrapped into an object of a Java class that implements the java.util.List interface.
Conversely, when a Java method returns a java.util.List, you can have it automatically converted into a Buffer:
You can’t use ArrayBuffer—the wrapped object is only guaranteed to be a Buffer.
If the Java method returns a wrapped Scala buffer, then the implicit conversion.
Write a code snippet that sets a to an array of n random integers between 0
Write a loop that swaps adjacent elements of an array of integers.
Repeat the preceding assignment, but produce a new array with the swapped values.
Given an array of integers, produce a new array that contains all positive values of the original array, in their original order, followed by all values that are zero or negative, in their original order.
Write a code snippet that produces all values from an array with duplicates removed.
Make a collection of all time zones returned by java.util.TimeZone.getAvailableIDs that are in America.
Import java.awt.datatransfer._ and make an object of type SystemFlavorMap with the call.
Then call the getNativesForFlavor method with parameter DataFlavor.imageFlavor and get the return value as a Scala buffer.
Why this obscure class? It’s hard to ﬁnd uses of java.util.List in the standard Java library.)
As you will see in this chapter, Scala makes it particularly easy to use them.
Scala has a general notation of tuples— aggregates of n objects, not necessarily of the same type.
A pair is simply a tuple together, and we brieﬂy discuss the syntax at the end of this chapter.
Scala has a pleasant syntax for creating, querying, and traversing maps.
By default, you get a hash map, but you can also get a tree map.
If you want to start out with a blank map, you have to pick a map implementation and supply type parameters:
A pair is simply a grouping of two values, not necessarily of the same type, such as ("Alice", 10)
The -> operator is just a little easier on the eyes than the parentheses.
It also supports the intuition that a map data structure is a kind of function that maps keys to values.
The difference is that a function computes values, and a map just looks them up.
In Scala, the analogy between functions and maps is particularly close because.
If the map doesn’t contain a value for the requested key, an exception is thrown.
To check whether there is a key with the given value, call the contains method:
Since this call combination is so common, there is a shortcut:
If the map contains the key "Bob", return the value; otherwise, return 0
Finally, the call map.get(key) returns an Option object that is either Some(value for key) or None.
Updates the existing value for the key "Bob" (assuming scores is mutable) // Adds a new key/value pair to scores (assuming it is mutable)
You can’t update an immutable map, but you can do something that’s just as useful—obtain a new map that has the desired update:
The newScores map contains the same associations as scores, except that "Bob" has been updated and "Fred" added.
Instead of saving the result as a new value, you can update a var:
Similarly, to remove a key from an immutable map, use the - operator to obtain a new map without the key:
You might think that it is inefﬁcient to keep constructing new maps, but that is not the case.
The old and new maps share most of their structure.
The following amazingly simple loop iterates over all key/value pairs of a map:
The magic here is that you can use pattern matching in a Scala for loop.
Chapter 14 has all the details.) That way, you get the key and value of each pair in the map without any tedious method calls.
If for some reason you just want to visit the keys or values, use the keySet and values methods, as you would in Java.
The values method returns an Iterable that you can use in a for loop.
When working with a map, you need to choose an implementation—a hash table or a balanced tree.
You might want a tree map if you don’t have a good hash function for the keys, or if you need to visit the keys in sorted order.
To get an immutable tree map instead of a hash map, use.
Unfortunately, there is (as of Scala 2.9) no mutable tree map.
Your best bet is to adapt a Java TreeMap, as described in Chapter 13
TIP: If you want to visit the keys in insertion order, use a LinkedHashMap.
If you get a Java map from calling a Java method, you may want to convert it to a Scala map so that you can use the pleasant Scala map API.
This is also useful if you want to work with a mutable tree map, which Scala doesn’t provide.
Then trigger the conversion by specifying the Scala map type:
Conversely, to pass a Scala map to a method that expects a Java map, provide the opposite implicit conversion.
Pairs are the simplest case of tuples— aggregates of values of different types.
A tuple value is formed by enclosing individual values in parentheses.
Usually, it is better to use pattern matching to get at the components of a tuple, for example.
You can use a _ if you don’t need all components:
Tuples are useful for functions that return more than one value.
For example, the partition method of the StringOps class returns a pair of strings, containing the characters that fulﬁll a condition and those that don’t:
One reason for using tuples is to bundle together values so that they can be processed together.
TIP: The toMap method turns a collection of pairs into a map.
If you have a collection of keys and a parallel collection of values, then zip them up and turn them into a map like this:
Use a mutable map to count how often each word appears.
At the end, print out all words and their counts.
Repeat the preceding exercise with a sorted map, so that the words are printed in sorted order.
Deﬁne a linked hash map that maps "Monday" to java.util.Calendar.MONDAY, and similarly for the other weekdays.
You need to ﬁnd the length of the longest key before you can print the table.
Write a function minmax(values: Array[Int]) that returns a pair containing the smallest and largest values in the array.
Write a function lteqgt(values: Array[Int], v: Int) that returns a triple containing the counts of values less than v, equal to v, and greater than v.
What happens when you zip together two strings, such as "Hello".zip("World")? Come up with a plausible use case.
In this chapter, you will learn how to implement classes in Scala.
If you know classes in Java or C++, you won’t ﬁnd this difﬁcult, and you will enjoy the much more concise notation of Scala.
Use the @BeanProperty annotation to generate the JavaBeans getXxx/setXxx methods.
Every class has a primary constructor that is “interwoven” with the class deﬁnition.
The primary constructor executes all statements in the body of the class.
In its simplest form, a Scala class looks very much like its equivalent in Java or C++:
A Scala source ﬁle can contain multiple classes, and all of them have public visibility.
To use this class, you construct objects and invoke methods in the usual way:
You can call a parameterless method (such as current) with or without parentheses:
When writing a Java class, we don’t like to use public ﬁelds:
With a public ﬁeld, anyone could write to fred.age, making Fred younger or older.
That’s why we prefer to use getter and setter methods:
A getter/setter pair such as this one is often called a property.
We say that the class Person has an age property.
But if that becomes a problem, we can guard against it:
Getters and setters are better than public ﬁelds because they let you start with simple get/set semantics and evolve them as needed.
NOTE: Just because getters and setters are better than public ﬁelds doesn’t mean they are always good.
Often, it is plainly bad if every client can get or set bits and pieces of an object’s state.
In this section, I show you how to implement properties in Scala.
It is up to you to choose wisely when a gettable/settable property is an appropriate design.
Scala generates a class for the JVM with a private age ﬁeld and getter and setter methods.
These methods are public because we did not declare age as private.
For a private ﬁeld, the getter and setter methods are private.)
NOTE: To see these methods with your own eyes, compile the Person class and then look at the bytecode with javap:
NOTE: In Scala, the getters and setters are not named getXxx and setXxx, but they fulﬁll the same purpose.
At any time, you can redeﬁne the getter and setter methods yourself.
The user of your class still accesses fred.age, but now Fred can’t get younger:
NOTE: Bertrand Meyer, the inventor of the inﬂuential Eiffel language, formulated the Uniform Access Principle that states: “All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.” In Scala, the caller of fred.age doesn’t know whether age is implemented through a ﬁeld or a method.
Of course, in the JVM, the service is always implemented through a method, either synthesized or programmer-supplied.)
TIP: It may sound scary that Scala generates getter and setter methods for every ﬁeld.
If the ﬁeld is private, the getter and setter are private.
If the ﬁeld is a val, only a getter is generated.
Sometimes you want a read-only property with a getter but no setter.
If the value of the property never changes after the object has been constructed, use a val ﬁeld:
Scala makes a private final ﬁeld and a getter method, but no setter.
Sometimes, however, you want a property that a client can’t set at will, but that is mutated in some other way.
Conceptually, the counter has a current property that is updated when the increment method is called, but there is no setter for the property.
You can’t implement such a property with a val—a val never changes.
Instead, provide a private ﬁeld and a property getter, like this:
NOTE: In Scala, you cannot have a write-only property (that is, a property with a setter and no getter)
TIP: When you see a ﬁeld in a Scala class, remember that it is not the same as a ﬁeld in Java or C++
It is a private ﬁeld together with a getter (for a val ﬁeld) or a getter and a setter (for a var ﬁeld)
In Scala (as well as in Java or C++), a method can access the private ﬁelds of all objects of its class.
Accessing other.value is legal because other is also a Counter object.
Scala allows an even more severe access restriction, with the private[this] qualiﬁer:
Now, the methods of the Counter class can only access the value ﬁeld of the current object, not of other objects of type Counter.
This access is sometimes called object-private, and it is common in some OO languages, such as SmallTalk.
With a class-private ﬁeld, Scala generates private getter and setter methods.
However, for an object-private ﬁeld, no getters and setters are generated at all.
NOTE: Scala allows you to grant access rights to speciﬁc classes.
Here, the ClassName must be the name of the class being deﬁned or an enclosing class.
In this case, the implementation will generate auxiliary getter and setter methods that allow the enclosing class to access the ﬁeld.
These methods will be public because the JVM does not have a ﬁne-grained access control system, and they will have implementation-dependent names.
However, the names of these methods are not what Java tools expect.
The JavaBeans speciﬁcation (www.oracle.com/ technetwork/java/javase/tech/index-jsp-138795.html) deﬁnes a Java property as a pair of getFoo/setFoo methods (or just a getFoo method for a read-only property)
When you annotate a Scala ﬁeld with @BeanProperty, then such methods are automatically generated.
Table 5–1 shows which methods are generated in all cases.
To implement a property that is publicly accessible and backed by a field.
To confine the field to the methods of this class, just like in Java.
To confine the field to methods invoked on the same object.
As in Java or C++, a Scala class can have as many constructors as you like.
However, a Scala class has one constructor that is more important than all the others, called the primary constructor.
In addition, a class may have any number of auxiliary constructors.
We discuss auxiliary constructors ﬁrst because they are easier to understand.
They are very similar to constructors in Java or C++, with just two differences.
Each auxiliary constructor must start with a call to a previously deﬁned auxiliary constructor or the primary constructor.
We will look at the primary constructor in the next section.
For now, it is sufﬁcient to know that a class for which you don’t deﬁne a primary constructor has a primary constructor with no arguments.
You can construct objects of this class in three ways:
The primary constructor is not deﬁned with a this method.
The parameters of the primary constructor are placed immediately after the class name.
Parameters of the primary constructor turn into ﬁelds that are initialized with the construction parameters.
In our example, name and age become ﬁelds of the Person class.
A constructor call such as new Person("Fred", 42) sets the name and age ﬁelds.
Half a line of Scala is the equivalent of seven lines of Java:
The primary constructor executes all statements in the class deﬁnition.
This is useful when you need to conﬁgure a ﬁeld during construction.
NOTE: If there are no parameters after the class name, then the class has a primary constructor with no parameters.
That constructor simply executes all statements in the body of the class.
TIP: You can often eliminate auxiliary constructors by using default arguments in the primary constructor.
Primary constructor parameters can have any of the forms in Table 5–1
Construction parameters can also be regular method parameters, without val or var.
How these parameters are processed depends on their usage inside the class.
If a parameter without val or var is used inside at least one method, it becomes a ﬁeld.
It’s just a regular parameter that can be accessed in the code of the primary constructor.
Table 5–2 summarizes the ﬁelds and methods that are generated for different kinds of primary constructor parameters.
If you ﬁnd the primary constructor notation confusing, you don’t need to use it.
Just provide one or more auxiliary constructors in the usual way, but remember.
Martin Odersky suggests to think about it this way: In Scala, classes take parameters, just like methods do.
NOTE: When you think of the primary constructor’s parameters as class parameters, parameters without val or var become easier to understand.The scope of such a parameter is the entire class.
If you do, it is the compiler’s job to save it in a ﬁeld.
TIP: The Scala designers think that every keystroke is precious, so they let you combine a class with its primary constructor.
When reading a Scala class, you need to disentangle the two.
NOTE: To make the primary constructor private, place the keyword private like this:
A class user must then use an auxiliary constructor to construct a Person object.
You can deﬁne functions inside other functions, and classes inside other classes.
In Scala, each instance has its own class Member, just like each instance has its own ﬁeld members.
NOTE: This is different from Java, where an inner class belongs to the outer class.
For example, to make a new inner object, you simply use new with the type name: new chatter.Member.
In our network example, you can add a member within its own network, but not across networks.
No—can’t add a myFace.Member to a buffer of chatter.Member elements.
NOTE: In a nested class, you can access the this reference of the enclosing class as EnclosingClass.this, like in Java.
If you like, you can establish an alias for that reference with the following syntax:
The name self is common, but perhaps confusing when used with nested classes.
Write a class BankAccount with methods deposit and withdraw, and a read-only property balance.
Write a class Time with read-only properties hours and minutes and a method before(other: Time): Boolean that checks whether this time comes before the other.
That is, client code should be unaffected by your change.
Make a class Student with read-write JavaBeans properties name (of type String) and id (of type Long)
Write a class Person with a primary constructor that accepts a string containing a ﬁrst name, a space, and a last name, such as new Person("Fred Smith")
Make a class Car with read-only properties for manufacturer, model name, and model year, and a read-write property for the license plate.
Optionally, model year and license plate can also be speciﬁed in the constructor.
If not, the model year is set to -1 and the license plate to the empty string.
Rewrite it to use explicit ﬁelds and a default primary constructor.
In this short chapter, you will learn when to use the object construct in Scala.
Use it when you need a class with a single instance, or when you want to ﬁnd a home for miscellaneous values or functions.
A class can have a companion object with the same name.
The apply method of an object is usually used for constructing new instances of the companion class.
To avoid the main method, use an object that extends the App trait.
An object deﬁnes a single instance of a class with the features that you want.
When you need a new unique account number in your application, call.
The constructor of an object is executed when the object is ﬁrst used.
In our example, the Accounts constructor is executed with the ﬁrst call to.
There is just one exception: You cannot provide constructor parameters.
You use an object in Scala whenever you would have used a singleton object in Java or C++:
When a single instance is required to coordinate some service (the singleton design pattern)
NOTE: Many people view the singleton design pattern with disdain.
Scala gives you the tools for both good and bad design, and it is up to you to use them wisely.
In Java or C++, you often have a class with both instance methods and static methods.
In Scala, you achieve this by having a class and a “companion” object of the same name.
The class and its companion object can access each other’s private features.
NOTE: The companion object of a class is accessible, but it is not in scope.
TIP: In the REPL, you must deﬁne the class and the object together in paste mode.
Then type or paste both the class and object deﬁnitions, and type Ctrl+D.
An object can extend a class and/or one or more traits.
The result is an object of a class that extends the given class and/or traits, and in addition has all of the features speciﬁed in the object deﬁnition.
One useful application is to specify default objects that can be shared.
For example, consider a class for undoable actions in a program.
The DoNothingAction object can be shared across all places that need this default.
It is common to have objects with an apply method.
The apply method is called for expressions of the form.
Typically, such an apply method returns an object of the companion class.
For example, the Array object deﬁnes apply methods that allow array creation with expressions such as.
Why doesn’t one just use a constructor? Not having the new keyword is handy for nested expressions, such as.
Each Scala program must start with an object’s main method of type Array[String]
Instead of providing a main method for your application, you can extend the App trait and place the program code into the constructor body:
If you need the command-line arguments, you can get them from the args property:
If you invoke the application with the scala.time option set, then the elapsed time is displayed when the program exits.
The App trait extends another trait, DelayedInit, that gets special handling from the compiler.
All initialization code of a class with that trait is moved into a delayedInit method.
The main of the App trait method captures the command-line arguments, calls the delayedInit method, and optionally prints the elapsed time.
NOTE: Older versions of Scala had an Application trait for the same purpose.
That trait carried out the program’s action in the static initializer, which is not optimized by the just-in-time compiler.
Unlike Java or C++, Scala does not have enumerated types.
However, the standard library provides an Enumeration helper class that you can use to produce enumerations.
Deﬁne an object that extends the Enumeration class and initialize each value in your enumeration with a call to the Value method.
Here we deﬁne three ﬁelds, Red, Yellow, and Green, and initialize each of them with a call to Value.
Each call to the Value method returns a new instance of an inner class, also called Value.
Alternatively, you can pass IDs, names, or both to the Value method:
If not speciﬁed, the ID is one more than the previously assigned one, starting with zero.
You can now refer to the enumeration values as TrafficLightColor.Red, TrafficLightColor.Yellow, and so on.
See Chapter 7 for more information on importing members of a class or object.)
Remember that the type of the enumeration is TrafficLightColor.Value and not TrafficLightColor—that’s the type of the object holding the values.
Now the type of the enumeration is TrafficLightColor.TrafficLightColor, which is only an improvement if you use an import statement.
The ID of an enumeration value is returned by the id method, and its name by the toString method.
Finally, you can look up an enumeration value by its ID or name.
Why is this not actually a good idea? (Have a close look at the methods of the Point class.)
Write a Scala application, using the App trait, that prints the command-line arguments in reverse order, separated by spaces.
Implement a function that checks whether a card suit value from the preceding exercise is red.
IDs, use the color values (for example, 0xff0000 for Red)
In this chapter, you will learn how packages and import statements work in Scala.
Both packages and imports are more regular than in Java; they are also a bit more ﬂexible.
A chain x.y.z in a package clause leaves the intermediate packages x and x.y invisible.
Package statements without braces at the top of the ﬁle extend to the entire ﬁle.
Packages in Scala fulﬁll the same purpose as packages in Java or namespaces in C++: to manage names in a large program.
For example, the name Map can occur in the packages scala.collection.immutable and scala.collection.mutable without conﬂict.
To access either name, you can use the fully qualiﬁed scala.collection.immutable.Map or scala.collection.mutable.Map.
To add items to a package, you can include them in package statements, such as:
Then the class name Employee can be accessed anywhere as com.horstmann.impatient.
Unlike the deﬁnition of an object or a class, a package can be deﬁned in multiple ﬁles.
The preceding code might be in a ﬁle Employee.scala, and a ﬁle Manager.scala might contain.
NOTE: There is no enforced relationship between the directory of the source ﬁle and the package.You don’t have to put Employee.scala and Manager.scala into a com/horstmann/impatient directory.
Conversely, you can contribute to more than one package in a single ﬁle.
In Scala, the scope rules for packages are more consistent than those in Java.
Everything in the parent package is in scope, and it is not necessary to use com.horstmann.Utils.percentOf.
You could, though, if you prefer—after all, com is also in scope.)
This code takes advantage of the fact that the scala package is always imported.
And now suppose someone introduces the following package, perhaps in a different ﬁle:
It looks for a mutable member inside the com.horstmann.collection package and doesn’t ﬁnd it.
The intent in the Manager class was the collection package in the top-level scala package, not whatever collection subpackage happened to be in some accessible scope.
In Java, this problem can’t occur because package names are always absolute, starting at the root of the package hierarchy.
But in Scala, package names are relative, just like inner class names.
With inner classes, one doesn’t usually run into problems because all the code is in one ﬁle, under control of whoever is in charge of that ﬁle.
One solution is to use absolute package names, starting with _root_, for example:
Another approach is to use “chained” package clauses, as detailed in the next section.
NOTE: Most programmers use complete paths for package names, without the _root_ preﬁx.
This is safe as long as everyone avoids names scala, java, com, org, and so on, for nested packages.
A package clause can contain a “chain,” or path segment, for example:
Members of com and com.horstmann are not visible here class Person ...
Now a com.horstmann.collection package would no longer be accessible as collection.
Instead of the nested notation that we have used up to now, you can have package clauses at the top of the ﬁle, without braces.
This is the preferred notation if all the code in the ﬁle belongs to the same package (which is the usual case)
Note that in the example above, everything in the ﬁle belongs to the package com.horstmann.impatient.people, but the package com.horstmann.impatient has also been opened up so you can refer to its contents.
A package can contain classes, objects, and traits, but not the deﬁnitions of functions or variables.
It would make more sense to add utility functions or constants to a package than to some Utils object.
You deﬁne it in the parent package, and it has the same name as the child package.
Note that the defaultName value didn’t need to be qualiﬁed because it was in the same package.
Behind the scenes, the package object gets compiled into a JVM class with static methods and ﬁelds, called package.class, inside the package.
In our example, that would be a class com.horstmann.impatient.people.package with a static ﬁeld defaultName.
In the JVM, you can use package as a class name.)
It is a good idea to use the same naming scheme for source ﬁles.
That way, anyone who wants to add functions or variables to a package can ﬁnd the package object easily.
In Java, a class member that isn’t declared as public, private, or protected is visible in the package containing the class.
In Scala, you can achieve the same effect with qualiﬁers.
Imports let you use short names instead of long ones.
If you don’t mind long names, you’ll never need them.
This is the same as the * wildcard in Java.
In Scala, * is a valid character for an identiﬁer.
You can also import all members of a class or object.
Java programmers seem to live in fear of this variant, but in Scala it is commonly used.
Once you import a package, you can access its subpackages with shorter names.
The event package is a member of java.awt, and the import brings it into scope.
In Scala, an import statement can be anywhere, not just at the top of a ﬁle.
The scope of the import statement extends until the end of the enclosing block.
This is a very useful feature, particularly with wildcard imports.
It is always a bit worrisome to import lots of names from different sources.
In fact, some Java programmers dislike wildcard imports so much that they never use them, but let their IDE generate long lists of imported classes.
By putting the imports where they are needed, you can greatly reduce the potential for conﬂicts.
If you want to import a few members from a package, use a selector like this:
Now JavaHashMap is a java.util.HashMap and plain HashMap is a scala.collection.
Now HashMap unambiguously refers to scala.collection.mutable.HashMap since java.util.HashMap is hidden.
Next, the scala package is imported, but in a special way.
Unlike all other imports, this one is allowed to override the preceding import.
For example, scala.StringBuilder overrides java.lang.StringBuilder instead of conﬂicting with it.
These could equally well have been placed into the scala package object, but Predef was introduced before Scala had package objects.)
Since the scala package is imported by default, you never need to write package names that start with scala.
Write a puzzler that bafﬂes your Scala friends, using a package com that isn’t at the top level.
Why do you think the Scala language designers provided the package object syntax instead of simply letting you add functions and variables to a package?
Write a program that copies all elements from a Java hash map into a Scala hash map.
In the preceding exercise, move all imports into the innermost scope possible.
Write a program that imports the java.lang.System class, reads the user name from the user.name system property, reads a password from the Console object, and prints a message to the standard error stream if the password is not "secret"
Do not use any other imports, and do not use any qualiﬁed names (with dots)
Apart from StringBuilder, what other members of java.lang does the scala.
In this chapter, you will learn the most important ways in which inheritance in Scala differs from its counterparts in Java and C++
Only the primary constructor can call the primary superclass constructor.
In this chapter, we only discuss the case in which a class inherits from another class.
You extend a class in Scala just like you would in Java—with the extends keyword:
As in Java, you specify ﬁelds and methods that are new to the subclass or that override methods in the superclass.
As in Java, you can declare a class final so that it cannot be extended.
Unlike Java, you can also declare individual methods or ﬁelds final so that they cannot be overridden.
In Scala, you must use the override modiﬁer when you override a method that isn’t abstract.
The override modiﬁer can give useful error messages in a number of common situations, such as:
When you misspell the name of the method that you are overriding.
When you accidentally provide a wrong parameter type in the overriding method.
When you introduce a new method in a superclass that clashes with a subclass method.
NOTE: The last case is an instance of the fragile base class problem, where a change in the superclass cannot be veriﬁed without looking at all the subclasses.
Suppose programmer Alice deﬁnes a Person class, and, unbeknownst to Alice, programmer Bob deﬁnes a subclass Student with a method id yielding the student ID.
Later, Alice also deﬁnes a method id that holds the person’s national ID.
When Bob picks up that change, something may break in Bob’s program (but not in Alice’s test cases) since Student objects now return unexpected IDs.
In Java, one is often advised to “solve” this problem by declaring all methods as final unless they are explicitly designed to be overridden.
That sounds good in theory, but programmers hate it when they can’t make even the most innocuous changes to a method (such as adding a logging call)
Invoking a superclass method in Scala works exactly like in Java, with the keyword super:
The call super.toString invokes the toString method of the superclass—that is, the Person.toString method.
To test whether an object belongs to a given class, use the isInstanceOf method.
If the test succeeds, you can use the asInstanceOf method to convert a reference to a subclass reference:
The p.isInstanceOf[Employee] test succeeds if p refers to an object of class Employee or its subclass (such as Manager)
If p is not an Employee, then p.asInstanceOf[Employee] throws an exception.
If you want to test whether p refers to a Employee object, but not a subclass, use.
The classOf method is deﬁned in the scala.Predef object that is always imported.
Table 8–1 shows the correspondence between Scala and Java type checks and casts.
However, pattern matching is usually a better alternative to using type checks and casts.
As in Java or C++, you can declare a ﬁeld or method as protected.
Such a member is accessible from any subclass, but not from other locations.
Unlike in Java, a protected member is not visible throughout the package to which the class belongs.
Recall from Chapter 5 that a class has one primary constructor and any number of auxiliary constructors, and that all auxiliary constructors must start with a call to a preceding auxiliary constructor or the primary constructor.
As a consequence, an auxiliary constructor can never invoke a superclass constructor directly.
The auxiliary constructors of the subclass eventually call the primary constructor of the subclass.
Recall that the primary constructor is intertwined with the class deﬁnition.
Intertwining the class and the constructor makes for very concise code.
You may ﬁnd it helpful to think of the primary constructor parameters as parameters of.
Here, the Employee class has three parameters: name, age, and salary, two of which it “passes” to the superclass.
In Java, the equivalent code is quite a bit more verbose:
NOTE: In a Scala constructor, you can never call super(params), as you would in Java, to call the superclass constructor.
Its primary constructor must invoke one of the constructors of the Java superclass.
Recall from Chapter 5 that a ﬁeld in Scala consists of a private ﬁeld and accessor/mutator methods.
You can override a val (or a parameterless def) with another val ﬁeld of the same name.
The subclass has a private ﬁeld and a public getter, and the getter overrides the superclass getter (or method)
This example shows the mechanics, but it is rather artiﬁcial.
A more common case is to override an abstract def with a val, like this:
A val can only override another val or a parameterless def.
Only if the superclass var is abstract (see Section 8.8)
NOTE: In Chapter 5, I said that it’s OK to use a var because you can always change your mind and reimplement it as a getter/setter pair.
However, the programmers extending your class do not have that choice.
In other words, if you provide a var, all subclasses are stuck with it.
As in Java, you make an instance of an anonymous subclass if you include a block with deﬁnitions or overrides, such as.
As in Java, you can use the abstract keyword to denote a class that cannot be instantiated, usually because one or more of its methods are not deﬁned.
Here we say that every person has an ID, but we don’t know how to compute it.
Each concrete subclass of Person needs to specify an id method.
In Scala, unlike Java, you do not use the abstract keyword for an abstract method.
As in Java, a class with at least one abstract method must be declared abstract.
In a subclass, you need not use the override keyword when you deﬁne a method that was abstract in the superclass.
In addition to abstract methods, a class can also have abstract ﬁelds.
An abstract ﬁeld is simply a ﬁeld without an initial value.
This class deﬁnes abstract getter methods for the id and name ﬁelds, and an abstract setter for the name ﬁeld.
As with methods, no override keyword is required in the subclass when you deﬁne a ﬁeld that was abstract in the superclass.
You can always customize an abstract ﬁeld by using an anonymous type:
For simplicity, we assume the creature lives in a one-dimensional world, and the sensory data are represented as integers.
The range value is used in the superclass constructor, and the superclass constructor runs before the subclass constructor.
The Ant constructor calls the Creature constructor before doing its own construction.
That is the initial value of all integer ﬁelds when an object is allocated.)
The Ant constructor continues, setting its range ﬁeld to 2
The moral is that you should not rely on the value of a val in the body of a constructor.
In Java, you have a similar issue when you call a method in a superclass constructor.
The method might be overridden in a subclass, and it might not do what you want it to do.
In fact, that is the root cause of our problem—the expression range calls the getter method.)
Declare the val as lazy in the superclass (see Chapter 2)
The syntax is so ugly that only a mother could love it.
You place the val ﬁelds in a block after the extends keyword, like this:
The right-hand side of an early deﬁnition can only refer to previous early deﬁnitions, not to other ﬁelds or methods of the class.
TIP: You can debug construction order problems with the -Xcheckinit compiler ﬂag.
This ﬂag generates code that throws an exception (instead of yielding the default value) when an uninitialized ﬁeld is accessed.
NOTE: At the root of the construction order problem lies a design decision of the Java language—namely, to allow the invocation of subclass methods in a superclass constructor.
In C++, an object’s virtual function table pointer is set to the table of the superclass when the superclass constructor executes.
Afterwards, the pointer is set to the subclass table.Therefore, in C++, it is not possible to modify constructor behavior through overriding.The Java designers felt that this subtlety was unnecessary, and the Java virtual machine does not adjust the virtual function table during construction.
The classes that correspond to the primitive types in Java, as well as the type Unit, extend AnyVal.
All other classes are subclasses of the AnyRef class, which is a synonym for the Object class from the Java or .NET virtual machine.
Both AnyVal and AnyRef extend the Any class, the root of the hierarchy.
The AnyRef class adds the monitor methods wait and notify/notifyAll from the Object class.
It also provides a synchronized method with a function parameter.
That method is the equivalent of a synchronized block in Java.
NOTE: Just like in Java, I suggest you stay away from wait, notify, and synchronized unless you have a good reason to use them instead of higher-level concurrency constructs.
All Scala classes implement the marker interface ScalaObject, which has no methods.
At the other end of the hierarchy are the Nothing and Null types.
Null is the type whose sole instance is the value null.
You can assign null to any reference, but not to one of the value types.
For example, setting an Int to null is not possible.
This is better than in Java, where it would be possible to set an Integer wrapper to null.
CAUTION: The Nothing type is not at all the same as void in Java or C++
In Note that Unit is not a supertype of any other type.
When you implement a class, you should consider overriding the equals method to provide a natural notion of equality for your situation.
For example, if you deﬁne a class Item(val description: String, val price: Double), you might want to consider two items equal if they have the same description and price.
NOTE: We deﬁned the method as final because it is generally very difﬁcult to correctly extend equality in a subclass.The problem is symmetry.You want a.equals(b) to have the same result as b.equals(a), even when b belongs to a subclass.
CAUTION: Be sure to deﬁne the equals method with parameter type Any.
This is a different method that does not override the equals method of AnyRef.
When you deﬁne equals, remember to deﬁne hashCode as well.
The hash code should be computed only from the ﬁelds that you use in the equality check.
In the Item example, combine the hash codes of the ﬁelds:
TIP: You are not compelled to override equals and hashCode.
For many classes, it is appropriate to consider distinct objects unequal.
For example, if you have two distinct input streams or radio buttons, you will never consider them equal.
In an application program, you don’t generally call eq or equals.
Extend the following BankAccount class to a CheckingAccount class that charges $1
Extend the BankAccount class of the preceding exercise into a class SavingsAccount that earns interest every month (when a method earnMonthlyInterest is called) and has three free deposits or withdrawals every month.
Consult your favorite Java or C++ textbook that is sure to have an example of a toy inheritance hierarchy, perhaps involving employees, pets, graphical shapes, or the like.
Deﬁne an abstract class Item with methods price and description.
A SimpleItem is an item whose price and description are speciﬁed in the constructor.
Take advantage of the fact that a val can override a def.
Its price is the sum of the prices in the bundle.
Also provide a mechanism for adding items to the bundle and a suitable description method.
Design a class Point whose x and y coordinate values can be provided in a constructor.
Provide a subclass LabeledPoint whose constructor takes a label value and x and y coordinates, such as.
Provide appropriate constructors for the subclasses and override the centerPoint method in each subclass.
Hint: Review the discussion of private constructors in Chapter 5.)
In this chapter, you will learn how to carry out common ﬁle processing tasks, such as reading all lines or words from a ﬁle or reading a ﬁle containing numbers.
To convert a string into a number, use the toInt or toDouble method.
Use """...""" if your regular expression contains backslashes or quotes.
To read all lines from a ﬁle, call the getLines method on a scala.io.Source object:
The ﬁrst argument can be a string or a java.io.File // You can omit the encoding if you know that the ﬁle uses // the default platform encoding.
You can use it to process the lines one at a time:
Or you can put the lines into an array or array buffer by applying the toArray or toBuffer method to the iterator:
Sometimes, you just want to read an entire ﬁle into a string.
CAUTION: Call close when you are done using the Source object.
To read individual characters from a ﬁle, you can use a Source object directly as an iterator since the Source class extends Iterator[Char]:
If you want to be able to peek at a character without consuming it (like istream::peek in C++ or a PushbackInputStreamReader in Java), call the buffered method on the source.
Then you can peek at the next input character with the head method without consuming it.
Alternatively, if your ﬁle isn’t large, you can just read it into a string and process that:
Here is a quick-and-dirty way of reading all whitespace-separated tokens in a source:
To convert a string into a number, use the toInt or toDouble method.
For example, if you have a ﬁle containing ﬂoating-point numbers, you can read them all into an array by.
TIP: Remember—you can always use the java.util.Scanner class to process a ﬁle that contains a mixture of text and numbers.
Finally, note that you can read numbers from the console:
CAUTION: These methods assume that the next input line contains a single number, without leading or trailing whitespace.
The Source object has methods to read from sources other than ﬁles:
Reads from the given string—useful for debugging // Reads from standard input.
CAUTION: When you read from a URL, you need to know the character set in advance, perhaps from an HTTP header.
Here is how you can read a ﬁle into a byte array:
To write a text ﬁle, use a java.io.PrintWriter, for example:
When you pass a number to printf, the compiler will complain that you need to convert it to an AnyRef:
NOTE: The printf method of the Console class does not suffer from this problem.You can use.
There are currently no “ofﬁcial” Scala classes for visiting all ﬁles in a directory, or for recursively traversing directories.
NOTE: A prior version of Scala had File and Directory classes.You can still ﬁnd them in the scala.tools.nsc.io package inside scala-compiler.jar.
It is simple to write a function that produces an iterator through all subdirectories of a directory:
With this function, you can visit all subdirectories like this:
Alternatively, if you use Java 7, you can adapt the walkFileTree method of the java.nio.file.Files class.
In Scala, we generally prefer to use function objects, not interfaces, for specifying work (even though in this case the interface allows more ﬁne-grained control—see the Javadoc for details)
The following implicit conversion adapts a function to the interface:
Of course, if you don’t just want to print the ﬁles, you can specify other actions in the function that you pass to the walkFileTree method.
In Java, serialization is used to transmit objects to other virtual machines or for short-term storage.
For long-term storage, serialization can be awkward—it is tedious to deal with different object versions as classes evolve over time.)
Here is how you declare a serializable class in Java and Scala.
The Serializable trait is deﬁned in the scala package and does not require an import.
NOTE: You can omit the @SerialVersionUID annotation if you are OK with the default ID.
The Scala collections are serializable, so you can have them as members of your serializable classes:
The shell language makes it easy to specify subsets of ﬁles, and to pipe the output of one program into the input of another.
However, as programming languages, most shell languages leave much to be desired.
Scala was designed to scale from humble scripting tasks to massive programs.
The scala.sys.process package provides utilities to interact with shell programs.
You can write your shell scripts in Scala, with all the power that the Scala language puts at your disposal.
The sys.process package contains an implicit conversion from strings to ProcessBuilder objects.
You can pipe the output of one program into the input of another, using the #| operator:
NOTE: As you can see, the process library uses the commands of the underlying operating system.
To redirect the output to a ﬁle, use the #> operator:
But frankly, Scala is better at control ﬂow than the shell, so why not implement the control ﬂow in Scala?
If you need to run a process in a different directory, or with different environment variables, construct the ProcessBuilder with the apply method of the Process object.
Supply the command, the starting directory, and a sequence of (name, value) pairs for environment settings.
When you process input, you often want to use regular expressions to analyze it.
To construct a Regex object, use the r method of the String class:
If the regular expression contains backslashes or quotation marks, then it is a good idea to use the “raw” string syntax, """..."""
To ﬁnd the ﬁrst match anywhere in a string, use findFirstIn.
To check whether the beginning of a string matches, use findPrefixOf:
Add parentheses around the subexpressions that you want to extract, for example:
If you want to extract groups from multiple matches, use a for statement like this:
Write a Scala program that reads a ﬁle with tabs, replaces each tab with spaces so that tab stops are at n-column boundaries, and writes the result to the same ﬁle.
Write a Scala code snippet that reads a ﬁle and prints all words with more than 12 characters to the console.
Extra credit if you can do this in a single line.
Write a Scala program that reads a text ﬁle containing only ﬂoating-point numbers.
Print the sum, average, maximum, and minimum of the numbers in the ﬁle.
Write a Scala program that prints out all such strings in a source ﬁle.
Write a Scala program that reads a text ﬁle and prints all tokens in the ﬁle that are not ﬂoating-point numbers.
Write a Scala program that prints the src attributes of all img tags of a web page.
Write a Scala program that counts how many ﬁles with .class extension are in a given directory and its subdirectories.
Expand the example with the serializable Person class that stores a collection of friends.
Construct a few Person objects, make some of them friends of another, and then save an Array[Person] to a ﬁle.
Read the array back in and verify that the friend relations are intact.
