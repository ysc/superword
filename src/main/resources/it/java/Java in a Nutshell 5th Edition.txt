OnJava.com is a one-stop resource for enterprise Java developers, featuring news, code recipes, interviews, weblogs, and more.
Conferences O’Reilly Media brings diverse innovators together to nurture the ideas that spark revolutionary industries.
We specialize in documenting the latest tools and systems, translating the innovator’s knowledge into useful skills for those in the trenches.
Safari Bookshelf (safari.oreilly.com) is the premier online reference library for programmers and IT professionals.
Subscribers can zero in on answers to time-critical questions in a matter of seconds.
Read the books on your Bookshelf from cover to cover or simply flip to the page you need.
O’Reilly books may be purchased for educational, business, or sales promotional use.
The In a Nutshell series designations, Java in a Nutshell, the image of the Javan tiger, and related trade dress are trademarks of O’Reilly Media, Inc.
Java™ and all Java-based trademarks and logos are trademarks or registered trademarks of Sun Microsystems, Inc., in the United States and other countries.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc.
While every precaution has been taken in the preparation of this book, the publisher and author assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.
This book is a desktop Java™ quick reference, designed to sit faithfully by your keyboard while you program.
Part I of the book is a fast-paced, “no-fluff” introduction to the Java programming language and the core APIs of the Java platform.
Part II is a quick reference section that succinctly details most classes and interfaces of those core APIs.
Changes in the Fifth Edition The fifth edition of this book covers Java 5.0
As its incremented version number attests, this new version of Java has a lot of new features.
The three most significant new language features are generic types, enumerated types, and annotations, which are covered in a new chapter of their own.
Experienced Java programmers who just want to learn about these new features can jump straight to Chapter 4
The for/in statement for easily iterating through arrays and collections (this statement is sometimes called “foreach”)
Autoboxing and autounboxing conversions to automatically convert back and forth between primitive values and their corresponding wrapper objects (such as int values and Integer objects) as needed.
Varargs methods to define and invoke methods that accept an arbitrary number of arguments.
Covariant returns to allow a subclass to override a superclass method and narrow the return type of the method.
The import static declaration to import the static members of a type into the namespace.
Although each of these features is new in Java 5.0, none of them is large enough to merit a chapter of its own.
In addition to these language changes, Java 5.0 also includes changes to the Java platform.
The java.util collections classes have been converted to be generic types, providing support for typesafe collections.
This class enables C-style formatted text output with printf( ) and format( ) methods.
The java.util.Formatter entry in the quick reference includes a detailed table of formatting options.
The new package java.util.concurrent includes important utilities for threadsafe concurrent programming.
These packages support Java 5.0 annotations and the instrumentation, management, and monitoring of a running Java interpreter.
Although their position in the java.lang hierarchy marks these packages as very important, they are not commonly used.
In a mostly futile attempt to make room for this new material, I’ve had to make some cuts.
JavaBeans standards have not caught on in core Java APIs and now appear to be relevant only for Swing and related graphical APIs.
As such, they are no longer relevant in this book.
The java.security.acl package has been deprecated since Java 1.2 and I’ve taken this opportunity to remove it.
Along with removing coverage of java.beans from the quick reference section, I’ve also cut the chapter on JavaBeans from Part I of this book.
The material on JavaBeans naming conventions from that chapter remains useful, however, and has been moved into Chapter 7
Contents of This Book The first eight chapters of this book document the Java language, the Java platform, and the Java development tools that are supplied with Sun’s Java Development Kit (JDK)
The first five chapters are essential; the next three cover topics of interest to some, but not all, Java programmers.
Chapter 1: Introduction This chapter is an overview of the Java language and the Java platform that explains the important features and benefits of Java.
It concludes with an example Java program and walks the new Java programmer through it line by line.
It is a long and detailed chapter that does not assume substantial programming experience.
Experienced Java programmers can use it as a language reference.
Programmers with substantial experience with languages such as C and C++ should be able to pick up Java syntax quickly by reading this chapter; beginning programmers with only a modest amount of experience should be able to learn Java programming by studying this chapter carefully.
It can be used as a tutorial by new programmers or as a reference by experienced Java programmers.
If you read previous editions of this book, you might want to skip directly to this chapter.
Chapter 5: The Java Platform This chapter is an overview of the essential Java APIs covered in this book.
It contains numerous short examples that demonstrate how to perform common tasks with the classes and interfaces that comprise the Java platform.
Programmers who are new to Java (and especially those who learn best by example) should find this a valuable chapter.
Chapter 6: Java Security This chapter explains the Java security architecture that allows untrusted code to run in a secure environment from which it cannot do any malicious damage to the host system.
It is important for all Java programmers to have at least a passing familiarity with Java security mechanisms.
Chapter 7: Programming and Documentation Conventions This chapter documents important and widely adopted Java programming conventions, including JavaBeans naming conventions.
It also explains how you can make your Java code self-documenting by including specially formatted documentation comments.
Chapter 8: Java Development Tools Sun’s JDK includes a number of useful Java development tools, most notably the Java interpreter and the Java compiler.
These first eight chapters teach you the Java language and get you up and running with the Java APIs.
Part II of the book is a succinct but detailed API reference formatted for optimum ease of use.
Reference in Part II; it explains how to get the most out of the quick reference section.
Also, please note that the quick reference chapters are followed by one final chapter called “Class, Method, and Field Index.” This special index allows you to look up the name of a type and find the package in which it is defined or to look up the name of a method or field and find the type in which it it is defined.
Related Books O’Reilly publishes an entire series of books on Java programming, including several companion books to this one.
Java Examples in a Nutshell This book contains hundreds of complete, working examples illustrating many common Java programming tasks using the core, enterprise, and desktop APIs.
Java Examples in a Nutshell is like Chapter 4 of this book, but greatly expanded in breadth and depth, and with all the code snippets fully fleshed out into working examples.
This is a particularly valuable book for readers who learn well by experimenting with existing code.
You can find a complete list of Java books from O’Reilly at http://java.oreilly.com/
Books that focus on the core Java APIs, as this one does, include:
Learning Java, by Pat Niemeyer and Jonathan Knudsen This book is a comprehensive tutorial introduction to Java, with an emphasis on client-side Java programming.
Java Threads, by Scott Oaks and Henry Wong Java makes multithreaded programming easy, but doing it right can still be tricky.
Java I/O, by Elliotte Rusty Harold Java’s stream-based input/output architecture is a thing of beauty.
Java Security, by Scott Oaks This book explains the Java access-control mechanisms in detail and also documents the authentication mechanisms of digital signatures and message digests.
Examples Online The examples in this book are available online and can be downloaded from the home page for the book at http://www.oreilly.com/catalog/javanut5
You may also want to visit this site for any important notes or errata that have been published there.
Conventions Used in This Book We use the following formatting conventions in this book:
Italic Used for emphasis and to signify the first use of a term.
Italic is also used for commands, email addresses, web sites, FTP sites, and file and directory names.
Bold Occasionally used to refer to particular keys on a computer keyboard or to portions of a user interface, such as the Back button or the Options menu.
Constant Width Used for all Java code as well as for anything that you would type literally when programming, including keywords, data types, constants, method names, variables, class names, and interface names.
Constant Width Italic Used for the names of function arguments and generally as a placeholder to indicate an item that should be replaced with an actual value in your program.
Sometimes used to refer to a conceptual section or line of code as in statement.
Franklin Gothic Book Condensed Used for the Java class synopses in the quick reference section.
This very narrow font allows us to fit a lot of information on the page without a lot of distracting line breaks.
This font is also used for code entities in the descriptions in the quick reference section.
Franklin Gothic Demi Condensed Used for highlighting class, method, field, property, and constructor names in the quick reference section, which makes it easier to scan the class synopses.
Franklin Gothic Book Condensed Italic Used for method parameter names and comments in the quick reference section.
Request for Comments Please address comments and questions concerning this book to the publisher:
There is a web page for this book, which lists errata, examples, and any additional information.
To ask technical questions or comment on this book, send email to:
For more information about books, conferences, Resource Centers, and the O’Reilly Network, see the O’Reilly web site at:
How the Quick Reference Is Generated For the curious reader, this section explains a bit about how the quick reference material in Java in a Nutshell and related books is created.
As Java has evolved, so has my system for generating Java quick reference material.
The current system is part of a larger commercial documentation browser system I’m developing (visit http://www.davidflanagan.com/Jude for more information about it)
The program works in two passes: the first pass collects and organizes the API information, and the second pass outputs that information in the form of quick reference chapters.
The first pass begins by reading the class files for all of the classes and interfaces to be documented.
Almost all of the API information in the quick reference is available in these class files.
The notable exception is the names of method arguments, which are not stored in class files.
These argument names are obtained by parsing the Java source file for each class and interface.
Where source files are not available, I obtain method argument names by parsing the API documentation generated by javadoc.
The parsers I use to extract API information from the source files and javadoc files are created using the Antlr parser generator developed by Terence Parr.
See http://www.antlr.org for details on this very powerful programming tool.)
Once the API information has been obtained by reading class files, source files, and javadoc files, the program spends some time sorting and cross-referencing everything.
Then it stores all the API information into a single large data file.
The second pass reads API information from that data file and outputs quick reference chapters using a custom XML doctype.
Once I’ve generated the XML output, I hand it off to the production team at O’Reilly.
In this edition, the chapters were converted from XML to Framemaker instead, using in-house production tools.
When you see a Safari®-enabled icon on the cover of your favorite technology book, that means the book is available online through the O’Reilly Network Safari Bookshelf.
It’s a virtual library that lets you easily search thousands of top tech books, cut and paste code samples, download chapters, and find quick answers when you need the most accurate, current information.
Acknowledgments Many people helped in the creation of this book, and I am grateful to them all.
I am indebted to the many, many readers of the first four editions who wrote in with comments, suggestions, bug reports, and praise.
Also, my apologies to those who made many good suggestions that could not be incorporated into this edition.
Deb edited not only the material that was new in this edition but also made the time to carefully read over the old material, giving it a much-needed updating.
Deb was patient when my work on this book veered off in an unexpected direction and provided steady guidance to help get me back on track.
The fourth edition was edited by Bob Eckstein, a careful editor with a great sense of humor.
Paula Ferguson, a friend and colleague, was the editor of the first three editions of this book.
Her careful reading and practical suggestions made the book stronger, clearer, and more useful.
As usual, I’ve had a crack team of technical reviewers for this edition of the book.
Gilad Bracha of Sun reviewed the material on generic types.
Josh Bloch, a former Sun employee who is now at Google, reviewed the material on enumerated types and annotations.
Josh was also a reviewer for the third and fourth editions of the book, and his helpful input has been an invaluable resource for me.
Neal Gafter, who, like Josh, left Sun for Google, answered many questions about annotations and generics.
Iris Garcia of Sun answered my questions about the new java.util.Formatter class that she authored.
Any mistakes that remain in the book are, of course, my own.
The fourth edition was also reviewed by a number of engineers from Sun and elsewhere.
Josh Bloch reviewed material on assertions and the Preferences API.
Philip Milne, a former Sun employee, now at Dresdner Kleinwort Wasserstein, reviewed the material on the JavaBeans persistence mechanism.
Mark deserves special thanks for having been a reviewer for the second, third, and fourth editions of this book.
The third edition also benefited greatly from the contributions of reviewers who are intimately familiar with the Java platform.
Joshua Bloch, one of the primary authors of the Java collections framework, reviewed my descriptions of the collections classes and interfaces.
Josh was also helpful in discussing the Timer and TimerTask classes of Java 1.3 with me.
Mark Reinhold, creator of the java.lang.ref package, explained the package to me and reviewed my documentation of it.
Scott Oaks reviewed my descriptions of the Java security and cryptography classes and interfaces.
The documentation of the javax.crypto package and its subpackages was also reviewed by Jon Eaves.
Finally, Chapter 1 was improved by the comments of reviewers who were not already familiar with the Java platform: Christina Byrne reviewed it from the standpoint of a novice programmer, and Judita Byrne of Virginia Power offered her comments as a professional COBOL programmer.
For the second edition, John Zukowski reviewed my Java 1.1 AWT quick reference material, and George Reese reviewed most of the remaining new material.
John Rose, the author of the Java inner class specification, reviewed the chapter on inner classes.
Mark Reinhold, author of the new character stream classes in java.io, reviewed my documentation of these classes.
Nakul Saraiya, the designer of the Java Reflection API, reviewed my documentation of the java.
Mike Loukides provided high-level direction and guidance for the first edition of the book.
Eric Raymond and Troy Downing reviewed that first edition—they helped spot my errors and omissions and offered good advice on making the book more useful to Java programmers.
The O’Reilly production team has done its usual fine work of creating a book out of the electronic files I submit.
Part I is an introduction to the Java language and the Java platform.
These chapters provide enough information for you to get started using Java right away.
This chapter begins by explaining what Java is and describing some of the features that distinguish it from other programming languages.
Next, it outlines the structure of this book, with special emphasis on what is new in Java 5.0
Finally, as a quick tutorial introduction to the language, it walks you through a simple Java program you can type, compile, and run.
The Java programming language is the language in which Java applications, applets, servlets, and components are written.
When a Java program is compiled, it is converted to byte codes that are the portable machine language of a CPU architecture known as the Java Virtual Machine (also called the Java VM or JVM)
The JVM can be implemented directly in hardware, but it is usually implemented in the form of a software program that interprets and executes byte codes.
The Java platform is distinct from both the Java language and Java VM.
The Java platform is the predefined set of Java classes that exist on every Java installation; these classes are available for use by all Java programs.
The Java platform is also sometimes referred to as the Java runtime environment or the core Java APIs (application programming interfaces)
The Java platform can be extended with optional packages (formerly called standard extensions)
These APIs exist in some Java installations but are not guaranteed to exist in all installations.
The Java programming language is a state-of-the-art, object-oriented language that has a syntax similar to that of C.
The language designers strove to make the Java language powerful, but, at the same time, they tried to avoid the overly.
By keeping the language simple, the designers also made it easier for programmers to write robust, bug-free code.
As a result of its elegant design and next-generation features, the Java language has proved popular with programmers, who typically find it a pleasure to work with Java after struggling with more difficult, less powerful languages.
Most experienced Java programmers have welcomed the new features, despite the added complexity they bring.
The Java Virtual Machine, or Java interpreter, is the crucial piece of every Java installation.
By design, Java programs are portable, but they are only portable to platforms to which a Java interpreter has been ported.
Sun ships VM implementations for its own Solaris operating system and for Microsoft Windows and Linux platforms.
Many other vendors, including Apple and various commercial Unix vendors, provide Java interpreters for their platforms.
The Java VM is not only for desktop systems, however.
It has been ported to set-top boxes and handheld devices that run Windows CE and PalmOS.
Although interpreters are not typically considered high-performance systems, Java VM performance has improved dramatically since the first versions of the language.
Of particular note is a VM technology called just-in-time (JIT) compilation whereby Java byte codes are converted on the fly into native platform machine language, boosting execution speed for code that is run repeatedly.
The Java platform is just as important as the Java programming language and the Java Virtual Machine.
All programs written in the Java language rely on the set of predefined classes† that comprise the Java platform.
Java classes are organized into related groups known as packages.
The Java platform defines packages for functionality such as input/output, networking, graphics, user-interface creation, security, and much more.
It is important to understand what is meant by the term platform.
To a computer programmer, a platform is defined by the APIs he can rely on when writing programs.
These APIs are usually defined by the operating system of the target computer.
Thus, a programmer writing a program to run under Microsoft Windows must use a different set of APIs than a programmer writing the same program for a Unix-based system.
Java 5.0 represents a significant change in version numbering for Sun.
A class is a module of Java code that defines a data structure and a set of methods (also called procedures, functions, or subroutines) that operate on that data.
Nevertheless, the Java platform provides APIs with a comparable breadth and depth to those defined by an operating system.
With the Java platform, you can write applications in Java without sacrificing the advanced features available to programmers writing native applications targeted at a particular underlying operating system.
An application written on the Java platform runs on any operating system that supports the Java platform.
This means you do not have to create distinct Windows, Macintosh, and Unix versions of your programs, for example.
The Java platform is not an operating system, but for programmers, it is an alternative development target and a very popular one at that.
The Java platform reduces programmers’ reliance on the underlying operating system, and, by allowing programs to run on top of any operating system, it increases end users’ freedom to choose an operating system.
As of this writing, there have been six major versions of Java.
Java 1.0 This was the first public version of Java.
It was simple and elegant but is now completely outdated.
Important additions included the Collections API for working with sets, lists, and maps of objects and the Swing API for creating graphical user interfaces.
Additions to the platform included the Java Naming and Directory Interface (JNDI) and the Java Sound APIs, which were previously available as extensions to the platform.
The most interesting classes in this release were probably java.util.Timer and java.lang.reflect.Proxy.
In addition to these platform changes, the 1.4 release introduced an assert statement to the Java language.
Java 5.0 The most recent release of Java introduces a number of changes to the core language itself including generic types, enumerated types, annotations, varargs methods, autoboxing, and a new for/in statement.
Because of the major language changes, the version number was incremented.
In addition to the language changes, Java 5.0 includes a number of additions to the Java platform as well.
Notable additions include utilities for concurrent programming, a remote management framework, and classes for the remote management and instrumentation of the Java VM itself.
See the Preface for a list of changes in this edition of the book, including pointers to coverage of the new language and platform features.
To write programs in Java, you must obtain the Java Development Kit (JDK)
Sun releases a new version of the JDK for each new version of Java.
The JRE contains everything you need to run Java programs, but it does not contain the tools you need to develop Java programs (primarily the compiler)
See Java Enterprise in a Nutshell and Java Micro Edition in a Nutshell (both by O’Reilly) for more information on these other editions.
It is built into the popular web browsers, which places it on virtually every Internet-connected PC in the world.
It is even being built into consumer electronic devices such as television set-top boxes, PDAs, and cell phones.
Both the language and the platform were designed from the ground up with security in mind.
The Java platform allows users to download untrusted code over a network and run it in a secure environment in which it cannot do any harm: untrusted code cannot infect the host system with a virus, cannot read or write files from the hard drive, and so forth.
It made security levels and restrictions highly configurable and extended them beyond applets.
As of Java 1.2, any Java code, whether it is an applet, a servlet, a JavaBeans component, or a complete Java application, can be run with restricted permissions that prevent it from doing harm to the host system.
The security features of the Java language and platform have been subjected to intense scrutiny by security experts around the world.
In the earlier days of Java, security-related bugs, some of them potentially serious, were found and promptly fixed.
Because of the strong security promises Java makes, it is big news when a new security bug is found.
No other mainstream platform can make security guarantees nearly as strong as those Java makes.
No one can say that Java security holes will not be found in the future, but if Java’s security is not yet perfect, it has been proven strong enough for practical day-to-day use and is certainly better than any of the alternatives.
From a programmer’s point of view, Java makes it easy to work with resources across a network and to create network-based applications using client/server or multitier architectures.
Java code is organized in modular objectoriented units called classes.
Classes are stored in separate files and are loaded into the Java interpreter only when needed.
This means that an application can decide as it is running what classes it needs and can load them when it needs them.
It also means that a program can dynamically extend itself by loading the classes it needs to expand its functionality.
The network-centric design of the Java platform means that a Java application can dynamically extend itself by loading new classes over a network.
An application that takes advantage of these features ceases to be a monolithic block of code.
Instead, it becomes an interacting collection of independent software components.
Thus, Java enables a powerful new metaphor of application design and development.
The Java language and the Java platform were designed from the start with the rest of the world in mind.
When it was created, Java was the only commonly used programming language that had internationalization features at its core rather than tacked on as an afterthought.
Java’s internationalization features are not restricted to just low-level character representation, however.
The features permeate the Java platform, making it easier to write internationalized programs with Java than it is with any other environment.
As described earlier, Java programs are compiled to a portable intermediate form known as byte codes, rather than to native machine-language instructions.
The Java Virtual Machine runs a Java program by interpreting these portable bytecode instructions.
This architecture means that Java programs are faster than programs or scripts written in purely interpreted languages, but Java programs are typically slower than C and C++ programs compiled to native machine language.
Keep in mind, however, that although Java programs are compiled to byte code, not all of the Java platform is implemented with interpreted byte codes.
Although early releases of Java suffered from performance problems, the speed of the Java VM has improved dramatically with each new release.
The VM has been highly tuned and optimized in many significant ways.
Furthermore, most current implementations include a just-in-time (JIT) compiler, which converts Java byte codes to native machine instructions on the fly.
Using sophisticated JIT compilers, Java programs can execute at speeds comparable to the speeds of native C and C++ applications.
Java is a portable, interpreted language; Java programs run almost as fast as native, nonportable C and C++ programs.
Performance used to be an issue that made some programmers avoid using Java.
The final, and perhaps most important, reason to use Java is that programmers like it.
Java is an elegant language combined with a powerful and (usually) well-designed set of APIs.
Programmers enjoy programming in Java and are often amazed at how.
Because Java is a simple and elegant language with a well-designed, intuitive set of APIs, programmers write better code with fewer bugs than for other platforms, thus reducing development time.
Before we look at how the program works, we must first discuss how to run it.
In order to compile and run the program, you need a Java development kit (JDK) of some sort.
Sun Microsystems created the Java language and ships a free JDK for its Solaris operating system and also for Linux and Microsoft Windows platforms.† At the time of this writing, the current version of Sun’s JDK is available for download from http://java.sun.com.
The JRE enables you to run existing Java programs, but not to write and compile your own.
The factorial of an integer is the product of the number and all positive integers less than the number.
Other companies, such as Apple, have licensed and ported the JDK to their operating systems.
In Apple’s case, this arrangement leads to a delay in the latest JDK being available on that platform.
The Sun JDK is not the only Java programming environment you can use.
A number of companies sell Java IDEs (integrated development environments), and high-quality open-source IDEs are also available.
This book assumes that you are using Sun’s JDK and its accompanying command-line tools.
If you are using a product from some other vendor, be sure to read that vendor’s documentation to learn how to compile and run a simple program, like that shown in Example 1-1
Once you have a Java programming environment installed, the first step towards running our program is to type it in.
Using your favorite text editor, enter the program as it is shown in Example 1-1.* Omit the line numbers, which are just for reference.
Note that Java is a case-sensitive language, so you must type lowercase letters in lowercase and uppercase letters in uppercase.
You’ll notice that many of the lines of this program end with semicolons.
It is a common mistake to forget these characters, but the program won’t work without them, so be careful! You can omit everything from // to the end of a line: those are comments that are there for your benefit and are ignored by Java.
When writing Java programs, you should use a text editor that saves files in plaintext format, not a word processor that supports fonts and formatting and saves files in a proprietary format.
If you use a Windows system, you might use Notepad or WordPad, if you don’t have a more specialized programmer’s editor (versions of GNU Emacs, for example, are available for Windows)
If you are using an IDE, it should include an appropriate text editor; read the documentation that came with the product.
When you are done entering the program, save it in a file named Factorial.java.
This is important; the program will not work if you save it by any other name.
After writing a program like this one, the next step is to compile it.
With Sun’s JDK, the Java compiler is known as javac.
If this command prints any error messages, you probably got something wrong when you typed in the program.
If it does not print any error messages, however, the compilation has succeeded, and javac creates a file called Factorial.class.
Once you have compiled a Java program, you must still run it.
Java programs are not compiled into native machine language, so they cannot be executed directly by the system.
Instead, they are run by another program known as the Java interpreter.
In Sun’s JDK, the interpreter is a command-line program named, appropriately enough, java.
I recommend that you type this example in by hand, to get a feel for the language.
If you really don’t want to, however, you can download this, and all examples in the book, from http://www.
Congratulations! You’ve just written, compiled, and run your first Java program.
Try running it again to compute the factorials of some other numbers.
Now that you have run the factorial program, let’s analyze it line by line to see what makes a Java program tick.
The first three lines of the program are a comment.
Java ignores them, but they tell a human programmer what the program does.
Any amount of text, including multiple lines of text, may appear between these characters.
If the characters // appear in a Java program, Java ignores those characters and any other text that appears between those characters and the end of the line.
It says that we are defining a class named Factorial.
This explains why the program had to be stored in a file named Factorial.java.
That filename indicates that the file contains Java source code for a class named Factorial.
The word public is a modifier; it says that the class is publicly available and that anyone may use it.
The program contains a number of pairs of curly braces; the lines are indented to show the nesting within these braces.
A class is the fundamental unit of program structure in Java, so it is not surprising that the first line of our program declares a class.
All Java programs are classes, although some programs use many classes instead of just one.
Java is an object-oriented programming language, and classes are a fundamental part of the object-oriented paradigm.
Example 1-1 is not really an object-oriented program, however, so I’m not going to go into detail about classes and objects here.
For now, all you need to understand is that a class defines a set of interacting members.
The Factorial class contains two members, both of which are methods.
Line 5 begins the definition of a method of our Factorial class.
A Java program can call, or invoke, a method to execute the code in it.
If you have programmed in other languages, you have probably seen methods before, but they may have been called functions, procedures, or subroutines.
The interesting thing about methods is that they have parameters and return values.
When you call a method, you pass it some data you want it to operate on, and it returns a result to you.
Here, the mathematical function f performs some computation on the value represented by x and returns a value, which we represent by y.
To return to line 5, the public and static keywords are modifiers.
The meaning of the static modifier is not important here; it is explained in Chapter 3
The void keyword specifies the return value of the method.
In this case, it specifies that this method does not have a return value.
It is not actually sufficient for a method to be named main( ), however.
The method must be declared public static void exactly as shown in line 5
In fact, the only part of line 5 you can change is the word args, which you can replace with any word you want.
You’ll be using this line in all of your Java programs, so go ahead and commit it to memory now!
In the algebraic equation f(x), x is simply a way of referring to an unknown value.
Examples are applets, which are programs run by a web browser, and servlets, which are programs run by a web server.
Applets are discussed in Java Foundation Classes in a Nutshell (O’Reilly) while servlets are discussed in Java Enterprise in a Nutshell (O’Reilly)
By convention, when this book refers to a method, it follows the name of the method by a pair of parentheses.
As you’ll see, parentheses are an important part of method syntax, and they serve here to keep method names distinct from the names of classes, fields, variables, and so on.
More precisely, an array of strings containing only one entry, 4, is passed to.
Our program looks only at the first string in the array, so the other strings are ignored.
Finally, the last thing on line 5 is an open curly brace.
Methods are composed of statements, which the Java interpreter executes in sequential order.
In any programming language, a variable is simply a symbolic name for a value.
We’ve already seen that, in this program, the name args refers to the variable.
It is also possible for methods to declare additional “local” variables.
Methods can use local variables to store and reference the intermediate values they use while performing their computations.
This is exactly what we are doing on line 6
That line begins with the words int input, which declare a variable named input and specify that the variable has the type int; that is, it is an integer.
Java can work with several different types of values, including integers, real or floating-point numbers, characters (e.g., letters and digits), and strings of text.
Java is a strongly typed language, which means that all variables must have a type specified and can refer only to values of that type.
Our input variable always refers to an integer, so it cannot refer to a floating-point number or a string.
This is the assignment operator in Java; it sets the value of a variable.
This first statement of the main( ) method invokes another method whose name is Integer.parseInt( )
As you might guess, this method “parses” an integer; that is, it converts a string representation of an integer, such.
Every Java program can use the powerful set of classes and methods defined by this core API.
The second half of this book is a quick reference that documents that core API.
When you call a method, you pass values (called arguments) that are assigned to the corresponding parameters defined by the method, and the method returns a elements of an array are numbered sequentially, and the first one is always numbered 0
We care about only the first string in the args array, so we use the expression args[0] to refer to that string.
Finally, this returned integer is assigned to the variable named input.
It declares a variable and assigns a value to it.
The value assigned to the variable is computed by invoking a method.
The variable is named result, and it has a type of double.
The variable is assigned a however, is not part of the standard Java API.
The argument passed to factorial( ) is the value referred to by the input variable that was computed on line 6
We’ll consider the this method takes an input value, computes the factorial of that value, and returns the result.
This commonly used method is part of the core Java API; it causes the Java interpreter to print out a value.
In this case, the value that it prints is the value referred to by the variable named result.
Another way to say this is that, like the main( ) method of line 5, System.out.println( ) is declared void.
When the Java interpreter gets here, it is through executing the main( ) method, so it stops running.
The end of the main( ) method is also the end of the variable.
These variable and parameter names have meaning only within the main( ) method and cannot be used elsewhere in the program unless other parts of the program declare different variables or parameters that happen to have the same name.
You can insert blank lines and spaces anywhere in a program, and you should use them liberally to make the program readable.
You’ll notice that the program also uses whitespace to indent the various lines of code.
This kind of indentation is optional; it emphasizes the structure of the program and greatly enhances the readability of the code.
Compare this line to line 5 to note its similarities and differences.
The factorial( ) method has the same public and static modifiers.
It takes a single integer parameter, which we call x.
Unlike the main( ) method, which had no return value (void), factorial( ) returns a value of type double.
It is an if statement, which executes another statement conditionally.
We saw earlier that the Java interpreter executes them in exactly that way, in exactly that order.
An if statement is a flowcontrol statement; it can affect the way the interpreter runs a program.
The if keyword is followed by a parenthesized expression and a statement.
If the expression is false, however, the interpreter skips the statement and goes to the next one.
It this expression is true, and the statement on line 13 is executed.
Semicolons are required only at the end of a statement.
It says that the return value of the factorial( ) method is 0.0
When the Java interpreter sees a return, it stops executing the current method and returns the specified value immediately.
A return statement can stand alone, but in this case, the return statement is part of the if statement on line 12
It is an error to try to compute a factorial for a negative number, so these lines make sure that the input value x is valid.
If it is not valid, they cause factorial( ) to return a consistent invalid result, 0.0
This variable holds the value of the factorial as we compute it in the statements that follow.
In Java, variables can be declared anywhere; they are not restricted to the beginning of a method or block of code.
Line 15 introduces another type of statement: the while loop.
Like an if statement, a while statement consists of a parenthesized expression and a statement.
When the Java interpreter sees a while statement, it evaluates the associated expression.
If that expression is true, the interpreter executes the statement.
The interpreter repeats this process, evaluating the expression and executing the statement if the expression is true, until the expression evaluates to false.
Another way to say this is that the loop continues until x holds a value less than or equal to 1
We can assume from this expression that if the loop is ever going to terminate, the value of x must somehow be modified by the statement that the loop executes.
A compound statement is zero or more statements grouped between curly braces.
The while keyword on line 15 is followed by an expression in parentheses and then by an open curly brace.
This means that the body of the loop consists of all statements between that opening brace and the closing brace on line 18
Earlier in the chapter, I said that all Java statements end with semicolons.
This rule does not apply to compound statements, however, as you can see by the lack of a semicolon at the end of line 18
Line 16 multiplies the value of fact by the value of x and stores the result back into fact.
It subtracts 1 from the value of x and stores the result back into x.
An operator is a key part of Java syntax: it performs a computation on one or two operands to produce a new value.
The value of this expression is a boolean truth value—either true or false, depending on the result of the comparison.
To understand this while loop, it is helpful to think like the Java interpreter.
Suppose we are trying to compute the factorial of 4
This one does earlier, the value of fact is 24.0, so this is the value returned.
Recall that the statement is executed, control returns to line 7, where the return value is assigned to the variable named result.
There is one more important feature of Java programming I want to introduce, but it is one that does not appear in the program listing itself.
Recall that the program computes the factorial of the number you specify on the command line.
What happens if you run the program without specifying a number?
And what happens if you specify a value that is not a number?
If you didn’t understand all the details of this factorial program, don’t worry.
We’ll cover the details of the Java language a lot more thoroughly in subsequent chapters.
However, if you feel like you didn’t understand any of the line-by-line analysis, you may also find that the upcoming chapters are over your head.
In that case, you should probably go elsewhere to learn the basics of the Java language and return to this book to solidify your understanding, and, of course, to use as a reference.
One resource you may find useful in learning the language is Sun’s online Java tutorial, available at http://java.sun.com/docs/books/tutorial.
In both cases, an error occurs or, in Java terminology, an exception is thrown.
When an exception is thrown, the Java interpreter prints a message that explains what type of exception it was and where it occurred (both exceptions above occurred on line 6)
In the first case, the exception is thrown because there are no strings in the args list, meaning we asked for a nonexistent string with args[0]
In the second case, the exception is thrown because Integer.parseInt( ) cannot convert the string “ten” to a number.
We’ll see more about exceptions in Chapter 2 and learn how to handle them gracefully as they occur.
This chapter is a terse but comprehensive introduction to Java syntax.
It is written primarily for readers who are new to the language but have at least some previous programming experience.
Determined novices with no prior programming experience may also find it useful.
If you already know Java, you should find it a useful language reference.
The chapter includes comparisons of Java to C and C++ for the benefit of programmers coming from those languages.
This chapter documents the syntax of Java programs by starting at the very lowest level of Java syntax and building from there, covering increasingly higher orders of structure.
The characters used to write Java programs and the encoding of those characters.
Literal values, identifiers, and other tokens that comprise a Java program.
The operators used in Java to group individual tokens into larger expressions.
Statements, which group expressions and other statements to form logical chunks of Java code.
Methods (also called functions, procedures, or subroutines), which are named collections of Java statements that can be invoked by other Java code.
Classes are the central program element in Java and form the basis for object-oriented programming.
Chapter 3 is devoted entirely to a discussion of classes and objects.
Java programs, which consist of one or more interacting classes that may be drawn from one or more packages.
The syntax of most programming languages is complex, and Java is no exception.
In general, it is not possible to document all elements of a language without referring to other elements that have not yet been discussed.
But it is also not possible to document objects thoroughly without referring to the operators and statements of the language.
The process of learning Java, or any language, is therefore an iterative one.
If you are new to Java (or a Java-style programming language), you may find that you benefit greatly from working through this chapter and the next twice, so that you can grasp the interrelated concepts.
Java Programs from the Top Down Before we begin our bottom-up exploration of Java syntax, let’s take a moment for a top-down overview of a Java program.
Java programs consist of one or more files, or compilation units, of Java source code.
Near the end of the chapter, we describe the structure of a Java file and explain how to compile and run a Java program.
Each compilation unit begins with an optional package declaration followed by zero or more import declarations.
These declarations specify the namespace within which the compilation unit will define names, and the namespaces from which the compilation unit imports names.
The optional package and import declarations are followed by zero or more reference type definitions.
These are typically class or interface definitions, but in Java 5.0 and later, they can also be enum definitions or annotation definitions.
Type definitions include members such as fields, methods, and constructors.
Most statements include expressions, which are built using operators and values known as primitive data types.
Finally, the keywords used to write statements, the punctuation characters that represent operators, and the literals values that appear in a program are all tokens, which are described next.
As the name of this section implies, this chapter moves from describing the smallest units, tokens, to progressively larger units.
Since the concepts build upon one another, we recommend reading this chapter sequentially.
Lexical Structure This section explains the lexical structure of a Java program.
It starts with a discussion of the Unicode character set in which Java programs are written.
It then covers the tokens that comprise a Java program, explaining comments, identifiers, reserved words, literals, and so on.
You can use Unicode characters anywhere in a Java program, including comments and identifiers such as variable names.
Thus, you can simply write plain ASCII programs, and they will work as valid Unicode.
If you do not use a Unicode-enabled text editor, or if you do not want to force other programmers who view or edit your code to use a Unicode-enabled editor, you can embed Unicode characters into your Java programs using the special Unicode escape sequence \uxxxx, in other words, a backslash and a lowercase u, followed by four hexadecimal characters.
If you ever need to include one of these (rarely used) supplementary characters in Java source code, use two \u sequences to represent the surrogate pair.
Details of surrogate pair encoding are beyond the scope of this book, however.)
Its keywords are written in lowercase and must always be used that way.
That is, While and WHILE are not the same as the while keyword.
Similarly, if you declare a variable named i in your program, you may not refer to it as I.
Java ignores spaces, tabs, newlines, and other whitespace, except when it appears within quoted characters and string literals.
Programmers typically use whitespace to format and indent their code for easy readability, and you will see common indentation conventions in the code examples of this book.
Comments are natural-language text intended for human readers of a program.
The first type is a single-line comment, which begins with the characters // and continues until the end of the current line.
Although this style of comment is typically used for multiline comments, it can also be used for single-line comments.
When writing multiline comments, programmers often use extra * characters to make the comments stand out.
The third type of comment is a special case of the second.
If a comment begins with /**, it is regarded as a special doc comment.
Like regular multiline comments, doc comments end with */ and cannot be nested.
When you write a Java class you expect other programmers to use, use doc comments to embed documentation about the class and each of its methods directly into the source code.
A program named javadoc extracts these comments and processes them to create online documentation for your class.
A doc comment can contain HTML tags and can use additional syntax understood by javadoc.
Comments may appear between any tokens of a Java program, but may not appear within a token.
In particular, comments may not appear within doublequoted string literals.
A comment within a string literal simply becomes a literal part of that string.
The following words are reserved in Java: they are part of the syntax of the language and may not be used to name variables, classes, and so forth.
We’ll meet each of these reserved words again later in this book.
Some of them are the names of primitive types and others are the names of Java statements, both of which are discussed later in this chapter.
Still others are used to define classes and their members (see Chapter 3)
Note that const and goto are reserved but aren’t actually used in the language.
An identifier is simply a name given to some part of a Java program, such as a class, a method within a class, or a variable declared within a method.
An identifier may not begin with a digit, however, because the compiler would then think it was a numeric literal rather than an identifier.
Currency symbols are intended for use in automatically generated source code, such as code produced by parser generators.
By avoiding the use of currency symbols in your own identifiers you don’t have to worry about collisions with automatically generated identifiers.
Formally, the characters allowed at the beginning of and within an identifier are defined by the methods isJavaIdentifierStart( ) and isJavaIdentifierPart( ) of the class java.lang.Character.
Literals are values that appear directly in Java source code.
They include integer and floating-point numbers, characters within single quotes, strings of characters within double quotes, and the reserved words true, false and null.
Java also uses a number of punctuation characters as tokens.
The Java Language Specification divides these characters (somewhat arbitrarily) into two categories, separators and operators.
Primitive Data Types Java supports eight basic data types known as primitive types as described in Table 2-1
The primitive types include a boolean type, a character type, four integer types, and two floating-point types.
The four integer types and the two floatingpoint types differ in the number of bits that represent them and therefore in the.
In addition to these primitive types, Java supports nonprimitive data types such as classes, interfaces, and arrays.
This type has only two possible values, representing the two boolean states: on or off, yes or no, true or false.
Java reserves the words true and false to represent these two boolean values.
In particular, a boolean is not an integral type, and integer values cannot be used in place of a boolean.
In other words, you cannot take shortcuts such as the following in Java:
Instead, Java forces you to write cleaner code by explicitly stating the comparisons you want:
It surprises many experienced programmers to learn that Java char values are 16 bits long, but in practice this fact is totally transparent.
To include a character literal in a Java program, simply place it between single quotes (apostrophes):
You can, of course, use any Unicode character as a character literal, and you can use the \u Unicode escape sequence.
In addition, Java supports a number of other escape sequences that make it easy both to represent commonly used nonprinting ASCII characters such as newline and to escape certain punctuation characters that have special meaning in Java.
Table 2-2 lists the escape characters that can be used in char literals.
These characters can also be used in string literals, which are covered in the next section.
Unlike byte, short, int, and long, however, char is an unsigned type.
The Character class defines a number of useful static methods for working with characters, including isDigit( ), isJavaLetter( ), isLowerCase( ), and toUpperCase( )
The Java language and its char type were designed with Unicode in mind.
The Unicode standard is evolving, however, and each new version of Java adopts the latest version of Unicode.
These supplementary characters, which are mostly infrequently used Han (Chinese) ideographs, occupy 21 bits and cannot be represented in a single char value.
Unless you commonly write programs that use Asian languages, you are unlikely to encounter any supplementary characters.
If you do anticipate having to process characters that do not fit into a char, Java 5.0 has added methods to the Character, String, and related classes for working with text using int codepoints.
Unicode escapes can appear anywhere in a Java program, not only in character and string literals.
In addition to the char type, Java also has a data type for working with strings of text (usually simply called strings)
The String type is a class, however, and is not one of the primitive types of the language.
Because strings are so commonly used, though, Java does have a syntax for including string values literally in a program.
A String literal consists of arbitrary text within double quotes.
String literals can contain any of the escape sequences that can appear as char literals (see Table 2-2)
Use the \" sequence to include a double-quote within a String literal.
Chapter 5 demonstrates some of the ways you can work with String objects in Java.
The integer types in Java are byte, short, int, and long.
As shown in Table 2-1, these four types differ only in the number of bits and, therefore, in the range of numbers each type can represent.
All integral types represent signed numbers; there is no unsigned keyword as there is in C and C++
Literals for each of these types are written exactly as you would expect: as a string of decimal digits, optionally preceded by a minus sign.* Here are some legal integer literals:
Integer literals can also be expressed in hexadecimal or octal notation.
Java does not allow integer literals to be expressed in binary (base-2) notation.
Technically, the minus sign is an operator that operates on the literal, but is not part of the literal itself.
There is no special syntax for byte and short literals, but int literals are usually converted to these shorter types as needed.
Integer arithmetic in Java is modular, which means that it never produces an overflow or an underflow when you exceed the range of a given integer type.
Neither the Java compiler nor the Java interpreter warns you in any way when this occurs.
When doing integer arithmetic, you simply must ensure that the type you are using has a sufficient range for the purposes you intend.
Integer division by zero and modulo by zero are illegal and cause an ArithmeticException to be thrown.
Each integer type has a corresponding wrapper class: Byte, Short, Integer, and Long.
The classes also define useful static methods, such as Byte.
Real numbers in Java are represented by the float and double data types.
Both types adhere to the IEEE 754-1985 standard, which specifies both the format of the numbers and the behavior of arithmetic for the numbers.
Floating-point values can be included literally in a Java program as an optional string of digits, followed by a decimal point and another string of digits.
Floating-point literals can also use exponential, or scientific, notation, in which a number is followed by the letter e or E (for exponent) and another number.
This second number represents the power of ten by which the first number is multiplied.
To include a float value literally in a program, follow the number with f or F:
Floating-point literals cannot be expressed in hexadecimal or octal notation.
Most real numbers, by their very nature, cannot be represented exactly in any finite number of bits.
Thus, it is important to remember that float and double values are only approximations of the numbers they are meant to represent.
In practice, these data types are suitable for most real-number computations.
In addition to representing ordinary numbers, the float and double types can also represent four special values: positive and negative infinity, zero, and NaN.
The infinity values result when a floating-point computation produces a value that overflows the representable range of a float or double.
When a floating-point computation underflows the representable range of a float or a double, a zero value results.
The Java floating-point types make a distinction between positive zero and negative zero, depending on the direction from which the underflow occurred.
In practice, positive and negative zero behave pretty much the same.
Here are examples of statements that result in these special values:
Because the Java floating-point types can handle overflow to infinity and underflow to zero and have a special NaN value, floating-point arithmetic never throws exceptions, even when performing illegal operations, like dividing zero by zero or taking the square root of a negative number.
The float and double primitive types have corresponding classes, named Float and Double.
Adding or operator reports that negative zero is equal to positive zero.
One way to distinguish negative zero from positive, or regular, zero is to divide by it.
Finally, number, including itself! To check whether a float or double value is NaN, you must use the Float.isNaN( ) and Double.isNaN( ) methods.
In addition, because every character corresponds to a number in the Unicode encoding, char values can be converted to and from the integer and floating-point types.
In fact, boolean is the only primitive type that cannot be converted to or from another primitive type in Java.
A widening conversion occurs when a value of one type is converted to a wider type—one that has a larger range of legal.
Java performs widening conversions automatically when, for example, you assign an int literal to a double variable or a char literal to an int variable.
A narrowing conversion occurs when a value is converted to a type that is not wider than it is.
Because you can lose data in a narrowing conversion, the Java compiler complains when you attempt any narrowing conversion, even if the value being converted would in fact fit in the narrower range of the specified type:
The one exception to this rule is that you can assign an integer literal (an int value) to a byte or short variable if the literal falls within the range of the variable.
If you need to perform a narrowing conversion and are confident you can do so without losing data or precision, you can force Java to perform the conversion using a language construct known as a cast.
Perform a cast by placing the name of the desired type in parentheses before the value to be converted.
Casts of primitive types are most often used to convert floating-point values to integers.
When you do this, the fractional part of the floating-point value is simply truncated (i.e., the floating-point value is rounded towards zero, not towards the nearest integer)
The methods Math.round( ), Math.floor( ), and Math.ceil( ) perform other types of rounding.
The char type acts like an integer type in most ways, so a char value can be used anywhere an int or long value is required.
Recall, however, that the char type is unsigned, so it behaves differently than the short type, even though both are 16 bits wide:
Table 2-3 shows which primitive types can be converted to which other types and how the conversion is performed.
The letter N in the table means that the conversion cannot be performed.
The letter Y means that the conversion is a widening conversion and is therefore performed automatically and implicitly by Java.
The letter C means that the conversion is a narrowing conversion and requires an explicit cast.
Finally, the notation Y* means that the conversion is an automatic widening conversion, but that some of the least significant digits of the value may be lost in the conversion.
This can happen when converting an int or long to a float or double.
The floating-point types have a larger range than the integer types, so any int or long can be represented by a float or double.
However, the floating-point types are approximations of numbers and cannot always hold as many significant digits as the integer types.
Expressions and Operators So far in this chapter, we’ve learned about the primitive types that Java programs can manipulate and seen how to include primitive values as literals in a Java program.
We’ve also used variables as symbolic names that represent, or hold, values.
These literals and variables are the tokens out of which Java programs are built.
An expression is the next higher level of structure in a Java program.
The Java interpreter evaluates an expression to compute its value.
The very simplest expressions are called primary expressions and consist of literals and variables.
When the Java interpreter evaluates a literal expression, the resulting value is the literal itself.
When the interpreter evaluates a variable expression, the resulting value is the value stored in the variable.
More complex expressions are made by using operators to combine primary expressions.
But operators are used not only with primary expressions; they can also be used with expressions at any level of complexity.
The kinds of expressions you can write in a programming language depend entirely on the set of operators available to you.
The P and A columns of the table specify the precedence and associativity of each group of related operators, respectively.
The P column of Table 2-4 specifies the precedence of each operator.
The multiplication operator has higher precedence than the addition operator, so a is added to the product of b and c.
Operator precedence can be thought of as a measure of how tightly operators bind to their operands.
Default operator precedence can be overridden through the use of parentheses that explicitly specify the order of operations.
The previous expression can be rewritten as follows to specify that the addition should be performed before the multiplication:
The default operator precedence in Java was chosen for compatibility with C; the designers of C chose this precedence so that most expressions can be written naturally without parentheses.
There are only a few common Java idioms for which parentheses are required.
When an expression involves several operators that have the same precedence, the operator associativity governs the order in which the operations are performed.
Most operators are left-to-right associative, which means that the operations are performed from left to right.
The A column of Table 2-4 specifies the associativity of each operator or group of operators.
The value L means left to right, and R means right to left.
Unary operators and assignment operators are evaluated from right to left.
As with operator precedence, operator associativity establishes a default order of evaluation for an expression.
This default order can be overridden through the use of parentheses.
However, the default operator associativity in Java has been chosen to yield a natural expression syntax, and you rarely need to alter it.
The fourth column of Table 2-4 specifies the number and type of the operands expected by each operator.
Some operators operate on only one operand; these are called unary operators.
For example, the unary minus operator changes the sign of a single number:
Most operators, however, are binary operators that operate on two operand values.
Java also defines one ternary operator, often called the conditional operator.
Its three operands are separated by a question mark and a colon; the second and third operands must be convertible to the same type:
In addition to expecting a certain number of operands, each operator also expects particular types of operands.
Some of the codes used in that column require further explanation:
Just as every operator expects its operands to be of specific types, each operator produces a value of a specific type.
The arithmetic, increment and decrement, bitwise, and shift operators return a double if at least one of the operands is a double.
They return a float if at least one of the operands is a float.
They return a long if at least one of the operands is a long.
Otherwise, they return an int, even if both operands are byte, short, or char types that are narrower than int.
The comparison, equality, and boolean operators always return boolean values.
Each assignment operator returns whatever value it assigned, which is of a type compatible with the variable on the left side of the expression.
Every operator computes a value based on one or more operand values.
Some operators, however, have side effects in addition to their basic evaluation.
If an expression contains side effects, evaluating it changes the state of a Java program in such a way that evaluating the expression again may yield a different result.
For example, the ++ increment operator has the side effect of incrementing a variable.
The expression ++a increments the variable a and returns the newly incremented value.
If this expression is evaluated again, the value will be different.
The various 2, but the expression also has the side effect of storing that value back into a.
The method invocation operator ( ) has side effects if the invoked method has side effects.
Some methods, such as Math.sqrt( ), simply compute and return a value without side effects of any kind.
Finally, the new operator has the profound side effect of creating a new object.
When the Java interpreter evaluates an expression, it performs the various operations in an order specified by the parentheses in the expression, the precedence of the operators, and the associativity of the operators.
Before any operation is performed, however, the interpreter first evaluates the operands of the operator.
This matters if any of the operands are expressions that contain side effects.
Although the multiplication is performed before the addition, the operands of the + operator are evaluated first.
Since most programs operate primarily on numbers, the most commonly used operators are often those that perform arithmetic operations.
The arithmetic operators can be used with integers, floating-point numbers, and even characters (i.e., they can be used with any primitive type other than boolean)
If either of the operands is a floating-point number, floating-point arithmetic is used; otherwise, integer arithmetic is used.
This matters because integer arithmetic and floatingpoint arithmetic differ in the way division is performed and in the way underflows and overflows are handled, for example.
As we’ll see shortly, the + operator can also be used to concatenate strings.
If either operand of + is a string, the other.
Be sure to use parentheses when you want to combine addition with concatenation.
Subtraction (-) When the - operator is used as a binary operator, it subtracts its second operand from its first.
Division (/) The / operator divides its first operand by its second.
If both operands are integers, the result is an integer, and any remainder is lost.
If either operand is a floating-point value, however, the result is a floating-point value.
When dividing two integers, division by zero throws an ArithmeticException.
For floating-point calculations, however, division by zero simply yields an infinite result or NaN:
The sign of the result is the same as the sign of the first operand.
While the modulo operator is typically used with integer operands, it also works for floating-point values.
When operating with integers, trying to compute a value modulo zero causes an ArithmeticException.
When working with floating-point values, anything modulo 0.0 evaluates to NaN, as does infinity modulo anything.
In other words, it converts a positive value to an equivalently negative value, and vice versa.
If either of the operands to + is a string, the operator converts the other operand to a string.
As a result, you must be careful to put any addition expressions in parentheses when combining them with string concatenation.
If you do not, the addition operator is interpreted as a concatenation operator.
The Java interpreter has built-in string conversions for all primitive types.
An object is converted to a string by invoking its toString( ) method.
Some classes define custom toString( ) methods so that objects of that class can easily be converted to strings in this way.
An array is converted to a string by invoking the built-in toString( ) method, which, unfortunately, does not return a useful string representation of the array contents.
The ++ operator increments its single operand, which must be a variable, an element of an array, or a field of an object, by one.
The behavior of this operator depends on its position relative to the operand.
When used before the operand, where it is known as the pre-increment operator, it increments the operand and evaluates to the incremented value of that operand.
When used after the operand, where it is known as the post-increment operator, it increments its operand, but evaluates to the value of that operand before it was incremented.
For example, the following code sets both i and j to 2:
Similarly, the -- operator decrements its single numeric operand, which must be a variable, an element of an array, or a field of an object, by one.
Like the ++ operator, the behavior of -- depends on its position relative to the operand.
When used before the operand, it decrements the operand and returns the decremented value.
When used after the operand, it decrements the operand, but returns the undecremented value.
If x is itself an expression with side effects, this makes a big difference.
These operators, in both prefix and postfix forms, are most commonly used to increment or decrement the counter that controls a loop.
The comparison operators consist of the equality operators that test values for equality or inequality and the relational operators used with ordered types (numbers and characters) to test for greater than and less than relationships.
Both types of operators yield a boolean result, so they are typically used with if statements and while and for loops to make branching and looping decisions.
With primitive operands, it tests whether the operand values themselves are identical.
For operands of reference types, however, it tests whether the operands refer to the same object or array.
In other words, it does not test the equality of two distinct objects or arrays.
In particular, note that you cannot test two distinct strings for equality with this operator.
For example, when comparing a short to a float, the short is first converted to a float before the comparison is performed.
For floating-point numbers, the special negative zero value tests equal to the regular, positive zero value.
Also, the special NaN (not-a-number) value is not equal to any other number, including itself.
To test whether a floating-point value is NaN, use the Float.isNan( ) or Double.isNan( ) method.
The relational operators can be used with numbers and characters, but not with boolean values, objects, or arrays because those types are not ordered.
Less than (<) Evaluates to true if the first operand is less than the second.
Evaluates to true if the first operand is less than or equal to the second.
Greater than (>) Evaluates to true if the first operand is greater than the second.
Evaluates to true if the first operand is greater than or equal to the second.
As we’ve just seen, the comparison operators compare their operands and yield a boolean result, which is often used in branching and looping statements.
In order to make branching and looping decisions based on conditions more interesting than a single comparison, you can use the boolean (or logical) operators to combine multiple comparison expressions into a single, more complex expression.
The boolean operators require their operands to be boolean values and they evaluate to boolean values.
Conditional AND (&&) This operator performs a boolean AND operation on its operands.
It evaluates to true if and only if both its operands are true.
If either or both operands are false, it evaluates to false.
This operator (and all the boolean operators except the unary ! operator) have a lower precedence than the comparison operators.
Thus, it is perfectly legal to write a line of code like the one above.
However, some programmers prefer to use parentheses to make the order of evaluation explicit:
You should use whichever style you find easier to read.
This operator is called a conditional AND because it conditionally evaluates its second operand.
If the first operand evaluates to false, the value of the expression is false, regardless of the value of the second operand.
Therefore, to increase efficiency, the Java interpreter takes a shortcut and skips the second operand.
Since the second operand is not guaranteed to be evaluated, you must use caution when using this operator with expressions that have side effects.
On the other hand, the conditional nature of this operator allows us to write Java expressions such as the following:
The second and third comparisons in this expression would cause errors if the first or second comparisons evaluated to false.
Fortunately, we don’t have to worry about this because of the conditional behavior of the && operator.
Conditional OR (||) This operator performs a boolean OR operation on its two boolean operands.
It evaluates to true if either or both of its operands are true.
If the first operand evaluates to true, the value of the expression is true, regardless of the value of the second operand.
Thus, the operator simply skips the second operand in that case.
Boolean NOT (!) This unary operator changes the boolean value of its operand.
If applied to a true value, it evaluates to false, and if applied to a false value, it evaluates to true.
Because ! is a unary operator, it has a high precedence and often must be used with parentheses:
This operator is almost always used as a bitwise operator with integer operands, however, and many Java programmers would not even recognize its use with boolean operands as legal Java code.
Boolean OR (|) This operator performs a boolean OR operation on its two boolean operands.
It is like the || operator, except that it always evaluates both operands, even if the first one is true.
The | operator is almost always used as a bitwise operator on integer operands; its use with boolean operands is very rare.
Boolean XOR (^) When used with boolean operands, this operator computes the Exclusive OR (XOR) of its operands.
It evaluates to true if exactly one of the two operands is true.
In other words, it evaluates to false if both operands are false or if both operands are true.
The ^ operator is much more commonly used as a bitwise operator on integer operands.
The bitwise and shift operators are low-level operators that manipulate the individual bits that make up an integer value.
The bitwise operators are most commonly used for testing and setting individual flag bits in a value.
In order to understand their behavior, you must understand binary (base-2) numbers and the twos-complement format used to represent negative integers.
You cannot use these operators with floating-point, boolean, array, or object operands.
If either of the arguments to a bitwise operator is a long, the result is a long.
If the left operand of a shift operator is a long, the result is a long; otherwise, the result is an int.
It inverts each bit of its single operand, converting ones to zeros and zeros to ones.
Bitwise AND (&) This operator combines its two integer operands by performing a boolean AND operation on their individual bits.
The result has a bit set only if the corresponding bit is set in both operands.
When used with boolean operands, & is the infrequently used boolean AND operator described earlier.
Bitwise OR (|) This operator combines its two integer operands by performing a boolean OR operation on their individual bits.
The result has a bit set if the corresponding bit is set in either or both of the operands.
It has a zero bit only where both corresponding operand bits are zero.
When used with boolean operands, | is the infrequently used boolean OR operator described earlier.
Bitwise XOR (^) This operator combines its two integer operands by performing a boolean XOR (Exclusive OR) operation on their individual bits.
The result has a bit set if the corresponding bits in the two operands are different.
If the corresponding operand bits are both ones or both zeros, the result bit is a zero.
When used with boolean operands, ^ is the infrequently used boolean XOR operator.
High-order bits of the left operand are lost, and zero bits are shifted in from the right.
Shifting an integer left by n places is equivalent to multiplying that number by 2n.
The low-order bits of the left operand are shifted away and are lost.
The high-order bits shifted in are the same as the original high-order bit of the left operand.
In other words, if the left operand is positive, zeros are shifted into the high-order bits.
If the left operand is negative, ones are shifted in instead.
This technique is known as sign extension; it is used to preserve the sign of the left operand.
This technique is called zero extension; it is appropriate when the left operand is being treated as an unsigned value (despite the fact that Java integer types are all signed)
The assignment operators store, or assign, a value into some kind of variable.
The left operand must evaluate to an appropriate local variable, array element, or object field.
The right side can be any value of a type compatible with the variable.
An assignment expression evaluates to the value that is assigned to the variable.
More importantly, however, the expression has the side effect of actually performing the assignment.
This makes a difference when that operand has a side effect.
This is equivalent (unless there are side effects in var) to:
The conditional operator ?: is a somewhat obscure ternary (three-operand) operator inherited from C.
It allows you to embed a conditional within an expression.
You can think of it as the operator version of the if/else statement.
The first and second operands of the conditional operator are separated by a question mark (?)
The second and third operands can be of any type, but they must be convertible to the same type.
If it is true, the operator evaluates its second operand and uses that as the value of the expression.
On the other hand, if the first operand is false, the conditional operator evaluates and returns its third operand.
The conditional operator never evaluates both its second and third operand, so be careful when using expressions with side effects with this operator.
Note that the ?: operator has lower precedence than all other operators except the assignment operators, so parentheses are not usually necessary around the operands of this operator.
Many programmers find conditional expressions easier to read if the first operand is placed within parentheses, however.
This is especially true because the conditional if statement always has its conditional expression written within parentheses.
The instanceof operator requires an object or array value as its left operand and the name of a reference type as its right operand.
It evaluates to true if the object or array is an instance of the specified type; it returns false otherwise.
If the left operand is null, instanceof always evaluates to false.
If an instanceof expression evaluates to true, it means that you can safely cast and assign the left operand to a variable of the type of the right operand.
The instanceof operator can be used only with reference types and objects, not primitive types and values.
Use instanceof to make sure that it is safe to cast an object.
Java has five language constructs that are sometimes considered operators and sometimes considered simply part of the basic language syntax.
The use of these language constructs is detailed elsewhere in this book but is described briefly here so that you can recognize them in code examples.
Object member access (.) An object is a collection of data and methods that operate on that data; the data fields and methods of an object are called its members.
If o is an expression that evaluates to an object reference, and f is the name of a field of the object, o.f evaluates to the value contained in that field.
If m is the name of a method, o.m refers to that method and allows it to be invoked using the ( ) operator shown later.
Each element of an array can be referred to by its number, or index.
If a is an array, and i is an expression that evaluates to an int, a[i] refers to one of the elements of a.
Unlike other operators that work with integer values, this operator restricts array index values to be of type int or narrower.
Method invocation (( )) A method is a named collection of Java code that can be run, or invoked, by following the name of the method with zero or more comma-separated expressions contained within parentheses.
The values of these expressions are the arguments to the method.
The method processes the arguments and optionally returns a value that becomes the value of the method invocation expression.
If o.m is a method that expects no arguments, the method can be invoked with o.m( )
If the method expects three arguments, for example, it can be invoked with an expression such as o.m(x,y,z)
Before the Java interpreter invokes a method, it evaluates each of the arguments to be passed to the method.
These expressions are guaranteed to be evaluated in order from left to right (which matters if any of the arguments have side effects)
Object creation (new) In Java, objects (and arrays) are created with the new operator, which is followed by the type of the object to be created and a parenthesized list of arguments to be passed to the object constructor.
A constructor is a special method that initializes a newly created object, so the object creation syntax is similar to the Java method invocation syntax.
Type conversion or casting (( )) As we’ve already seen, parentheses can also be used as an operator to perform narrowing type conversions, or casts.
The first operand of this operator is the type to be converted to; it is placed between the parentheses.
The second operand is the value to be converted; it follows the parentheses.
Statements A statement is a single command executed by the Java interpreter.
By default, the Java interpreter runs one statement after another, in the order they are written.
Many of the statements defined by Java, however, are flow-control statements, such as conditionals and loops, that alter this default order of execution in welldefined ways.
As we saw earlier in the chapter, certain types of Java expressions have side effects.
In other words, they do not simply evaluate to some value; they also change the program state in some way.
Any expression with side effects can be used as a statement simply by following it with a semicolon.
The legal types of expression statements are assignments, increments and decrements, method calls, and object creation.
A compound statement is any number and kind of statements grouped together within curly braces.
You can use a compound statement anywhere a statement is required by Java syntax:
An empty statement in Java is written as a single semicolon.
The empty statement doesn’t do anything, but the syntax is occasionally useful.
For example, you can use it to indicate an empty loop body in a for loop:
A labeled statement is simply a statement that has been given a name by prepending an identifier and a colon to it.
A local variable, often simply called a variable, is a symbolic name for a location to store a value that is defined within a method or compound statement.
All variables must be declared before they can be used; this is done with a variable declaration statement.
Because Java is a strongly typed language, a variable declaration specifies the type of the variable, and only values of that type can be stored in the variable.
In its simplest form, a variable declaration specifies a variable’s type and name:
A variable declaration can also include an initializer: an expression that specifies an initial value for the variable.
The initializer expression need not be a literal value or a constant expression that can be evaluated by the compiler; it can be an arbitrarily complex expression whose value is computed when the program is run.
A single variable declaration statement can declare and initialize more than one variable, but all variables must be of the same type.
Variable names and optional initializers are separated from each other with commas:
In Java 1.1 and later, variable declaration statements can begin with the final keyword.
This modifier specifies that once an initial value is specified for the variable, that value is never allowed to change:
Local variable declarations can also be integrated with the initialize portion of a for loop, as we’ll discuss shortly.
Local variables can be used only within the method or block of code in which they are defined.
The if statement is the fundamental control statement that allows Java to make decisions or, more precisely, to execute statements conditionally.
If the expression evaluates to true, the interpreter executes the statement.
If the expression evaluates to false the interpreter skips the statement.
In Java 5.0, the expression may be of the wrapper type Boolean instead of the primitive type boolean.
Although they look extraneous, the parentheses around the expression are a required part of the syntax for the if statement.
As I already mentioned, a block of statements enclosed in curly braces is itself a statement, so we can also write if statements that look like this:
An if statement can include an optional else keyword that is followed by a second statement.
In this form of the statement, the expression is evaluated, and, if it is true, the first statement is executed.
When you use nested if/else statements, some caution is required to ensure that the else clause goes with the appropriate if statement.
In this example, the inner if statement forms the single statement allowed by the syntax of the outer if statement.
Unfortunately, it is not clear (except from the hint given by the indentation) which if the else goes with.
The rule is that an else clause like this is associated with the nearest if statement.
This is legal code, but it is clearly not what the programmer had in mind.
When working with nested if statements, you should use curly braces to make your code easier to read.
The if/else statement is useful for testing a condition and choosing between two statements or blocks of code to execute.
But what about when you need to choose between several blocks of code? This is typically done with an else if clause, which is not really new syntax, but a common idiomatic usage of the standard if/ else statement.
It is just a series of if statements, where each if is part of the else clause of the previous statement.
Using the else if idiom is preferable to, and more legible than, writing these statements out in their fully nested form:
An if statement causes a branch in the flow of a program’s execution.
You can use multiple if statements, as shown in the previous section, to perform a multiway branch.
This is not always the best solution, however, especially when all of the branches depend on the value of a single variable.
In this case, it is inefficient to repeatedly check the value of the same variable in multiple if statements.
A better solution is to use a switch statement, which is inherited from the C programming language.
Although the syntax of this statement is not nearly as elegant as other parts of Java, the brute practicality of the construct makes it worthwhile.
If you are not familiar with the switch statement itself, you may at least be familiar with the basic concept, under the name computed goto or jump table.
A switch statement starts with an expression whose type is an int, short, char, or byte.
In Java 5.0 Integer, Short, Character and Byte wrapper types are allowed, as are enumerated types.
For example, the following switch statement is equivalent to the repeated if and else/if statements shown in the previous section:
As you can see from the example, the various entry points into a switch statement are labeled either with the keyword case, followed by an integer value and a colon, or with the special default keyword, followed by a colon.
When a switch statement executes, the interpreter computes the value of the expression in parentheses and then looks for a case label that matches that value.
If it finds one, the interpreter starts executing the block of code at the first statement following the case label.
If it does not find a case label with a matching value, the interpreter starts execution at the first statement following a special-case default: label.
Or, if there is no default: label, the interpreter skips the body of the switch statement altogether.
Note the use of the break keyword at the end of each case in the previous code.
The break statement is described later in this chapter, but, in this case, it causes the interpreter to exit the body of the switch statement.
The case clauses in a switch statement specify only the starting point of the desired code.
The individual cases are not independent blocks of code, and they do not have any implicit ending point.
Therefore, you must explicitly specify the end of each case with a break or related statement.
In the absence of break statements, a switch statement begins executing code at the first statement after the matching case label and continues executing statements until it reaches the end of the block.
On rare occasions, it is useful to write code like this that falls through from one case label to the next, but 99% of the time you should be careful to end every case and default section with a statement that causes the switch statement to stop executing.
Normally you use a break statement, but return and throw also work.
A switch statement can have more than one case clause labeling the same statement.
The switch statement and its case labels have some important restrictions.
First, the expression associated with a switch statement must have a byte, char, short, or int value.
The floating-point and boolean types are not supported, and neither is long, even though long is an integer type.
Second, the value associated with each case label must be a constant value or a constant expression the compiler can evaluate.
A case label cannot contain a runtime expression involving variables or method calls, for example.
Third, the case label values must be within the range of the data type used for the switch expression.
And finally, it is obviously not legal to have two or more case labels with the same value or more than one default label.
Just as the if statement is the basic control statement that allows Java to make decisions, the while statement is the basic statement that allows Java to perform repetitive actions.
The while statement works by first evaluating the expression, which must result in a boolean (or, in Java 5.0, a Boolean) value.
If the value is false, the interpreter skips the statement associated with the loop and moves to the next statement in the program.
If it is true, however, the statement that forms the body of the loop is executed, and the expression is reevaluated.
Again, if the value of expression is false, the interpreter moves on to the next statement in the program; otherwise it executes the statement again.
This cycle continues while the expression remains true (i.e., until it evaluates to false), at which point the while statement ends, and the interpreter moves on to the next statement.
You can create an infinite loop with the syntax while(true)
As you can see, the variable count starts off at 0 in this example and is incremented each time the body of the loop runs.
The variable names i, j, and k are commonly used as loop counters, although you should use more descriptive names if it makes your code easier to understand.
A do loop is much like a while loop, except that the loop expression is tested at the bottom of the loop rather than at the top.
This means that the body of the loop is always executed at least once.
Notice a couple of differences between the do loop and the more ordinary while loop.
First, the do loop requires both the do keyword to mark the beginning of the loop and the while keyword to mark the end and introduce the loop condition.
Also, unlike the while loop, the do loop is terminated with a semicolon.
This is because the do loop ends with the loop condition rather than simply ending with a curly brace that marks the end of the loop body.
The following do loop prints the same output as the while loop just discussed:
The do loop is much less commonly used than its while cousin because, in practice, it is unusual to encounter a situation where you are sure you always want a loop to execute at least once.
The for statement provides a looping construct that is often more convenient than the while and do loops.
The for statement takes advantage of a common looping pattern.
Most loops have a counter, or state variable of some kind, that is initialized before the loop starts, tested to determine whether to execute the loop body, and then incremented or updated somehow at the end of the loop body before the test expression is evaluated again.
The initialization, test, and update steps are the three crucial manipulations of a loop variable, and the for statement makes these three steps an explicit part of the loop syntax:
This for loop is basically equivalent to the following while loop:*
As you’ll see when we consider the continue statement, this while loop is not exactly equivalent to the for loop.
Placing the initialize, test, and update expressions at the top of a for loop makes it especially easy to understand what the loop is doing, and it prevents mistakes such as forgetting to initialize or update the loop variable.
The interpreter discards the values of the initialize and update expressions, so in order to be useful, these expressions must have side effects.
Notice how this syntax places all the important information about the loop variable on a single line, making it very clear how the loop executes.
Placing the update expression in the for statement itself also simplifies the body of the loop to a single statement; we don’t even need to use curly braces to produce a statement block.
The for loop supports some additional syntax that makes it even more convenient to use.
Because many loops use their loop variables only within the loop, the for loop allows the initialize expression to be a full variable declaration, so that the variable is scoped to the body of the loop and is not visible outside of it.
Furthermore, the for loop syntax does not restrict you to writing loops that use only a single variable.
Both the initialize and update expressions of a for loop can use a comma to separate multiple initializations and update expressions.
Even though all the examples so far have counted numbers, for loops are not restricted to loops that count numbers.
For example, you might use a for loop to iterate through the elements of a linked list:
The initialize, test, and update expressions of a for loop are all optional; only the semicolons that separate the expressions are required.
If the test expression is omitted, it is assumed to be true.
The for/in statement is a powerful new loop that was added to the language in Java 5.0
It iterates through the elements of an array or collection or any object that implements java.lang.Iterable (we’ll see more about this new interface in a moment)
On each iteration it assigns an element of the array or Iterable object.
No loop counter or Iterator object is involved; the for/in loop performs the iteration automatically, and you need not concern yourself with correct initialization or termination of the loop.
A for/in loop is written as the keyword for followed by an open parenthesis, a variable declaration (without initializer), a colon, an expression, a close parenthesis, and finally the statement (or block) that forms the body of the loop.
Despite its name, the for/in loop does not use the keyword in.
It is common to read the colon as “in,” however.
Because this statement does not have a keyword of its own, it does not have an unambiguous name.
For the while, do, and for loops, we’ve shown an example that prints ten numbers.
The for/in loop can do this too, but not on its own.
It is a specialized loop that executes its body once for each element in an array or collection.
So, in order to loop ten times (to print out ten numbers), we need an array or other collection with ten elements.
These are the numbers we want to print // This is the loop that prints them for(int n : primes)
Here are some more things you should know about the syntax of the for/in loop:
As noted earlier, expression must be either an array or an object that implements the java.lang.Iterable interface.
This type must be known at compiletime so that the compiler can generate appropriate looping code.
For example, you can’t use this loop with an array or List that you have cast to an Object.
The type of the array or Iterable elements must be assignment-compatible with the type of the variable declared in the declaration.
If you use an Iterable object that is not parameterized with an element type, the variable must be declared as an Object.
The declaration usually consists of just a type and a variable name, but it may include a final modifier and any appropriate annotations (see Chapter 4)
Using final prevents the loop variable from taking on any value other than the array or collection element the loop assigns it and serves to emphasize that the array or collection cannot be altered through the loop variable.
The loop variable of the for/in loop must be declared as part of the loop, with both a type and a variable name.
You cannot use a variable declared outside the loop as you can with the for loop.
The following class further illustrates the use of the for/in statement.
It relies on parameterized types, which are covered in Chapter 4, and you may want to return to this section after reading that chapter.
We start with a basic loop over the elements of an array.
The body of the loop is executed once for each element of args[]
Each time through one element is assigned to the variable word.
To understand how the for/in loop works with collections, we need to consider two interfaces, java.lang.Iterable, introduced in Java 5.0, and java.util.
Iterator defines a way to iterate through the elements of a collection or other data structure.
It works like this: while there are more elements in the collection (hasNext( ) returns true), call next( ) to obtain the next element of the collection.
Ordered collections, such as lists, typically have iterators that guarantee that they’ll return elements in order.
Unordered collections like Set simply guarantee that repeated calls to next( ) return all elements of the set without omissions or duplications but do not specify an ordering.
If you are not already familiar with parameterized types, you may want to skip this section now and return to it after reading Chapter 4
The Iterable interface was introduced to make the for/in loop work.
A class implements this interface in order to advertise that it is able to provide an Iterator to anyone interested.
This can be useful in its own right, even when you are not using the for/in loop)
If you implement Iterable and provide an Iterator for your own classes, you’ll be able to iterate over those classes with the for/in loop.
Remember that if you use the for/in loop with an Iterable<E>, the loop variable must be of type E or a superclass or interface.
For example, to iterate through the elements of a List<String>, the variable must be declared String or its superclass Object, or one of its interfaces CharSequence, Comparable, or Serializable.
If you use for/in to iterate through the elements of a raw List with no type parameter, the Iterable and Iterator also have no type parameter, and the type returned by the next( ) method of the raw Iterator is Object.
In this case, you have no choice but to declare the loop variable to be an Object.
It is not a general replacement for the while, for, or do loops, however, because it hides the loop counter or Iterator from you.
This means that some algorithms simply cannot be expressed with a for/in loop.
Suppose you want to print the elements of an array as a comma-separated list.
To do this, you need to print a comma after every element of the array except the last, or equivalently, before every element of the array except the first.
With a traditional for loop, the code might look like this:
This is a very straightforward task, but you simply cannot do it with for/in.
The problem is that the for/in loop doesn’t give you a loop counter or any other way to tell if you’re on the first iteration, the last iteration, or somewhere in between.
Here are two other simple loops that can’t be converted to use for/in, for the same basic reason:
A similar issue exists when using for/in to iterate through the elements of the collection.
Just as a for/in loop over an array has no way to obtain the array index of the current element, a for/in loop over a collection has no way to obtain the.
Iterator object that is being used to itemize the elements of the collection.
This means, for example, that you cannot use the remove( ) method of the iterator (or any of the additional methods defined by java.util.ListIterator) as you could if you used the Iterator explicitly yourself.
Here are some other things you cannot do with for/in:
Iterate backwards through the elements of an array or List.
Use a single loop counter to access the same-numbered elements of two distinct arrays.
Iterate through the elements of a List using calls to its get( ) method rather than calls to its iterator.
A break statement causes the Java interpreter to skip immediately to the end of a containing statement.
We have already seen the break statement used with the switch statement.
The break statement is most often written as simply the keyword break followed by a semicolon:
When used in this form, it causes the Java interpreter to immediately exit the innermost containing while, do, for, or switch statement.
The break statement can also be followed by the name of a containing labeled statement.
When used in this form, break causes the Java interpreter to immediately exit the named block, which can be any kind of statement, not just a loop or switch.
While a break statement exits a loop, a continue statement quits the current iteration of a loop and starts the next one.
When used without a label, continue causes the innermost loop to start a new iteration.
When used with a label that is the name of a containing loop, it causes the named loop to start a new iteration.
With a while loop, the Java interpreter simply returns to the top of the loop, tests the loop condition again, and, if it evaluates to true, executes the body of the loop again.
With a do loop, the interpreter jumps to the bottom of the loop, where it tests the loop condition to decide whether to perform another iteration of the loop.
With a for loop, the interpreter jumps to the top of the loop, where it first evaluates the update expression and then evaluates the test expression to decide whether to loop again.
A return statement tells the Java interpreter to stop executing the current method.
If the method is declared to return a value, the return statement is followed by an expression.
The value of the expression becomes the return value of the method.
For example, the following method computes and returns the square of a number:
Some methods are declared void to indicate that they do not return any value.
The Java interpreter runs methods like this by executing their statements one by one until it reaches the end of the method.
Sometimes, however, a void method has to return explicitly before reaching the last statement.
In this case, it can use the return statement by itself, without any expression.
For example, the following method prints, but does not return, the square root of its argument.
If the argument is a negative number, it returns without printing anything:
Java makes it easy to write multithreaded programs (see Chapter 5 for examples)
When working with multiple threads, you must often take care to prevent multiple threads from modifying an object simultaneously in a way that might.
Sections of code that must not be executed simultaneously are known as critical sections.
Java provides the synchronized statement to protect these critical sections.
The statements constitute the code of the critical section and must be enclosed in curly braces.
Before executing the critical section, the Java interpreter first obtains an exclusive lock on the object or array specified by expression.
It holds the lock until it is finished running the critical section, then releases it.
While a thread holds the lock on an object, no other thread can obtain that lock.
Therefore, no other thread can execute this or any other critical sections that require a lock on the same object.
If a thread cannot immediately obtain the lock required to execute a critical section, it simply waits until the lock becomes available.
Note that you do not have to use the synchronized statement unless your program creates multiple threads that share data.
If only one thread ever accesses a data structure, there is no need to protect it with synchronized.
When you do have to use synchronized, it might be in code like the following:
This is synchronized so that some other thread // cannot change elements of the array while we're sorting it (at // least not other threads that protect their changes to the array // with synchronized)
The synchronized keyword is also available as a modifier in Java and is more commonly used in this form than as a statement.
When applied to a method, the synchronized keyword indicates that the entire method is a critical section.
For a synchronized class method (a static method), Java obtains an exclusive lock on the class before executing the method.
For a synchronized instance method, Java obtains an exclusive lock on the class instance.
An exception is a signal that indicates some sort of exceptional condition or error has occurred.
To throw an exception is to signal an exceptional condition.
To catch an exception is to handle it—to take whatever actions are necessary to recover from it.
In Java, the throw statement is used to throw an exception:
The expression must evaluate to an exception object that describes the exception or error that has occurred.
When the Java interpreter executes a throw statement, it immediately stops normal program execution and starts looking for an exception handler that can catch, or handle, the exception.
Exception handlers are written with the try/ catch/finally statement, which is described in the next section.
The Java interpreter first looks at the enclosing block of code to see if it has an associated exception handler.
If so, it exits that block of code and starts running the exception-handling code associated with the block.
After running the exception handler, the interpreter continues execution at the statement immediately following the handler code.
If the enclosing block of code does not have an appropriate exception handler, the interpreter checks the next higher enclosing block of code in the method.
If the method does not contain an exception handler that can handle the exception thrown by the throw statement, the interpreter stops running the current method and returns to the caller.
Now the interpreter starts looking for an exception handler in the blocks of code of the calling method.
In this way, exceptions propagate up through the lexical structure of Java methods, up the call stack of the Java interpreter.
If the exception is never caught, it propagates all the way up to the main( ) method of the program.
If it is not handled in that method, the Java interpreter prints an error message, prints a stack trace to indicate where the exception occurred, and then exits.
The type of this object is java.lang.Throwable, or more commonly, some subclass* of Throwable that more specifically describes the type of exception that occurred.
Exceptions that are subclasses of Error generally indicate unrecoverable problems: the virtual machine has run out of memory, or a class file is corrupted and cannot be read, for example.
Exceptions of this sort can be caught and handled, but it is rare to do so.
Exceptions that are subclasses of Exception, on the other hand, indicate less severe conditions.
They include such exceptions as java.io.EOFException, which signals the end of a file, and java.lang.ArrayIndexOutOfBoundsException, which indicates that a program has tried to read past the end of an array.
Since an exception is an object, it can contain data, and its class can define methods that operate on that data.
The Throwable class and all its subclasses include a String field that stores a human-readable error message that describes the exceptional condition.
It’s set when the exception object is created and can be read from the exception with the getMessage( ) method.
Most exceptions contain only this single message, but a few add other data.
The java.io.InterruptedIOException, for example, adds a field named bytesTransferred that specifies how much input or output was completed before the exceptional condition interrupted it.
The try clause of this statement establishes a block of code for exception handling.
This try block is followed by zero or more catch clauses, each of which is a block of statements designed to handle a specific type of exception.
The catch clauses are followed by an optional finally block that contains cleanup code guaranteed to be executed regardless of what happens in the try block.
Both the catch and finally clauses are optional, but every try block must be accompanied by at least one or the other.
The try, catch, and finally blocks all begin and end with curly braces.
These are a required part of the syntax and cannot be omitted, even if the clause contains only a single statement.
The following code illustrates the syntax and purpose of the try/catch/finally statement:
Normally this code runs from the top of the block to the bottom // without problems.
But it can sometimes throw an exception, // either directly with a throw statement or indirectly by calling // a method that throws an exception.
This block contains statements that handle an exception object // of type SomeException or a subclass of that type.
Statements in // this block can refer to that exception object by the name e1
This block contains statements that handle an exception object // of type AnotherException or a subclass of that type.
Statements // in this block can refer to that exception object by the name e2
The try clause simply establishes a block of code that either has its exceptions handled or needs special cleanup code to be run when it terminates for any reason.
The try clause by itself doesn’t do anything interesting; it is the catch and finally clauses that do the exception-handling and cleanup operations.
A try block can be followed by zero or more catch clauses that specify code to handle various types of exceptions.
Each catch clause is declared with a single argument that specifies the type of exceptions the clause can handle and also provides a name the clause can use to refer to the exception object it is currently handling.
The type and name of an exception handled by a catch clause are exactly like the type and name of an argument passed to a method, except that for a catch clause, the argument type must be Throwable or one of its subclasses.
When an exception is thrown, the Java interpreter looks for a catch clause with an argument of the same type as the exception object or a superclass of that type.
The interpreter invokes the first such catch clause it finds.
The code within a catch block should take whatever action is necessary to cope with the exceptional condition.
If the exception is a java.io.FileNotFoundException exception, for example, you might handle it by asking the user to check his spelling and try again.
It is not required to have a catch clause for every possible exception; in some cases the correct response is to allow the exception to propagate up and be caught by the invoking method.
In other cases, such as a programming error signaled by NullPointerException, the correct response is probably not to catch the exception at all, but allow it to propagate and have the Java interpreter exit with a stack trace and an error message.
The finally clause is generally used to clean up after the code in the try clause (e.g., close files and shut down network connections)
What is useful about the finally clause is that it is guaranteed to be executed if any portion of the try block is executed, regardless of how the code in the try block completes.
In fact, the only way a try clause can exit without allowing the finally clause to be executed is by invoking the System.exit( ) method, which causes the Java interpreter to stop running.
In the normal case, control reaches the end of the try block and then proceeds to the finally block, which performs any necessary cleanup.
If control leaves the try block because of a return, continue, or break statement, the finally block is executed before control transfers to its new destination.
If an exception occurs in the try block and there is an associated catch block to handle the exception, control transfers first to the catch block and then to the finally block.
If there is no local catch block to handle the exception, control transfers first to the finally block, and then propagates up to the nearest containing catch clause that can handle the exception.
If a finally block itself transfers control with a return, continue, break, or throw statement or by calling a method that throws an exception, the pending control.
For example, if a finally clause throws an exception, that exception replaces any exception that was in the process of being thrown.
If a finally clause issues a return statement, the method returns normally, even if an exception has been thrown and has not yet been handled.
In this case, the finally block is simply cleanup code that is guaranteed to be executed, regardless of any break, continue, or return statements within the try clause.
In previous discussions of the for and continue statements, we’ve seen that a for loop cannot be naively translated into a while loop because the continue statement behaves slightly differently when used in a for loop than it does when used in a while loop.
The finally clause gives us a way to write a while loop that handles the continue statement in the same way that a for loop does.
The following while loop behaves the same, even if the statement block contains a continue statement:
Note, however, that placing the update statement within a finally block causes this while loop to respond to break statements differently than the for loop does.
An assert statement is used to document and verify design assumptions in Java code.
This statement was added in Java 1.4 and cannot be used with previous versions of the language.
An assertion consists of the assert keyword followed by a boolean expression that the programmer believes should always evaluate to true.
By default, assertions are not enabled, and the assert statement does not actually do anything.
It is possible to enable assertions as a debugging and testing tool, however; when this is done, the assert statement evaluates the expression.
On the other hand, if the expression evaluates to false, the assertion fails, and the assert statement throws a java.lang.AssertionError.
The assert statement may include an optional second expression, separated from the first by a colon.
When assertions are enabled and the first expression evaluates to false, the value of the second expression is taken as an error code or error message and is passed to the AssertionError( ) constructor.
It is important to remember that the assertion must be a boolean expression, which typically means that it contains a comparison operator or invokes a boolean-valued method.
For this reason, the javac compiler does not recognize the assert statement by default.
To compile Java code that uses the assert statement, you must use the command-line argument -source 1.4
If it finds assert used as an identifier, it issues an incompatibility warning to encourage you to modify your code.
If you have legacy code that still uses assert as an identifier, it will no longer compile by default in Java 5.0
For efficiency, it does not make sense to test assertions each time code is executed.
Thus, by default, assertions are disabled, and assert statements have no effect.
The assertion code remains compiled in the class files, however, so it can always be enabled for testing, diagnostic, and debugging purposes.
You can enable assertions, either across the board or selectively, with command-line arguments to the Java interpreter.
To enable assertions in all classes except for system classes, use the -ea argument.
To enable assertions within a specific class, use -ea followed by a colon and the classname:
To enable assertions for all classes in a package and in all of its subpackages, follow the -ea argument with a colon, the package name, and three dots:
You can disable assertions in the same way, using the -da argument.
For example, to enable assertions throughout a package and then disable them in a specific class or subpackage, use:
If you prefer verbose command-line arguments, you can use -enableassertions and -disableassertions instead of -ea and -da and -enablesystemassertions instead of -esa.
Java 1.4 added to java.lang.ClassLoader methods for enabling and disabling the assertions for classes loaded through that ClassLoader.
If you use a custom class loader in your program and want to turn on assertions, you may be interested in these methods.
Because assertions are disabled by default and impose no performance penalty on your code, you can use them liberally to document any assumptions you make while programming.
It may take some time to get used to this, but as you do, you’ll find more and more uses for the assert statement.
Without assertions, you might code an if statement that looks like this:
The comment in this code is an informal assertion indicating that you believe that within the body of the else clause, x will always equal 1
The comment and the assumption that go along with it are no longer valid, and this may cause a bug that is not immediately apparent or is difficult to localize.
The solution in this situation is to convert your comment into an assert statement.
Now, if x somehow ends up holding an unexpected value, an AssertionError is thrown, which makes the bug immediately apparent and easy to pinpoint.
This message is not intended to mean anything to an end user, but to provide enough information so that you know not just that an assertion failed but also what caused it to fail.
If you write a switch statement without a default clause, you make an assumption about the set of possible values for the switch expression.
If you believe that no other value is possible, you can add an assert statement to document and validate that fact.
It is a useful “dead-end” statement when you believe that the statement can never be reached.
Another common use of the assert statement is to test whether the arguments passed to a method all have values that are legal for that method; this is also known as enforcing method preconditions.
Now go on to create and return a subarray of a...
The programmer has used an assert statement to document a precondition of the subArray( ) method and state that she believes that all methods that invoke this private method do in fact honor that precondition.
She can state this because she has control over all the methods that invoke subArray( )
She can verify her belief by enabling assertions while testing the code.
But once the code is tested, if assertions are left disabled, the method does not suffer the overhead of testing its arguments each time it is called.
Note that the programmer did not use an assert statement to test that argument a is non-null and that the x and y arguments were legal indexes into that array.
These implicit preconditions are always tested by Java at runtime, and a failure results in an unchecked NullPointerException or an ArrayIndexOutOfBoundsException, so an assertion is not required for them.
It is important to understand that the assert statement is not suitable for enforcing preconditions on public methods.
A public method can be called from anywhere, and the programmer cannot assert in advance that it will be invoked correctly.
To be robust, a public API must explicitly test its arguments and enforce its preconditions each time it is called, whether or not assertions are enabled.
A related use of the assert statement is to verify a class invariant.
Suppose you are creating a class that represents a list of objects and allows objects to be inserted and deleted but always maintains the list in sorted order.
You believe that your implementation is correct and that the insertion methods always leave the list in sorted order, but you want to test this to be sure.
You might write a method that tests whether the list is actually sorted, then use an assert statement to invoke the method at the end of each method that modifies the list.
When writing code that must be threadsafe, you must obtain locks (using a synchronized method or statement) when required.
One common use of the assert statement in this situation is to verify that the current thread holds the lock it requires:
The Thread.holdsLock( ) method was added in Java 1.4 primarily for use with the assert statement.
To use assertions effectively, you must be aware of a couple of fine points.
First, remember that your programs will sometimes run with assertions enabled and.
This means that you should be careful not to write assertion expressions that contain side effects.
If you do, your code will run differently when assertions are enabled than it will when they are disabled.
There are a few exceptions to this rule, of course.
For example, if a method contains two assert statements, the first can include a side effect that affects only the second assertion.
Another use of side effects in assertions is the following idiom that determines whether assertions are enabled (which is not something that your code should ever really need to do):
Note that the expression in the assert statement is an assignment, not a comparison.
The value of an assignment expression is always the value assigned, so this expression always evaluates to true, and the assertion never fails.
Because this assignment expression is part of an assert statement, the assertions variable is set to true only if assertions are enabled.
In addition to avoiding side effects in your assertions, another rule for working with the assert statement is that you should never try to catch an AssertionError (unless you catch it at the top level simply so that you can display the error in a more user-friendly fashion)
If an AssertionError is thrown, it indicates that one of the programmer’s assumptions has not held up.
This means that the code is being used outside of the parameters for which it was designed, and it cannot be expected to work correctly.
In short, there is no plausible way to recover from an AssertionError, and you should not attempt to catch it.
Methods A method is a named sequence of Java statements that can be invoked by other Java code.
When a method is invoked, it is passed zero or more values known as arguments.
The method performs some computations and, optionally, returns a value.
Because method invocations can have side effects, however, they can also be used as expression statements.
This section does not discuss method invocation, but instead describes how to define methods.
You already know how to define the body of a method; it is simply an arbitrary sequence of statements enclosed within curly braces.
What is more interesting about a method is its signature.* The signature specifies the following:
The number, order, type, and name of the parameters used by the method.
In the Java Language Specification, the term “signature” has a technical meaning that is slightly different than that used here.
This book uses a less formal definition of method signature.
The checked exceptions that the method can throw (the signature may also list unchecked exceptions, but these are not required)
Various method modifiers that provide additional information about the method.
A method signature defines everything you need to know about a method before calling it.
It is the method specification and defines the API for the method.
The reference section of this book is essentially a list of method signatures for all In order to use the reference section of this book, you need to know how to read a method signature.
And, in order to write Java programs, you need to know how to define your own methods, each of which begins with a method signature.
The signature (the method specification) is followed by the method body (the method implementation), which is simply a sequence of Java statements enclosed in curly braces.
If the method is abstract (see Chapter 3), the implementation is omitted, and the method body is replaced with a single semicolon.
In Java 5.0 and later, the signature of a generic method may also include type variable declarations.
Generic methods and type variables are discussed in Chapter 4
Here are some example method definitions, which begin with the signature and are followed by the method body:
This method is passed an array of strings and has no return value.
All Java programs have a main entry point with this name and signature.
This method is passed two double arguments and returns a double.
This method is abstract which means it has no body.
A method might be declared with the public and static modifiers, for example.
The allowed modifiers and their meanings are described in the next section.
The type in a method signature specifies the return type of the method.
If the method does not return a value, type must be void.
If a method is declared with a non-void return type, it must include a return statement that returns a value of (or convertible to) the declared type.
A constructor is a special kind of method used to initialize newly created objects.
As we’ll see in Chapter 3, constructors are defined just like methods, except that their signatures do not include this type specification.
The name of a method follows the specification of its modifiers and type.
Method names, like variable names, are Java identifiers and, like all Java identifiers, may contain letters in any language represented by the Unicode character set.
It is legal, and often quite useful, to define more than one method with the same name, as long as each version of the method has a different parameter list.
Defining multiple methods with the same name is called method overloading.
The System.out.println( ) method we’ve seen so much of is an overloaded method.
One method by this name prints a string and other methods by the same name print the values of the various primitive types.
The Java compiler decides which method to call based on the type of the argument passed to the method.
When you are defining a method, the name of the method is always followed by the method’s parameter list, which must be enclosed in parentheses.
The parameter list defines zero or more arguments that are passed to the method.
The parameter specifications, if there are any, each consist of a type and a name and are separated from each other by commas (if there are multiple parameters)
When a method is invoked, the argument values it is passed must match the number, type, and order of the parameters specified in this method signature line.
The values passed need not have exactly the same type as specified in the signature, but they must be convertible to those types without casting.
In Java 5.0 and later, it is possible to define and invoke methods that accept a variable number of arguments, using a syntax known colloquially as varargs.
The final part of a method signature is the throws clause, which is used to list the checked exceptions that a method can throw.
Checked exceptions are a category of exception classes that must be listed in the throws clauses of methods that can throw them.
If a method uses the throw statement to throw a checked exception, or if it calls some other method that throws a checked exception and does not catch or handle that exception, the method must declare that it can throw that exception.
If a method can throw one or more checked exceptions, it specifies this by placing the throws keyword after the argument list and following it by the name of the exception class or classes it can throw.
If a method does not throw any exceptions, it does not use the throws keyword.
If a method throws more than one type of exception, separate the names of the exception classes from each other with commas.
The modifiers of a method consist of zero or more modifier keywords such as and @SuppressWarnings, are treated as modifiers and may be mixed in with the.
Anyone can define new annotation types, so it is not possible to list all possible method annotations.
The curly braces and Java statements that would normally comprise the body of the method are replaced with a single semicolon.
A class that includes an abstract method must itself be declared abstract.
Such a class is incomplete and cannot be instantiated (see Chapter 3)
All private methods are implicitly final, as are all methods of any class that is declared final.
Like abstract methods, native methods have no body: the curly braces are replaced with a semicolon.
When Java was first released, native methods were sometimes used for efficiency reasons.
Instead, native methods are used to interface Java code to existing libraries written in C or C++
Native methods are implicitly platform-dependent, and the procedure for linking the implementation with the Java class that declares the method is dependent on the implementation of the Java virtual machine.
These access modifiers specify whether and where a method can be used outside of the class that defines it.
Before a thread can invoke a synchronized method, it must obtain a lock on the method’s class (for static methods) or on the relevant instance of the class (for non-static methods)
This prevents two threads from executing the method at the same time.
The synchronized modifier is an implementation detail (because methods can make themselves threadsafe in other ways) and is not formally part of the.
Good documentation specifies explicitly whether a method is threadsafe; you should not rely on the presence or absence of the synchronized keyword when working with multithreaded programs.
In the discussion of the throw statement, we said that exceptions are Throwable objects and that exceptions fall into two main categories, specified by the Error and Exception subclasses.
In addition to making a distinction between Error and Exception classes, the Java exception-handling scheme also distinguishes between checked and unchecked exceptions.
Any exception object that is an Exception is checked, unless it is a subclass of java.lang.RuntimeException, in which case it is unchecked.
The distinction between checked and unchecked exceptions has to do with the circumstances under which the exceptions are thrown.
Practically any method can throw an unchecked exception at essentially any time.
There is no way to predict an OutOfMemoryError, for example, and any method that uses objects or arrays can throw a NullPointerException if it is passed an invalid null argument.
Checked exceptions, on the other hand, arise only in specific, well-defined circumstances.
If you try to read data from a file, for example, you must at least consider the possibility that a FileNotFoundException will be thrown if the specified file cannot be found.
Java has different rules for working with checked and unchecked exceptions.
If you write a method that throws a checked exception, you must use a throws clause to declare the exception in the method signature.
The reason these types of exceptions are called checked exceptions is that the Java compiler checks to make sure you have declared them in method signatures and produces a compilation error if you have not.
Even if you never throw an exception yourself, sometimes you must use a throws clause to declare an exception.
If your method calls a method that can throw a checked exception, you must either include exception-handling code to handle that exception or use throws to declare that your method can also throw that exception.
For example, the following method reads the first line of text from a named file.
It uses methods that can throw various types of java.io.IOException objects, so it declares this fact with a throws clause:
How do you know if the method you are calling can throw a checked exception? You can look at its method signature to find out.
Or, failing that, the Java compiler will tell you (by reporting a compilation error) if you’ve called a method whose exceptions you must handle or declare.
In Java 5.0 and later, methods may be declared to accept, and may be invoked with, variable numbers of arguments.
The new System.out.printf( ) method as well as the related format( ) methods of String and java.util.Formatter use varargs.
The similar, but unrelated, format( ) method of java.text.MessageFormat has been converted to use varargs as have a number of important methods from the Reflection API of java.lang.reflect.
A variable-length argument list is declared by following the type of the last argument to the method with an ellipsis (...), indicating that this last argument can be repeated zero or more times.
The second, however may be repeated zero or more times.
All of the following are legal invocations of max( ):
As you can tell from the for/in statement in the body of max( ), the second argument is treated as an array of int values.
To the Java interpreter, the max( ) method is indistinguishable from this one:
To convert a varargs signature to the “real” signature, simply replace ...
Remember that only one ellipsis can appear in a parameter list, and it may only appear on the last parameter in the list.
Since varargs methods are compiled into methods that expect an array of arguments, invocations of those methods are compiled to include code that creates and initializes such an array.
If you already have method arguments stored in an array, it is perfectly legal for you to pass them to the method that way, instead of writing them out individually.
The converse is not true, however: you can only use varargs method invocation syntax when the method is actually declared as a varargs method using an ellipsis.
The printf( ) and format( ) methods mentioned at the beginning of this section are all declared with an Object...
It does not arise very often in practice, but studying the quirk will solidify your understanding of varargs.
Recall that varargs methods can be invoked with an argument of array type or any number of arguments of the element type.
Here we invoke the varargs method with individual Object arguments.
Note the use of autoboxing to convert primitives to wrapper objects.
This line does the same thing but passes the arguments in an array // that has already been created:
Now consider the following Object[], which we wish to pass // as a single argument, not as an array of two arguments.
If we want arg to be treated as a single Object argument, we need to // pass it as an the element of an array.
An easier way is to convince the compiler to create the array itself.
We use a cast to say that arg is a single Object argument, not an array:
As part of the addition of generic types, Java 5.0 now also supports covariant returns.
This means that an overriding method may narrow the return type of the method it overrides.* The following example makes this clearer:
Method overriding is not the same as method overloading discussed earlier in this section.
Method overriding involves subclassing and is covered in Chapter 3
If you are not already familiar with these concepts, you should skip this section for now and return to it later.
This code defines four classes: a two-dimensional point, a three-dimensional point, and event objects that represent an event in two-dimensional space and in three-dimensional space.
In Java 1.4 and earlier, the return type of an overriding method must be identical to the type of the method it overrides.
This one is a compile-time assertion that the method overrides something.
The compiler would have produced a compilation error if the assertion failed.
Classes and Objects Introduced Now that we have introduced operators, expressions, statements, and methods, we can finally talk about classes.
A class is a named collection of fields that hold data values and methods that operate on those values.
Classes are just one of five reference types supported by Java, but they are the most important type.
Classes are thoroughly documented in a chapter of their own, Chapter 3
We introduce them here, however, because they are the next higher level of syntax after methods, and because the rest of this chapter requires a basic familiarity with the concept of class and the basic syntax for defining a class, instantiating it, and using the resulting object.
The most important thing about classes is that they define new data types.
For example, you might define a class named Point to represent a data point in the two-dimensional Cartesian coordinate system.
This class would define fields (each of type double) to hold the X and Y coordinates of a point and methods to manipulate and operate on the point.
When discussing data types, it is important to distinguish between the data type itself and the values the data type represents.
A class is a data type; a class value is called an object.
We use the name class because each class defines a type (or kind, or species, or class) of objects.
The Point class is a data type that represents X,Y points, while a Point object represents a single specific X,Y point.
As you might imagine, classes and their objects are closely linked.
Here is a possible definition of the Point class we have been discussing:
This class definition is stored in a file named Point.java and compiled to a file named Point.class, where it is available for use by Java programs and other classes.
This class definition is provided here for completeness and to provide context, but don’t expect to understand all the details just yet; most of Chapter 3 is devoted to the topic of defining classes.
Keep in mind that you don’t have to define every class you want to use in a Java program.
The Java platform includes thousands of predefined classes that are guaranteed to be available on every computer that runs Java.
Now that we have defined the Point class as a new data type, we can use the following line to declare a variable that holds a Point object:
Declaring a variable to hold a Point object does not create the object itself, however.
To actually create an object, you must use the new operator.
This keyword is followed by the object’s class (i.e., its type) and an optional argument list in parentheses.
These arguments are passed to the constructor method for the class, which initializes internal fields in the new object:
Declare a variable p and store a reference to the new Point object in it.
The new keyword is by far the most common way to create objects in Java.
First, a couple of classes are so important that Java defines special literal syntax for creating objects of those types (as we discuss later in this section)
Second, Java supports a dynamic loading mechanism that allows programs to load classes and create instances of those classes dynamically.
This dynamic instantiation is done with the newInstance( ) methods of java.lang.Class and java.lang.reflect.Constructor.
In other words, an object that has had its state saved, or serialized, usually to a file, can be recreated using the java.io.
Now that we’ve seen how to define classes and instantiate them by creating objects, we need to look at the Java syntax that allows us to use those objects.
Recall that a class defines a collection of fields and methods.
Each object has its own copies of those fields and has access to those methods.
We use the dot character (.) to access the named fields and methods of an object.
This syntax is central to object-oriented programming in Java, so you’ll see it a lot.
This tells the Java compiler to look up a method named distanceFromOrigin( ) defined by the class Point and use that method to perform a computation on the fields of the object p.
We’ll cover the details of this operation in Chapter 3
In our discussion of primitive types, we saw that each primitive type has a literal syntax for including values of the type literally into the text of a program.
Java also defines a literal syntax for a few special reference types, as described next.
The String class represents text as a string of characters.
Since programs usually communicate with their users through the written word, the ability to manipulate strings of text is quite important in any programming language.
In some languages, strings are a primitive type, on a par with integers and characters.
In Java, however, strings are objects; the data type used to represent text is the String class.
Because strings are such a fundamental data type, Java allows you to include text literally in programs by placing it between double-quote (") characters.
Don’t confuse the double-quote characters that surround string literals with the single-quote (or apostrophe) characters that surround char literals.
String literals can contain any of the escape sequences char literals can (see Table 2-2)
Escape sequences are particularly useful for embedding double-quote characters within double-quoted string literals.
String literals cannot contain comments and may consist of only a single line.
Java does not support any kind of continuation-character syntax that allows two separate lines to be treated as a single line.
If you need to represent a long string of text that does not fit on a single line, break it into independent string literals and use the + operator to concatenate the literals.
This concatenation of literals is done when your program is compiled, not when it is run, so you do not need to worry about any kind of performance penalty.
The second type that supports its own special object literal syntax is the class named Class.
Instances of the Class class represent a Java data type.
To include a Class object literally in a Java program, follow the name of any data type with .class.
The null keyword is a special literal value that is a reference to nothing, or an absence of a reference.
The null value is unique because it is a member of every reference type.
You can assign null to variables of any reference type.
Arrays An array is a special kind of object that holds zero or more primitive values or references.
These values are held in the elements of the array, which are unnamed variables referred to by their position or index.
The type of an array is characterized by its element type, and all elements of the array must be of that type.
Array elements are numbered starting with zero, and valid indexes range from zero to the number of elements minus one.
The array element with index 1, for example, is the second element in the array.
The number of elements in an array is its length.
The length of an array is specified when the array is created, and it never changes.
The element type of an array may be any valid Java type, including array types.
This means that Java supports arrays of arrays, which provide a kind of multidimensional array capability.
Java does not support the matrix-style multidimensional arrays found in some languages.
Instances of arrays are objects, just as the instances of a class are.* Unlike classes, array types do not have to be defined.
For example, the following code declares three variables of array type:
The length of an array is not part of the array type.
It is not possible, for example, to declare a method that expects an array of exactly four int values, for example.
Array types are not classes, but array instances are objects.
Arrays implement the Cloneable interface and override the clone( ) method to guarantee that an array can always be cloned and that clone( ) never throws a CloneNotSupportedException.
Arrays also implement Serializable so that any array can be serialized if its element type can be serialized.
Finally, all arrays have a public final int field named length that specifies the number of elements in the array.
Since arrays extend Object and implement the Cloneable and Serializable interfaces, any array type can be widened to any of these three types.
But certain array types can also be widened to other array types.
Note that there are no widening conversions of this sort for arrays of a given primitive type.
As examples, the following lines of code show legal array widening conversions:
Unlike with classes and their instances, we use the term “array” for both the array type and the array instance.
In practice, it is usually clear from context whether a type or a value is being discussed.
This ability to widen an array type to another array type means that the compiletime type of an array is not always the same as its runtime type.
The compiler must usually insert runtime checks before any operation that stores a reference value into an array element to ensure that the runtime type of the value matches the runtime type of the array element.
As we’ve seen, an array type is written simply by placing brackets after the element type.
For compatibility with C and C++, however, Java supports an alternative syntax in variable declarations: brackets may be placed after the name of the variable instead of, or in addition to, the element type.
These three lines declare fields of the same array type:
This method signature includes two parameters with the same type.
This compatibility syntax is uncommon, and its use is strongly discouraged.
To create an array value in Java, you use the new keyword, just as you do to create an object.
Array types don’t have constructors, but you are required to specify a length whenever you create an array.
Specify the desired size of your array as a nonnegative integer between square brackets:
Array creation expressions can also be used to create and initialize a multidimensional rectangular array of arrays.
This syntax is somewhat more complicated and is explained later in this section.
To create an array and initialize its elements in a single expression, omit the array length and follow the square brackets with a comma-separated list of expressions within curly braces.
The type of each expression must be assignable to the element type of the array, of course.
The length of the array that is created is equal.
It is legal, but not necessary, to include a trailing comma following the last expression in the list.
Note that this syntax allows arrays to be created, initialized, and used without ever being assigned to a variable.
In a sense these array creation expressions are anonymous array literals.
Call a method, passing an anonymous array literal that contains two strings.
Call another method with an anonymous array (of anonymous objects) new Point(3,4),
When an array initializer is part of a variable declaration, you may omit the new keyword and element type and  list the desired array elements within curly braces:
The Java Virtual Machine architecture does not support any kind of efficient array initialization.
In other words, array literals are created and initialized when the program is run, not when the program is compiled.
This is compiled into Java byte codes that are equivalent to:
If you want to initialize a large array, you should think twice before including the values literally in the program, since the Java compiler has to emit lots of Java byte codes to initialize the array.
It may be more space-efficient to store your data in an external file and read it into the program at runtime.
The fact that Java does all array initialization at runtime has an important corollary, however.
It means that the expressions in an array initializer may be computed at runtime and need not be compile-time constants.
Once an array has been created, you are ready to start using it.
The following sections explain basic access to the elements of an array and cover common idioms of array usage such as iterating through the elements of an array and copying an array or part of an array.
When an array element appears in an expression, it evaluates to the value held in the element.
And when an array element appears on the left-hand side of an assignment operator, a new value is stored into that element.
Unlike a normal variable, however, an array element has no name, only a number.
If a is an expression that evaluates to an array reference, you index that array and refer to a specific element with a[i], where i is an integer literal or an expression that evaluates to an int.
Both the array reference and the array index may be more complex expressions.
The array index expression must be of type int, or a type that can be widened to an int: byte, short, or even char.
It is obviously not legal to index an array with a boolean, float, or double value.
Remember that the length field of an array is an int and that arrays may not have more than Integer.MAX_VALUE elements.
Indexing an array with an expression of type long generates a compile-time error, even if the value of that expression at runtime would be within the range of an int.
A common bug involving arrays is use of an index that is too small (a negative index) or too large (greater than or equal to the array length)
In languages like C or C++, accessing elements before the beginning or after the end of an array yields unpredictable behavior that can vary from invocation to invocation and platform to platform.
Such bugs may not always be caught, and if a failure occurs, it may be at some later time.
While it is just as easy to write faulty array indexing code in Java, Java guarantees predictable results by checking every array access at runtime.
If an array index is too small or too large, Java throws an ArrayIndexOutOfBoundsException immediately.
It is common to write loops that iterate through each of the elements of an array in order to perform some operation on it.
The following code, for example, computes the sum of an array of integers:
The structure of this for loop is idiomatic, and you’ll see it frequently.
In Java 5.0 and later, arrays can also be iterated with the for/in loop.
All array types implement the Cloneable interface, and any array can be copied by invoking its clone( ) method.
Note that a cast is required to convert the return value to the appropriate array type, but that the clone( ) method of arrays is guaranteed not to throw CloneNotSupportedException:
If the element type of the array is a reference type, only the references are copied, not the referenced objects themselves.
Because the copy is shallow, any array can be cloned, even if the element type is not itself Cloneable.
Sometimes you simply want to copy elements from one existing array to another existing array.
The System.arraycopy( ) method is designed to do this efficiently, and you can assume that Java VM implementations performs this method using high-speed block copy operations on the underlying hardware.
First pass the source array from which elements are to be copied.
Second, pass the index of the start element in that array.
Pass the destination array and the destination index as the third and fourth arguments.
Finally, as the fifth argument, specify the number of elements to be copied.
The java.util.Arrays class contains a number of static utility methods for working with arrays.
Most of these methods are heavily overloaded, with versions for arrays of each primitive type and another version for arrays of objects.
The sort( ) and binarySearch( ) methods are particularly useful for sorting and searching arrays.
The equals( ) method allows you to compare the content of two arrays.
The Arrays.toString( ) method is useful when you want to convert array content to a string, such as for debugging or logging output.
As of Java 5.0, the Arrays class includes deepEquals( ), deepHashCode( ), and deepToString( ) methods that work correctly for multidimensional arrays.
As we’ve seen, an array type is written as the element type followed by a pair of square brackets.
When the elements of an array are themselves arrays, we say that the array is multidimensional.
In order to work with multidimensional arrays, you need to understand a few additional details.
Imagine that you want to use a multidimensional array to represent a multiplication table:
Each of the pairs of square brackets represents one dimension, so this is a twodimensional array.
To access a single int element of this two-dimensional array, you must specify two index values, one for each dimension.
Assuming that this array was actually initialized as a multiplication table, the int value stored at any given element would be the product of the two indexes.
To create a new multidimensional array, use the new keyword and specify the size of both dimensions of the array.
In some languages, an array like this would be created as a single block of 100 int values.
Declares a variable named products to hold an array of arrays of int.
It assigns each of these 10 new arrays to the elements of the initial array.
To put this another way, the previous single line of code is equivalent to the following code:
The new keyword performs this additional initialization automatically for you.
It works with arrays with more than two dimensions as well:
When using new with multidimensional arrays, you do not have to specify a size for all dimensions of the array, only the leftmost dimension or dimensions.
If you specify a size for only some of the.
Like a one-dimensional array, a multidimensional array can be initialized using an array initializer.
Simply use nested sets of curly braces to nest arrays within arrays.
For example, we can declare, create, and initialize a 5×5 multiplication table like this:
Or, if you want to use a multidimensional array without declaring a variable, you can use the anonymous initializer syntax:
When you create a multidimensional array using the new keyword, you always get a rectangular array: one in which all the array values for a given dimension have the same size.
This is perfect for rectangular data structures, such as matrices.
However, because multidimensional arrays are implemented as arrays of arrays in Java, instead of as a single rectangular block of elements, you are in no way constrained to use rectangular arrays.
For example, since our multiplication table is symmetrical diagonally from top left to bottom right, we can represent the same information in a nonrectangular array with fewer elements:
When working with multidimensional arrays, you’ll often find yourself using nested loops to create or initialize them.
For example, you can create and initialize a large triangular multiplication table as follows:
Reference Types Now that we’ve covered arrays and introduced classes and objects, we can turn to a more general description of reference types.
Classes and arrays are two of Java’s five kinds of reference types.
Classes were introduced earlier and are covered in complete detail, along with interfaces, in Chapter 3
This section does not cover specific syntax for any particular reference type, but instead explains the general behavior of reference types and illustrates how they differ from Java’s primitive types.
In this section, the term object refers to a value or instance of any reference type, including arrays.
Reference types and objects differ substantially from primitive types and their primitive values:
Reference types are user-defined, so there is an unlimited number of them.
For example, a program might define a class named Point and use objects of this newly defined type to store and manipulate X,Y points in a Cartesian coordinate system.
Reference types are aggregate types that hold zero or more primitive values or objects.
Our hypothetical Point class, for example, might hold two double values to represent the X and Y coordinates of the points.
Primitive types require between one and eight bytes of memory.
When a primitive value is stored in a variable or passed to a method, the computer makes a copy of the bytes that hold the value.
Objects, on the other hand, may require substantially more memory.
Memory to store an object is dynamically allocated on the heap when the object is created and this memory is automatically “garbage-collected” when the object is no longer needed.
When an object is assigned to a variable or passed to a method, the memory that represents the object is not copied.
Instead, only a reference to that memory is stored in the variable or passed to the method.
This last difference between primitive and reference types explains why reference types are so named.
The sections that follow are devoted to exploring the substantial differences between types that are manipulated by value and types that are manipulated by reference.
Before moving on, however, it is worth briefly considering the nature of references.
A reference is simply some kind of reference to an object.
References are completely opaque in Java and the representation of a reference is an implementation detail of the Java interpreter.
If you are a C programmer, however, you can safely imagine a reference as a pointer or a memory address.
Remember, though, that Java programs cannot manipulate references in any way.
Unlike pointers in C and C++, references cannot be converted to or from integers, and they cannot be incremented or decremented.
In Java, primitive types are always handled exclusively by value, and objects are always handled exclusively by reference: the.
After these lines execute, the variable y contains a copy of the value held in the variable x.
Now think about what happens if we run the same basic code but use a reference type instead of a primitive type:
After this code runs, the variable q holds a copy of the reference held in the variable p.
There is still only one copy of the Point object in the VM, but there are now two copies of the reference to that object.
Suppose the two previous lines of code are followed by this code:
Since the variables p and q hold references to the same object, either variable can be used to make changes to the object, and those changes are visible through the other variable as well.
This behavior is not specific to objects; the same thing happens with arrays, as illustrated by the following code:
A similar difference in behavior between primitive types and reference types occurs when arguments are passed to methods.
When this method is invoked, the method is given a copy of the argument used to invoke the method in the parameter x.
The code in the method uses x as a loop counter and decrements it to zero.
Since x is a primitive type, the method has its own private copy of this value, so this is a perfectly reasonable thing to do.
On the other hand, consider what happens if we modify the method so that the parameter is a reference type:
When this method is invoked, it is passed a private copy of a reference to a Point object and can use this reference to change the Point object.
When the changeReference( ) method is invoked, it is passed a copy of the reference held in variable q.
Now both the variable q and the method parameter p hold references to the same object.
The method can use its reference to change the contents of the object.
Note, however, that it cannot change the contents of the variable q.
In other words, the method can change the Point object beyond recognition, but it cannot change the fact that the variable q refers to that object.
To make an actual copy of an object, you must use the special clone( ) method (inherited by all objects from java.lang.Object):
Note that a cast is necessary to coerce the return value of the clone( ) method to the correct type.
There are a couple of points you should be aware of when using clone( )
Java only allows an object to be cloned if the object’s class has explicitly declared itself to be cloneable by implementing the Cloneable interface.
We haven’t discussed interfaces or how they are implemented yet; that is covered in Chapter 3.) The definition of Point that we showed earlier does not actually implement this interface, so our Point type, as implemented, is not cloneable.
If you call the clone( ) method for a noncloneable object, it throws a CloneNotSupportedException.
When you use the clone( ) method, you may want to use it within a try block to catch this exception.
The second thing you need to understand about clone( ) is that, by default, it creates a shallow copy of an object.
The copied object contains copies of all the primitive values and references in the original object.
In other words, any references in the object are copied, not cloned; clone( ) does not recursively make copies of the objects referred to by those references.
A class may need to override this shallow copy behavior by defining its own version of the clone( ) method that explicitly performs a deeper copy where needed.
To understand the shallow copy behavior of clone( ), consider cloning a two-dimensional array of arrays:
If you want to make a deep copy of this multidimensional array, you have to copy each dimension explicitly:
We’ve seen that primitive types and reference types differ significantly in the way they are assigned to variables, passed to methods, and copied.
The types also differ in the way they are compared for equality.
When used with primitive values, references refer to the same object; it does not test whether two objects have the same content.
When working with reference types, there are two kinds of equality: equality of reference and equality of object.
It is important to distinguish between these two kinds of equality.
To test two nonidentical objects for equality, pass one of them to the equals( ) method of the other:
Our Point class does not do this, but the String class does, as indicated in the code example.
You can call the equals( ) method inherit the default equals( ) method that compares references rather than array content.
You can compare arrays for equality with the convenience method java.util.Arrays.equals( )
Thus, if the method modifies its parameters, those modifications are visible when the method returns, even for primitive types.
However, when a reference type is involved, the value that is passed is a reference.
If Java were a pass-by-reference language, when a reference type is passed to a method, it would be passed as a reference to the reference.
As we’ve already noted, objects are composite values that can contain a number of other values and may require a substantial amount of memory.
When you use the new keyword to create a new object or use an object literal in your program, Java automatically creates the object for you, allocating whatever amount of memory is necessary.
You don’t need to do anything to make this happen.
In addition, Java also automatically reclaims that memory for reuse when it is no longer needed.
An object is considered garbage when no references to it are stored in any variables, the fields of any objects, or the elements of any arrays.
After the Java interpreter executes the third line, a reference to the new Point object has replaced the reference to the first one.
No references to the first object remain, so it is garbage.
At some point, the garbage collector discovers this and reclaims the memory used by the object.
Even though it seems like magic, it really works! There is a slight, but usually negligible, performance penalty due to the use of garbage collection.
However, having garbage collection built into the language dramatically reduces the occurrence of memory leaks and related bugs and almost always improves programmer productivity.
As with primitive types, reference type conversions can be widening conversions (allowed automatically by the compiler) or narrowing conversions that require a cast (and possibly a.
In order to understand reference type conversions, you need to understand that reference types form a hierarchy, usually called the class hierarchy.
Every Java reference type extends some other type, known as its superclass.
A type inherits the fields and methods of its superclass and then defines its own additional fields and methods.
A special class named Object serves as the root of the class hierarchy in Java.
The Object class defines a number of special methods that are inherited (or overridden) by all objects.
The predefined String class and the Point class we discussed earlier in this chapter both extend Object.
Thus, we can say that all String objects are also Object objects.
We can also say that all Point objects are Object objects.
We cannot say that every Object is a String because, as we’ve just seen, some Object objects are Point objects.
With this simple understanding of the class hierarchy, we can return to the rules of reference type conversion:
The Java compiler does not allow you to convert a String to a Point, for example, even if you use a cast operator.
An object can be converted to the type of its superclass or of any ancestor class.
This is a widening conversion, so no cast is required.
For example, a String value can be assigned to a variable of type Object or passed to a method where an Object parameter is expected.
Note that no conversion is actually performed; the object is simply treated as if it were an instance of the superclass.
An object can be converted to the type of a subclass, but this is a narrowing conversion and requires a cast.
The Java compiler provisionally allows this kind of conversion, but the Java interpreter checks at runtime to make sure it is valid.
Only cast an object to the type of a subclass if you are sure, based on the logic of your program, that the object is actually an instance of the subclass.
For example, if we assign a String object to a variable of type Object, we can later cast the value of that variable back to type String:
Arrays are objects and follow some conversion rules of their own.
First, any array can be converted to an Object value through a widening conversion.
A narrowing conversion with a cast can convert such an object value back to an array.
Note that these array conversion rules apply only to arrays of objects and arrays of arrays.
An array of primitive type cannot be converted to any other array type, even if the primitive base types can be converted:
It is sometimes useful to treat primitive values as objects, and for this reason, the Java platform includes wrapper classes for each of the primitive types.
Boolean, Byte, Short, Character, Integer, Long, Float, and Double are immutable classes whose instances each hold a single primitive value.
These wrapper classes are usually used when you want to store primitive values in collections such as java.util.List:
Prior to Java 5.0, no conversions between primitive types and reference types were allowed.
This code explicitly calls the Integer( ) constructor to wrap a primitive int in an object and explicitly calls the intValue( ) method to extract a primitive value from the wrapper object.
Java 5.0 introduces two new types of conversions known as boxing and unboxing conversions.
Boxing conversions convert a primitive value to its corresponding wrapper object and unboxing conversions do the opposite.
You may explicitly specify a boxing or unboxing conversion with a cast, but this is unnecessary since these conversions are automatically performed when you assign a value to a variable or pass a value to a method.
Because Java 5.0 performs boxing and unboxing automatically, this new language feature is often known as autoboxing.
Here are some examples of automatic boxing and unboxing conversions:
Automatic boxing and unboxing conversions make it much simpler to use primitive values with collection classes.
The list-of-numbers code earlier in this section can be translated as follows in Java 5.0
Packages and the Java Namespace A package is a named collection of classes, interfaces, and other reference types.
Packages serve to group related classes and define a namespace for the classes they contain.
The core classes of the Java platform are in packages whose names begin with java.
For example, the most fundamental classes of the language are in the package java.lang.
Classes for input and output are in java.io, and classes for networking are in java.net.
Some of these packages contain subpackages, such as java.lang.reflect and java.util.regex.
Extensions to the Java platform that have been standardized by Sun typically have package names that begin with javax.
Some of these extensions, such as javax.swing and its myriad subpackages, were later adopted into the core platform itself.
Every class has both a simple name, which is the name given to it in its definition, and a fully qualified name, which includes the name of the package of which it is a part.
The String class, for example, is part of the java.lang package, so its fully qualified name is java.lang.String.
This section explains how to place your own classes and interfaces into a package and how to choose a package name that won’t conflict with anyone else’s package name.
Next, it explains how to selectively import type names into the namespace so that you don’t have to type the package name of every class or interface you use.
Finally, the section explains a feature that is new in Java 5.0: the ability to prefix these with a package name or a class name.
To specify the package a class is to be part of, you use a package declaration.
The thing other than comments and space) in the Java file.
The keyword should be followed by the name of the desired package and a semicolon.
All classes defined by this file are part of the package com.davidflanagan.examples.
If no package directive appears in a Java file, all classes defined in that file are part of an unnamed default package.
In this case, the qualified and unqualified names of a class are the same.
The possibility of naming conflicts means that you should use this default package only for very simple code or early on in the development process of a larger project.
One of the important functions of packages is to partition the Java namespace and prevent name collisions between classes.
It is only their package names that keep the java.util.List and java.awt.List classes distinct, for example.
In order for this to work, however, package names must themselves be distinct.
As the developer of Java, Sun controls all package names that begin with java, javax, and sun.
For the rest of us, Sun proposes a package-naming scheme, which, if followed correctly, guarantees globally unique package names.
The scheme is to use your Internet domain name, with its elements reversed, as the prefix for all your namespace below com.davidflanagan, but since I own that domain name, no other person or organization who is playing by the rules can define a package with the same name as any of mine.
Note that these package-naming rules apply primarily to API developers.
If other programmers will be using classes that you develop along with unknown other classes, it is important that your package name be globally unique.
On the other hand, if you are developing a Java application and will not be releasing any of the classes for reuse by others, you know the complete set of classes that your application will be deployed with and do not have to worry about unforeseen naming conflicts.
In this case, you can choose a package naming scheme for your own convenience rather than for global uniqueness.
One common approach is to use the application name as the main package name (it may have subpackages beneath it)
When referring to a class or interface in your Java code, you must, by default, use the fully qualified name of the type, including the package name.
If you’re writing code to manipulate a file and need to use the File class of the java.io package, you must type java.io.File.
Types from the package java.lang are so important and so commonly used that they can always be referred to by their simple names.
The code in a type p.T may refer to other types defined in the package p by their simple names.
Types that have been imported into the namespace with an import declaration may be referred to by their simple names.
Typing the package name of commonly used types that are not in java.lang or the current package quickly becomes tedious, and so it is also possible to explicitly import types from other packages into the namespace.
An import declaration applies to all type definitions in the file (but not to any import declarations that follow it)
To import a single type into the namespace, follow the import keyword with the name of the type and a semicolon:
Thus, if you want to use several other classes from the java.io package in addition to the File class, you can simply import the entire package:
If I import the java.util package, I must still refer to the java.util.zip.ZipInputStream class by its fully qualified name.
Using an on-demand type import declaration is not the same as explicitly writing out a single type import declaration for every type in the package.
It is more like an explicit single type import for every type in the package that you actually use in your code.
The java.awt package contains a number of important types that are commonly used in client-side applications, but java.awt.List has.
It is illegal to import both java.util.List and java.awt.List in the same Java file.
The following single type import declarations produce a compilation error:
Using on-demand type imports for the two packages is legal:
Difficulty arises, however, if you actually try to use the type List.
This type can be unqualified type name produces a compilation error.
The workaround, in this case, is to explicitly specify the package name you want.
Because java.util.List is much more commonly used than java.awt.List, it is useful to combine the two on-demand type import declarations with a single-type.
With these import declarations in place, we can use List to mean the java.util.List interface.
If we actually need to use the java.awt.List class, we can still do so as long as we include its package name.
In Java 5.0 and later, you can import the static members of types as well as types themselves using the keywords import static.
If you are not already familiar with them, you may want to come back to this section later.) Like type import declarations, these static import declarations come in two forms: single static member import and on-demand static member import.
Suppose, for example, that you are writing a text-based program that sends a lot of output to System.out.
In this case, you might use this single static member import to save yourself typing:
With this import in place, you can then use out.print( ) instead of System.out.
Or suppose you are writing a program that uses many of the the trigonometric and other functions of the Math class.
In a program that is clearly focused on numerical methods like this, having to repeatedly type the class name “Math” does not add clarity to your code; it just gets in the way.
In this case, an ondemand static member import may be appropriate:
With this import declaration, you are free to write concise expressions like sqrt(abs(sin(x))) without having to prefix the name of each static method with the class name Math.
Another important use of import static declarations is to import the names of constants into your code.
This works particularly well with enumerated types (see Chapter 4)
Suppose, for example that you want to use the values of this enumerated type in code you are writing:
You could import the type climate.temperate.Seasons and then prefix the constants with the type name: Seasons.SPRING.
Using static member import declarations for constants is generally a better technique than implementing an interface that defines the constants.
A static import declaration imports a name, not any one specific member with that name.
Since Java allows method overloading and allows a type to have fields and methods with the same name, a single static member import declaration may actually import more than one member.
If you use the imported name sort to invoke a method, the compiler will look at the types of the method arguments to determine which method you mean.
It is even legal to import static methods with the same name from two or more different types as long as the methods all have different signatures.
You might expect that this code would cause a syntax error.
In fact, it does not because the sort( ) methods defined by the Collections class have different signatures than all of the sort( ) methods defined by the Arrays class.
Java File Structure This chapter has taken us from the smallest to the largest elements of Java syntax, from individual characters and tokens to operators, expressions, statements, and methods, and on up to classes and packages.
From a practical standpoint, the unit of Java program structure you will be dealing with most often is the Java file.
Java file is the smallest unit of Java code that can be compiled by the Java compiler.
These elements can be interspersed with comments, of course, but they must appear in this order.
All Java statements (except the package and import directives, which are not true statements) must appear within methods, and all methods must appear within a type definition.
First, each file can contain at most one class that is declared public.
A public class is one that is designed for use by other classes in other packages.
This restriction on public classes only applies to top-level classes; a class can contain any number of nested or inner classes that are declared public.
We’ll see more about the public modifier and nested classes in Chapter 3
The second restriction concerns the filename of a Java file.
If a Java file contains a the extension .java appended.
Thus, if Point is defined as a public class, its source code must appear in a file named Point.java.
Regardless of whether your classes are public or not, it is good programming practice to define only one per file and to give the file the same name as the class.
When a Java file is compiled, each of the classes it defines is compiled into a separate class file that contains Java byte codes to be interpreted by the Java Virtual Machine.
A class file has the same name as the class it defines, with the extension .class appended.
Thus, if the file Point.java defines a class named Point, a Java compiler compiles it to a file named Point.class.
On most systems, class files are stored in directories that correspond to their package names.
Thus, the class com.davidflanagan.examples.Point is defined by the class file com/davidflanagan/examples/Point.class.
The Java interpreter knows where the class files for the standard system classes are located and can load them as needed.
When the interpreter runs a program that wants to use a class named com.davidflanagan.examples.Point, it knows that the code for that class is located in a directory named com/davidflanagan/examples/ and, by default, it “looks” in the current directory for a subdirectory of that name.
In order to tell the interpreter to look in locations other than the current directory, you must use the -classpath option when invoking the interpreter or set the CLASSPATH environment variable.
For details, see the documentation for the Java interpreter, java, in Chapter 8
Defining and Running Java Programs A Java program consists of a set of interacting class definitions.
But not every Java class or Java file defines a program.
To create a program, you must define a class that has a special method with the following signature:
This main( ) method is the main entry point for your program.
This method is passed an array of strings and returns no value.
When main( ) returns, the Java interpreter exits (unless main( ) has created separate threads, in which case the interpreter waits for all those threads to exit)
To run a Java program, you run the Java interpreter, java, specifying the fully qualified name of the class that contains the main( ) method.
Note that you specify the name of the class, not the name of the class file that contains the class.
You may also need to specify the -classpath option (or -cp) to tell the interpreter where to look for the classes needed by the program.
Finally, datafile.jude is a string that is passed to that main( ) method as the single element of an array of String objects.
If a program and all its auxiliary classes (except those that are part of the Java platform) have been properly bundled in a Java archive (JAR) file, you can run the program simply by specifying the name of the JAR file:
Because Java and C are so similar in some ways, it is important for C and C++ programmers to understand where the similarities end.
Constant definitions are replaced with static final fields in Java.
See the java.lang.Math.PI field for an example.) Macro definitions are not available in Java, but advanced compiler technology and inlining has made them less useful.
Java does not require an #include directive because Java has no header files.
Java class files contain both the class API and the class implementation, and the compiler reads API information from class files as necessary.
Java lacks any form of conditional compilation, but its cross-platform portability means that this feature is rarely needed.
Packages contain classes, classes contain fields and methods, and methods contain local variables.
But Java has no global variables, and thus there is no possibility of namespace collisions among those variables.
Well-defined primitive type sizes All the primitive types in Java have well-defined sizes.
In C, the size of short, int, and long types is platform-dependent, which hampers portability.
No pointers Java classes and arrays are reference types, and references to objects and arrays are akin to pointers in C.
Unlike C pointers, however, references in Java are entirely opaque.
There is no way to convert a reference to a primitive type, and a reference cannot be incremented or decremented.
Eliminating them simplifies the language and makes Java programs more robust and secure.
Garbage collection The Java Virtual Machine performs garbage collection so that Java programmers do not have to explicitly manage the memory used by all objects and arrays.
This feature eliminates another entire category of common bugs and all but eliminates memory leaks from Java programs.
Use of goto except in certain welldefined circumstances is regarded as poor programming practice.
Java adds exception handling and labeled break and continue statements to the flowcontrol statements offered by C.
Variable declarations anywhere C requires local variable declarations to be made at the beginning of a method or block, while Java allows them anywhere in a method or block.
Many programmers prefer to keep all their variable declarations grouped together at the top of a method, however.
Forward references The Java compiler is smarter than the C compiler in that it allows methods to be invoked before they are defined.
This eliminates the need to declare functions in a header file before defining them in a program file, as is done in C.
Method overloading Java programs can define multiple methods with the same name, as long as the methods have different parameter lists.
No struct and union types Java doesn’t support C struct and union types.
A Java class can be thought of as an enhanced struct, however.
No bitfields Java doesn’t support the (infrequently used) ability of C to specify the number of individual bits occupied by fields of a struct.
No typedef Java doesn’t support the typedef keyword used in C to define aliases for type names.
Java’s lack of pointers makes its type-naming scheme simpler and more consistent than C’s, however, so many of the common uses of typedef are not really necessary in Java.
No method pointers C allows you to store the address of a function in a variable and pass this function pointer to other functions.
You cannot do this with Java methods, but you can often achieve similar results by passing an object that implements a particular interface.
Also, a Java method can be represented and invoked through a java.lang.reflect.Method object.
Now that we’ve covered fundamental Java syntax, we are ready to begin objectoriented programming in Java.
All Java programs use objects, and the type of an object is defined by its class or interface.
Every Java program is defined as a class, and nontrivial programs usually include a number of classes and interface definitions.
This chapter explains how to define new classes and interfaces and how to do object-oriented programming with them.*
This is a relatively long and detailed chapter, so we begin with an overview and some definitions.
A class is a collection of fields that hold values and methods that operate on those values.
Classes are the most fundamental structural element of all Java programs.
All Java statements appear within methods, and all methods are implemented within classes.
A class defines a new reference type, such as the Point type defined in Chapter 2
The Point class defines a type that is the set of all possible two-dimensional points.
A Point object is a value of that type: it represents a single two-dimensional point.
Objects are usually created by instantiating a class with the new keyword and a constructor invocation, as shown here:
If you do not have object-oriented (OO) programming background, don’t worry; this chapter does not assume any prior experience.
If you do have experience with OO programming, however, be careful.
Don’t assume that Java works the same way as your favorite OO language.
Although Java and C++ borrow much syntax from C, the similarities between the two languages do not go far beyond the level of syntax.
Don’t let your experience with C++ lull you into a false familiarity with Java.
A class definition consists of a signature and a body.
The class signature defines the name of the class and may also specify other important information.
The body of a class is a set of members enclosed in curly braces.
The members of a class may include fields and methods, constructors and initializers, and nested types.
The signature of a class may declare that the class extends another class.
The extended class is known as the superclass and the extension is known as the subclass.
A subclass inherits the members of its superclass and may declare new members or override inherited methods with new implementations.
The signature of a class may also declare that the class implements one or more interfaces.
An interface is a reference type that defines method signatures but does not include method bodies to implement the methods.
A class that implements an interface is required to provide bodies for the interface’s methods.
Instances of such a class are also instances of the interface type that it implements.
The members of a class may have access modifiers public, protected, or private, which specify their visibility and accessibility to clients and to subclasses.
This allows classes to hide members that are not part of their public API.
When applied to fields, this ability to hide members enables an object-oriented design technique known as data encapsulation.
Classes and interfaces are the most important of the five fundamental reference types defined by Java.
Arrays, enumerated types (or “enums”) and annotation types are the other three.
Enums are a specialized kind of class and annotation types are a specialized kind of interface.
Class Definition Syntax At its simplest level, a class definition consists of the keyword class followed by the name of the class and a set of class members within curly braces.
The class keyword may be preceded by modifier keywords and annotations (see Chapter 4)
If the class extends another class, the class name is followed by the extends keyword and the name of the class being extended.
If the class implements one or more interfaces then the class name or the extends clause is followed by the implements keyword and a comma-separated list of interface names.
Generic class declarations include additional syntax that is covered in Chapter 4
Class declarations may include zero or more of the following modifiers:
A public class is visible to classes defined outside of its package.
Any class with one or more abstract methods must be declared abstract.
Declaring a class final may enable the Java VM to optimize its methods.
By convention, if a class has more than one modifier, they appear in the order shown.
Fields and Methods A class can be viewed as a collection of data and code to operate on that data.
The data is stored in fields, and the code is organized into methods.
This section covers fields and methods, the two most important kinds of class members.
Fields and methods come in two distinct types: class members (also known as static members) are associated with the class itself, while instance members are associated with individual instances of the class (i.e., with objects)
The simple class definition for the class Circle, shown in Example 3-1, contains all four types of members.
Method declaration syntax is covered in “Methods” later in this chapter.)
Field declaration syntax is much like the syntax for declaring local variables (see Chapter 2) except that field definitions may also include modifiers.
The simplest field declaration consists of the field type followed by the field name.
The type may be preceded by zero or more modifier keywords or annotations (see Chapter 4), and the name may be followed by an equals sign and initializer expression that provides the initial value of the field.
If two or more fields share the same type and modifiers, the type may be followed by a comma-separated list of field names and initializers.
Field modifiers are comprised of zero or more of the following keywords:
These access modifiers specify whether and where a field can be used outside of the class that defines it.
No more than one of these access modifiers may appear in any field declaration.
Fields that are both static and final are compile-time constants that the compiler can inline.
A class field is associated with the class in which it is defined rather than with an instance of the class.
This line declares a field of type double named PI and assigns it a value of 3.14159
As you can see, a field declaration looks quite a bit like a local variable declaration.
The difference, of course, is that variables are defined within methods while fields are members of classes.
The static modifier says that the field is a class field.
Class fields are sometimes called static fields because of this static modifier.
The final modifier says that the value of the field does not change.
Since the field PI represents a constant, we declare it final so that it cannot be changed.
It is a convention in Java (and many other languages) that constants are named with capital letters, which is why our field is named PI, not pi.
Defining constants like this is a common use for class fields, meaning that the static and final modifiers are often used together.
In other words, a field can be declared static without being declared final.
Finally, the public modifier says that anyone can use the field.
This is a visibility modifier, and we’ll discuss it and related modifiers in more detail later in this chapter.
The key point to understand about a static field is that there is only a single copy of it.
This field is associated with the class itself, not with instances of the class.
If you look at the various methods of the Circle class, you’ll see that they use this field.
From inside the Circle class, the field can be referred to simply as PI.
Outside the class, however, both class and field names are required to uniquely specify the field.
Methods that are not part of Circle access this field as Circle.PI.
The names of class fields are qualified by the unique names of the classes that contain them, however.
Thus, Java does not suffer from the name collisions that can affect other languages when different modules of code define global variables with the same name.
As with class fields, class methods are declared with the static modifier:
The body of the method is quite short; it performs a simple computation and returns the result.
Like class fields, class methods are associated with a class, rather than with an object.
When invoking a class method from code that exists outside the class, you must specify both the name of the class and the method.
If you want to invoke a class method from inside the class in which it is defined, you don’t have to specify the class name.
However, it is often good style to specify the class name anyway, to make it clear that a class method is being invoked.
Note that the body of our Circle.radiansToDegrees( ) method uses the class field PI.
A class method can use any class fields and class methods of its own class (or of any other class)
But it cannot use any instance fields or instance methods because class methods are not associated with an instance of the class.
The instance fields and instance methods of the class are associated with Circle objects, not with the class itself.
Since a class method is not associated with an instance of its class, it cannot use any instance methods or fields.
As we discussed earlier, a class field is essentially a global variable.
In a similar way, a class method is a global method, or global function.
Although Circle class because it is a utility method that is sometimes useful when working with circles.
In many nonobject-oriented programming languages, all methods, or functions, are global.
You can write complex Java programs using only class methods.
This is not object-oriented programming, however, and does not take advantage of the power of the Java language.
To do true object-oriented programming, we need to add instance fields and instance methods to our repertoire.
Any field declared without the static modifier is an instance field:
Instance fields are associated with instances of the class, rather than with the class itself.
Thus, every Circle object we create has its own copy of the double field r.
In our example, r represents the radius of a circle.
Thus, each Circle object can have a radius independent of all other Circle objects.
Inside a class definition, instance fields are referred to by name alone.
In code outside the class, the name of an instance method must be prefixed with a reference to the object that contains it.
For example, if the variable c holds a reference to a Circle object, we use the expression c.r to refer to the radius of that circle:
Instance fields hold the state of an object; the values of those fields make one object distinct from another.
Any method not declared with the static keyword is an instance method.
An instance method operates on an instance of a class (an object) instead of operating on the class itself.
It is with instance methods that object-oriented programming starts to get interesting.
The Circle class defined in Example 3-1 contains two and circumference of the circle represented by a given Circle object.
To use an instance method from outside the class in which it is defined, we must prefix it with a reference to the instance that is to be operated on.
If you’re new to object-oriented programming, that last line of code may look a little strange.
This is why it is called object-oriented programming; the object is the focus here, not the function call.
You’ll notice the same thing in the signature of the area( ) method: it doesn’t have a parameter.
Now look at the body of the area( ) method: it uses the instance field field, the method can use the unqualified name r.
It is understood that this refers to the radius of whatever Circle instance invokes the method.
Another important thing to notice about the bodies of the area( ) and that class methods can use only class fields and class methods, not instance fields or methods.
Instance methods are not restricted in this way: they can use any member of a class, whether it is declared static or not.
All instance methods are implemented with an implicit parameter not shown in the method signature.
The implicit argument is named this; it holds a reference to the object through which the method is invoked.
The implicit this parameter is not shown in method signatures because it is usually not needed; whenever a Java method accesses the instance fields in its class, it is implicit that it is accessing fields in the object referred to by the this parameter.
The same is true when an instance method invokes another instance method in the same class.
I said earlier that to invoke an instance method you must prepend a reference to the object to be operated on.
When an instance method is invoked within another instance method in the same class, however, you don’t need to specify an object.
In this case, it is implicit that the method is being invoked on the this object.
You can use the this keyword explicitly when you want to make it clear that a method is accessing its own fields and/or methods.
This code also uses the class name explicitly to refer to class field PI.
In a method this simple, it is not necessary to be explicit.
In more complicated cases, however, you may find that it increases the clarity of your code to use an explicit this where it is not strictly required.
For example, when a method parameter or local variable in a method has the same name as one of the fields of the class, you must use this to refer to the field since the field name used alone refers to the method parameter or local variable.
For example, we can add the following method to the Circle class:
Finally, note that while instance methods can use the this keyword, class methods cannot.
This is because class methods are not associated with objects.
Instance methods are one of the key features of object-oriented programming.
That doesn’t mean, however, that you should shun class methods.
In many cases, it is perfectly reasonable to define class methods.
When working with the Circle class, for example, you might find that you often want to compute the area of a circle with a given radius but don’t want to bother creating a Circle object to represent that circle.
It is perfectly legal for a class to define more than one method with the same name, as long as the methods have different parameters.
Since this version of the must have a parameter that specifies the radius of the circle.
This parameter keeps it distinct from the instance method of the same name.
As another example of the choice between instance methods and class methods, consider defining a method named bigger( ) that examines two Circle objects.
We can write bigger( ) as an instance method as follows:
Compare the implicit "this" circle to the "that" circle passed // explicitly as an argument and return the bigger one.
We can also implement bigger( ) as a class method as follows:
Compare circle a to circle b and return the one with the larger radius if (a.r > b.r) return a; else return b;
Given two Circle objects, x and y, we can use either the instance method or the class method to determine which is bigger.
The invocation syntax differs significantly for the two methods, however:
The instance method is more formally object-oriented, but its invocation syntax suffers from a kind of asymmetry.
In a case like this, the choice between an instance method and a class method is simply a design decision.
Depending on the circumstances, one or the other will likely be the more natural choice.
We’ve never explained why this method has such an long, awkward name or what those two periods are doing in it.
Now that you understand class and instance fields and class and instance methods, it is easier to understand what is going on: System is a class.
The object System.out has an instance method named println( )
If you want to explore this in more detail, you can look up the java.lang.System class in the reference section.
The class synopsis there tells you that the field out is of type java.io.PrintStream, and you can look up that class to find out about the println( ) method.
Creating and Initializing Objects Now that we’ve covered fields and methods, we move on to other important members of a class.
Constructors and initializers are class members whose job is to initialize the fields of a class.
Take another look at how we’ve been creating Circle objects:
What are those parentheses doing there? They make it look like we’re calling a method.
Every class in Java has at least one constructor, which is a method that has the same name as the class and whose purpose is to perform any necessary initialization for a new object.
Since we didn’t explicitly define a constructor for our Circle class in Example 3-1, Java gave us a default constructor that takes no arguments and performs no special initialization.
The new operator creates a new, but uninitialized, instance of the class.
The constructor method is then called, with the new object passed implicitly (a this reference, as we saw earlier) as well as whatever arguments that are specified between parentheses passed explicitly.
The constructor can use these arguments to do whatever initialization is necessary.
There is some obvious initialization we could do for our circle objects, so let’s define a constructor.
Example 3-2 shows a new definition for Circle that contains a constructor that lets us specify the radius of a new Circle object.
The constructor also uses the this reference to distinguish between a method parameter and an instance field of the same name.
When we relied on the default constructor supplied by the compiler, we had to write code like this to initialize the radius explicitly:
With this new constructor, the initialization becomes part of the object creation step:
Here are some important notes about naming, declaring, and writing constructors:
The constructor name is always the same as the class name.
Unlike all other methods, a constructor is declared without a return type, not even void.
The body of a constructor should initialize the this object.
A constructor may not return this or any other value.
A constructor may include a return statement, but only one that does not include a return value.
Sometimes you want to initialize an object in a number of different ways, depending on what is most convenient in a particular circumstance.
For example, we might want to initialize the radius of a circle to a specified value or a reasonable default value.
Since our Circle class has only a single instance field, we can’t initialize it too many ways, of course.
But in more complex classes, it is often convenient to define a variety of constructors.
It is perfectly legal to define multiple constructors for a class, as long as each constructor has a different parameter list.
The compiler determines which constructor you wish to use based on the number and type of arguments you supply.
This is simply an example of method overloading, as we discussed in Chapter 2
A specialized use of the this keyword arises when a class has multiple constructors; it can be used from a constructor to invoke one of the other constructors of the same class.
In other words, we can rewrite the two previous Circle constructors as follows:
The this( ) syntax is a method invocation that calls one of the other constructors of the class.
The particular constructor that is invoked is determined by the number and type of arguments, of course.
This is a useful technique when a number of constructors share a significant amount of initialization code, as it avoids repetition of that code.
This would be a more impressive example, of course, if the one-parameter version of the Circle( ) constructor did more initialization than it does.
It may, of course, be followed by any additional initialization a particular version of the constructor needs to do.
The reason for this restriction involves the automatic invocation of superclass constructor methods, which we’ll explore later in this chapter.
These default values are guaranteed by Java and apply to both instance fields and class fields.
If the default field value is not appropriate for your field, you can explicitly provide a different initial value.
Field declarations and local variable declarations have similar syntax, but there is an important difference in how their initializer expressions are handled.
As described in Chapter 2, a local variable declaration is a statement that appears within a Java method; the variable initialization is performed when the statement is executed.
Field declarations, however, are not part of any method, so they cannot be executed as statements are.
Instead, the Java compiler generates instance-field initialization code automatically and puts it in the constructor or constructors for the class.
The initialization code is inserted into a constructor in the order in which it appears in the source code, which means that a field initializer can use the initial values of any fields declared before it.
Consider the following code excerpt, which shows a constructor and two instance fields of a hypothetical class:
In this case, the code generated for the constructor is actually equivalent to the following:
If a constructor begins with a this( ) call to another constructor, the field initialization code does not appear in the first constructor.
Instead, the initialization is handled in the constructor invoked by the this( ) call.
So, if instance fields are initialized in constructor methods, where are class fields initialized? These fields are associated with the class, even if no instances of the class are ever created, so they need to be initialized even before a constructor is called.
To support this, the Java compiler generates a class initialization method.
Class fields are initialized in the body of this method, which is invoked exactly once before the class is first used (often when the class is first loaded by the Java VM.)* As with instance field initialization, class field initialization expressions are inserted into the class initialization method in the order in which they appear in the source code.
This means that the initialization expression for a class field can use the class fields declared before it.
The class initialization method is an internal method that is hidden from Java programmers.
So far, we’ve seen that objects can be initialized through the initialization expressions for their fields and by arbitrary code in their constructor methods.
A class has a class initialization method, which is like a constructor, but we cannot explicitly define the body of this method as we can for a constructor.
Java does allow us to write arbitrary code for the initialization of class fields, however, with a construct known as a static initializer.
A static initializer is simply the keyword static followed by a block of code in curly braces.
A static initializer can appear in a class definition anywhere a field or method definition can appear.
For example, consider the following code that performs some nontrivial initialization for two class fields:
We can draw the outline of a circle using trigonometric functions // Trigonometry is slow, though, so we precompute a bunch of values // Here are our static lookup tables and their own simple initializers.
Here's a static initializer that fills in the arrays // The rest of the class is omitted...
The body of each initializer block is incorporated into the class initialization method, along with any static field initialization expressions.
A static initializer is like a class method in that it cannot use the this keyword or any instance fields or instance methods of the class.
It is actually possible to write a class initializer for a class C that calls a method of another class that creates an instance of C.
In this contrived recursive case, an instance of C is created before the class C is fully initialized.
In Java 1.1 and later, classes are also allowed to have instance initializers.
An instance initializer is like a static initializer, except that it initializes an object, not a class.
A class can have any number of instance initializers, and they can appear anywhere a field or method definition can appear.
The body of each instance initializer is inserted at the beginning of every constructor for the class, along with any field initialization expressions.
An instance initializer looks just like a static initializer, except that it doesn’t use the static keyword.
In other words, an instance initializer is just a block of arbitrary Java code that appears within curly braces.
Instance initializers can initialize arrays or other fields that require complex initialization.
They are sometimes useful because they locate the initialization code right next to the field, instead of separating into a constructor method.
In practice, however, this use of instance initializers is fairly rare.
Instance initializers were introduced in Java 1.1 to support anonymous inner classes, which are not allowed to define constructors.
Destroying and Finalizing Objects Now that we’ve seen how new objects are created and initialized in Java, we need to study the other end of the object life cycle and examine how objects are finalized and destroyed.
In Java, the memory occupied by an object is automatically reclaimed when the object is no longer needed.
This is done through a process known as garbage collection.
Garbage collection is a technique that has been around for years in function or the delete operator to reclaim memory.
The fact that you don’t need to remember to destroy every object you create is one of the features that makes Java a pleasant language to work with.
It is also one of the features that makes programs written in Java less prone to bugs than those written in languages that don’t support automatic garbage collection.
The Java interpreter knows exactly what objects and arrays it has allocated.
It can also figure out which local variables refer to which objects and arrays and which objects and arrays refer to which other objects and arrays.
Thus, the interpreter is able to determine when an allocated object is no longer referred to by any other active object or variable.
When the interpreter finds such an object, it knows it can safely reclaim the object’s memory and does so.
The garbage collector can also detect and destroy cycles of objects that refer to each other, but are not referenced by any other active objects.
It is reasonable, however, to imagine the garbage collector running as a low-priority.
The only time the garbage collector must run while something high-priority is going on (i.e., the only time it actually slows down the system) is when available memory has become dangerously low.
This doesn’t happen very often because the low-priority thread cleans things up in the background.
The fact that Java supports garbage collection dramatically reduces the incidence of a class of bugs known as memory leaks.
A memory leak occurs when memory is allocated and never reclaimed.
At first glance, it might seem that garbage collection prevents all memory leaks because it reclaims all unused objects.
A memory leak can still occur in Java, however, if a valid (but unused) reference to an unused object is left hanging around.
For example, when a method runs for a long time (or forever), the local variables in that method can retain object references much longer than they are actually required.
It will get garbage collected when there // are no more references to it.
Since big_array is a local variable, // it refers to the array until this method returns.
So we've got to explicitly get rid of the reference // ourselves, so the garbage collector knows it can reclaim the array.
Memory leaks can also occur when you use a hash table or similar data structure to associate one object with another.
Even when neither object is required anymore, the association remains in the hash table, preventing the objects from being reclaimed until the hash table itself is reclaimed.
If the hash table has a substantially longer lifetime than the objects it holds, this can cause memory leaks.
The key to avoiding memory leaks is to set object references to null when they are no longer needed if the object that contains those references is going to continue to exist.
One common source of leaks is in data structures in which an Object array is used to represent a collection of objects.
It is common to use a separate size field to keep track of which elements of the array are currently valid.
When removing an object from the collection, it is not sufficient to simply decrement this size field: you must also set the appropriate array element to null so that the obsolete object reference does not live on.
A finalizer in Java is the opposite of a constructor.
While a constructor method performs initialization for an object, a finalizer method can be used to perform cleanup or “finalization” for the object.
Garbage collection automatically frees up the memory resources used by objects, but objects can hold other kinds of resources, such as open files and network connections.
The garbage collector cannot free these resources for you, so you may occasionally want to write a finalizer method for any object that needs to perform such tasks as closing files, terminating network connections, deleting temporary files, and so on.
This is particularly true for classes that use native methods: these classes may need a native finalizer to release native resources (including memory) that are not under the control of the Java garbage collector.
A finalizer is an instance method that takes no arguments and returns no value.
Finalizer methods are typically declared protected (which we have not discussed yet) but can also be declared public.
Invoke the finalizer of our superclass // We haven't discussed superclasses or this syntax yet.
Delete a temporary file we were using // If the file doesn't exist or tempfile is null, this can throw // an exception, but that exception is ignored.
If an object has a finalizer, the finalizer method is invoked sometime after the object becomes unused (or unreachable), but before the garbage collector reclaims the object.
Java makes no guarantees about when garbage collection will occur or in what order objects will be collected.
Therefore, Java can make no guarantees about when (or even whether) a finalizer will be invoked, in what order finalizers will be invoked, or what thread will execute finalizers.
The Java interpreter can exit without garbage collecting all outstanding objects, so some finalizers may never be invoked.
In this case, resources such as network connections are closed and reclaimed by the operating system.
Note, however, that if a finalizer that deletes a file does not run, that file will not be deleted by the operating system.
As we will see, they do not behave quite like C++ destructor methods either.
After a finalizer is invoked, objects are not freed right away.
This is because a called, the garbage collector must once again determine that the object is unreferenced before it can garbage-collect it.
However, even if an object is resurrected, the finalizer method is never invoked more than once.
Resurrecting an object is never a useful thing to do—just a strange quirk of object finalization.
The finalize( ) method is an instance method, and finalizers act on instances.
In practice, it is quite rare for an application-level class to require a finalize( ) method.
Finalizer methods are more useful, however, when writing Java classes that interface to native platform code with native methods.
In this case, the native implementation can allocate memory or other resources that are not under the control of the Java garbage collector and need to be reclaimed explicitly by a.
Furthermore, because of the uncertainty about when and whether a finalizer runs, it close( ) method of the socket.
This way, when the user of your class is done with it, she can call close( ) and be sure that the network connection is closed.
You might, however, define a finalize( ) method as backup in case the user of your class forgets to call close( ) and allows an unclosed instance to be garbage-collected.
Subclasses and Inheritance The Circle defined earlier is a simple class that distinguishes circle objects only by their radii.
Suppose, instead, that we want to represent circles that have both a size and a position.
To do this, we need a new class, which we’ll call PlaneCircle.
We’d like to add the ability to represent the position of a circle without losing any of the existing functionality of the Circle class.
This is done by defining PlaneCircle as a subclass of Circle so that PlaneCircle inherits the fields and methods of its superclass, Circle.
The ability to add functionality to a class by subclassing, or extending, is central to the object-oriented programming paradigm.
Example 3-3 shows how we can implement PlaneCircle as a subclass of the Circle class.
Note the use of the keyword extends in the first line of Example 3-3
This keyword tells Java that PlaneCircle extends, or subclasses, Circle, meaning that it method shows field inheritance; this method uses the field r (defined by the Circle class) as if it were defined right in PlaneCircle itself.
Thus, if we have a PlaneCircle object referenced by variable pc, we can say:
Another feature of subclassing is that every PlaneCircle object is also a perfectly legal Circle object.
If pc refers to a PlaneCircle object, we can assign it to a Circle variable and forget all about its extra positioning capabilities:
This assignment of a PlaneCircle object to a Circle variable can be done without a cast.
The value held in the Circle variable c is still a valid PlaneCircle object, but the compiler cannot know this for sure, so it doesn’t allow us to do the opposite (narrowing) conversion without a cast:
We automatically inherit the fields and methods of Circle, // so we only have to put the new stuff here.
New instance fields that store the center point of the circle.
A new instance method that checks whether a point is inside the circle // Note that it uses the inherited instance field r.
Narrowing conversions require a cast (and a runtime check by the VM)
When a class is declared with the final modifier, it means that it cannot be extended or subclassed.
Declaring a class final prevents unwanted extensions to the class: if you invoke a method on a String object, you know that the method is the one defined by the String class itself, even if the String is passed to you from some unknown outside source.
Because String is final, no one can create a subclass of it and change the meaning or behavior of its methods.
Declaring a class final also allows the compiler to make certain optimizations when invoking the methods of a class.
We’ll explore this when we talk about method overriding later in this chapter.
We can also say that Circle is the superclass of PlaneCircle.
The superclass of a class is specified in its extends clause:
If you do not specify the superclass with an extends clause, the superclass is the class java.lang.Object.
Object is a special class for a couple of reasons:
It is the only class in Java that does not have a superclass.
Because every class has a superclass, classes in Java form a class hierarchy, which can be represented as a tree with Object at its root.
Figure 3-1 shows a partial class hierarchy diagram that includes our Circle and PlaneCircle classes, as well as some of the standard classes from the Java API.
This constructor explicitly initializes the cx and cy fields newly defined by PlaneCircle, but it relies on the superclass Circle( ) constructor to initialize the inherited fields of the class.
To invoke the superclass constructor, our constructor constructor method of a superclass from within the constructor method of a subclass.
This use is analogous to the use of this( ) to invoke one constructor.
The call to the superclass constructor must appear as the first statement within the constructor method, even before local variable declarations.
The arguments passed to super( ) must match the parameters of the superclass constructor.
If the superclass defines more than one constructor, super( ) can be used to invoke any one of them, depending on the arguments passed.
Java guarantees that the constructor method of a class is called whenever an instance of that class is created.
It also guarantees that the constructor is called whenever an instance of any subclass is created.
In order to guarantee this second point, Java must ensure that every constructor method calls its superclass call super( ), that is, it calls the superclass constructor with no arguments.
If the superclass does not have a constructor that takes no arguments, this implicit invocation causes a compilation error.
Consider what happens when we create a new instance of the PlaneCircle class.
When it returns, the body of the Circle( ) constructor runs.
Finally, when the call to super(r) returns, the remaining statements of the PlaneCircle( ) constructor are executed.
What all this means is that constructor calls are chained; any time an object is created, a sequence of constructor methods is invoked, from subclass to superFigure 3-1
Because a superclass constructor is always invoked as the first statement of its subclass constructor, the body of the Object constructor always runs first, followed by the constructor of its subclass and on down the class hierarchy to the class that is being instantiated.
There is an important implication here; when a constructor is invoked, it can count on the fields of its superclass to be initialized.
There is one missing piece in the previous description of constructor chaining.
If a constructor does not invoke a superclass constructor, Java does so implicitly.
But what if a class is declared without a constructor? In this case, Java implicitly adds a constructor to the class.
This default constructor does nothing but invoke the superclass constructor.
For example, if we don’t declare a constructor for the PlaneCircle class, Java implicitly inserts this constructor:
If the superclass, Circle, doesn’t declare a no-argument constructor, the super( ) call in this automatically inserted default constructor for PlaneCircle( ) causes a compilation error.
In general, if a class does not define a no-argument constructor, all its subclasses must define constructors that explicitly invoke the superclass constructor with the necessary arguments.
If a class does not declare any constructors, it is given a no-argument constructor by default.
All other classes are given a default constructor that is declared without any visibility modifier: such a constructor has default visibility.
The notion of visibility is explained later in this chapter.) If you are creating a public class that should not be publicly instantiated, you should declare at least one non-public constructor to prevent the insertion of a default public constructor.
Classes that should never be instantiated (such as java.lang.Math or java.lang.System) should define a private constructor.
Such a constructor can never be invoked from outside of the class, but it prevents the automatic insertion of the default constructor.
You might assume that since Java chains constructor methods, it also automatically chains the finalizer methods for an object.
In other words, you might assume method, you must explicitly invoke the superclass finalizer.
You should do this even if you know that the superclass does not have a finalizer because a future implementation of the superclass might add a finalizer.)
As we saw in our example finalizer earlier in the chapter, you can invoke a superclass method with a special syntax that uses the super keyword:
We’ll discuss this syntax in more detail when we consider method overriding.
In practice, the need for finalizer methods, and thus finalizer chaining, rarely arises.
For the sake of example, imagine that our PlaneCircle class needs to know the distance between the center of the circle and the origin (0,0)
We can add another instance field to hold this value:
Adding the following line to the constructor computes the value of the field:
But wait; this new field r has the same name as the radius field r in the Circle superclass.
When this happens, we say that the field r of PlaneCircle hides the field r of Circle.
This is a contrived example, of course: the new field should really be called distanceFromOrigin.
Although you should attempt to avoid it, subclass fields do sometimes hide fields of their superclass.)
With this new definition of PlaneCircle, the expressions r and this.r both refer to the field of PlaneCircle.
How, then, can we refer to the field r of Circle that holds the radius of the circle? A special syntax for this uses the super keyword:
Another way to refer to a hidden field is to cast this (or any instance of the class) to the appropriate superclass and then access the field:
Circle) this).r   // Refers to field r of the Circle class.
This casting technique is particularly useful when you need to refer to a hidden field defined in a class that is not the immediate superclass.
Suppose, for example, that classes A, B, and C all define a field named x and that C is a subclass of B, which is a subclass of A.
Then, in the methods of class C, you can refer to these different fields as follows:
You cannot refer to a hidden field x in the superclass of a superclass with super.super.x.
Similarly, if you have an instance c of class C, you can refer to the three fields named x like this:
You can use the same super syntax to refer to the hidden value of the field, but this is never necessary since you can always refer to a class field by prepending the name of the desired class.
Circle.PI field does not express π to enough decimal places.
Now, code in PlaneCircle can use this more accurate value with the expressions PI or PlaneCircle.PI.
It can also refer to the old, less accurate value with the expressions super.PI and Circle.PI.
Note, however, that the area( ) and so they use the value Circle.PI, even though that value is hidden now by PlaneCircle.PI.
When a class defines an instance method using the same name, return type, and parameters as a method in its superclass, that method overrides the method of the superclass.
When the method is invoked for an object of the class, it is the new definition of the method that is called, not the superclass’s old definition.
In Java 5.0 and later, the return type of the overriding method may be a subclass of return type of the overridden method instead of being exactly the same type.
Method overriding is an important and useful technique in object-oriented programming.
PlaneCircle does not override either of the methods defined by Circle, but suppose we define another subclass of Circle, named Ellipse.* In this methods of Circle since the formulas used to compute the area and circumference of a circle do not work for ellipses.
The upcoming discussion of method overriding considers only instance methods.
Class methods behave quite differently, and there isn’t much to say.
Like fields, class methods can be hidden by a subclass but not overridden.
As noted earlier in this chapter, it is good programming style to always prefix a class method invocation with the name of the class in which it is defined.
If you consider the class name part of the class method name, the two methods have different names, so nothing is actually hidden at all.
It is, however, illegal for a class method to hide an instance method.
Before we go any further with the discussion of method overriding, you should understand the difference between method overriding and method overloading.
As we discussed in Chapter 2, method overloading refers to the practice of defining multiple methods (in the same class) that have the same name but different parameter lists.
This is very different from method overriding, so don’t get them confused.
Mathematical purists may argue that since all circles are ellipses, Ellipse should be the superclass and Circle the subclass.
A pragmatic engineer might counter that circles can be represented with fewer instance fields, so Circle objects should not be burdened by inheriting unnecessary fields from Ellipse.
Although Java treats the fields and methods of a class analogously in many ways, method overriding is not like field hiding at all.
You can refer to hidden fields simply by casting an object to an instance of the appropriate superclass, but you cannot invoke overridden instance methods with this technique.
While this difference between method overriding and field hiding may seem surprising at first, a little thought makes the purpose clear.
Suppose we are manipulating a bunch of Circle and Ellipse objects.
To keep track of the circles and ellipses, we store them in an array of type Circle[]
We can do this because Ellipse is a subclass of Circle, so all Ellipse objects are legal Circle objects.) When we loop through the elements of this array, we don’t have to know or care whether the element is actually a Circle or an Ellipse.
What we do care about very much, however, is that the correct value is computed when we invoke the the formula for the area of a circle when the object is actually an ellipse! Seen in this context, it is not surprising at all that method overriding is handled differently by Java than is field hiding.
Ellipse class for any given item in the array? In fact, the compiler does not know this because it cannot know it.
The compiler knows that it does not know, however, and produces code that uses dynamic method lookup at runtime.
When the interpreter runs the code, it looks up the appropriate area( ) method to call for each of the objects in the array.
That is, when the interpreter interprets the not simply use the area( ) method that is statically associated with the type of the variable o.
This process of dynamic method lookup is sometimes also called virtual method invocation.*
Virtual method invocation is fast, but method invocation is faster when no dynamic lookup is necessary at runtime.
Fortunately, Java does not always need to use dynamic method lookup.
In particular, if a method is declared with the final modifier, it means that the method definition is the final one; it cannot be overridden by any subclasses.
If a method cannot be overridden, the compiler knows that there is only one version of the method, and dynamic method lookup is not necessary.† In addition, all methods of a final class are themselves implicitly final and cannot be overridden.
As we’ll discuss later in this chapter, private methods are not inherited by subclasses and, therefore, cannot be overridden (i.e., all private methods are implicitly final)
Finally, class methods behave like fields (i.e., they can be hidden by subclasses but not overridden)
Taken together, this means that all methods of a class that is declared final, as well as all methods that are final, private, or static, are invoked without dynamic method lookup.
These methods are also candidates for inlining at runtime by a just-in-time compiler ( JIT) or similar optimization tool.
We’ve seen the important differences between method overriding and field hiding.
Nevertheless, the Java syntax for invoking an overridden method is quite similar to the syntax for accessing a hidden field: both use the super keyword.
An important difference between Java and C++ is that Java does not have a virtual keyword.
In this sense, the final modifier is the opposite of the virtual modifier in C++
Recall that when you use super to refer to a hidden field, it is the same as casting this to the superclass type and accessing the field through that.
Using super to invoke an overridden method, however, is not the same as casting this.
When the interpreter invokes an instance method with this super syntax, a modified form of dynamic method lookup is performed.
The first step, as in regular dynamic method lookup, is to determine the actual class of the object through which the method is invoked.
Normally, the dynamic search for an appropriate method definition would begin with this class.
When a method is invoked with the super syntax, however, the search begins at the superclass of the class.
If the superclass implements the method directly, that version of the method is invoked.
If the superclass inherits the method, the inherited version of the method is invoked.
Note that the super keyword invokes the most immediately overridden version of a method.
Suppose class A has a subclass B that has a subclass C and that all three classes is relatively common when working with overridden methods: it is a way of augmenting the behavior of a method without replacing the method entirely.
Although they both use the same keyword, these are two entirely different syntaxes.
In particular, you can use super to invoke an overridden method.
It is also important to remember that super can be used only to invoke an overridden method from within the class that overrides it.
Given an Ellipse object e, there is no way for a program that uses an object (with or without the super.
Data Hiding and Encapsulation We started this chapter by describing a class as a collection of data and methods.
One of the important object-oriented techniques we haven’t discussed so far is hiding the data within the class and making it available only through the methods.
This technique is known as encapsulation because it seals the data (and internal.
Why would you want to do this? The most important reason is to hide the internal implementation details of your class.
If you prevent programmers from relying on those details, you can safely modify the implementation without worrying that you will break existing code that uses the class.
Another reason for encapsulation is to protect your class against accidental or willful stupidity.
A class often contains a number of interdependent fields that must be in a consistent state.
If you allow a programmer (including yourself) to manipulate those fields directly, he may change one field without changing important related fields, leaving the class in an inconsistent state.
If instead he has to call a method to change the field, that method can be sure to do everything necessary to keep the state consistent.
Similarly, if a class defines certain methods for internal use only, hiding these methods prevents users of the class from calling them.
Here’s another way to think about encapsulation: when all the data for a class is hidden, the methods define the only possible operations that can be performed on objects of that class.
Once you have carefully tested and debugged your methods, you can be confident that the class will work as expected.
On the other hand, if all the fields of the class can be directly manipulated, the number of possibilities you have to test becomes unmanageable.
Other reasons to hide fields and methods of a class include:
Internal fields and methods that are visible outside the class just clutter up the API.
Keeping visible fields to a minimum keeps your class tidy and therefore easier to use and understand.
If a field or method is visible to the users of your class, you have to document it.
All the fields and methods of a class can always be used within the body of the class itself.
Java defines access control rules that restrict members of a class from being used outside the class.
In a number of examples in this chapter, you’ve seen the public modifier used in field and method declarations.
This public keyword, along with protected and private, are access control modifiers; they specify the access rules for the field or method.
A package is always accessible to code defined within the package.
Whether it is accessible to code from other packages depends on the way the package is deployed on the host system.
When the class files that comprise a package are stored in a directory, for example, a user must have read access to the directory and the files within it in order to have access to the package.
Package access is not part of the Java language itself.
Access control is usually done at the level of classes and members of classes instead.
By default, top-level classes are accessible within the package in which they are defined.
However, if a top-level class is declared public, it is accessible everywhere (or everywhere that the package itself is accessible)
The reason that we’ve restricted these statements to top-level classes is that, as we’ll see later in this chapter, classes can also be defined as members of other classes.
Because these inner classes are members of a class, they obey the member access-control rules.
The members of a class are always accessible within the body of the class.
By default, members are also accessible throughout the package in which the class is defined.
This implies that classes placed in the same package should trust each other with their internal implementation details.
This default level of access is often called package access.
It is only one of four possible levels of access.
The other three levels of access are defined by the public, protected, and private modifiers.
If a member of a class is declared with the public modifier, it means that the member is accessible anywhere the containing class is accessible.
If a member of a class is declared private, the member is never accessible, except within the class itself.
If a member of a class is declared protected, it is accessible to all classes within the package (the same as the default package accessibility) and also accessible within the body of any subclass of the class, regardless of the package in which that subclass is defined.
This is more restrictive than public access, but less restrictive than package access.
If a member of a class is not declared with any of these modifiers, it has the default package access: it is accessible to code within all classes that are defined in the same package but inaccessible outside of the package.
Suppose class A declares a protected field x and is extended by a class B, which is defined in a different code can access that field in the current instance of B or in any other instances of B that the code can refer to.
This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them.
The Java specification states that a subclass inherits all the instance fields and instance methods of its superclass accessible to it.
If the subclass is defined in the same package as the superclass, it inherits all non-private instance fields and methods.
If the subclass is defined in a different package, however, it inherits all protected and public instance fields and methods.
Finally, constructors are not inherited; they are chained, as described earlier in this chapter.
The statement that a subclass does not inherit the inaccessible fields and methods of its superclass can be a confusing one.
It would seem to imply that when you create an instance of a subclass, no memory is allocated for any private fields defined by the superclass.
Every instance of a subclass does, in fact, include a complete instance of the superclass within it, including all inaccessible fields and methods.
Because the inaccessible fields cannot be used in the subclass, we say they are not inherited.
Earlier in this section we said that the members of a class are always accessible within the body of the class.
If you don’t care for this definition, you can think of it this way instead:
A class inherits all instance fields and instance methods (but not constructors) of its superclass.
The body of a class can always access all the fields and methods it declares itself.
It can also access the accessible fields and members it inherits from its superclass.
Here are some simple rules of thumb for using visibility modifiers:
Use public only for methods and constants that form part of the public API of the class.
Certain important or frequently used fields can also be public, but it is common practice to make fields non-public and encapsulate them with public accessor methods.
Use protected for fields and methods that aren’t required by most programmers using the class but that may be of interest to anyone creating a subclass.
Note that protected members are technically part of the exported API of a class.
They should be documented and cannot be changed without potentially breaking code that relies on them.
Use the default package visibility for fields and methods that are internal implementation details but are used by cooperating classes in the same package.
You cannot take real advantage of package visibility unless you use the.
Use private for fields and methods that are used only inside the class and should be hidden everywhere else.
If you are not sure whether to use protected, package, or private accessibility, it is better to start with overly restrictive member access.
You can always relax the access restrictions in future versions of your class, if necessary.
Doing the reverse is not a good idea because increasing access restrictions is not a backwardcompatible change and can break code that relies on access to those members.
In the Circle example, we declared the circle radius to be a public field.
The Circle class is one in which it may well be reasonable to keep that field publicly accessible; it is a simple enough class, with no dependencies between its fields.
On the other hand, our current implementation of the class allows a Circle object to have a negative radius, and circles with negative radii should simply not exist.
As long as the radius is stored in a public field, however, any programmer can set the field to any value she wants, no matter how unreasonable.
The only solution is to restrict the programmer’s direct access to the field and define public methods that provide indirect access to the field.
Providing public methods to read and write a field is not the same as making the field itself public.
The crucial difference is that methods can perform error checking.
Example 3-4 shows how we might reimplement Circle to prevent circles with negative radii.
This version of Circle declares the r field to be protected and the field value while enforcing the restriction on negative radius values.
Because the r field is protected, it is directly (and more efficiently) accessible to subclasses.
This is a generally useful constant, so we keep it public.
We have defined the Circle class within a package named shapes.
Since r is protected, any other classes in the shapes package have direct access to that field and can set it however they like.
The assumption here is that all classes within the shapes package were written by the same author or a closely cooperating group of authors and that the classes all trust each other not to abuse their privileged level of access to each other’s implementation details.
Finally, the code that enforces the restriction against negative radius values is itself class cannot call this method, subclasses of the class can call it and even override it if they want to change the restrictions on the radius.
An interesting way to study a complex class is to look at the set of properties it defines.
Properties are particularly common in the AWT and Swing APIs, which are covered in Java Foundation Classes in a Nutshell (O’Reilly)
Abstract Classes and Methods In Example 3-4, we declared our Circle class to be part of a package named shapes.
Suppose we plan to implement a number of shape classes: Rectangle, Square, Ellipse, Triangle, and so on.
If we structure our class hierarchy this way, every shape object, regardless of the actual type of shape it represents, can be assigned to variables, fields, or array elements of type Shape.
We want the Shape class to encapsulate circumference( ) methods)
But our generic Shape class doesn’t represent any real kind of shape, so it cannot define useful implementations of the methods.
Java lets us define a method without implementing it by declaring the method with the abstract modifier.
An abstract method has no body; it simply has a signature definition followed by a semicolon.* Here are the rules about abstract methods and the abstract classes that contain them:
Any class with an abstract method is automatically abstract itself and must be declared as such.
A subclass of an abstract class can be instantiated only if it overrides each of the abstract methods of its superclass and provides an implementation (i.e., a method body) for all of them.
Such a class is often called a concrete subclass, to emphasize the fact that it is not abstract.
If a subclass of an abstract class does not implement all the abstract methods it inherits, that subclass is itself abstract and must be declared as such.
A class can be declared abstract even if it does not actually have any abstract methods.
Declaring such a class abstract indicates that the implementation is somehow incomplete and is meant to serve as a superclass for one or more subclasses that complete the implementation.
There is an important feature of the rules of abstract methods.
If we define the Shape is required to provide implementations of these methods so that it can be instantiated.
In other words, every Shape object is guaranteed to have implementations of these methods defined.
It defines an abstract Shape class and two concrete subclasses of it.
The same is true of Java classes that contain abstract methods.
Each abstract method in Shape has a semicolon right after its parentheses.
They have no curly braces, and no method body is defined.
Using the classes defined in Example 3-5, we can now write code such as:
Subclasses of Shape can be assigned to elements of an array of Shape.
This is another example of a widening reference type conversion (discussed in Chapter 2)
When you do this, the method to be invoked is found using dynamic method lookup, so the area of a circle is computed using the method defined by Circle, and the area of a rectangle is computed using the method defined by Rectangle.
Important Methods of java.lang.Object As we’ve noted, all classes extend, directly or indirectly, java.lang.Object.
This class defines several important methods that you should consider overriding in every class you write.
The sections that follow the example document the default implementation of.
You may also find it helpful to look up Object in the reference section for an API listing.
Some of the syntax in Example 3-6 may be unfamiliar to you.
First, it implements a parameterized, or generic, version of the Comparable interface.
Second, the example uses the @Override annotation to emphasize (and have the compiler verify) that certain methods override Object.
This class represents a circle with immutable position and radius.
These fields hold the coordinates of the center and the radius.
They are private for data encapsulation and final for immutability.
A hash code allows an object to be used in a hash table.
The purpose of the toString( ) method is to return a textual representation of an object.
The method is invoked automatically on objects during string concatenation and by methods such as System.out.println( )
The toString( ) method in Example 3-6 instead returns a human-readable string that includes the value of each of the fields of the Circle class.
Circles are ordered top to bottom, left to right, and then by radius.
We have to use a long value for subtraction because the differences // between a large positive and large negative value could overflow // an int.
But we can't return the long, so return its sign as an int.
The equals( ) method in Example 3-6 considers two distinct Circle objects to be as an optimization and then checks the type of the other object with instanceof: a method to throw a ClassCastException.
Note that the instanceof test also rules out null arguments: instanceof always evaluates to false if its left-hand operand is null.
Whenever you override equals( ), you must also override hashCode( )
This method returns an integer for use by hash table data structures.
It is important (for efficient operation of hash tables) but not required that unequal objects have unequal hash codes, or at least that unequal objects are methods that involve mildly tricky arithmetic or bit-manipulation.
If you ever need an identity-based hash code, you can access the functionality of equal objects have equal hash codes.
Since the equals( ) method in Example 3-6 bases object equality on the values of the three fields, the hashCode( ) method computes its hash code based on these three fields as well.
It is clear from the code that if two Circle objects have the same field values, they will have the same hash code.
Note that the hashCode( ) method in Example 3-6 does not simply add the three fields and return their sum.
Such an implementation would be legal but not efficient because two circles with the same radius but whose X and Y coordinates were reversed would then have the same hash code.
This method is defined by the java.lang.Comparable interface rather than by Object.
If a class implements Comparable, we can say that one instance is less than, greater than, or equal to another instance.
Since compareTo( ) is defined by an interface, the Object class does not provide any default implementation.
It is up to each individual class to determine whether and implements that ordering.
The ordering defined by Example 3-6 compares Circle objects as if they were words on a page.
Circles are first ordered from top to bottom: circles with larger Y coordinates are less than circles with smaller Y coordinates.
If two circles have the same Y coordinate, they are ordered from left to right.
A circle with a smaller X coordinate is less than a circle with a larger X coordinate.
Finally, if two circles have the same X and Y coordinates, they are compared by radius.
Notice that under this ordering, two circles are equal only if all three of their fields are equal.
The compareTo( ) method returns an int value that requires further explanation.
First, it works only if the class implements the java.lang.Cloneable interface.
Cloneable does not define any methods, so implementing it is simply a matter of listing it in the implements clause of the class signature.
This means that subclasses of Object can want your object to be cloneable, you must implement Cloneable and override the.
The Circle class of Example 3-6 does not implement Cloneable; instead it provides a copy constructor for making copies of Circle objects:
It can be difficult to implement clone( ) correctly, and it is usually easier and safer to provide a copy constructor.
To make the Circle class cloneable, you would add Cloneable to the implements clause and add the following method to the class body:
Interfaces Like a class, an interface defines a new reference type.
Unlike classes, however, interfaces provide no implementation for the types they define.
As its name implies, an interface specifies only an API: all of its methods are abstract and have no bodies.
It is not possible to directly instantiate an interface and create a member of the interface type.
Instead, a class must implement the interface to provide the necessary method bodies.
Any instances of that class are members of both the type defined by the class and the type defined by the interface.
Interfaces provide a limited but very powerful alternative to multiple inheritance.* Classes in Java can inherit members from only a single superclass, but they can implement any number of interfaces.
Objects that do not share the same class or superclass may still be members of the same type by virtue of implementing the same interface.
An interface definition is much like a class definition in which all the methods are abstract and the keyword class has been replaced with interface.
For example, the following code shows the definition of an interface named Centered.
A Shape class, such as those defined earlier in the chapter, might implement this interface if it wants to allow the coordinates of its center to be set and queried:
A number of restrictions apply to the members of an interface:
All methods of an interface are implicitly abstract and must have a semicolon in place of a method body.
The abstract modifier is allowed but, by convention, is usually omitted.
Since static methods may not be abstract, the methods of an interface may not be declared static.
All members of an interface are implicitly an error to define a protected or private method in an interface.
Fields are an implementation detail, and an interface is a pure specification without any implementation.
The only fields allowed in an interface definition are constants that are declared both static and final.
An interface cannot be instantiated, so it does not define a constructor.
C++ supports multiple inheritance, but the ability of a class to have more than one superclass adds a lot of complexity to the language.
Interfaces may extend other interfaces, and, like a class definition, an interface definition may include an extends clause.
When one interface extends another, it inherits all the abstract methods and constants of its superinterface and can define new abstract methods and constants.
Unlike classes, however, the extends clause of an interface definition may include more than one superinterface.
For example, here are some interfaces that extend other interfaces:
An interface that extends more than one interface inherits all the abstract methods and constants from each of those interfaces and can define its own additional abstract methods and constants.
A class that implements such an interface must implement the abstract methods defined directly by the interface, as well as all the abstract methods inherited from all the superinterfaces.
Just as a class uses extends to specify its superclass, it can use implements to name one or more interfaces it supports.
When a class declares an interface in its implements clause, it is saying that it provides an implementation (i.e., a body) for each method of that interface.
If a class implements an interface but does not provide an implementation for every interface method, it inherits those unimplemented abstract methods from the interface and must itself be declared abstract.
If a class implements more than one interface, it must implement every method of each interface it implements (or be declared abstract)
The following code shows how we can define a CenteredRectangle class that extends the Rectangle class from earlier in the chapter and implements our Centered interface.
Suppose we implement CenteredCircle and CenteredSquare just as we have implemented this CenteredRectangle class.
Since each class extends Shape, instances of the classes can be treated as instances of the Shape class, as we saw earlier.
Since each class implements the Centered interface, instances can also be treated as instances of that type.
The following code demonstrates how objects can be members of both a class type and an interface type:
Create some centered shapes, and store them in the Shape[] // No cast necessary: these are all widening conversions.
This example demonstrates that interfaces are data types in Java, just like classes.
When a class implements an interface, instances of that class can be assigned to variables of the interface type.
Don’t interpret this example to imply that you must assign a CenteredRectangle object to a Centered variable before you can invoke the setCenter( ) method or to a Shape variable before you can invoke the its Rectangle superclass, so you can always invoke these methods.
Suppose we want shape objects that can be positioned in terms of not only their center points but also their upper-right corners.
And suppose we also want shapes that can be scaled larger and smaller.
Remember that although a class can extend only a single superclass, it can implement any number of interfaces.
When a class implements more than one interface, it simply means that it must provide implementations for all abstract methods in all its interfaces.
When defining an abstract type (e.g., Shape) that you expect to have many subtypes (e.g., Circle, Rectangle, Square), you are often faced with a choice between interfaces and abstract classes.
Since they have similar features, it is not always clear which to use.
An interface is useful because any class can implement it, even if that class extends some entirely unrelated superclass.
But an interface is a pure API specification and contains no implementation.
If an interface has numerous methods, it can become tedious to implement the methods over and over, especially when much of the implementation is duplicated by each implementing class.
An abstract class does not need to be entirely abstract; it can contain a partial implementation that subclasses can take advantage of.
In some cases, numerous subclasses can rely on default method implementations provided by an abstract class.
But a class that extends an abstract class cannot extend any other class, which can cause design difficulties in some situations.
Another important difference between interfaces and abstract classes has to do with compatibility.
If you define an interface as part of a public API and then later add a new method to the interface, you break any classes that implemented the previous version of the interface.
If you use an abstract class, however, you can safely add nonabstract methods to that class without requiring modifications to existing classes that extend the abstract class.
In some situations, it is clear that an interface or an abstract class is the right design choice.
In other cases, a common design pattern is to use both.
Define the type as a totally abstract interface, then create an abstract class that implements the interface and provides useful default implementations that subclasses can take advantage of.
It represents a shape that fits inside // of a rectangular bounding box.
Any class that wants to serve as a // RectangularShape can implement these methods from scratch.
Many // implementations may find this a useful starting point.
The position and size of the shape protected double x, y, w, h;
Sometimes it is useful to define an interface that is entirely empty.
A class can implement this interface simply by naming it in its implements clause without having to implement any methods.
In this case, any instances of the class become valid instances of the interface.
Java code can check whether an object is an instance of the interface using the instanceof operator, so this technique is a useful way to provide additional information about an object.
The java.io.Serializable interface is a marker interface of this sort.
A class implements Serializable interface to tell ObjectOutputStream that its instances may safely be serialized.
Algorithms that care about the performance of randomaccess operations can test for RandomAccess like this:
Before sorting the elements of a long arbitrary list, we may want to make // sure that the list allows fast random access.
If not, it may be quicker // make a random-access copy of the list before sorting it.
As noted earlier, constants can appear in an interface definition.
Any class that implements an interface inherits the constants it defines and can use them as if they were defined directly in the class itself.
Importantly, there is no need to prefix the constants with the name of the interface or provide any kind of implementation of the constants.
When a set of constants is used by more than one class, it is tempting to define the constants once in an interface and then have any classes that require the constants implement the interface.
This situation might arise, for example, when client and server classes implement a network protocol whose details (such as the port number to connect to and listen on) are captured in a set of symbolic constants.
The primary benefit of inheriting constant definitions from an interface is that it saves typing: you don’t need to specify the type that defines the constants.
Despite its use with ObjectStreamConstants, this is not a recommended technique.
The use of constants is an implementation detail that is not appropriate to declare in the implements clause of a class signature.
A better approach is to define constants in a class and use the constants by typing the full class name and the constant name.
In Java 5.0 and later, you can save typing by importing the constants from their defining class with the import static declaration.
Nested Types The classes, interfaces, and enumerated types we have seen so far in this book have all been defined as top-level classes.
This means that they are direct members of packages, defined independently of other types.
However, type definitions can also be nested within other type definitions.
A type can be nested within another type in four ways:
Static member types A static member type is any type defined as a static member of another type.
A static member type behaves much like an ordinary top-level type, but its name is part of the namespace, rather than the package, of the containing type.
Also, a static member type can access the static members of the class that contains it.
Nested interfaces, enumerated types, and annotation types are implicitly static, whether or not the static keyword appears.
Any type nested within an interface or annotation is also implicitly static.
Static member types may be defined within top-level types or nested to any depth within other static member types.
A static member type may not be defined within any other kind of nested type, however.
Nonstatic member classes may be defined within other classes or enumerated types and are analogous to instance methods or fields.
An instance of a nonstatic member class is always associated with an instance of the enclosing type, and the code of a nonstatic member class has access to all the fields and methods (both static and non-static) of its enclosing type.
Several features of Java syntax exist specifically to work with the enclosing instance of a nonstatic member class.
Local classes A local class is a class defined within a block of Java code.
Interfaces, enumerated types, and annotation types may not be defined locally.
Like a local variable, a local class is visible only within the block in which it is defined.
Although local classes are not member classes, they are still defined within an enclosing class, so they share many of the features of member classes.
Additionally, however, a local class can access any final local variables or parameters that are accessible in the scope of the block that defines the class.
Anonymous classes An anonymous class is a kind of local class that has no name; it combines the syntax for class definition with the syntax for object instantiation.
While a local class definition is a Java statement, an anonymous class definition (and instantiation) is a Java expression, so it can appear as part of a larger expression, such as method invocation.
Interfaces, enumerated types, and annotation types cannot be defined anonymously.
Sometimes, however, inner class is used to refer to a nonstatic member class, local class, or anonymous class, but not a static member type.
Although the terminology for describing nested types is not always clear, the syntax for working with them is, and it is usually clear from context which kind of nested type is being discussed.
Now we’ll describe each of the four kinds of nested types in greater detail.
Each section describes the features of the nested type, the restrictions on its use, and any special Java syntax used with the type.
These four sections are followed by an implementation note that explains how nested types work under the hood.
A static member type is much like a regular top-level type.
For convenience, however, it is nested within the namespace of another type.
Example 3-7 shows a helper interface defined as a static member of a containing class.
The example also shows how this interface is used both within the class that contains it and by external classes.
Note the use of its hierarchical name in the external class.
A class that implements a stack as a linked list // This static member interface defines how objects are linked // The static keyword is optional: all nested interfaces are static.
The head of the list is a Linkable object Linkable head;
A static member type is defined as a static member of a containing type.
Any type (class, interface, enumerated type, or annotation type) may be defined as a static member of any other type.
Interfaces, enumerated types, and annotation types are implicitly static, whether or not the static keyword appears in their definition.
A static member type is like the other static members of a class: static fields and static methods.
Like a class method, a static member type is not associated with any instance of the containing class (i.e., there is no this object)
A static member type does, however, have access to all the static members (including any other static member types) of its containing type.
A static member type can use any other static member without qualifying its name with the name of the containing type.
A static member type has access to all static members of its containing type, including private members.
The reverse is true as well: the methods of the containing type have access to all members of a static member type, including the other static member types, including the private members of those types.
Top-level types can be declared with or without the public modifier, but they cannot use the private and protected modifiers.
Static member types, however, are members and can use any access control modifiers that other members of the containing type can.
These modifiers have the same meanings for static member types as they do for other members of a type.
In Example 3-7, the Linkable interface is declared public, so it can be implemented by any class that is interested in being stored on a LinkedStack.
Recall that all members of interfaces (and annotation types) are implicitly public, so static member types nested within interfaces or annotation types cannot be protected or private.
This class implements the static member interface // Here's the node's data and constructor int i;
Here are the data and methods required to implement the interface LinkedStack.Linkable next;
A static member type cannot have the same name as any of its enclosing classes.
In addition, static member types can be defined only within top-level types and other static member types.
This is actually part of a larger prohibition against static members of any sort within member, local, and anonymous classes.
In code outside the containing class, a static member type is named by combining the name of the outer type with the name of the inner type (e.g., LinkedStack.
You can use the import directive to import a static member type:
In Java 5.0 and later, you can also use the import static directive to import a static member type.
Note that importing a nested type obscures the fact that that type is closely associated with its containing type, and it is not commonly done.
A nonstatic member class is a class that is declared as a member of a containing class or enumerated type without the static keyword.
If a static member type is analogous to a class field or class method, a nonstatic member class is analogous to an instance field or instance method.
Example 3-8 shows how a member class can be defined and used.
This example extends the previous LinkedStack example to allow enumeration of the elements on the stack by defining an iterator( ) method that returns an implementation of the java.util.Iterator interface.
The implementation of this interface is defined as a member class.
The example uses Java 5.0 generic type syntax in a couple of places, but this should not prevent you from understanding it.
Notice how the LinkedIterator class is nested within the LinkedStack class.
Since LinkedIterator is a helper class used only within LinkedStack, there is real elegance to having it defined so close to where it is used by the containing class.
Like instance fields and instance methods, every instance of a nonstatic member class is associated with an instance of the class in which it is defined.
This means that the code of a member class has access to all the instance fields and instance methods (as well as the static members) of the containing class, including any that are declared private.
This single line of code sets the current field of the inner class to the value of the head field of the containing class.
The code works as shown, even though head is declared as a private field in the containing class.
A nonstatic member class, like any member of a class, can be assigned one of three visibility levels: public, protected, or private.
If none of these visibility modifiers is specified, the default package visibility is used.
In Example 3-8, the LinkedIterator class is declared protected, so it is inaccessible to code (in a different package) that uses the LinkedStack class but is accessible to any class that subclasses LinkedStack.
Here is the implementation of the Iterator interface, // defined as a nonstatic member class.
Linkable current; // The constructor uses the private head field of the containing class // The following 3 methods are defined by the Iterator interface return value;
A nonstatic member class cannot have the same name as any containing class or package.
This is an important rule, one not shared by fields and methods.
Nonstatic member classes cannot contain any static fields, methods, or types, except for constant fields declared both static and final.
Defining a static top-level member within a member class that is not at the top level would cause confusion, so it is not allowed.
Interfaces, enumerated types, and annotation types are all implicitly static, even if the static keyword is omitted.
The most important feature of a member class is that it can access the instance fields and methods in its containing object.
In this example, head is a field of the LinkedStack class, and we assign it to the current field of the LinkedIterator class.
What if we want to make these references explicit? We could try code like this:
It is the this.head expression that causes the problem; it refers to a field named head in the LinkedIterator object.
Since there is no such field, the compiler generates an error.
To solve this problem, Java defines a special syntax for explicitly referring to the containing instance of the this object.
Thus, if we want to be explicit in our constructor, we can use the following syntax:
The general syntax is classname.this, where classname is the name of a containing class.
Note that member classes can themselves contain member classes, nested to any depth.
Since no member class can have the same name as any containing class, however, the use of the enclosing class name prepended to this is a perfectly general way to refer to any containing instance.
This syntax is needed only when referring to a member of a containing class that is hidden by a member of the same name in the member class.
When a class shadows or overrides a member of its superclass, you can use the keyword super to refer to the hidden member.
This super syntax can be extended to work with member classes as well.
As we’ve seen, every instance of a member class is associated with an instance of its containing class.
When a member class constructor is invoked like this, the new instance of the member class is automatically associated with the this object.
This is what you would expect to happen and exactly what you want to occur in most cases.
Occasionally, however, you may want to specify the containing instance explicitly when instantiating a member class.
You can do this by preceding the new operator earlier is shorthand for the following:
Let’s pretend we didn’t define an iterator( ) method for LinkedStack.
In this case, the code to obtain an LinkedIterator object for a given LinkedStack object might look like this:
The containing instance implicitly specifies the containing class; it is a syntax error to explicitly specify the containing class name:
One other special piece of Java syntax specifies an enclosing instance for a member class explicitly.
Before we consider it, however, let me point out that you should rarely, if ever, need to use this syntax.
It is one of the pathological cases that snuck into the language along with all the elegant features of nested types.
As strange as it may seem, it is possible for a top-level class to extend a member class.
This means that the subclass does not have a containing instance, but its superclass does.
When the subclass constructor invokes the superclass constructor, it must specify the containing instance.
It does this by prepending the containing instance and a period to the super keyword.
If we had not declared our LinkedIterator class to be a protected member of LinkedStack, we could subclass it.
Although it is not clear why we would want to do so, we could write code like the following:
A top-level class that extends a member class // The constructor must explicitly specify a containing instance // when invoking the superclass constructor.
We’ve just noted that a top-level class can extend a member class.
With the introduction of nonstatic member classes, two separate hierarchies must be considered for any class.
The first is the inheritance hierarchy, from superclass to subclass, that defines the fields and methods a member class inherits.
The second is the containment hierarchy, from containing class to contained class, that defines a set of fields and methods that are in the scope of (and are therefore accessible to) the member class.
The two hierarchies are entirely distinct from each other; it is important that you do not confuse them.
This should not be a problem if you refrain from creating naming conflicts, where a field or method in a superclass has the same name as a field or method in a containing class.
If such a naming conflict does arise, however, the inherited field or method takes precedence over the field or method of the same name in the containing class.
This behavior is logical: when a class inherits a field or method, that field or method effectively becomes part of that class.
Therefore, inherited fields and methods are in the scope of the class that inherits them and take precedence over fields and methods by the same name in enclosing scopes.
A good way to prevent confusion between the class hierarchy and the containment hierarchy is to avoid deep containment hierarchies.
If a class is nested more than two levels deep, it is probably going to cause more confusion than it is worth.
Furthermore, if a class has a deep class hierarchy (i.e., it has many ancestors), consider defining it as a top-level class rather than as a nonstatic member class.
A local class is declared locally within a block of Java code rather than as a member of a class.
Only classes may be defined locally: interfaces, enumerated types and annotation types must be top-level or static member types.
Typically, a local class is defined within a method, but it can also be defined within a static initializer or instance initializer of a class.
Because all blocks of Java code appear within class definitions, all local classes are nested within containing classes.
For this reason, local classes share many of the features of member classes.
It is usually more appropriate, however, to think of them as an entirely separate kind of nested type.
A local class has approximately the same relationship to a member class as a local variable has to an instance variable of a class.
The defining characteristic of a local class is that it is local to a block of code.
Like a local variable, a local class is valid only within the scope defined by its enclosing block.
If a member class is used only within a single method of its containing class, for example, there is usually no reason it cannot be coded as a local class rather method of the LinkedStack class so it defines LinkedIterator as a local class instead of a member class.
By doing this, we move the definition of the class even closer to where it is used and hopefully improve the clarity of the code even further.
For brevity, Example 3-9 shows only the iterator( ) method, not the entire LinkedStack class that contains it.
Like member classes, local classes are associated with a containing instance and can access any members, including private members, of the containing class.
In addition to accessing fields defined by the containing class, local classes can access any local variables, method parameters, or exception parameters that are in the scope of the local method definition and are declared final.
The name of a local class is defined only within the block that defines it; it can never be used outside that block.
Note however that instances of a local class created within the scope of the class can continue to exist outside of that scope.
This situation is described in more detail later in this section.)
Local classes cannot be declared public, protected, private, or static.
These modifiers are for members of classes; they are not allowed with local variable declarations or local class declarations.
Like member classes, and for the same reasons, local classes cannot contain static fields, methods, or classes.
The only exception is for constants that are declared both static and final.
Interfaces, enumerated types, and annotation types cannot be defined locally.
This method returns an Iterator object for this LinkedStack // Here's the definition of LinkedIterator as a local class Linkable current;
The constructor uses the private head field of the containing class // The following 3 methods are defined by the Iterator interface return value;
Create and return an instance of the class we just defined.
A local class, like a member class, cannot have the same name as any of its enclosing classes.
As noted earlier, a local class can use the local variables, method parameters, and even exception parameters that are in its scope but only if those variables or parameters are declared final.
This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined.
For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler)
The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.
In Java 1.0, only fields, methods, and classes could be declared final.
The addition of local classes in Java 1.1 required a liberalization in the use of the final modifier.
As of Java 1.1, final can be applied to local variables, method parameters, and even the exception parameter of a catch statement.
The meaning of the final modifier remains the same in these new uses: once the local variable or parameter has been assigned a value, that value cannot be changed.
Instances of local classes, like instances of nonstatic member classes, have an enclosing instance that is implicitly passed to all constructors of the local class.
Local classes can use the same this syntax as nonstatic member classes to refer explicitly to members of enclosing classes.
Because local classes are never visible outside the blocks that define them, however, there is never a need to use the new and super syntax used by member classes to specify the enclosing instance explicitly.
In discussing nonstatic member classes, we saw that a member class can access any members inherited from superclasses and any members defined by its containing classes.
The same is true for local classes, but local classes can also access final local variables and parameters.
The following code illustrates the many fields and variables that may be accessible to a local class:
All of these fields and variables are accessible to this class.
A local variable is defined within a block of code that defines its scope.
A local variable ceases to exist outside of its scope.
Java is a lexically scoped language, which means that its concept of scope has to do with the way the source code is written.
Any code within the curly braces that define the boundaries of a block can use local variables defined in that block.*
Lexical scoping simply defines a segment of source code within which a variable can be used.
It is common, however, to think of a scope as a temporal scope—to think of a local variable as existing from the time the Java interpreter begins executing the block until the time the interpreter exits the block.
This is usually a reasonable way to think about local variables and their scope.
The introduction of local classes confuses the picture, however, because local classes can use local variables, and instances of a local class can have a lifetime much longer than the time it takes the interpreter to execute the block of code.
In other words, if you create an instance of a local class, the instance does not automatically go away when the interpreter finishes executing the block that defines the class, as shown in the following code:
This section covers advanced material; first-time readers may want to skip it for now and return to it later.
The local class is now out of scope, so we can't use it.
But we have // 10 valid instances of that class in our array.
The local variable // fi is not in our scope here, but it is still in scope for the // for each object and print it out.
To make sense of it, remember that the lexical scope of the methods of a local class has nothing to do with when the interpreter enters and exits the block of code that defines the local class.
Here’s another way to think about it: each instance of a local class has an automatically created private copy of each of the final local variables it uses, so, in effect, it has its own private copy of the scope that existed when it was created.
In general terms, a closure is an object that saves the state of a scope and makes that scope available later.
Closures are useful in some styles of programming, and different programming languages define and implement closures in different ways.
Java’s closures are relatively weak (and some would argue that they are not truly closures) because they retain the state of only final variables.
An anonymous class is a local class without a name.
An anonymous class is defined and instantiated in a single succinct expression using the new operator.
While a local class definition is a statement in a block of Java code, an anonymous class definition is an expression, which means that it can be included as part of a larger expression, such as a method call.
In practice, anonymous classes are much more common than local classes.
If you find yourself defining a short local class and then instantiating it exactly once, consider rewriting it using anonymous class syntax, which places the definition and use of the class in exactly the same place.
Consider Example 3-10, which shows the LinkedIterator class implemented as an anonymous class within the iterator( ) method of the LinkedStack class.
Compare it with Example 3-9, which shows the same class implemented as a local class.
The generic syntax in this example is covered in Chapter 4
The anonymous class is defined as part of the return statement Linkable current; // Replace constructor with an instance initializer.
The following 3 methods are defined by the Iterator interface.
One common use for an anonymous class is to provide a simple implementation of an adapter class.
An adapter class is one that defines code that is invoked by some method lists the files in a directory.
Before it returns the list, though, it passes the name of each file to a FilenameFilter object you must supply.
This FilenameFilter the body of such a class is typically quite short, it is easy to define an adapter class as an anonymous class.
Here’s how you can define a FilenameFilter class to list only those files whose names end with .java:
Define and instantiate an anonymous implementation of FilenameFilter // as part of the method invocation expression.
As you can see, the syntax for defining an anonymous class and creating an instance of that class uses the new keyword, followed by the name of a class and a class body definition in curly braces.
If the name following the new keyword is the name of a class, the anonymous class is a subclass of the named class.
If the name following new specifies an interface, as in the two previous examples, the anonymous class implements that interface and extends Object.
The syntax does not include any way to specify an extends clause, an implements clause, or a name for the class.
Because an anonymous class has no name, it is not possible to define a constructor for it within the class body.
This is one of the basic restrictions on anonymous classes.
Any arguments you specify between the parentheses following the superclass name in an anonymous class definition are implicitly passed to the superclass constructor.
Anonymous classes are commonly used to subclass simple classes that do not take any constructor arguments, so the parentheses in the anonymous class definition syntax are often empty.
In the previous examples, each anonymous class implemented an interface and extended Object.
Since the Object( ) constructor takes no arguments, the parentheses were empty in those examples.
Anonymous classes allow you to define a one-shot class exactly where it is needed.
Anonymous classes have all the features of local classes but use a more concise syntax that can reduce clutter in your code.
Because an anonymous class is just a type of local class, anonymous classes and local classes share the same restrictions.
An anonymous class cannot define any static fields, methods, or classes, except for static final constants.
Interfaces, enumerated types, and annotation types cannot be defined anonymously.
Also, like local classes, anonymous classes cannot be public, private, protected, or static.
Since an anonymous class has no name, it is not possible to define a constructor for an anonymous class.
If your class requires a constructor, you must use a local class instead.
However, you can often use an instance initializer as a substitute for a constructor.
The syntax for defining an anonymous class combines definition with instantiation.
Using an anonymous class instead of a local class is not appropriate if you need to create more than a single instance of the class each time the containing block is executed.
We’ve already seen examples of the syntax for defining and instantiating an anonymous class.
Although they are not limited to use with anonymous classes, instance initializers were introduced into the language for this purpose.
The contents of all instance initializers for a class are automatically inserted into all constructors for the class, including any automatically created default constructor.
An anonymous class cannot define a constructor, so it gets a default constructor.
By using an instance initializer, you can get around the fact that you cannot define a constructor for an anonymous class.
As we’ve discussed, an anonymous class behaves just like a local class and is distinguished from a local class merely in the syntax used to define and instantiate it.
In your own code, when you have to choose between using an anonymous class and a local class, the decision often comes down to a matter of style.
In general, you should consider using an anonymous class instead of a local class if:
The name of the class does not make your code any easier to understand.
The common indentation and formatting conventions we are familiar with for block-structured languages like Java and C begin to break down somewhat once we start placing anonymous class definitions within arbitrary expressions.
Based on their experience with nested types, the engineers at Sun recommend the following formatting rules:
The opening curly brace should not be on a line by itself; instead, it should follow the closing parenthesis of the new operator.
Similarly, the new operator should, when possible, appear on the same line as the assignment or other expression of which it is a part.
The body of the anonymous class should be indented relative to the beginning of the line that contains the new keyword.
The closing curly brace of an anonymous class should not be on a line by itself either; it should be followed by whatever tokens are required by the rest of the expression.
Often this is a semicolon or a closing parenthesis followed by a semicolon.
This extra punctuation serves as a flag to the reader that this is not just an ordinary block of code and makes it easier to understand anonymous classes in a code listing.
The preceding sections explained the features and behavior of the four kinds of nested types.
Strictly speaking, that should be all you need to know about nested types.
You may find it easier to understand nested types if you understand how they are implemented, however.
Despite the dramatic changes to the Java language, the introduction of nested types did not change the Java Virtual Machine or the Java class file format.
As far as the Java interpreter is concerned, there is no such thing as a nested type: all classes are normal top-level classes.
In order to make a nested type behave as if it is actually defined inside another class, the Java compiler ends up inserting hidden fields, methods, and constructor arguments into the classes it generates.
You may want to use the javap disassembler to disassemble some of the class files for nested types so you can see what tricks the compiler has used to make the nested types work.
Recall our first LinkedStack example (Example 3-7), which defined a static member interface named Linkable.
When you compile this LinkedStack class, the compiler actually generates two class files.
The $ in this name is automatically inserted by the Java compiler.
This second class file contains the implementation of the static member interface.
As we discussed earlier, a static member type can access all the static members of its containing class.
If a static member type does this, the compiler automatically qualifies the member access expression with the name of the containing class.
A static member type is even allowed to access the private static fields of its containing class.
Since the static member type is compiled into an ordinary toplevel class, however, there is no way it can directly access the private members of its container.
Therefore, if a static member type uses a private member of its containing type (or vice versa), the compiler generates synthetic non-private access methods and converts the expressions that access the private members into expressions that invoke these specially generated methods.
These methods are given the default package access, which is sufficient, as the member class and its containing class are guaranteed to be in the same package.
A nonstatic member class is implemented much like a static member type.
It is compiled into a separate top-level class file, and the compiler performs various code manipulations to make interclass member access work correctly.
The most significant difference between a nonstatic member class and a static member type is that each instance of a nonstatic member class is associated with an instance of the enclosing class.
The compiler enforces this association by defining a synthetic field named this$0 in each member class.
This field is used to hold a reference to the enclosing instance.
Every nonstatic member class constructor is given an extra parameter that initializes this field.
Every time a member class constructor is invoked, the compiler automatically passes a reference to the enclosing class for this extra parameter.
As we’ve seen, a nonstatic member class, like any member of a class, can be declared public, protected, or private, or given the default package visibility.
Member classes are compiled to class files just like top-level classes, but top-level classes can have only public or package access.
Therefore, as far as the Java interpreter is concerned, member classes can have only public or package visibility.
This means that a member class declared protected is actually treated as a public class, and a member class declared private actually has package visibility.
This does not mean you should never declare a member class as protected or private.
Although the Java VM cannot enforce these access control modifiers, the modifiers are stored in the class file and conforming Java compilers do enforce them.
A local class is able to refer to fields and methods in its containing class for exactly the same reason that a nonstatic member class can; it is passed a hidden reference to the containing class in its constructor and saves that reference away in a classes, local classes can use private fields and methods of their containing class because the compiler inserts any required accessor methods.
What makes local classes different from member classes is that they have the ability to refer to local variables in the scope that defines them.
The crucial restriction on this ability, however, is that local classes can reference only local variables and parameters that are declared final.
The reason for this restriction becomes apparent in the implementation.
A local class can use local variables because the compiler automatically gives the class a private instance field to hold a copy of each local variable the class uses.
The compiler also adds hidden parameters to each local class constructor to initialize these automatically created private fields.
A local class does not actually access local variables but merely its own private copies of them.
The only way this can work correctly is if the local variables are declared final so that they are guaranteed not to change.
With this guarantee, the local class can be assured that its internal copies of the variables are always in sync with the real local variables.
Since anonymous classes have no names, you may wonder what the class files that represent them are named.
This is an implementation detail, but Sun’s Java compiler uses numbers to provide anonymous class names.
Modifier Summary As we’ve seen, classes, interfaces, and their members can be declared with one or more modifiers—keywords such as public, static, and final.
Table 3-2 lists the Java modifiers, explains what types of Java constructs they can modify, and explains what they do.
Method The method cannot be overridden (and is not subject to dynamic method lookup)
Variable A local variable, method parameter, or exception parameter cannot have its value changed.
No body is provided; the signature is followed by a semicolon.
None (package) Class A non-public class is accessible only in its package.
Interface A non-public interface is accessible only in its package.
Member A member that is not private, protected, or public has package visibility and is accessible only within its package.
Several features of C++ have no parallel in Java, however.
In general, Java does not adopt those features of C++ that make the language significantly more complicated.
C++ supports multiple inheritance of method implementations from more than one superclass at a time.
While this seems like a useful feature, it actually introduces many complexities to the language.
The Java language designers chose to avoid the added complexity by using interfaces instead.
Thus, a class in Java can inherit method implementations only from a single superclass, but it can inherit method declarations from any number of interfaces.
In particular, all values, including intermediate results, must be expressed as IEEE float or double values and cannot take advantage of any extra precision or range offered by native platform floating-point formats or hardware.
There is only one instance of the field, regardless of the number of class instances created.
Initializer The initializer is run when the class is loaded rather than when an instance is created.
For a static method, a lock for the class is acquired before executing the method.
For a non-static method, a lock for the specific object instance is acquired.
This modifier can sometimes be used as an alternative to synchronized.
C++ allows you to define operators that perform arbitrary operations on instances of your classes.
In effect, it allows you to extend the syntax of the language.
This is a nifty feature, called operator overloading, that makes for elegant examples.
In practice, however, it tends to make code quite difficult to understand.
After much debate, the Java language designers decided to omit such operator overloading from the language.
Note, though, that the use of the + operator for string concatenation in Java is at least reminiscent of operator overloading.
C++ allows you to define conversion functions for a class that automatically invokes an appropriate constructor method when a value is assigned to a variable of that class.
This is simply a syntactic shortcut (similar to overriding the assignment operator) and is not included in Java.
In Java, all objects are manipulated by reference, so there is no need for the & syntax.
This chapter covers the three most important new language features of Java 5.0
Generics add type-safety and expressiveness to Java programs by allowing types to be parameterized with other types.
A List that contains String objects, for example, can be written as List<String>
Using parameterized types makes Java code clearer and allows us to remove most casts from our programs.
Enumerated types, or enums, are a new category of reference type, like classes and interfaces.
An enumerated type defines a finite (“enumerated”) set of values, and, values of that enumerated type or null.
The third Java 5.0 feature discussed in this chapter is program annotations and the annotation types that define them.
An annotation associates arbitrary data (or metadata) with a program element such as a class, method, field, or even a method parameter or local variable.
The type of data held in an annotation is defined by its annotation type, which, like enumerated types, is another new category of reference type.
The Java 5.0 platform includes three standard annotation types used to provide additional information to the Java compiler.
Annotations will probably find their greatest use with code generation tools in Java enterprise programming.
Java 5.0 also introduces a number of other important new language features that don’t require a special chapter to explain.
Coverage of these changes is found in sections throughout Chapter 2
Methods with variable-length argument lists, also known as varargs methods.
The import static directive, which imports the static members of a type into the namespace.
Generic Types Generic types and methods are the defining new feature of Java 5.0
A generic type is defined using one or more type variables and has one or more methods that use a type variable as a placeholder for an argument or return type.
For example, the type java.util.List<E> is a generic type: a list that holds elements of some type value of type E.
In order to use a generic type like this, you specify actual types for the type variable (or variables), producing a parameterized type such as List<String>.* The reason to specify this extra type information is that the compiler can provide much stronger compile-time type checking for you, increasing the type safety of your programs.
This type checking prevents you from adding a String[], for example, to a List that is intended to hold only String objects.
Also, the additional type information enables the compiler to do some casting for you.
The compiler knows that the get( ) method of a List<String> (for example) returns a String object: you are no longer required to cast a return value of type Object to a String.
The collections classes of the java.util package have been made generic in Java 5.0, and you will probably use them frequently in your programs.
Typesafe collections are the canonical use case for generic types.
Even if you never define generic types of your own and never use generic types other than the collections classes in java.
We begin by exploring the basic use of generics in typesafe collections, then delve into more complex details about the use of generic types.
After describing how to use generic types, we explain how to write your own generic types and generic methods.
Our coverage of generics concludes with a tour of important generic types in the core Java API.
It explores these types and their use in depth in order to provide a deeper understanding of how generics work.
The java.util package includes the Java Collections Framework for working with sets and lists of objects and mappings from key objects to value objects.
Here, we discuss the fact that in Java 5.0 the collections classes use type parameters to identify the type of the objects in the collection.
This is not the case in Java 1.4 and earlier.
Without generics, the use of collections requires the programmer to remember the proper element type for each collection.
When you create a collection in Java 1.4, you know what type of.
In common usage, however, the distinction is not a sharp one and the terms are sometimes used interchangeably.
You must be careful to add elements of the appropriate type.
And when querying elements from a collection, you must write explicit casts to convert them from Object to their actual type.
The compiler doesn't know that so we have to remember ourselves.
Since the list is intended to hold strings, we cast the // return value to String but get a ClassCastException because of // the error above.
Generic types solve the type safety problem illustrated by this code.
List and the other collection classes in java.util have been rewritten to be generic.
As mentioned above, List has been redefined in terms of a type variable named E that represents the type of the elements of the list.
The add( ) method is redefined to expect an argument of type E instead of Object and get( ) has been redefined to return E instead of Object.
In Java 5.0, when we declare a List variable or create an instance of an ArrayList, we specify the actual type we want E to represent by placing the actual type in angle brackets following the name of the generic type.
A List that holds strings is a List<String>, for example.
Note that this is much like passing an argument to a method, except that we use types rather than values and angle brackets instead of parentheses.
The elements of the java.util collection classes must be objects; they cannot be used with primitive values.
In Java 5.0, the example above would be rewritten as follows:
Note that this code isn’t much shorter than the nongeneric example it replaces.
The cast, which uses the word String in parentheses, is replaced with the type parameter, which places the word String in angle brackets.
The difference is that the type parameter has to be declared only once, but the list can be used any number of times without a cast.
But even in cases where the generic syntax is more verbose than the nongeneric syntax, it is still very much worth using generics because the extra type information allows the compiler to perform much stronger error checking on your code.
Errors that would only be apparent at runtime can now be detected at compile time.
Furthermore, the compilation error appears at the exact line where the type safety violation occurs.
Without generics, a ClassCastException can be thrown far from the actual source of the error.
Just as methods can have any number of arguments, classes can have more than one type variable.
A Map is a mapping from key objects to value objects.
The Map interface declares one type variable to represent the type of the keys and one variable to represent the type of the values.
As an example, suppose you want to map from String objects to Integer objects:
A map from strings to their position in the args[] array.
Note that we use autoboxing to wrap i in an Integer object.
We can also rely on autounboxing to convert directly to an int, // but this throws a NullPointerException if the key does not exist // in the map.
A parameterized type like List<String> is itself a type and can be used as the value of a type parameter for some other type.
The compiler knows all the types and we can write expressions // like this without casting.
We might still get NullPointerException // or ArrayIndexOutOfBounds at runtime, of course.
Here's how we break that expression down step by step.
In the code above, the get( ) methods of java.util.List<E> and java.util.
Map<K,V> return a list or map element of type E and V respectively.
Note, however, that generic types can use their variables in more sophisticated ways.
That is, the method returns an instance of a parameterized type whose actual type parameter is the same as the actual type parameter of the list.
This section delves deeper into the details of generic type usage, explaining the following topics:
A hole in the compile-time type safety of generic types and a patch to ensure runtime type safety.
Even though the Java collection classes have been modified to take advantage of generics, you are not required to specify type parameters to use them.
A generic type used without type parameters is known as a raw type.
Existing pre-5.0 code continues to work: you simply write all the casts that you’re already used to writing, and you put up with some pestering from the compiler.
Consider the following code that stores objects of mixed types into a raw List:
If we compile it using Java 5.0, however, javac compiles the code but prints this complaint:
When we recompile with the -Xlint option as suggested, we see these warnings:
The compiler warns us about the add( ) calls because it cannot ensure that the values being added to the list have the correct types.
It is letting us know that because we’ve used a raw type, it cannot verify that our code is typesafe.
Note that the call to get( ) is okay because it is extracting an element that is already safely in the list.
Parameterized types form a type hierarchy, just as normal types do.
The hierarchy is based on the base type, however, and not on the type of the parameters.
This is nonintuitive, and it is important to understand why generics work this way.
But for the purposes of this // thought-experiment, assume that it does compile and see how much // trouble we get ourselves into.
Now we can retrieve elements of the list as Object instead of Integer.
At the time of this writing, javac does not yet honor the @SuppressWarnings annotation.
If the line above is allowed then the line below throws ClassCastException.
If the conversion to List<Object> were allowed, non-Integer objects could be added to the list.
A List<X> can be converted to a List, however, so that you can pass it to a legacy method that expects an argument of that type and has not been updated for generics.
This ability to convert parameterized types to nonparameterized types is essential for backward compatibility, but it does open up a hole in the type safety system that generics offer:
It is legal to assign a parameterized type to a nonparameterized variable.
This line is a bug, but it compiles and runs.
The Java 5.0 compiler will issue an unchecked warning about it.
If it appeared as part of a legacy class compiled with Java 1.4, however, // then we'd never even get the warning.
This line compiles without warning but throws ClassCastException at runtime.
Note that the failure can occur far away from the actual bug.
If you compile all your code with the Java 5.0 compiler and do not get any unchecked warnings, these compile-time checks are enough to ensure that your code is also typesafe at runtime.
But if you have unchecked warnings or are working with legacy code that manipulates your collections as raw types, you may want to take additional steps to ensure type checkedMap( ) of java.util.Collections.
These methods enclose your collection in a wrapper collection that performs runtime type checks to ensure that only values of the correct type are added to the collection.
For example, we could prevent the type safety hole shown above like this:
This line compiles but fails at runtime with a ClassCastException.
The exception occurs exactly where the bug is, rather than far away.
Because of this, the Java interpreter must perform a runtime check every time you store an object in an array to ensure that the runtime type of the object and of the array are compatible.
For example, the following code fails this runtime check and throws an ArrayStoreException:
When we work with generic types, the runtime check for array store exceptions is no longer sufficient because a check performed at runtime does not have access to the compile-time type parameter information.
If the code above were allowed, the runtime array store check would succeed: without compile-time type parameters, the code simply stores an ArrayList into an ArrayList[] array, which is perfectly legal.
Since the compiler can’t prevent you from defeating type safety in this way, it instead prevents you from creating any array of parameterized type.
The scenario above can never occur because the compiler will refuse to compile the first line.
Note that this is not a blanket restriction on using arrays with generics; it is just a restriction on creating arrays of parameterized type.
We’ll return to this issue when we look at how to write generic methods.
Suppose we want to write a method to display the elements of a List.* Before List was a generic type, we’d just write code like this:
In Java 5.0, List is a generic type, and, if we try to compile this method, we’ll get unchecked warnings.
In order to get rid of those warnings, you might be tempted to modify the method as follows:
This code compiles without warnings but isn’t very useful because the only lists that can be passed to it are lists explicitly declared of type List<Object>
The solution is to use a wildcard as the type parameter.
This version of the method compiles without warnings and can be used the way we want it to be used.
As a general rule, if a type is generic and you don’t know or don’t care about the value of the type variable, you should always use a ? wildcard instead of using a raw type.
Raw types are allowed only for backward compatibility and should be used only in legacy code.
Note, however, that you cannot use a wildcard when invoking a constructor.
There is no sense in creating a List of unknown type.
If you are creating it, you should know what kind of elements it will hold.
You may later want to pass such a list to a method that does not care about its element type, but you need to specify an element type when you create it.
If what you really want is a List that can hold any type of object, do this:
A List<?> has two important properties that result from the use of a wildcard.
In this case, that type is unknown, so these methods return an this is fine for our needs.
Let’s continue now with a slightly more complex variant of our original example.
As before, we could use a raw List, but we would give up type safety and have to deal with unchecked warnings from the compiler.
But if we use a wildcard, we don’t actually get the type safety that we want because we have to trust that our method will be called with a List whose type parameter is actually Number or a subclass and not, say, a String.
To fix this method and make it truly typesafe, we need to use a bounded wildcard that states that the type parameter of the List is an unknown type that is either Number or a subclass of Number.
The use of a for/in loop obscures the process of extracting elements from a list somewhat.
The general rule is that when you use a that return a value of the type parameter use the upper bound.
The prohibition on calling methods like list.add( ) that have arguments of the type parameter type still stands: if the compiler allowed us to call those methods we could add an Integer to a list that was declared to hold only Short values, for example.
It is also possible to specify a lower-bounded wildcard using the keyword super instead of extends.
This technique has a different impact on what methods can be called.
Lower-bounded wildcards are much less commonly used than upperbounded wildcards, and we discuss them later in the chapter.
First, declare your type variables by enclosing a comma-separated list of their names within angle brackets after the name of the class or interface.
You can use those type variables anywhere a type is required in any instance fields or methods of the class.
Remember, though, that type variables exist only at compile time, so you can’t use a type variable with the runtime operators instanceof and new.
We begin this section with a simple generic type, which we will subsequently refine.
This code defines a Tree data structure that uses the type variable V to represent the type of the value held in each node of the tree:
A tree is a data structure that holds values of type V.
Each tree has a single value of type V and can have any number of * branches, each of which is itself a Tree.
These are instance methods for manipulating the node value and branches.
Note the use of the type variable V in the arguments or return types.
As you’ve probably noticed, the naming convention for type variables is to use a single capital letter.
The use of a single letter distinguishes these variables from the names of actual types since real-world types always have longer, more descriptive names.
The use of a capital letter is consistent with type naming conventions and.
Notice that the type variables declared by a generic type can be used only by the instance fields and methods (and nested types) of the type and not by static fields and methods.
The reason, of course, is that it is instances of generic types that are parameterized.
Static members are shared by all instances and parameterizations of the class, so static members do not have type parameters associated with them.
Methods, including static methods, can declare and use their own type parameters, however, and each invocation of such a method can be parameterized differently.
The type variable V in the declaration above of the Tree<V> class is unconstrained: Tree can be parameterized with absolutely any type.
Often we want to place some constraints on the type that can be used: we might want to enforce that a type parameter implements one or more interfaces, or that it is a subclass of a specified class.
This can be done by specifying a bound for the type variable.
We’ve already seen upper bounds for wildcards, and upper bounds can also be specified for type variables using a similar syntax.
The following code is the Tree example rewritten to make Tree objects Serializable and Comparable.
In order to do this, the example uses a type variable bound to ensure that its value type is also Serializable and Comparable.
The bound shown here requires that the value type V is comparable to itself, in other words, that it implements the Comparable interface directly.
This rules out the use of types that inherit the Comparable interface from a superclass.
We’ll consider the Comparable interface in much more detail at the end of this section and present an alternative there.
This method is a nonrecursive implementation of Comparable<Tree<V>> // It only compares the value of this node and ignores branches.
The bounds of a type variable are expressed by following the name of the variable with the word extends and a list of types (which may themselves be parameterized, as Comparable is)
Note that with more than one bound, as in this case, the bound types are separated with an ampersand rather than a comma.
Commas are used to separate type variables and would be ambiguous if used to separate type variable bounds as well.
A type variable can have any number of bounds, including any number of interfaces and at most one class.
Earlier in the chapter we saw examples using wildcards and bounded wildcards in methods that manipulated parameterized types.
Our current design of the Tree class requires the value object of every node to have exactly the same type, V.
Perhaps this is too strict, and we should allow branches of a tree to have values that are a subtype of V instead of requiring V itself.
This version of the Tree class (minus the Comparable and Serializable implementation) is more flexible:
These fields hold the value and the branches V value;
If we query the branch with the getBranch( ) method, the value type of the returned branch is unknown, and we must use a wildcard to express this.
The next two lines are legal, but the third is not:
When we query a branch like this, we don’t know the precise type of the value, but we do still have an upper bound on the value type, so we can do this:
What we cannot do, however, is set the value of the branch, or add a new branch to that branch.
As explained earlier in the chapter, the existence of the upper bound does not change the fact that the value type is unknown.
This example has illustrated a typical trade-off in the design of a generic type: using a bounded wildcard made the data structure more flexible but reduced our ability to safely use some of its methods.
Whether or not this was a good design is probably a matter of context.
In general, generic types are more difficult to design well.
Fortunately, most of us will use the preexisting generic types in the java.util package much more frequently than we will have to create our own.
As noted earlier, the type variables of a generic type can be used only in the instance members of the type, not in the static members.
And although static methods cannot use the type variables of their containing class, they can declare their own type variables.
When a method declares its own type variable, it is called a generic method.
Here is a static method that could be added to the Tree class.
Recursively compute the sum of the values of all nodes on the tree */ return total;
This method could also be rewritten as a generic method by declaring a type variable to express the upper bound imposed by the wildcard:
Generic methods are required where a single type variable is used to express a relationship between two parameters or between a parameter and a return value.
This method returns the largest of two trees, where tree size if (ts > us) return t; else return u;
This method uses the type variable N to express the constraint that both arguments and the return value have the same type parameter and that that type parameter is Number or a subclass.
One way to express this is to use two unrelated type variables to represent the two unrelated value types.
Note, however, that we cannot use either variable in the return type of the method and must use a wildcard there:
Since the two type variables N and M have no relation to each other, and since each is used in only a single place in the signature, they offer no advantage over bounded wildcards.
All the examples of generic methods shown here have been static methods.
This is not a requirement: instance methods can declare their own type variables as well.
When you use a generic type, you must specify the actual type parameters to be substituted for its type variables.
The same is not generally true for generic methods: the compiler can almost always figure out the correct parameterization of a generic method based on the arguments you pass to the method.
You need not specify N when you invoke this method because N is implicitly specified in the values of the method arguments t and u.
In the following code, for example, the compiler determines that N is Integer:
The process the compiler uses to determine the type parameters for a generic method is called type inference.
Type inference is relatively intuitive to understand, but the actual algorithm the compiler must use is surprisingly complex and is well beyond the scope of this book.
Let’s look at a slightly more complex version of type inference.
Set all elements of a to the value v; return a.
In the first invocation, the compiler can easily determine that T is Boolean.
In the second invocation, the compiler determines that T is Number.
In very rare circumstances you may need to explicitly specify the type parameters for a generic method.
This is sometimes necessary, for example, when a generic method expects no arguments.
Consider the java.util.Collections.emptySet( ) method: it returns a set with no elements, but unlike the Collections.singleton( ) method (you can look these up in the reference section), it takes no arguments that would specify the type parameter for the returned set.
You can specify the type parameter explicitly by placing it in angle brackets before the method name:
Type parameters cannot be used with an unqualified method name: they must follow a dot or come after the keyword new or before the keyword this or super used in a constructor.
Although the explicit type parameter specification in the code above can be a helpful clarification, it is not necessary and the line could be rewritten as:
An explicit type parameter is necessary when you use the return value of the emptySet( ) method within a method invocation expression.
If you want to pass an empty set to this method, you could use this code:
In this case, the explicit specification of the type parameter String is required.
Earlier in the chapter we saw that the compiler does not allow you to create an array whose type is parameterized.
This is not, however, a restriction on all uses of example.
Its first argument and its return value are both of type T[]
The body of the method does not have to create an array whose element type is T, so the method is perfectly legal.
Return the largest of the specified values or null if there are none */
You can invoke this method with parameters of type Integer because the compiler can insert the necessary array creation code for you when you call it.
Exceptions are thrown and caught at runtime, and there is no way for the compiler to perform type checking to ensure that an exception of unknown origin matches type parameters specified in a catch clause.
For this reason, catch clauses may not include type variables or wildcards.
Since it is not possible to catch an exception at runtime with compile-time type parameters intact, you are not allowed to make any subclass of Throwable generic.
You can, however, use a type variable in the throws clause of a method signature.
This interface represents a “command”: a block of code with a single string argument and no return value.
The code may throw an exception represented by the type parameter X.
Here is an example that uses a parameterization of this interface:
These APIs were carefully created or reviewed by the inventors of generic types, and we can learn a lot about the good design of generic types and methods through the study of these APIs.
The generic types of java.util are relatively easy: for the most part they are collections classes, and type variables are used to represent the element type of the collection.
They are not collections, and it is not immediately apparent why they have been made generic.
Studying these difficult generic types gives us a deeper understanding of how generics work and introduces some concepts that we have not yet covered in this chapter.
Specifically, we’ll examine the Comparable interface and the Enum class (the supertype of enumerated types, described later in this chapter) and will learn about an important but infrequently used feature of generics known as lowerbounded wildcards.
In Java 5.0, the Comparable interface has been made generic, with a type variable that specifies what a class is comparable to.
The raw Comparable interface is problematic from a type-safety standpoint.
It is possible to have two Comparable objects that cannot be meaningfully compared to each other.
Prior to Java 5.0, the nongeneric Comparable interface was useful but not fully satisfactory.
The generic version of this interface, however, captures exactly the information we want: it tells us that a type is comparable and tells us what we can compare it to.
Integer is final and cannot be subclassed, so let’s look at java.math.BigInteger instead:
If we implement a BiggerInteger subclass of BigInteger, it inherits the Comparable interface from its superclass.
This means that BigInteger and BiggerInteger objects are mutually comparable, which is usually a good thing.
BiggerInteger can override the compareTo( ) method of its superclass, but it is not allowed to implement a different parameterization of Comparable.
That is, BiggerInteger cannot both extend BigInteger and implement Comparable<BiggerInteger>
In general, a class is not allowed to implement two different parameterizations of the.
When you’re working with comparable objects (as you do when writing sorting algorithms, for example), remember two things.
First, it is not sufficient to use Comparable as a raw type: for type safety, you must also specify what it is comparable to.
Second, types are not always comparable to themselves: sometimes they’re comparable to one of their ancestors.
The method has a type variable T with complicated bounds that we’ll return to later.
The element type of the collection is specified with a bounded wildcard.
We don’t know the exact type of the collection’s elements, but we know that they have an upper bound of T.
That is, we know that the elements of the collection are type T or a subclass of T.
Any element of the collection could therefore be used as the return value of the method.
Now let’s look again at the type variable declaration used by the max( ) method:
This says first that the type T must implement Comparable.
Generics syntax uses the keyword extends for all type variable bounds, whether classes or interfaces.) This is expected since the purpose of the method is to find the “maximum” object in a collection.
This is a wildcard, but it is bounded with the keyword super instead of the keyword extends.
For other examples of lower-bounded wildcards (that have nothing to do with.
It adds all the elements of a to the collection c.
The element type of the collection is unknown but has a lower bound: the elements are all of type T or a superclass of T.
Recall from our earlier discussion of upper-bounded wildcards that if you have a collection whose element type is an upper-bounded wildcard, it is effectively readonly.
We know that all elements are the list is unknown.
You can’t add arbitrary serializable objects to the list because their implementing class may not be of the correct type.
Since upper-bounded wildcards result in read-only collections, you might expect lower-bounded wildcards to result in write-only collections.
The actual element type is unknown, but the only possibilities are Integer or its ancestors Number and Object.
Whatever the actual type is, it is safe to add Integer objects (but not Number or Object objects) to the list.
And, whatever the actual element type is, all elements of the list are instances of Object, so List methods like get( ) return Object in this case.
Enum serves as the supertype of all enumerated types (described later)
It implements the Comparable interface but has a confusing generic signature:
At first glance, the declaration of the type variable E appears circular.
Take a closer look though: what this signature really says is that Enum must be parameterized by a type that is itself an Enum.
The reason for this seemingly circular type variable declaration becomes apparent if we look at the implements clause of the signature.
As we’ve seen, Comparable classes are usually defined to be comparable to themselves.
And subclasses of those classes are comparable to their superclass instead.
Enum, on the other hand, implements the Comparable interface not for itself but for a subclass E of itself!
Enumerated Types In previous chapters, we’ve seen the class keyword used to define class types, and the interface keyword used to define interface types.
This section introduces the enum keyword, which is used to define an enumerated type (informally called an enum)
Enumerated types are new in Java 5.0, and the features described here cannot be used (although they can be partially simulated) prior to that release.
We begin with the basics: how to define and use an enumerated type, including common programming idioms involving enumerated types and values.
Next, we discuss the more advanced features of enums and show how to simulate enums prior to Java 5.0
An enumerated type is a reference type with a finite (usually small) set of possible values, each of which is individually listed, or enumerated.
Like class and interface, the enum keyword defines a new reference type.
The single line of Java code above defines an enumerated type named DownloadStatus.
The body of this type is simply a comma-separated list of the four values of the type.
These values are like static final fields (which is why their names are capitalized), and you refer to them with names like DownloadStatus.CONNECTING, DownloadStatus.READING, and so on.
A variable of type DownloadStatus can be assigned one of these four values or null but nothing else.
The values of an enumerated type are called enumerated values and are sometimes also referred to as enum constants.
It is possible to define more complex enumerated types than the one shown here, and we describe the complete enum syntax later in this chapter.
For now, however, you can define simple, but very useful, enumerated types with this basic syntax.
Prior to the introduction of enumerated types in Java 5.0, the DownloadStatus values would probably have been implemented as integer constants with lines like the following in a class or interface:
The use of integer constants has a number of shortcomings, the most important of which is its lack of type safety.
If a method expects a download status constant value, for example, no error checking prevents me from passing an illegal value.
The compiler can’t tell me that I’ve used the constant UploadStatus.DONE when I should have used DownloadStatus.DONE.
Fortunately, enumerated types in Java are not simple integer constants.
The type defined by an enum keyword is actually a class and its enumerated values are instances of that class.
This provides type safety: if I try to pass a DownloadStatus value to a method that expects an UploadStatus, the compiler issues an error.
Enumerated types do not have a public constructor, so a program cannot create a new undefined instance of the type.
If a method expects a DownloadStatus, it can be confident that it will not be passed some unknown instance of the type.
If you are accustomed to writing code using integer constants instead of true enumerated types, you have probably already made a list of pragmatic advantages of integers over objects for enumerated values.
Hold your judgment, however: the sections that follow illustrate common enumerated type programming idioms and demonstrate that anything you can do with integer constants can be done elegantly, efficiently, and more safely with enums.
First, however, we consider the basic features of all enumerated types.
The following list describes the basic facts about enumerated types.
These are the features of enums that you need to know to understand and use them effectively:
The only instances of an enumerated type are those declared by the enum.
Enums are not Cloneable, so copies of the existing instances cannot be created.
Enums implement java.io.Serializable so they can be serialized, but the Java serialization mechanism handles them specially to ensure that no new instances are ever created.
Instances of an enumerated type are immutable: each enum value retains its identity.
We’ll see later in this chapter that you can add your own fields and methods to an enumerated type, which means that you can create enumerated values that have mutable portions.
This is not recommended, but does not affect the basic identity of each value.)
Instances of an enumerated type are stored in public static final fields of the type itself.
Because these fields are final, they cannot be overwritten with inappropriate values: you can’t assign the DownloadStatus.ERROR value to the DownloadStatus.DONE field, for example.
By convention, the values of enumerated types are written using all capital letters, just as other static final fields are.
Because there is a strictly limited set of distinct enumerated values, it is.
Enumerated types do have a working equals( ) method, however.
The working equals( ) method allows enumerated values to be used as members of collections such as Set, List, and Map.
Enumerated types include a working toString( ) method that returns the name of the enumerated value.
For example, DownloadStatus.DONE.toString( ) returns the string "DONE" by default.
This method is not final, and enum types can provide a custom implementation if they choose.
Enumerated types provide a static valueOf( ) method that does the opposite of the default toString( ) method.
The ordinal of an enumerated value represents its position (starting at zero) in the list of value names in the enum declaration.
You do not typically need to use the ordinal( ) method, but it is used by a number of enum-related facilities, as described later in the chapter.
Each enumerated type defines a static method named values( ) that returns an array of enumerated values of that type.
This array contains the complete set of values, in the order they were declared, and is useful for iterating through the complete set of possible values.
Because arrays are mutable, the values( ) method always returns a newly created and initialized array.
Enumerated types are subclasses of java.lang.Enum, which is new in Java 5.0
Enum is not itself an enumerated type.) You cannot produce an enumerated type by manually extending the Enum class, and it is a compilation error to attempt this.
The only way to define an enumerated type is with the enum keyword.
Enumerated types are effectively final, but the final keyword is neither required nor permitted in their declarations.
Because enums are effectively final, they may not be abstract.
We’ll see how enumerated types may define methods later in the chapter.)
The following sections illustrate common idioms for working with enumerated types.
They demonstrate the use of the switch statement with enumerated types and introduce the important new EnumSet and EnumMap collections.
In Java 1.4 and earlier, the switch statement works only with int, short, char, and byte values.
Because enumerated types have a finite set of values, they are ideally suited for use with the switch statement, and this statement has been extended in Java 5.0 to support the use of enumerated types.
If the compile-time type of the switch expression is an enumerated type, the case labels must all be unqualified names of instances of that type.
The following hypothetical code shows a switch statement used with the DownloadStatus enumerated type.
Note that the case labels are just the constant name: the syntax of the switch statement does not allow the class name DownloadStatus to appear here.
The ability to omit the class name is very convenient since it would otherwise appear in every single case.
However the requirement that the class name be omitted is surprising since (in the absence of an import static declaration) the class name is required in every other context.
If the switch expression (status in the code above) evaluates to null, a NullPointerException is thrown.
It is not legal to use null as the value of a case label.
If you use the switch statement on an enumerated type and do not include either a default: label or a case label for each enumerated value, the compiler will most likely issue an -Xlint warning letting you know that you have not written code to handle all possible values of the enumerated type.* Even when you do write a case for each enumerated value, you may still want to include a default: clause; this covers the possibility that a new value is added to the enumerated type after your switch statement has been compiled.
The following default clause, for example, could be added to the switch statement shown earlier:
A common programming technique when using integer constants instead of true enumerated values is to use those constants as array indexes.
In the big picture, this technique creates a mapping from enumerated integer constants to strings.
We can’t use Java’s enumerated values as array indexes, but we can use them as keys in a java.util.Map.
Because this is a common thing to do, Java 5.0 defines a new java.util.EnumMap class that is optimized for exactly this case.
EnumMap requires an enumerated type as its key, and, relying on the fact the number of possible keys is finite, it uses an array to hold the corresponding values.
This implementation means that EnumMap is more efficient than HashMap.
At the time of this writing, this warning is expected to appear in Java 5.1
Like other collection classes in Java 5.0, EnumMap is a generic type that accepts type parameters.
The use of an EnumMap to associate a value with each instance of an enumerated type is appropriate when you’re working with an enum defined elsewhere.
If you defined the enum value yourself, you can create the necessary associations as part of the enum definition itself.
We’ll see how to do this later in the chapter.
Another common programming idiom when using integer-based constants instead of an enumerated type is to define all the constants as powers of two so that a set of those constants can be compactly represented as bit-flags in an integer.
Consider the following flags that describe options that can apply to an American-style espresso drink:
These power-of-two constants can be combined with the bitwise OR operator (|) to create a compact set of constants that is easy to work with:
The bitwise AND operator (&) can be used to test for the presence or absence of bits:
If we step back from the binary representation of these bit flags and the boolean operators that manipulate them, we can see that integer bit flags are simply compact sets of values.
For reference types such as Java’s enumerated values, we can use a java.util.Set instead.
Since this is an important and common thing to do with enumerated values, Java 5.0 provides the special-purpose java.util.EnumSet class.
The espresso drink code above could be rewritten as follows using an enum and EnumSet:
Note that the code above can be made as compact as the integer-based code with a simple static import:
A varargs (see Chapter 2) form that can accept any number of arguments is also defined.
We can remove individual members or sets of members from a set.
Start with a set that includes all enumerated values, then remove a subset:
Here's an empty set if you ever need one // Note that since we don't specify a value, we must specify the element type.
You can also easily describe a contiguous subset of values:
The example code shown here demonstrates the use and capabilities of the EnumSet class.
Note, however, that an EnumSet<DrinkFlags> is not really an appropriate representation for the description of an espresso drink.
An EnumSet<DrinkFlags> might be overspecified, including both SHORT and GRANDE, for example, or it might be underspecified and include no drink size at all.
At the root, the problem is that the DrinkFlag type is a naive translation of the integer bit flags we began this section with.
A better and more complete representation is captured by the following interface, which requires one value from each of five different enumerated types and a set of values from a sixth enum.
The enums are defined as nested types within the interface itself (see Chapter 3)
This example highlights the type safety provided by enumerated types.
It is not possible (as it would be with integer constants) to specify a drink strength where a drink size is required, for example.
The examples shown so far have all used the simplest enum syntax in which the body of the enum simply consists of a comma-separated list of value names.
The full enum syntax actually provides quite a bit more power and flexibility:
You can define your own fields, methods, and constructors for the enumerated type.
If you define one or more constructors, you can invoke a constructor for each enumerated value by following the value name with constructor arguments in parentheses.
Although an enum may not extend anything, it may implement one or more interfaces.
Most esoterically, individual enumerated values can have their own class bodies that override methods defined by the type.
Rather than formally specifying the syntax for each of these advanced enum declarations, we’ll demonstrate the syntax in the examples that follow.
It is an enum that includes a regular class body following the list of enumerated values.
It defines two instance fields and accessor methods for those fields.
It defines a custom constructor that initializes the instance field.
Each named value of the enumerated type is followed by constructor arguments in parentheses:
The values are separated from each other by commas, and the // list of values is terminated with a semicolon to separate it from // the class body that follows.
They are instance methods // of each value of the enumerated type.
Note that enum syntax requires a semicolon after the last enumerated value if that value is followed by a class body.
This semicolon may be omitted in the simple case where there is no class body.
It is also worth noting that enum syntax allows a comma following the last enumerated value.
A trailing comma looks somewhat odd but prevents syntax errors if in the future you add new enumerated values or rearrange existing ones.
An enum cannot be declared to extend a class or enumerated type.
It is perfectly legal, however, for an enumerated type to implement one or more interfaces.
Suppose, for example, that you defined a new enumerated type Unit with an abbrev( ) method like Prefix has.
In this case, you might define an interface Abbrevable for any objects that have abbreviations.
In addition to defining a class body for the enumerated type itself, you can also provide a class body for individual enumerated values within the type.
We’ve seen above that we can add fields to an enumerated type and use a constructor to initialize those fields.
The ability to define class bodies for each enumerated value means that we can write methods for each one: this gives us value-specific behavior.
Value-specific behavior is useful when defining an enumerated type that represents an operator in an expression parser.
To define a class body for an individual enumerated value, simply follow the value name and its constructor arguments with the class body in curly braces.
Individual values must still be separated from each other with commas, and the last value in the list must be separated from the type’s class body with a semicolon: it can be easy to forget about this required punctuation with the presence of curly braces for class and method bodies.
Each value-specific class body you write results in the creation of an anonymous subclass of the enumerated type and makes the enumerated value a singleton instance of that anonymous subclass.
Enumerated types can not be extended, but they are not strictly final in the sense that final classes are since they can have these anonymous subclasses.) Because these subclasses are anonymous, you cannot refer to them in your code: the compile-time type of each enumerated value is the enumerated type, not the anonymous subclass specific to that value.
Therefore, the only useful thing you can do in value-specific class bodies is override methods defined by the type itself.
If you define a new public field or method, you will not be able to refer to or invoke it.
It is perfectly legitimate, of course, to define helper methods or fields that you invoke or use from the overriding methods.)
A common pattern is to define default behavior in a method of the type-specific class body.
Then, each enumerated value that requires behavior other than the default can override that method in its value-specific class body.
A very useful variant of this pattern is to declare the method in the type-specific class body abstract and to define a value-specific implementation of the method for every enumerated value.
If the type-specific method is abstract, the compiler forces you to implement that method for every enumerated value in the type: it is not possible to accidentally omit an implementation.
Note that even though the typespecific class body contains an abstract method, the enumerated type as a whole is not abstract (and may not be declared abstract) since each value-specific class body implements the method.
The following code is an excerpt from a larger example that uses an enumerated type to represent the opcodes of a simulated stack-based CPU.
The Opcode constructor to illustrate the full syntax for each enumerated value: name, constructor arguments, and class body.
The code is easiest to understand, however, if you skip past the values and read the type-specific class body first:
These are the opcodes that our stack machine can execute.
Add the top two values on the stack and push the result.
Each opcode constant must implement this abstract method in a // value-specific class body to perform the operation it represents.
Value-specific class bodies are an extremely powerful language feature when each enumerated value must perform a unique computation of some sort.
Keep in mind, however, that value-specific class bodies are an advanced feature that is not commonly used and may be confusing to less experienced programmers.
Before you decide to use this feature, be sure that it is necessary.
Before using value-specific class bodies, ensure that your design is neither too simple nor too complex for the feature.
First, check that you do indeed require value-specific behavior and not simply value-specific data.
Value-specific data can be encoded in constructor arguments as was shown in the Prefix example earlier.
It would be unnecessary and inappropriate to rewrite that example to use valuespecific versions of the abbrev( ) method, for example.
Next, think about whether an enumerated type is sufficient for your needs.
If your design requires value-specific methods with complex implementations or requires more than a few methods for each value, you may find it unwieldy to code everything within a single type.
Instead, consider defining your own custom type hierarchy using traditional class and interface declarations and whatever singleton instances are necessary.
If value-specific behavior is indeed required within the framework of an enumerated type, value-specific class bodies are appropriate.
Whether value-specific bodies are truly elegant or simply confusing is a matter of opinion, and some.
An alternative that appeals to some is to encode the value-specific behavior in a type-specific method that uses a switch statement to treat each value as a separate case.
The compute( ) method of the following enum is an example.
The simplicity of this enumerated type makes a switch statement a compelling alternative to value-specific class bodies:
A shortcoming to the switch approach is that each time you add a new enumerated value, you must remember to add a corresponding case to the switch statement.
And if there is more than one method that uses a switch statement, you’ll have to maintain their switch statements in parallel.
Forgetting to implement value-specific behavior using a switch statement leads to a runtime AssertionError.
With a value-specific class body overriding an abstract method in the type-specific class body, the same omission leads to a compilation error and can be corrected sooner.
The performance of value-specific methods and switch statements in a typespecific method are quite similar.
The overhead of virtual method invocation in one case is balanced by the overhead of the switch statement in the other.
Valuespecific class bodies result in the generation of additional class files, each of which has overhead in terms of storage space and loading time.
Java places a few restrictions on the code that can appear in an enumerated type.
You won’t encounter these restrictions that often in practice, but you should still be aware of them.
When you define an enumerated type, the compiler does a lot of work behind the.
If you include a class body for the type, you should not include members whose names conflict with the automatically generated members or with the final methods inherited from Enum.
Enumerated types are effectively final, and the compiler does not allow you to extend an enum.
The class file generated for an enum is not technically declared final if the enum contains value-specific class bodies, however.
Types in Java may not be both final and abstract.
Since enumerated types are effectively final, they may not be declared abstract.
If the type-specific class body of an enum declaration contains an abstract method, the compiler requires that each enum value have a value-specific class body that includes an implementation of that abstract method.
Considered as a self-contained whole, the enumerated type defined this way is not abstract.
The constructor, instance field initializers, and instance initializer blocks of an enumerated type are subject to a sweeping but obscure restriction: they may not use the static fields of the type (including the enumerated values themselves)
The reason for this is that static initialization of enumerated types (and of all types) proceeds from top to bottom.
The enumerated values are static fields that appear at the top of the type and are initialized first.
Since they are self-typed fields, they invoke the constructor and any other instance initializer code of the type.
This means that the instance initialization code is invoked before the static initialization of the class is complete.
Since the static fields have not been initialized yet, the compiler does not allow them to be used.
The only exception is static fields whose values are compile-time constant expressions (such as integers and strings) that the compiler resolves.
If you define a constructor for an enumerated type, it may not use the super( ) keyword to invoke the superclass constructor.
This is because the compiler automatically inserts hidden name and ordinal arguments into any constructor you to invoke one constructor from the other.
Remember that the class bodies of individual enumerated values (if you define any) are anonymous, which means that they cannot have any constructors at all.
For a deeper understanding of how the enum keyword works, or to be able to simulate enumerated types prior to Java 5.0, it is useful to understand the Typesafe Enum Pattern.
This pattern is described definitively by Joshua Bloch* in his cover all the nuances here.
If you want to use the enumerated type Prefix (from earlier in the chapter) prior to Java 5.0, you could approximate it with a class like the following one.
He is the creator of and the driving force behind enumerated types.
Also, the code shown here does not include the enum types.
A class like this does not have special serialization support like an enum type does, so if you make it Serializable, you must provide a readResolve( ) method to prevent deserialization from creating multiple instances of the enumerated values.
The constructor is private so no instances can be created except // for the ones above.
Annotations Annotations provide a way to associate arbitrary information or metadata with program elements.
Syntactically, annotations are used like modifiers and can be applied to the declarations of packages, types, constructors, methods, fields, parameters, and local variables.
The information stored in an annotation takes the annotation type is a kind of interface that also serves to provide access to the annotation through the Java Reflection API.
Annotations can be used to associate any kind of information you want with a program element.
The only fundamental rule is that an annotation cannot affect the way the program runs: the code must run identically even if you add or remove annotations.
Another way to say this is that the Java interpreter ignores annotations (although it does make “runtime-visible” annotations available for reflective access through the Java Reflection API)
Since the Java VM ignores annotations, an annotation type is not useful unless accompanied by a tool that can do something with the information stored in annotations of that type.
In this chapter we’ll cover standard annotation and meta-annotation types like Override.
The tool that accompanies these types is the Java compiler, which must process them in certain ways (as we’ll describe later in this section)
It is easy to imagine any number of other uses for annotations.* A local variable might be annotated with a type named NonNull, as an assertion that the variable would never have a null value.
An associated (hypothetical) code-analysis tool could then parse the code and attempt to verify the assertion.
The JDK includes a tool named apt (for Annotation Processing Tool) that provides a framework for annotation processing tools: it scans source code for annotations and invokes specially written annotation processor classes that you provide.
Annotations will probably find their widest use in enterprise programming where they may replace tools such as XDoclet, which processes metadata embedded in ad-hoc javadoc comments.
We then cover the standard annotation types introduced in Java 5.0, annotations supported by javac that you can use in your programs right away.
Next, we describe the syntax for writing arbitrary annotations and briefly cover the use of the Java Reflection API for querying annotations at runtime.
At this point, we move on to more esoteric material on defining new annotation types, a task that few programmers will ever need to do.
The key concept to understand about annotations is that an annotation simply associates information or metadata with a program element.
Annotations never affect the way a Java program runs, but they may affect things like compiler warnings or the behavior of auxiliary tools such as documentation generators, stub generators, and so forth.
Of particular importance is the distinction between annotation and annotation type.
Annotations use new syntax introduced in Java 5.0 and behave like modifiers such as public or final.
Each annotation has a name and zero or more members.
Each member has a name and a value, and it is.
An annotation type is essentially a Java interface with some restrictions on its members and some new syntax used in its declaration.
When you query an annotation using the Java Reflection API, the returned value is an object that implements the annota* We won’t have to imagine these uses for long.
Java 5.0 includes three standard annotation types in the java.lang package.
The method name and return type define the name and type of the member.
A special default syntax allows the declaration of a default value for any annotation member.
An annotation appearing on a that override the defaults of other members.
An annotation of this type carries information simply by its presence or absence.
Java 5.0 includes several standard meta-annotation types in the java.lang.annotation package.
They are used to specify things like which program elements the annotation can be applied to.
Annotations can be applied to packages, types (classes, interfaces, enumerated types, and even annotation types), type members (methods, constructors, fields, and enumerated values), method parameters, and local variables (including loop variables and catch parameters)
The declaration of an annotation type may include a meta-annotation that restricts the allowable targets for that type of annotation.
Some annotations are discarded by the compiler and appear only in source code.
Of those that are compiled into the class file, some are ignored by the virtual machine, and others are read by the virtual machine when the class that contains them is loaded.
The declaration of an annotation type can use a meta-annotation to specify the retention for annotations of that type.
Annotations that are loaded by the VM are runtime-visible and can be queried by the reflective APIs of java.lang.reflect.
Because this term is used in many different ways in computer programming literature, I have avoided using it in this chapter.
Java 5.0 defines three standard annotation types in the java.lang package.
The following sections describe these annotation types and explain how to use them to annotate your code.
An annotation of this type serves as an assertion that the annotated method overrides a method of a superclass.
If you use this annotation on a method that does not override a superclass method, the compiler issues a compilation error to alert you to this fact.
This annotation is intended to address a common category of programming errors that result when you attempt to override a superclass method but get the method name or signature wrong.
In this case, you may have overloaded the method name but not actually overridden the method, and your code never gets invoked.
To use this annotation type, simply include @Override in the modifiers of the desired method.
Also by convention, there is no space between the @ character and the name Override, even though it is technically allowed.
Note that because the java.lang package is always automatically imported, you never need to include the package name to use this annotation type.
Here is an example in which the @Override annotation is superclass.
Without the annotation, the typo might go unnoticed and we’d have a puzzling expected because it is not actually overridden.
Note that the @Override annotation applies only to methods that are intended to override a superclass method and not to methods that are intended to implement a method defined in an interface.
The compiler already produces an error if you fail to correctly implement an interface method.
If you use (or extend or override) a deprecated type or member from code that is not itself declared @Deprecated, the compiler issues a warning.
The javadoc tag, on the other hand, is intended for the javadoc tool and serves as documentation: it may include a description of why the program element has been deprecated and what it has been superseded by or replaced with.
Here is an example that uses both the annotation and the javadoc tag:
Typically, when you see one of these lint warnings from the compiler, you should investigate the code that caused it.
If it truly represents an error, you then correct it.
If it simply represents sloppy programming, you may be able to rewrite your code so that the warning is no longer necessary.
For example, if the warning tells you that you have not covered all possible cases in a switch statement on an enumerated type, you can avoid the warning by adding a defensive default case to the switch statement, even if you are sure that it will never be invoked.
On the other hand, sometimes there is nothing you can do to avoid the error.
For example, if you use a generic collection class in code that must interact with nongeneric legacy code, you cannot avoid an unchecked warning.
This is where modifiers (typically on method modifiers) to tell the compiler that you’re aware of the issue and that it should stop pestering you about it.
Unlike Override and Deprecated, SuppressWarnings is not a marker annotation.
The value of this member is the names of the warnings to be suppressed.
The SuppressWarnings annotation does not define what warning names are allowed: this is an issue for.
The javac compiler did not yet support the @SuppressWarnings annotation when this chapter was written.
For the javac compiler, the warning names accepted by the -Xlint option are also legal for the @SuppressWarnings annotation.
It is legal to specify any warning names you want: compilers ignore (but may warn about) warning names they do not recognize.
So, to suppress warnings named unchecked and fallthrough, you could use an annotation that looks like the following.
In this case, the SuppressWarnings annotation type defines only a single member, so there is only a single pair within parentheses.
Since the member value is an array, curly braces are used to delimit array elements:
When an annotation has a single member and that member is named “value”, you are allowed (and encouraged) rewritten as:
Hopefully you will not often have more than one unresolvable lint warning in any particular method and will need to suppress only a single named warning.
When writing an array value that contains only a single member, you are allowed to omit the curly braces.
In this case we might have an annotation like this:
In the descriptions of the standard annotation types, we’ve seen the syntax for writing marker annotations and the syntax for writing single-member annotations, including the shortcut allowed when the single member is named “value” and the shortcut allowed when an array-typed member has only a single array element.
An annotation consists of the @ character followed by the name of the annotation type defines a default value for that member.
Each value must be a literal or compile-time constant, a nested annotation, or an array.
Near the end of this chapter, we define an annotation type named Reviews that has a single member that is an array of @Review annotations.
Assuming that the Reviews and Review types are properly imported, an annotation using these types might look like this (note the use of nested annotations, enumerated types, and arrays in this annotation):
Another important rule of annotation syntax is that no program element may have more than one instance of the same annotation.
It is not legal, for example, to simply place multiple @Review annotations on a class.
The values of annotation members must be non-null compile-time constant expressions that are assignment-compatible with the declared type of the member.
Allowed member types are the primitive types, String, Class, enumerated types, annotation types, and arrays of any of the above types (but not an array of arrays)
Near the end of the chapter, we define an annotation type named UncheckedExceptions whose sole member is an array of classes that extend RuntimeException.
Annotations are most commonly placed on type definitions (such as classes) and their members (such as methods and fields)
A package annotation appears before the package declaration in a file named Instead, it should contain an optional javadoc comment, zero or more annotations, and a package declaration.
When the package-info.java file is compiled, it produces a class file named has no members, and its name, package-info, is not a legal Java identifier, so it cannot be used in Java source code.
It exists simply as a placeholder for package annotations with class or runtime retention.
Note that package annotations appear outside the scope of any package or import declaration.
Annotations on method parameters, catch clause parameters, and local variables simply appear as part of the modifier list for those program elements.
The Java class file format has no provision for storing annotations on local variables or catch clause parameters, so those annotations always have source retention.
Method parameter annotations can be retained in the class file, however, and may have class or runtime retention.
Finally, note that the syntax for enumerated type definitions does not allow any modifiers to be specified for enumerated values.
It does, however, allow annotations on any of the values.
Annotations must include a value for every member that does not have a default value defined by the annotation type.
Annotations may, of course, include values for other members as well.
There is one important detail to understand about how default values are handled.
Default values are stored in the class file of the annotation type and are not compiled into annotations themselves.
If you modify an annotation type so that the default value of one of its members changes, that change affects all annotations of that type that do not specify an explicit value for that member.
Alreadycompiled annotations are affected, even if they are never recompiled after the change to the type.
The Reflection API of java.lang.reflect has been extended in Java 5.0 to support reading of runtime-visible annotations.
Remember that an annotation is only visible at runtime if its annotation type is specified to have runtime retention, that is, if the annotation is both stored in the class file and read by the Java VM when the class file is loaded.) This section briefly covers the new reflective capabilities.
For full details, look up the interface java.lang.reflect.AnnotatedElement in the reference section.
AnnotatedElement represents a program element that can be queried for annotations.
It is implemented by java.lang.Package, java.lang.Class, and indirectly implemented by the Method, Constructor, and Field classes of java.lang.reflect.
Annotations on method parameters can be queried with the getParameterAnnotations( ) method of the Method or Constructor class.
The following code uses the isAnnotationPresent( ) method of AnnotatedElement to determine whether a method is unstable by checking for an @Unstable annotation.
It assumes that the Unstable annotation type, which we’ll define later in the chapter, has runtime retention.
Note that this code uses class literals to specify both the class to be checked and the annotation to check for:
Consider the @Reviews annotation that appeared earlier in the chapter, for example.
If the annotation type was declared with runtime retention, you could query it as follows:
Note that these reflective methods correctly resolve default annotation values for you.
If an annotation does not include a value for a member with a default value, the default value is looked up within the annotation type itself.
An annotation type is an interface, but it is not a normal one.
An annotation type differs from a normal interface in the following ways:
An annotation type is defined with the keyword @interface rather than with interface.
An @interface declaration implicitly extends the interface java.lang.annotation.Annotation and may not have an explicit extends clause of its own.
The methods of an annotation type must be declared with no arguments and may not throw exceptions.
These methods define annotation members: the method name becomes the member name, and the method return type becomes the member type.
The return value of annotation methods may be a primitive type, a String, a Class, an enumerated type, another annotation type, or a single-dimensional array of one of those types.
Any method of an annotation type may be followed by the keyword default and a value compatible with the return type of the method.
This strange new syntax specifies the default value of the annotation member that corresponds to the method.
The syntax for default values is the same as the syntax used to.
Annotation types and their methods may not have type parameters—annotation types and members cannot be made generic.
The only valid use of generics in annotation types is for methods whose return type is Class.
These methods may use a bounded wildcard to specify a constraint on the returned class.
In other ways, annotation types declared with @interface are just like regular interfaces.
They may include constant definitions and static member types such as enumerated type definitions.
Annotation types may also be implemented or extended just as normal interfaces are.
The classes and interfaces that result from doing this are not themselves annotation types, however: annotation types can be created only with an @interface declaration.)
We now define the annotation types used in our examples.
These examples illustrate the syntax of annotation type declarations and demonstrate many of the differences between @interface and interface.
Because we used this type earlier in the chapter in a reflection example, its definition includes a meta-annotation that gives it runtime retention and makes it accessible to the reflection API.
Specifies that the annotated element is unstable and its API is * subject to change.
By naming the member value, we enable a syntactic shortcut for anyone using the annotation:
The Reviews annotation type has a single member, but the type of the member is complex: it is an array of Review annotations.
The Review annotation type has three members, one of which has an enumerated type defined as a member of the Review type itself, and another of which has a default value.
Because the Reviews annotation type is used in a reflection example, we’ve given it runtime retention with a meta-annotation:
An annotation of this type represents a single code review of the * annotated element.
Every review must specify the name of the reviewer * and the grade assigned to the code.
Finally, suppose we wanted to annotate methods to list the unchecked exceptions (but not errors) that they might throw.
Our annotation type would have a single member of array type.
Each element of the array would be the Class of an exception.
In order to enforce the requirement that only unchecked exceptions are used, we use a bounded wildcard on Class:
Java 5.0 defines four standard meta-annotation types that provide information about the use and meaning of other annotation types.
These types and their supporting classes are in the java.lang.annotation package, and you can find complete details in the quickreference section of the book.
The Target meta-annotation type specifies the “targets” for an annotation type.
That is, it specifies which program elements may have annotations of that type.
If an annotation type does not have a Target meta-annotation, it can be used with any of the program elements described earlier.
Some annotation types, however, make sense only when applied to certain program elements.
Override is one example: it is only meaningful when applied to a method.
The Target meta-annotation type has a single member named value.
ElementType is an enumerated type whose enumerated values represent program elements that can be annotated.
It specifies whether an annotation is discarded by the compiler or retained in the class file, and, if it is retained in the class file, whether it is read by the VM when the class file is loaded.
By default, annotations are stored in the class file but not available for runtime reflective access.
The three possible retention values (source, class, and runtime) are described by the enumerated type java.lang.annotation.RetentionPolicy.
The Retention meta-annotation type has a single member named value whose type is RetentionPolicy.
Documented is a meta-annotation type used to specify that annotations of some other type should be considered part of the public API of the annotated program element and should therefore be documented by tools like javadoc.
The @Inherited meta-annotation is a marker annotation that specifies that the annotated type is an inherited one.
That is, if an annotation type @Inherited is used to annotate a class, the annotation applies to subclasses of that class as well.
Note that @Inherited annotation types are inherited only by subclasses of an annotated class.
Classes do not inherit annotations from interfaces they implement, and methods do not inherit annotations from methods they override.
If you use java.lang.reflect to query a class for an annotation of an @Inherited type, the reflection code checks the specified class and each of its ancestors until an annotation of the specified type is found or the top of the class hierarchy is reached.
This chapter switches gears and covers the Java platform—a vast collection of predefined classes available to every Java program, regardless of the underlying host system on which it is running.
The classes of the Java platform are collected into related groups, known as packages.
This chapter begins with an overview of the packages of the Java platform that are documented in this book.
It then moves on to demonstrate, in the form of short examples, the most useful classes in these packages.
Most of the examples are code snippets only, not full programs you can compile and run.
For fully fleshed-out, real-world examples, see Java Examples in a Nutshell (O’Reilly)
That book expands greatly on this chapter and is intended as a companion to this book.
Java Platform Overview Table 5-1 summarizes the key packages of the Java platform that are covered in this book.
Although some of the classes in this bytes or characters.
Table 5-1 does not list all the packages in the Java platform, only the most important of those documented in this book.
Java also defines numerous packages for graphics and graphical user interface programming and for distributed, or enterprise, computing.
The graphics and GUI packages are java.awt and javax.swing and their many subpackages.
The enterprise packages of Java include java.rmi, java.sql, javax.jndi, org.omg.CORBA, org.omg.CosNaming, and all of their subpackages.
These packages, as well as several standard extensions to the Java platform, are documented in Java Enterprise in a Nutshell (O’Reilly)
A weak reference is one that does not prevent the referent object from being garbage-collected.
This package and its subpackages support cryptographic message digests and digital signatures.
Enables the creation of socket types other than the default.
Text Most programs manipulate text in one form or another, and the Java platform defines a number of important classes and interfaces for representing, formatting, and scanning text.
Strings of text are a fundamental and commonly used data type.
In Java, however, strings are not a primitive type, like char, int, and float.
Instead, strings are represented by the java.lang.String class, which defines many useful methods for manipulating strings.
String objects are immutable: once a String object has been created, there is no way to modify the string of text it represents.
Thus, each method that operates on a string typically returns a new String object that holds the modified string.
This code shows some of the basic operations you can perform on strings:
Strip blank space off the beginning and end of a string.
As you know, individual characters are represented in Java by the primitive char type.
The Java platform also defines a Character class, which contains useful class methods for checking the type of a character and for converting the case of a character.
Since String objects are immutable, you cannot manipulate the characters of an instantiated String.
If you need to do this, use a java.lang.StringBuffer or java.lang.StringBuilder instead.
These two classes are identical except that StringBuffer has synchronized methods.
StringBuilder was introduced in Java 5.0 and you should use it in preference to StringBuffer unless it might actually be manipulated by multiple threads.
The following code demonstrates the StringBuffer API but could be easily changed to use StringBuilder:
Replace a range of characters with a string (Java 1.2 and later)
As of Java 1.4, both the String and the StringBuffer classes implement the java.lang.CharSequence interface, which is a standard interface for querying the length of and extracting characters and subsequences from a readable sequence of characters.
This interface is also implemented by the java.nio.CharBuffer interface, which is part of the New I/O API that was introduced in Java 1.4
CharSequence provides a way to perform simple operations on strings of characters regardless of the underlying implementation of those strings.
Appendable is a Java 5.0 interface that represents an object that can have a char or a CharSequence appended to it.
StringBuilder, java.nio.CharBuffer, java.io.PrintStream, and java.io.Writer and all of its character output stream subclasses, including PrintWriter.
Thus, the Appendable interface represents the common appendability of the text buffer classes and the text output stream classes.
As we’ll see below, a Formatter object can send its output to any Appendable object.
The + operator concatenates two String objects or one String and one value of some other type, producing a new String object.
Be aware that each time a string concatenation is performed and the result stored in a variable or passed to a method, a new String object has been created.
In some circumstances, this can be inefficient and can result in poor performance.
It is especially important to be careful when doing string concatenation within a loop.
Inefficient: don't do this // Each iteration creates a new String object and discards an old one.
When you find yourself writing code like this, switch to a StringBuffer or a.
There is no need to be paranoid about string concatenation, however.
Remember that string literals are concatenated by the compiler rather than the Java interpreter.
Also, when a single expression contains multiple string concatenations, these are compiled efficiently using a StringBuilder (or StringBuffer prior to Java 5.0) and result in the creation of only a single new String object.
Since strings are objects rather than primitive values, they cannot, in general, be determine if two distinct strings contain the same text.
In Java 5.0 you can compare the content of a string to any other CharSequence with the contentEquals( ) method.
To compare Comparable<String> interface and is illustrated in the sample code above.
To compare strings without taking the case of the letters into account, use compareToIgnoreCase( )
Note that StringBuffer and StringBuilder do not implement Comparable and do from Object.
This means that it is not possible to compare the text held in two StringBuffer or StringBuilder objects for equality or for order.
One important, but little understood method of the String class is intern( )
When passed a string s, it returns a string t that is guaranteed to have the same content as s.
What’s important, though, is that for any given string content, it always returns a reference to the same String object.
That is, if s and t are two String objects such that s.equals(t), then:
VM, so if you plan to compare a string s against a number of string literals, you.
These are not always the right methods to use, however.
In some languages, the character ordering imposed by the Unicode standard does not match the dictionary ordering used when alphabetizing strings.
Compare two strings; results depend on where the program is run.
In String objects, or for any other type that represents text as a sequence of char values, these supplementary characters are represented as a series of two char values known as a surrogate pair.
Although readers of the English edition of this book are unlikely to ever encounter supplementary characters, you should be aware of them if you are working on programs that might be localized for use in China or another country that uses Han ideographs.
To help you work with supplementary characters, the Character, String, StringBuffer, and StringBuilder classes have been extended with new methods that operate on int codepoints rather than char values.
You can find other, similar methods in the reference section and read about them in the online javadoc documentation.
Get the UTF-16 surrogate pair of chars for the codepoint // Convert the chars to a string.
Print encoding of first character, then encoding of first codepoint.
Here's how to safely loop through a string that may contain // supplementary characters // Get the codepoint at the current position.
A common task when working with text output is to combine values of various types into a single block of human-readable text.
One way to accomplish this relies on the string-conversion power of Java’s string concatenation operator.
Java 5.0 introduces an alternative that is familiar to C programmers: a printf( ) method.
The printf( ) method has been added to the PrintWriter and PrintStream output stream classes in Java 5.0
It is a varargs method that expects one or more arguments.
The remaining arguments to printf( ) are values to be converted to strings and substituted into the format string in place of the format specifiers.
The format specifiers constrain the types of the remaining arguments and specify exactly how they are converted to strings.
The string concatenation shown above can be rewritten as follows in Java 5.0:
And if you request that a number be displayed with a thousands separator, you’ll get locale-specific punctuation there, too (a comma in England and a period in France, for example)
In addition to the basic printf( ) method, PrintWriter and PrintStream also define except that instead of printing the formatted string to a stream, it simply returns it:
Format a string, converting a double value to text using two decimal // places and a thousands separator.
The java.util.Formatter class is the general-purpose formatter class behind the or to a named file.
The following code uses a Formatter object to write a file:
When you concatenate an object to a string, the object is converted to a string by well.
Classes that want more precise control over their formatting can implement.
We’ll see additional examples of formatting with printf( ) when we cover the APIs for working with numbers, dates, and times.
See java.util.Formatter for a complete list of available format specifiers and options.
Simple terminal-based programs can send their output and error messages to that run unattended for long periods need a different solution for output: the.
Programs like this need logging functionality in which output messages are sent to a file for later analysis or through a network socket for remote monitoring.
Java 1.4 provides a logging API in the java.util.logging package.
Typically, the application developer uses a Logger object associated with the class or package of the application to generate log messages at any of seven severity levels (see java.util.logging.Level)
These messages may report errors and warnings or provide informational messages about interesting events in the application’s life cycle.
They can include debugging information or even trace the execution of important methods within the program.
The system administrator or end user of the application is responsible for setting up a logging configuration file that specifies where log messages are directed (the console, a file, a network socket, or a combination of these), how they are formatted (as plain text or XML documents), and at what severity threshold they are logged (log messages with a severity below the specified threshold are discarded with very little overhead and should not significantly impact the performance of the application)
In normal operation, most log messages will be discarded efficiently and automatically.
During program development, or when diagnosing a problem in a deployed application, however, the log messages can prove very valuable.
For most applications, using the Logging API is quite simple.
Obtain a named Logger object whenever necessary by calling the static Logger.getLogger( ) method, passing the class or package name of the application as the logger name.
Then, use one of the many Logger instance methods to generate log messages.
The easiest methods to use have names that correspond to severity levels, such as.
Get a Logger object named after the current package ServerSocket ss;                       // Do some stuff catch(Exception e) {                   // Log exceptions return;
In Java 1.4 and later, you can perform textual pattern matching with regular expressions.
Regular expression support is provided by the Pattern and Matcher.
Regular expressions use a fairly complex grammar to describe patterns of characters.
The Java implementation uses the same regex syntax as the Perl 5 programming language.
See the java.util.regex.Pattern class in the reference section for a summary of this syntax or consult a good Perl programming book for further details.
For a complete tutorial on Perl-style regular expressions, see Mastering Regular Expressions (O’Reilly)
The simplest String method that accepts a regular expression argument is.
This string is a regular expression that describes the pattern of a typical // sentence.
In Perl-style regular expression syntax, it specifies // a string that begins with a capital letter and ends with a period, // a question mark, or an exclamation point.
The matches( ) method returns true only if the entire string is a match for the specified pattern.
Perl programmers should note that this differs from Perl’s behavior, in which a match means only that some portion of the string matches the pattern.
To determine if a string or any substring matches a pattern, simply alter the regular expression to allow arbitrary characters before and after the desired pattern.
In the following code, the regular expression characters .* match any number of arbitrary characters:
If you are already familiar with Perl’s regular expression syntax, you know that it relies on the liberal use of backslashes to escape certain characters.
In Perl, regular expressions are language primitives and their syntax is part of the language itself.
In Java, however, regular expressions are described using strings and are typically embedded in programs using string literals.
The syntax for Java string literals also uses the backslash as an escape character, so to include a single backslash in the regular expression, you must use two backslashes.
Thus, in Java programming, you will often see double backslashes in regular expressions.
In addition to matching, regular expressions can be used for search-and-replace operations.
The replaceFirst( ) and replaceAll( ) methods search a string for the first substring or all substrings that match a given pattern and replace the string or strings with the specified replacement text, returning a new string that contains the replacements.
For example, you could use this code to ensure that the word “Java” is correctly capitalized in a string s:
If you are not familiar with parenthesized subexpressions within a regular expression, see java.util.regex.
Pattern in the reference section.) For example, to search for words such as JavaBean, JavaScript, JavaOS, and JavaVM (but not Java or Javanese) and to replace the Java prefix with the letter J without altering the suffix, you could use code such as:
To obtain an array of words in a string separated by any number of spaces, tabs, or newlines, do this:
An optional second argument specifies the maximum number of entries in the returned array.
If you want to use a regular expression for multiple matches, you should explicitly use the Pattern and Matcher classes of the java.util.regex package.
First, create a Pattern object to (Another reason to use the Pattern class explicitly instead of the String convenience methods is that Pattern.compile( ) allows you to specify flags such as Pattern.CASE_INSENSITIVE that globally alter the way the pattern matching is pass it an invalid regular expression string.
This exception is also thrown by the to be matched against:
Once you have a Matcher object, you can compare the string to the pattern in various ways.
One of the more sophisticated ways is to find all substrings that match the pattern:
Loop to find all matches of the string and print details of each match.
The Matcher class has been enhanced in several ways in Java 5.0
The most important of these is the ability to save the results of the most recent match in a MatchResult object.
The previous algorithm that finds all matches in a string could be rewritten in Java 5.0 as follows:
Scanner takes full advantage of Java regular expressions and can take its input text from a string, file, stream, or any object that implements the java.lang.Readable interface.
Readable is also new in Java 5.0 and is the opposite of the Appendable interface.
A Scanner can break its input text into tokens separated by whitespace or any desired delimiter character or regular expression.
It implements the Iterator<String> interface, which allows for simple looping through the returned tokens.
Scanner also defines a variety of convenience methods for parsing tokens as boolean, integer, or floating-point values, with locale-sensitive number parsing.
It has skip( ) methods for skipping input text that matches a specified pattern and also has methods for searching ahead in the input text for text that matches a specified pattern.
Here’s how you could use a Scanner to break a String into space-separated words:
Here’s how you might use a Scanner to break a file into lines:
Use a regex to specify line terminators as the token delimiter.
A number of other Java classes operate on strings and characters.
One notable class is java.util.StringTokenizer, which you can use to break a string of text into its component words:
You can even use this class to tokenize words that are delimited by characters other than spaces:
It has a more complicated API and has more powerful features than StringTokenizer.
Numbers and Math Java provides the byte, short, int, long, float, and double primitive types for representing numbers.
The java.lang package includes the corresponding Byte, Short, Integer, Long, Float, and Double classes, each of which is a subclass of Number.
These classes can be useful as object wrappers around their primitive types, and they also define some useful constants:
The Math class defines a number of methods that provide trigonometric, logarithmic, exponential, and rounding operations, among others.
The logarithm and exponentiation functions are base e, not base 10
In Java 5.0, several new functions have been added to the Math class, including the following:
The Math class also defines a rudimentary method for generating pseudo-random numbers, but the java.util.Random class is more flexible.
If you need very random pseudo-random numbers, you can use the java.security.SecureRandom class:
Create a new Random object, seeding with the current time.
These classes allow you to work with arbitrary-size and arbitrary-precision integers and floating-point values.
In Java 1.4, BigInteger has a method to randomly generate large prime numbers, which is useful in many cryptographic applications:
The BigDecimal class has been overhauled in Java 5.0 and is much more usable in this release.
In addition to its utility for representing very large or very precise floating point numbers, it is also useful for financial calculations because it relies on a decimal representation of fractions rather than a binary representation.
BigDecimal and its associated MathContext and RoundingMode types provide a solution.
Compute monthly interest payments on a loan int years,  // term in years double apr) // annual interest % // Convert the loan amount to a BigDecimal.
Convert term of loan in years to number of monthly payments.
A Java program that operates on numbers must get its input values from somewhere.
Often, such a program reads a textual representation of a number and must convert it to a numeric representation.
The %d format specifier is for formatting integers in decimal format:
You’ll notice that the numbers above are all formatted with six digits following the decimal point.
This default can be altered by specifying a precision in the format string:
Other flags can be applied to floating-point conversions as well.
The following code formats a column of numbers right-justified within a field 10 characters wide.
Each number has two digits following the decimal place and includes thousands separators when necessary.
Negative values are formatted in parentheses, a common formatting convention in accounting.
See java.util.Formatter in the reference section for complete details on supported format specifiers and formatting options.
Prior to Java 5.0, numbers can be formatted using the java.text.NumberFormat class:
Use NumberFormat to format and parse numbers for the current locale.
Dates and Times Java allows dates and times to be represented and manipulated in three forms: as long values or as java.util.Date or java.util.Calendar objects.
The values of this type represent time granularities or units: seconds, milliseconds, microseconds, and nanoseconds.
They have useful convenience methods but do not themselves represent a time value.
This special date and time is known as the epoch and is measured in Greenwich Mean Time (GMT) or Universal Time (UTC)
Using a Date object instead of a long allows simple conversion to a nonlocalized string with the toString method.
Date objects can be compared for equality with the equals( ) method and they can be compared for.
The no-argument version of the Date( ) constructor creates a Date that represents the current time.
You can also pass a long number of milliseconds to create a Date that represents some other time.
Date is a mutable class, so you can also pass a number of milliseconds to setTime( )
Date has a number of methods for querying and setting the year, month, day, hour, minute, and second.
All of these methods have been deprecated, however, in favor of the Calendar class, described next.
The java.util.Calendar class is a properly localized version of Date.
It is simply a wrapper around a long number of milliseconds but can represent that instant in time according to the calendar of the current locale (usually a Gregorian calendar) and the time zone of the current locale.
Furthermore, it has methods for querying, setting, and doing arithmetic on the various fields of the date and time.
The code below shows common uses of the Calendar class.
Note that the set( ), the date or time is being set, queried, or added to.
Fields such as year, day of month, day of week, hour, minute, and second are defined by integer constants in the class.
Other integer constants define values for the months and weekdays of the Gregorian calendar.
The month constant UNDECIMBER represents a 13th month used in lunar calendars.
Get a Date object that represents three months from now.
The toString( ) method should be used only to produce a machine-readable timestamp, not a human-readable string.
Like numbers, dates and times can be converted to strings using the String.format( ) method and the related java.util.Formatter class of Java 5.0
Format strings for displaying dates and times are all two-character sequences that begin with the letter t.
The second letter of each sequence specifies the field or set of fields of the date or time to display.
Prior to Java 5.0 and its Formatter class, you can format dates and times using the java.text.DateFormat class, which automatically handles locale-specific conventions for date and time formatting.
DateFormat even works correctly in locales that use a calendar other than the common era (Gregorian) calendar in use throughout much of the world:
Display today's date using a default format for the current locale.
Display the current time using a short time format for the current locale.
Display date and time using a long format for both.
Arrays The java.lang.System class defines an arraycopy( ) method that is useful for copying specified elements in one array to a specified position in a second array.
The second array must be the same type as the first, and it can even be the same array:
Move some of the text to later elements, making room for insertions.
In Java 1.2 and later, the java.util.Arrays class defines useful array-manipulation methods, including methods for sorting and searching arrays:
Arrays can be treated and manipulated as objects in Java.
Given an arbitrary object o, you can use code such as the following to find out if the object is an array and, if so, what type of array it is:
Collections The Java Collections Framework is a set of important utility classes and interfaces in the java.util package for working with collections of objects.
A Collection is a group of objects while a Map is a set of mappings, or associations, between objects.
A Set is a type of Collection with no duplicates, and a List is a Collection in which the elements are ordered.
SortedSet and SortedMap are specialized sets and maps that maintain their elements in a sorted order.
Collection, Set, List, Map, SortedSet, and SortedMap are all interfaces, but the java.util package also defines various concrete implementations, such as lists based on arrays and linked lists, and maps and sets based on hashtables or binary trees.
Other important interfaces are Iterator and ListIterator, which allow you to loop through the objects in a collection.
The Collections Framework was added in Java 1.2, but prior to that release you can use Vector and Hashtable, which are approximately the same as ArrayList and HashMap.
In Java 1.4, the Collections API added the RandomAccess marker interface, which is implemented by List implementations that support efficient random access (i.e., it is implemented by ArrayList and Vector but not by LinkedList)
Java 1.4 also introduced LinkedHashMap and LinkedHashSet, which are hashtable-based maps and sets that preserve the insertion order of elements.
Most of the interesting Queue implementations are BlockingQueue implementations in java.util.concurrent.
Collection<E> is a parameterized interface that represents a generic group of objects of type E.
The group may or may not allow duplicate elements and may or may not impose an ordering on the elements.
Methods are defined for adding and removing objects from the group, testing an object for membership in the group, and iterating through all elements in the group.
Additional methods return the elements of the group as an array and return the size of the collection.
The Java Collections Framework does not provide any implementations of Collection, but this interface is still very important because it defines the features common to all Set, List, and Queue implementations.
The following code illustrates the operations you can perform on Collection objects:
These methods return true if the collection // changes, which is useful with Sets that don't allow duplicates.
Some implementations (such as lists) guarantee an order of iteration // Others make no guarantees.
If the iterator guarantees // an order, this array has the same order.
The array is a copy, not a // reference to an internal data structure.
If we want the elements in a String[], we must pass one in.
Or we can pass an empty String[] just to specify the type and.
Remember that you can use any of the methods shown above with any Set, List, or Queue.
These subinterfaces may impose membership restrictions or ordering constraints on the elements of the collection but still provide the same basic the collection are optional, and read-only implementations may throw UnsupportedOperationException.
Collection, Map, and their subinterfaces do not extend the Cloneable or Serializable interfaces.
All of the collection and map implementation classes provided in the Java Collections Framework, however, do implement these interfaces.
Some collection implementations place restrictions on the elements that they can contain.
An implementation might prohibit null as an element, for example.
And EnumSet restricts membership to the values of a specified enumerated type.
Attempting to add a prohibited element to a collection always throws an unchecked exception such as NullPointerException or ClassCastException.
Checking whether a collection contains a prohibited element may also throw such an exception, or it may simply return false.
A set is a collection of objects that does not allow duplicates: it may not contain two references to the same object, two references to null, or references to two objects a and b such that a.equals(b)
Most general-purpose Set implementations impose no ordering on the elements of the set, but ordered sets are not prohibited (see SortedSet and LinkedHashSet)
Sets are further distinguished from ordered collections like lists by the general expectation that they have an efficient contains( ) method that runs in constant or logarithmic time.
Set defines no additional methods beyond those defined by Collection but places Set are required to enforce the no-duplicates rules: they may not add an element addAll( ) methods defined by the Collection interface return true if the call resulted in a change to the collection and false if it did not.
This return value is relevant for Set objects because the no-duplicates restriction means that adding an element does not always result in a change to the set.
Table 5-2 lists the implementations of the Set interface and summarizes their internal representation, ordering characteristics, member restrictions, and the.
You can read more about each class in the reference section.
Note that CopyOnWriteArraySet is in the java.util.concurrent package; all the other implementations are part of java.util.
This legacy class is useful as a compact and efficient list of boolean values but is not part of the Java Collections Framework.
The TreeSet implementation uses a red-black tree data structure to maintain a set that is iterated in ascending order according to the natural ordering of Comparable objects or according to an ordering specified by a Comparator object.
TreeSet actually implements the SortedSet interface, which is a subinterface of Set.
SortedSet offers several interesting methods that take advantage of its sorted nature.
Each element of a list has a position in the list, and the List interface defines methods to query or set the element at a particular position, or index.
In this respect a List is like an array whose size changes as needed to accommodate the number of elements it contains.
The List interface does not define methods that operate on a range of list indexes.
Instead it defines a single subList method that returns a List object that represents just the specified range of the original list.
The sublist is backed by the parent list, and any changes made to the sublist are immediately visible in the parent list.
Examples of subList( ) and the other basic List manipulation methods are below.
Sublists: backed by the original list // Sublists can restrict operations to a subrange of backing list // Independent copies of a sublist don't affect the parent list.
Get a view of the list that includes only the elements we // haven't searched yet.
A general expectation of List implementations is that they can be efficiently iterated, typically in time proportional to the size of the list.
Lists do not all provide efficient random-access to the elements at any index, however.
Sequential-access lists, such as the LinkedList class, provide efficient insertion and deletion operations at the expense of random access performance.
In Java 1.4 and later, implementations that provide efficient random access implement the RandomAccess marker interface, and you can test for this interface with instanceof if you need to ensure efficient list manipulations:
If not, use a copy constructor // to make a random-access copy of the list before manipulating it.
List implements Iterable, and lists can be iterated with a for/in loop just as any other collection can.
To iterate just a portion of a list, you can use the subList( ) method to create a sublist view:
Iterate just all elements of the list but the first.
In addition to normal iteration, lists also provide enhanced bidirectional iteration backward through a List, for example, start with a ListIterator with its cursor positioned after the end of the list:
Table 5-3 summarizes the five general-purpose List implementations in the Java platform.
Vector and Stack are legacy implementations left over from Java 1.0
CopyOnWriteArrayList is a new in Java 5.0 and is part of the java.util.concurrent.
A map is a set of key objects and a mapping from each member of that set to a value object.
The Map interface defines an API for defining and querying mappings.
Map is part of the Java Collections Framework, but it does not extend the Collection interface, so a Map is a little-c collection, not a big-C Collection.
Type variable K represents the type of keys held by the map, and type variable V represents the type of the values that the keys are mapped to.
A mapping from String keys to Integer values, for example, can be represented with a Map<String,Integer>
The general performance expectation for Map implementations is that these three basic methods are quite efficient: they should usually run in constant time and certainly no worse than in logarithmic time.
Map.Entry is a nested interface defined within Map: it simply represents a single key/value pair.)
Map and also demonstrates some common uses of the collection views of a Map:
Create maps to work with // Immutable Map containing a single key-value pair // Note this rarely-used syntax to explicitly specify the parameter.
Map keys, values, and entries can be viewed as collections.
Most maps have an undefined iteration order (but see SortedMap)
The Map.Entry<K,V> type represents a single key/value pair in a map // Print out mappings // And increment the value of each Entry.
Deletions may also be made via the collection views of a map.
Additions to the map may not be made this way, however.
The Map interface includes a variety of general-purpose and special-purpose implementations, which are summarized in Table 5-4
All classes in Table 5-4 are in the java.util package except ConcurrentHashMap, which is part of java.util.concurrent.
The ConcurrentHashMap class of the java.util.concurrent package implements the ConcurrentMap interface of the same package.
ConcurrentMap extends Map and defines some additional atomic operations that are important in multithreaded key/value pair to the map only if the key is not already mapped.
TreeMap implements the SortedMap interface, which extends Map to add methods that take advantage of the sorted nature of the map.
EnumMap array 5.0 no yes Keys are instances of an enum.
TreeMap red-black tree 1.2 no yes Sorts by key value.
WeakHashMap hashtable 1.2 yes yes Doesn’t prevent garbage collection of keys.
Properties hashtable 1.0 no no Extends Hashtable with String methods.
A queue is an ordered collection of elements with methods for extracting elements, in order, from the head of the queue.
Queue implementations are commonly based on insertion order as in first-in, first-out (FIFO) queues or last in, first-out queues (LIFO queues are also known as stacks)
Other orderings are possible, however: a priority queue orders its elements according to an external Comparator object, or according to the natural ordering of Comparable elements.
Unlike List, the Queue interface does not define methods for manipulating queue elements at arbitrary positions.
Only the element at the head of the queue is available for examination.
It is common for Queue implementations to have a fixed capacity: when a queue is full, it is not possible to add more elements.
Similarly, when a queue is empty, it is not possible to remove any more elements.
Because full and empty conditions are a normal part of many queue-based algorithms, the Queue interface defines methods that signal these conditions with return values return null to indicate that the queue is empty.
For this reason, most Queue implementations do not allow null elements.
The put( ) method adds an element to the queue, waiting, if necessary, until there is space in the queue for the element.
And the take( ) method removes an element from the head of the queue, waiting, if necessary, until there is an element to remove.
Blocking queues are an important part of many multithreaded algorithms, and the BlockingQueue interface (which extends Queue) is defined as part of the java.util.concurrent package.
Queue, BlockingQueue, and their implementations are new in Java 5.0
Queues are not nearly as commonly used as sets, lists, and maps, except perhaps in certain multithreaded programming styles.
In lieu of example code here, we’ll try to clarify the confusing array of queue insertion and removal operations:
This Collection method simply adds an element in the normal way.
In bounded queues, this method may throw an exception if the queue is full.
This Queue method is like add( ) but returns false instead of throwing an exception if the element cannot be added because a bounded queue is full.
BlockingQueue defines a timeout version of offer( ) that waits up to a specified amount of time for space to become available in a full queue.
Like the basic version of the method, it returns true if the element was inserted and false otherwise.
In addition to the Collection.remove( ) method, which removes a specified element from the queue, the Queue interface defines a no-argument version of remove( ) that removes and returns the element at the head of the queue.
If the queue is empty, this method throws a NoSuchElementException.
This BlockingQueue method removes and returns the element at the head of the queue.
If the queue is empty, it blocks until some other thread adds an element to the queue.
It does not block to wait for elements to be added to the queue.
A variant of the method accepts a maximum number of elements to drain.
Querying the element at the head, without removing it from the queue.
The LinkedList class has been retrofitted, in Java 5.0, to implement Queue.
It provides unbounded FIFO (first in, first out) ordering, and insertion and removal operations require constant time.
LinkedList allows null elements, although their use is discouraged when the list is being used as a queue.
The only other Queue implementation in the java.util package is PriorityQueue, which orders its elements according to a Comparator or orders Comparable elements according to the order defined by their compareTo( ) methods.
The head of a PriorityQueue is always the smallest element according to the defined ordering.
The java.util.concurrent package contains a number of BlockingQueue implementations; they are described later in the chapter.
This package also contains ConcurrentLinkedQueue, an efficient threadsafe Queue implementation that does not suffer the overhead of synchronized methods.
The java.util.Collections class is home to quite a few static utility methods designed for use with collections.
One important group of these methods are the collection wrapper methods: they return a special-purpose collection wrapped around a collection you specify.
The purpose of the wrapper collection is to wrap additional functionality around a collection that does not provide it itself.
Wrappers exist to provide thread-safety, write-protection and runtime type checking.
Wrapper collections are always backed by the original collection, which means that the methods of the wrapper simply dispatch to the equivalent methods of the wrapped collection.
This means that changes made to the collection through the wrapper are visible through the wrapped collection and vice versa.
The first set of wrapper methods provides threadsafe wrappers around collections.
Except for the legacy classes Vector and Hashtable, the collection implementations in java.util do not have synchronized methods and are not protected against concurrent access by multiple threads.
If you need threadsafe collections, create them with code like this:
A second set of wrapper methods provides collection objects through which the underlying collection cannot be modified.
They return a read-only view of a collection: any attempt to change the content of the collection results in an UnsupportedOperationException.
These wrappers are useful when you must pass a collection to a method that must not be allowed to modify or mutate the content of the collection in any way:
We can modify the list through primes // But we can't modify through the read-only wrapper.
The final set of wrapper methods provides runtime type checking of any values added to the collection.
They were added in Java 5.0 to complement the compiletime type safety provided by generics.
These wrappers are helpful when working with legacy code that has not been converted to use generics.
If you have a SortedSet<String>, for example, and must pass it to a method that expects a Set, you can use a checked wrapper to ensure that that method cannot add anything to the set that is not a String:
In addition to its wrapper methods, the java.util.Collections class also defines utility methods for creating immutable collection instances that contain a single.
These methods are useful, for example, when you need to pass a single object to a method that expects a collection.
The Collections class also includes methods that return empty collections.
If you are writing a method that returns a collection, it is usually best to handle the novalues-to-return case by returning an empty collection instead of a special-case value like null:
It is possible to convert from one to the other:
If you want the return value to be something other than Object[], pass // in an array of the appropriate type.
If the array is not big enough, // another one of the same type will be allocated.
If the array is too big, // the collection elements copied to it will be null-terminated.
Just as the java.util.Arrays class defined methods to operate on arrays, the java.
Most notable are methods to sort and search the elements of collections:
The Java Collections Framework provides abstract classes that make it simple to implement common types of collections.
The following code extends AbstractList to define a QuadraticSequence, a list implementation that computes list values on demand rather than actually storing them in memory anywhere.
Threads and Concurrency The Java platform has supported multithreaded or concurrent programming with the Thread class and Runnable interface since Java 1.0
Java 5.0 bolsters that support with a comprehensive set of new utilities for concurrent programming.
Java makes it easy to define and work with multiple threads of execution within a program.
One is to subclass Thread, override the run( ) method and then instantiate your Thread subclass.
A Thread class for sorting a List in the background */ List l;
Create a BackgroundSorter thread // the original thread continues with whatever statement comes next.
In Java 5.0, these states are represented by the Thread.State enumerated type, and the state of a thread can be queried with the getState( ) method.
A listing of the Thread.State constants provides a good overview of the lifecycle of a thread:
We’ll see more about synchronized methods and blocks later in this section.
Its run( ) method has exited normally or by throwing an exception.
A thread at a given priority level does not typically run unless no higher-priority threads are waiting to run.
Here is some code you can use when working with thread priorities:
Set a thread to lower priority than the current thread.
Threads that don't pause for I/O should explicitly yield the CPU // to give other threads with the same priority a chance to run.
A thread terminates normally when it reaches the end of its run( ) method or when it executes a return statement in that method.
A thread can also terminate by throwing an exception, however.
When a thread exits in this way, the default behavior is to print the name of the thread, the type of the exception, the exception message, and a stack trace.
In Java 5.0, you can install a custom handler for uncaught exceptions in a thread.
Often, threads are used to perform some kind of repetitive task at a fixed interval.
This is particularly true when doing graphical programming that involves animation or similar effects.
The key to doing this is making a thread sleep, or stop running, for a specified amount of time.
This is done with the static Thread.sleep( ) method, or, in Java 5.0, with utility methods of enumerated constants of the TimeUnit class:
This field is volatile because two different threads may access it.
This method demonstrates how to use the Clock class catch(InterruptedException ignore) {}  // Ignore interrupts.
The example is coded so that it can also be stopped by.
Java provides a number of ways to run tasks asynchronously or to schedule them for future execution without having to explicitly create Thread objects.
Added in Java 1.3, the java.util.Timer and java.util.TimerTask classes make it easy to run repetitive tasks.
Here is some code that behaves much like the Clock class shown earlier:
Define the time-display task // Create a timer object to run the task (and possibly others) // Now schedule that task to be run every 1,000 milliseconds, starting now.
In Java 5.0, the java.util.concurrent package includes the Executor interface.
An Executor is an object that can execute a Runnable object.
A user of an Executor often does not need to be aware of just how the Executor accomplishes this: it just needs to know that the Runnable will, at some point, run.
Executor implementations can be created to use a number of different threading strategies, as the following code makes clear.
Note that this example also demonstrates the use of a BlockingQueue.)
Queue up the Runnables and execute them in order using a single thread * created for that purpose.
Don't execute the Runnable here; just put it on the queue.
Our queue is effectively unbounded, so this should never block.
This is the body of the thread that actually executes the Runnables for(;;) {                   // Loop forever // If interrupted, stop executing queued Runnables.
These sample implementations help demonstrate how an Executor works and how it separates the notion of executing a task from the scheduling policy and threading details of the implementation.
It is rarely necessary to actually implement your own Executor, however, since java.util.concurrent provides the flexible and powerful ThreadPoolExecutor class.
This class is typically used via one of the static factory methods in the Executors class:
In addition to these convenient factory methods, you can also explicitly create a ThreadPoolExecutor if you want to specify a minimum and maximum size for the thread pool or want to specify the queue type (bounded, unbounded, prioritysorted, or synchronized, for example) to use for tasks that cannot immediately be run by a thread.
If you’ve looked at the signature for ThreadPoolExecutor or for the Executors factory methods cited above, you’ll see that it is an ExecutorService.
The ExecutorService interface extends Executor and adds the ability to execute Callable objects.
A time-consuming chunk of code that computes a large prime number, for example, could be wrapped in a Callable<BigInteger>:
You can invoke the call( ) method of any Callable object directly, of course, but Because ExecutorService implementations typically run tasks asynchronously, the code snippet:
But most of the time, you simply call get( ) to get the result complete.
Here is code you might use with the Future objects shown above:
If this happens, the Future call( ) method terminated abnormally with an exception.
ScheduledExecutorService is an extension of ExecutorService that adds Timer-like scheduling capabilities.
It allows you to schedule a Runnable or Callable to be executed once after a specified time delay or to schedule a Runnable for repeated execution.
In each case, the result of scheduling a task for future execution is a ScheduledFuture object.
This is simply a Future that also implements the Delay interface and provides a getDelay( ) method that can be used to query the remaining time before execution of the task.
The easiest way to obtain a ScheduledExecutorService is with factory methods of the Executors class.
The following code uses a ScheduledExecutorService to repeatedly perform an action and also to cancel the repeated action after a fixed interval.
Print random ASCII characters at a rate of cps characters per second * for a total of totalSeconds seconds.
When using multiple threads, you must be very careful if you allow more than one thread to access the same data structure.
Consider what would happen if one thread was trying to loop through the elements of a List while another thread was sorting those elements.
Preventing this kind of unwanted concurrency is one of the central problems of multithreaded computing.
The basic technique for preventing two threads from accessing the same object at the same time is to require a thread to obtain a lock on the object before the thread can modify it.
While any one thread holds the lock, another thread that requests the lock has to wait until the first thread is done and releases the lock.
Every Java object has the fundamental ability to provide such a locking capability.
The easiest way to keep objects threadsafe is to declare all sensitive methods synchronized.
A thread must obtain a lock on an object before it can execute any of its synchronized methods, which means that no other thread can execute any other synchronized method at the same time.
If a static method is declared synchronized, the thread must obtain a lock on the class, and this works in the same manner.) To do finer-grained locking, you can specify synchronized blocks of code that hold a lock on a specified object for a short time:
This method swaps two array elements in a synchronized block.
When working with multiple threads, you can // obtain synchronized wrapper objects.
Note that when you use the synchronized modifier or statement, the lock you acquire is block-scoped, and is automatically released when the thread exits the method or block.
The java.util.concurrent.locks package in Java 5.0 provides an alternative: a Lock object that you explicitly lock and unlock.
Lock objects are not automatically block-scoped and you must be careful to use try/finally constructs to ensure that locks are always released.
On the other hand, Lock enables algorithms that are simply not possible with block-scoped locks, such as the following “hand-over-hand” linked list traversal:
A partial implementation of a linked list of values of type E.
Append a node to the end of the list, traversing the list using * hand-over-hand locking.
This method is threadsafe: multiple threads * may traverse different portions of the list at the same time.
Loop 'till we find the last node in the list.
Lock the next node and then // unlock the current node.
We use a try/finally construct so // that the current node is unlocked even if the lock on the // next node fails with an exception.
At this point, node is the final node in the list, and we have // a lock on it.
When you are using locking to prevent threads from accessing the same data at the same time, you must be careful to avoid deadlock, which occurs when two threads end up waiting for each other to release a lock they need.
Since neither can proceed, neither one can release the lock it holds, and they both stop running.
Whether or not a deadlock actually occurs may vary from system to system and from execution to execution.
When two threads try to lock two objects, deadlock can occur unless // they always request the locks in the same order.
It is common in multithreaded programming to require one thread to wait for another thread to take some action.
Sometimes a thread needs to stop running and wait until some kind of event and notify( ) methods.
These aren’t methods of the Thread class, however; they are methods of Object.
Just as every Java object has a lock associated with it, every method of an object, any locks the thread holds are temporarily released, and the thread is added to the list of waiting threads for that object and stops running.
When another thread calls the notifyAll( ) method of the same object, the object wakes up the waiting threads and allows them to continue running:
Note that such a class is not necessary in Java 5.0 because java.util.concurrent defines the BlockingQueue interface and general-purpose implementations such as ArrayBlockingQueue.
The primary benefit is that it is possible to have more than one Condition for each Lock, something that is not possible with Object-based locking and waiting.
Sometimes one thread needs to stop and wait for another thread to complete.
List list;  // A long list of objects to be sorted; initialized elsewhere.
Define a thread to sort the list: lower its priority, so it runs only // when the current thread is waiting for I/O and then start it running.
Meanwhile, in this original thread, read data from a file.
Before we can proceed, we need the list to be fully sorted, so // we must wait for the sorter thread to exit, if it hasn't already.
Semaphore The Semaphore class models semaphores, a traditional concurrent programming construct.
Conceptually, a semaphore represents one or more “permits.” thread until another thread releases a permit.
CountDownLatch A latch is conceptually any variable or concurrency construct that has two possible states and transitions from its initial state to its final state only once.
Once the transition occurs, it remains in that final state forever.
CountDownLatch is a concurrency utility that can exist in two states, closed and open.
In its initial closed state, any threads that call the await( ) method block and cannot proceed until it transitions to its latched open state.
Once this transition occurs, all waiting threads proceed, and any threads that call.
Exchanger An Exchanger is a utility that allows two threads to rendezvous and exchange values.
The first thread to call the exchange( ) method blocks until a second thread calls the same method.
When this happens, the argument passed to Exchanger is a generic type and uses its type parameter to specify the type of values to be exchanged.
CyclicBarrier A CyclicBarrier is a utility that enables a group of N threads to wait for each other to reach a synchronization point.
The number of threads is specified when the CyclicBarrier is first created.
Threads call the await( ) method to block until the last thread calls await( ), at which point all threads resume again.
Unlike a CountDownLatch, a CyclicBarrier resets its count and is ready for immediate reuse.
CyclicBarrier is useful in parallel algorithms in which a computation is decomposed into parts, and each part is handled by a separate thread.
In such algorithms, the threads must typically rendezvous so that their partial solutions can be merged into a complete solution.
To facilitate this, the CyclicBarrier constructor allows you to specify a Runnable object to be executed by the last thread that calls await( ) before any of the other threads are woken up and allowed to resume.
This Runnable can provide the coordination required to assemble a solution from the threads’ computations or to assign a new computation to each of the threads.
The outcome of an interrupt depends on how you handle the InterruptedException.
The response that is usually preferred is for an interrupted thread to stop running.
On the other hand, if you simply catch and ignore the InterruptedException, an interrupt simply stops a thread from blocking.
A thread can test its own interrupt status by calling the static interrupt status of another thread with the instance method isInterrupted( ), which queries the status but does not clear it.
One of the most common times that threads block is while doing input/output; a thread often has to pause and wait for data to become available from the filesystem or from the network.
The java.io, java.net, and java.nio APIs for performing I/O operations are discussed later in this chapter.) Unfortunately, the java.io package.
This is one of the shortcomings of java.io that is cured by the New I/O API in java.nio.
If a thread is interrupted while blocked in an I/O operation on any channel that implements java.nio.channels.InterruptibleChannel, the channel is closed, the thread’s interrupt status is set, and the thread wakes up by throwing a java.nio.channels.ClosedByInterruptException.
Similarly, if a thread is interrupted while it is blocked in the select( ) method of a java.nio.channels.Selector (or if it calls select( ) while its interrupt status is set), select( ) will stop blocking (or will never start) and will return immediately.
No exception is thrown in this case; the interrupted thread simply wakes up, and.
The use of blocking queues is a common pattern in multithreaded programming: one thread produces objects and places them on a queue for consumption by another thread which removes them from the queue.
ArrayBlockingQueue This implementation is based on an array, and, like all arrays, has a fixed capacity established when it is created.
At the cost of reduced throughput, take( ) an element are served in the order in which they arrived.
LinkedBlockingQueue This implementation is based on a linked-list data structure.
It may have a maximum size specified, but, by default, it is essentially unbounded.
PriorityBlockingQueue This unbounded queue does not implement FIFO (first-in, first-out) ordering.
Instead, it orders its elements based on a specified Comparator object, or based on their natural ordering if they are Comparable objects and no Comparator is the Comparator or Comparable ordering.
DelayQueue A DelayQueue is like a PriorityBlockingQueue for elements that implement the Delayed interface.
Delayed is Comparable and orders elements by how long they are delayed.
But DelayQueue is more than just an unbounded queue that sorts its elements.
It also restricts take( ) and related methods so that elements cannot be removed from the queue until their delay has elapsed.
SynchronousQueue This class implements the degenerate case of a BlockingQueue with a capacity.
The java.util.concurrent.atomic package contains utility classes that permit atomic operations on fields without locking.
An atomic operation is one that is indivisible: no other thread can observe an atomic variable in the middle of an methods that have the properties of volatile fields but also define compound operations such as compare-and-set and get-and-increment that behave atomically.
The code below demonstrates the use of AtomicInteger and contrasts it with the use of a traditional synchronized method:
Files and Directories The java.io.File class represents a file or a directory and defines a number of none of these methods allow you to read the contents of a file; that is the job of java.io.FileInputStream, which is just one of the many types of I/O streams used in Java and discussed in the next section.
Get the name of the user's home directory and represent it with a File // Create a File object to represent a file in that directory.
Find out how big a file is and when it was last modified.
If the file exists, is not a directory, and is readable, // move it into a newly created directory.
The File class gained some important additional functionality as of Java 1.2:
List all filesystem root directories; on Windows, this gives us // File objects for all drive letters (Java 1.2 and later)
Atomically, create a lock file, then delete it (Java 1.2 and later) // We successfully created the file.
Now run the application secure in the knowledge that no one else // is running it at the same time ...
We didn't create the file; someone else has a lock.
Create a temporary file to use during processing (Java 1.2 and later) // Do something with the temp file ...
The java.io package also defines a RandomAccessFile class that allows you to read binary data from arbitrary locations in a file.
Input/Output with java.io The java.io package defines a large number of classes for reading and writing streaming, or sequential, data.
The InputStream and OutputStream classes are for reading and writing streams of bytes while the Reader and Writer classes are for reading and writing streams of characters.
Streams can be nested, meaning you might read characters from a FilterReader object that reads and processes characters from an underlying Reader stream.
This underlying Reader stream might read bytes from an InputStream and convert them to characters.
You can perform a number of common operations with streams.
One is to read lines of input the user types at the console:
Reading lines of text from a file is a similar operation.
The following code reads an entire text file and quits when it reaches the end:
You can print text to any output stream using similar techniques.
The following code shows how to output text to a file:
The following lines of code treat a file as a stream of bytes and read the bytes into a large array:
Various other packages of the Java platform define specialized stream classes that operate on streaming data in some useful way.
The following code shows how to use stream classes from java.util.zip to compute a checksum of data and then compress the data while writing it to a file:
File f;                         // File to write to; initialized elsewhere byte[] data;                    // Data to write; initialized elsewhere.
Create a stream that writes bytes to the file f.
Create a stream that compresses bytes and writes them to fos // Create a stream that computes a checksum on the bytes it writes to gzos.
The java.util.zip package also contains a ZipFile class that gives you random access to the entries of a ZIP archive and allows you to read those entries through a stream:
String filename;   // File to read; initialized elsewhere String entryname;  // Entry to read from the ZIP file; initialized elsewhere // Now read bytes from bis...
If you need to compute a cryptographic-strength checksum (also known as a message digest), use one of the stream classes of the java.security package.
File f;          // File to read and compute digest on; initialized elsewhere.
Get an object that can compute an SHA message digest // A stream to read bytes from the file f // A stream that reads bytes from fis and computes an SHA message digest // A stream that reads bytes from dis and converts them to characters.
A stream that can read a line at a time // Now read lines from the stream // Close the streams // Get the message digest.
So far, we’ve used a variety of stream classes to manipulate streaming data, but the data itself ultimately comes from a file or is written to the console.
Set up a stream that uses a byte array as its destination.
Set up a stream to read characters from a string // Read characters from it until we reach the end int c;
PipedInputStream and PipedOutputStream and their character-based counterparts, PipedReader and PipedWriter, are another interesting set of streams defined by java.io.
These streams are used in pairs by two threads that want to communicate.
One thread writes bytes to a PipedOutputStream or characters to a PipedWriter, and another thread reads bytes or characters from the corresponding PipedInputStream or PipedReader:
A pair of connected piped I/O streams forms a pipe.
One thread writes // bytes to the PipedOutputStream, and another thread reads them from the // corresponding PipedInputStream.
This thread reads bytes from the pipe and discards them.
Networking with java.net The java.net package defines a number of classes that make writing networked applications surprisingly easy.
The easiest networking class to use is URL, which represents a uniform resource locator.
Different Java implementations may support different sets of URL protocols, but, at a minimum, you can rely on support for the http://, ftp://, and file:// protocols.
As of Java 1.4, secure HTTP is also supported with the https:// protocol.
Here are some ways you can use the URL class:
Read the content of a URL from an input stream.
For more control over the reading process, get a URLConnection object.
If necessary, read the contents of the URL using this stream.
Sometimes you need more control over your networked application than is possible with the URL class.
In this case, you can use a Socket to communicate directly with a server.
Here's a simple client program that connects to a web server, // requests a document and reads the document from the server.
Get I/O streams we can use to talk to the server.
Request the file from the server, using the HTTP protocol.
Now read the server's response, assume it is a text file, and print it out.
In Java 1.4 and later, you can use https:// with the URL class as previously shown to securely download documents from web servers that support SSL.
Like all Java security APIs, JSSE is highly configurable and gives low-level control over all details of setting up and communicating over an SSL socket.
The following program is a variant on the preceding code that uses HTTPS instead of HTTP to securely transfer the contents of the requested URL:
Use the factory to create a secure socket connected to the // HTTPS port of the specified web server.
Now use the secure socket just as you would use a regular socket // First, send a regular HTTP request over the SSL socket.
Next, read the server's response and print it to the console String line;
A client application uses a Socket to communicate with a server.
The server does the same thing: it uses a Socket object to communicate with each of its clients.
However, the server has an additional task in that it must be able to recognize and accept client connection requests.
The following code shows how you might use a ServerSocket.
The code implements a simple HTTP server that responds to all requests by sending back (or mirroring) the exact contents of the HTTP request.
A dummy server like this is useful when debugging HTTP clients:
Socket client; // Get streams to talk to the client.
Read the HTTP request from the client and send it right back // Stop when we read the blank line from the client that marks // the end of the request and its headers.
This server code could be modified using JSSE to support SSL connections.
Making a server secure is more complex than making a client secure, however, because a server must have a certificate it can present to the client.
Both URL and Socket perform networking on top of a stream-based network connection.
Setting up and maintaining a stream across a network takes work at the network level, however.
Sometimes you need a low-level way to speed a packet of data across a network, but you don’t care about maintaining a stream.
If, in addition, you don’t need a guarantee that your data will get there or that the packets of data will arrive in the order you sent them, you may be interested in the DatagramSocket and DatagramPacket classes:
In Java 5.0 the InetAddress class has an isReachable( ) method that attempts to determine whether the host is reachable.
The following code uses it in a naive Java implementation of the Unix ping utility:
I/O and Networking with java.nio Java 1.4 introduced an entirely new API for high-performance, nonblocking I/O and networking.
This java.nio.charset package contains classes for efficiently converting buffers of bytes into buffers of characters.
The sections that follow contain examples of using all three of these packages as well as examples of specific I/O tasks with the New I/O API.
The java.nio package includes an abstract Buffer class, which defines generic operations on buffers.
This package also defines type-specific subclasses such as ByteBuffer, CharBuffer, and IntBuffer.
See Buffer and ByteBuffer in the reference section for details on these classes and their various methods.) The following code illustrates typical sequences of buffer operations on a ByteBuffer.
Or do this to try to get an efficient buffer from the low-level OS // Here's another way to get a buffer: by "wrapping" an array byte[] data;  // Assume this array is created and initialized elsewhere // It is also possible to create a "view buffer" to view bytes as other types.
Here are methods for querying basic numbers about a buffer // A buffer's limit specifies how many bytes of the buffer can be used.
When writing into a buffer, this should be the capacity.
When reading data // from a buffer, it should be the number of bytes that were previously // written.
The position and limit can also be set with methods of the same name // Suppose you want to read the bytes you've written into the buffer.
Instead of the two previous calls, you usually use a convenience method.
Discard bytes you've already read; shift the remaining ones to the // beginning of the buffer; set position to new limit and limit to capacity, // preparing the buffer for writing more bytes into it.
You may notice that many buffer methods return the object on which they operate.
This is done so that method calls can be “chained” in code, as follows:
Many methods throughout java.nio and its subpackages return the current object to enable this kind of method chaining.
Note that the use of this kind of chaining is a stylistic choice (which I have avoided in this chapter) and does not have any significant impact on efficiency.
CharBuffer objects can be created by wrapping a string and can also be converted to strings.
CharBuffer implements the new java.lang.CharSequence interface, which means that it can be used like a String or StringBuffer in certain applications (e.g., for regular expression pattern matching)
Create a read-only CharBuffer from a string // A relative read that reads the char and increments the current position // Note that only the characters between the position and limit are used when // a CharBuffer is converted to a String or used as a CharSequence.
Bytes in a ByteBuffer are commonly converted to characters in a CharBuffer and vice versa.
We’ll see how to do this when we consider the java.nio.charset.
Buffers are not all that useful on their own—there isn’t much point in storing bytes into a buffer only to read them out again.
Instead, buffers are typically used with channels: your program stores bytes into a buffer, then passes the buffer to a channel, which reads the bytes out of the buffer and writes them to a file, network socket, or some other destination.
Or, in the reverse, your program passes a buffer to a channel, which reads bytes from a file, socket, or other source and stores those bytes into the buffer, where they can then be retrieved by your program.
The java.nio.channels package defines several channel classes that represent files,
We’ll see examples of these concrete classes later in this chapter.) The following code, however, is based on the capabilities of the various channel interfaces defined by java.nio.channels and should work with any Channel object:
Channel c;  // Object that implements Channel interface; initialized elsewhere.
ReadableByteChannel source;      // Initialized elsewhere WritableByteChannel destination; // Initialized elsewhere.
Here is the basic loop to use when reading bytes from a source channel and // writing them to a destination channel until there are no more bytes to read // from the source and no more buffered bytes to write to the destination.
Flip buffer: set limit to position and position to 0
This prepares // the buffer for reading (which is done by a channel *write* operation)
Write some or all of the bytes in the buffer to the destination // Discard the bytes that were written, copying the remaining ones to // the start of the buffer.
Set position to limit and limit to capacity, // preparing the buffer for writing (done by a channel *read* operation)
In addition to the ReadableByteChannel and WritableByteChannel interfaces illustrated in the preceding code, java.nio.channels defines several other channel interfaces.
ByteChannel simply extends the readable and writable interfaces without adding any new methods.
It is a useful shorthand for channels that support both reading and writing.
GatheringByteChannel is an extension of channel and scatter or distribute them into more than one buffer.
The gathering network protocols that use fixed-size headers that you want to store in a buffer separate from the rest of the transferred data.
One confusing point to be aware of is that a channel read operation involves writing (or putting) bytes into a buffer, and a channel write operation involves reading (or getting) bytes from a buffer.
Thus, when I say that the flip( ) method prepares a buffer for reading, I mean that it prepares a buffer for use in a channel.
A java.nio.charset.Charset object represents a character set plus an encoding for that character set.
Charset and its associated classes, CharsetEncoder and CharsetDecoder, define methods for encoding strings of characters into sequences of bytes and decoding sequences of bytes into strings of characters.
Since these classes are part of the New I/O API, they use the ByteBuffer and CharBuffer classes:
Encode the characters and store the bytes in a newly allocated ByteBuffer // Decode these bytes into a newly allocated CharBuffer and print them out.
This 8-bit charset is suitable for most Western European languages, including English.
Programmers who work only with English may also use the 7-bit US-ASCII charset.
The Charset class does not do encoding and decoding itself, and the previous convenience routines create CharsetEncoder and CharsetDecoder classes internally.
If you plan to encode or decode multiple times, it is more efficient to create these objects yourself:
The preceding CharsetEncoder.encode( ) method must allocate a new ByteBuffer each time it is called.
For maximum efficiency, you can call lower-level methods to do the encoding and decoding into an existing buffer:
For more complex charsets, such as the UTF-8 encoding of Unicode or the EUC-JP charset.
When this is the case, there is no guarantee that all bytes in a buffer can be decoded at once (the end of the buffer may contain a partial character)
Also, since a single character may encode to more than one byte, it can be tricky to know how many bytes a given string will encode into.
The following code shows a loop you can use to decode bytes in a more general way:
Tell the decoder to ignore errors that might result from bad bytes.
At this point, there may still be some bytes in the buffer to decode.
FileChannel is a concrete Channel class that performs file I/O and implements only if the underlying file is open for reading, and its write( ) method works only if the file is open for writing)
Obtain a FileChannel object by using the java.io example, you can use two FileChannel objects to copy a file:
Create streams to read the original and write the copy // Use the streams to create corresponding channel objects // Allocate a low-level 8KB buffer for the copy.
These methods allow us to simplify the preceding file-copying code to the following:
FileChannel in, out;              // Assume these are initialized as in the // preceding example.
This code could be equally well-written using transferFrom( ) instead of orders):
FileChannel has other capabilities that are not shared by other channel classes.
Memory mapping a file is a somewhat expensive operation, so this technique is usually efficient only when you are working with a large file to which you need repeated access.
Memory mapping offers you yet another way to perform the same file-copy operation shown previously:
The channel interfaces defined by java.nio.channels include ByteChannel but not CharChannel.
The channel API is low-level and provides methods for reading bytes only.
All of the previous examples have treated files as binary files.
It is possible to use the CharsetEncoder and CharsetDecoder classes introduced earlier to convert between bytes and characters, but when you want to work with text files, the Reader and Writer classes of the java.io package are usually much easier to use than CharBuffer.
Fortunately, the Channels class defines convenience methods that bridge between the old and new APIs.
Here is code that wraps a Reader and a Writer object around input and output channels, reads lines of Latin-1 text from.
ReadableByteChannel in;      // Assume these are initialized elsewhere WritableByteChannel out; // Create a Reader and Writer from a FileChannel and charset name String line;
Unlike the FileInputStream and FileOutputStream classes, the FileChannel class method returns the file pointer (the position of the next byte to be read), and the one-argument position( ) method allows you to set this pointer to any value you want.
This allows you to skip around in a file in the way that the java.io.
Suppose you have a file that has data records scattered throughout, and the // last 1,024 bytes of the file are an index that provides the position of // those records.
Here is code that reads the index of the file, looks up the // position of the first record within the file and then reads that record.
The final feature of FileChannel that we’ll consider here is its ability to lock a file or a portion of a file against all concurrent access (an exclusive lock) or against concurrent writes (a shared lock)
Note that some operating systems strictly enforce all locks while others provide only an advisory locking facility that requires programs to cooperate and to attempt to acquire a lock before reading or writing portions of a shared file.) In the previous random-access example, suppose we wanted to ensure that no other program was modifying the record data while we read it.
We could acquire a shared lock on that portion of the file with the following code:
The New I/O API includes networking capabilities as well as file-access capabilities.
To communicate over the network, you can use the SocketChannel class.
Create a it as you would with any other channel object.
The following code uses SocketChannel to send an HTTP request to a web server and saves the server’s response (including all of the HTTP headers) to a file.
InetSocketAddress, a subclass of java.net.SocketAddress, to tell the SocketChannel what to connect to.
These classes were also introduced as part of the New I/O API.
Create a SocketChannel connected to the web server at www.oreilly.com // A charset for encoding the HTTP request // Send an HTTP request to the server.
Start with a string, wrap it to // a CharBuffer, encode it to a ByteBuffer, then write it to the socket.
Create a FileChannel to save the server's response to // Get a buffer for holding bytes while transferring from socket to file // Now loop until all bytes are read from the socket and written to the file.
Now connect the socket channel to the desired host and port.
In addition to the SocketChannel class, the java.nio.channels package defines a DatagramChannel for networking with datagrams instead of sockets.
DatagramChannel is not demonstrated here, but you can read about it in the reference section.
One of the most powerful features of the New I/O API is that channels such as SocketChannel and DatagramChannel can be used in nonblocking mode.
The java.net package defines a Socket class for communication between a client and a server and defines a ServerSocket class used by the server to listen for and accept connections from clients.
The java.nio.channels package is analogous: it defines a SocketChannel class for data transfer and a ServerSocketChannel class for accepting connections.
ServerSocketChannel is an unusual channel because it does and obtaining a SocketChannel through which it communicates with the client.
Here is the code for a simple, single-threaded server that listens for connections on port 8000 and reports the current time to any client that connects:
Get a CharsetEncoder for encoding the text sent to the client.
Create a new ServerSocketChannel and bind it to port 8000 // Note that this must be done using the underlying ServerSocket.
Because it does not maintain a connection with any client, it never needs to communicate with more than one at a time, and there is never more than one SocketChannel in use.
More realistic servers must be able to communicate with more than one client at a time.
The java.io and java.net APIs allow only blocking I/O, so servers written using these APIs must use a separate thread for each client.
For large-scale servers with many clients, this approach does not scale well.
To solve this problem, the New I/O API allows most channels (but not FileChannel) to be used in nonblocking mode and allows a single thread to manage all pending connections.
This is done with a Selector object, which keeps track of a set of registered channels and can block until one or more of those channels is ready for I/O, as the following code illustrates.
This is a longer example than most in this chapter, but it is a complete working server class that manages a ServerSocketChannel and any number of SocketChannel connections to clients through a single Selector object.
All of the channels in this code will be in nonblocking mode.
So create a Selector object that will block while monitoring // all of the channels and stop blocking only when one or more // of the channels is ready for I/O of some sort.
Create a new ServerSocketChannel and bind it to port 8000 // Note that this must be done using the underlying ServerSocket // Put the ServerSocketChannel into nonblocking mode // on the channel, not on the selector object, however)
The SelectionKey represents the registration of this channel with // this Selector.
This call blocks until there is activity on one of the // registered channels.
Get a java.util.Set containing the SelectionKey objects for // all channels that are ready for I/O.
Use a java.util.Iterator to loop through the selected keys // Get the next SelectionKey in the set and remove it // from the set.
Check whether this key is the SelectionKey obtained when // you registered the ServerSocketChannel.
Activity on the ServerSocketChannel means a client // is trying to connect to the server.
Accept the client connection and obtain a // SocketChannel to communicate with the client.
Put the client channel in nonblocking mode // Now register it with the Selector object, // telling it that you'd like to know when // there is data to be read from this channel.
You'll // use this state when you talk to the client.
If the key obtained from the Set of keys is not the // ServerSocketChannel key, then it must be a key // representing one of the client connections.
If you are here, there should be data to read from // the channel, but double-check.
Assume that all the // client's bytes are in one read operation.
Otherwise, decode the bytes to a request string // Now reply to the client based on the request string // If the request was "quit", send a final message // Close the channel and deregister the // SelectionKey // Otherwise, send a response string comprised of // the sequence number of this request plus an // uppercase version of the request string.
Note // that you keep track of the sequence number by // "attaching" an Integer object to the // SelectionKey and incrementing it each time.
Get sequence number from SelectionKey // For response string // Wrap, encode, and write the response string // Attach an incremented sequence nubmer to the key.
It is also useful in clients that have more than one network connection pending at the same time.
For example, consider a web browser downloading a web page and the images referenced by that page at the same time.
One other interesting use of nonblocking I/O is to perform nonblocking socket connection operations.
Put it in nonblocking // mode, register it with a new Selector, and then tell it to connect.
The connect call will return instead of waiting for the network // connect to be fully established.
Now go do other stuff while the connection is set up // For example, you can create a GUI here.
Now block if necessary until the SocketChannel is ready to connect.
Since you've registered only one channel with this selector, you // don't need to examine the key set; you know which channel is ready.
Finally, close the selector, which deregisters the channel from it.
The structure and content of the document are fully described by the method calls.
This is a streaming API that does not build any permanent representation of the document.
It is up to the ContentHandler implementation to store any state or perform any actions that are appropriate.
A DOM parser reads an XML document and converts it into a tree of nodes that represent the full content of the document.
Once the tree representation of the document is created, a program can examine and manipulate it however it wants.
Implementations are required to support the W3C XML Schema standard and may also support other schema types as well.
Examples using each of these packages are presented in the following sections.
The first step in parsing an XML document with SAX is to obtain a SAX parser.
If you have a SAX parser implementation of your own, you can simply instantiate the appropriate parser class.
It is usually simpler, however, to use the javax.xml.parsers The code looks like this:
Configure the factory object to specify attributes of the parsers it creates.
The SAXParser class is a simple wrapper around the org.xml.sax.XMLReader class.
The DefaultHandler class provides an empty implementation of all the methods of the ContentHandler, ErrorHandler, DTDHandler, and EntityResolver interfaces.
These are all the methods that the SAX parser can call while parsing an XML document.
By subclassing DefaultHandler and defining the methods you care about, you can perform whatever actions are necessary in response to the method calls generated by the parser.
The following code shows a method that uses SAX to parse an XML file and determine the number of XML elements that appear in a document as.
It reads the file and calls methods of the handler.
This inner class extends DefaultHandler to count elements and text in // the XML file and saves the results in public fields.
There are many // other DefaultHandler methods you could override, but you need only // these.
This method is invoked when the parser encounters the opening tag // of any XML element.
This method is called for any plain text within an element // Simply count the number of characters in that text.
While SAX is an efficient way to scan an XML document, it is not well-suited for programs that want to modify documents.
Instead of converting an XML document into a series of method calls,
The conversion of the complete XML document to tree form allows random access to the entire document but can consume substantial amounts of memory.
In the DOM API, each node in the document tree implements the Node interface and a type-specific subinterface.
The most common types of node in a DOM document are Element and Text nodes.) When the parser is done parsing the document, your program can examine and manipulate that tree using the various methods of Node and its subinterfaces.
The following code uses JAXP to obtain a DOM parser (which, in JAXP parlance, is called a DocumentBuilder)
It then parses an XML file and builds a document tree from it.
Now use the factory to create a DOM parser, a.k.a.
Parse the file and build a Document tree to represent its content.
Print the text contained in the Text node child of this element.
The javax.xml.transform package defines a TransformerFactory class for creating Transformer objects.
A Transformer can transform a document from its Source representation into a new Result representation and optionally apply an XSLT transformation to the document content in the process.
Three subpackages define concrete implementations of the Source and Result interfaces, which allow documents to be transformed among three representations:
The following code shows one use of these packages to transform the representation of a document from a DOM Document tree into a stream of XML text.
An interesting feature of this code is that it does not create the Document tree by parsing a file; instead, it builds it up from scratch.
Now create a TransformerFactory and use it to create a Transformer // object to transform our DOM document into a stream of XML text.
A tutorial on XSLT stylesheets is beyond the scope of this book, but the following code (which contains only six key lines) shows how you can apply such a stylesheet (which is an XML document itself) to another XML document and write the resulting document to a stream:
The javax.xml.validation package allows you to validate XML documents against a schema.
All implementations must support W3C XML Schema and are allowed to support other schema types, such as RELAX NG.
To use this package, begin with a SchemaFactory instance—a parser for a specific type of schema.
Use this parser to parse a schema file into a Schema object.
Obtain a Validator from the Schema, and then use the Validator to validate your XML document.
The document is specified as a SAXSource or DOMSource object.
You may recall these classes from the subpackages of javax.xml.transform.
If the document is valid, the validate( ) method of the Validator object returns normally.
If it is not valid, validate( ) throws a SAXException.
You can install an org.xml.sax.ErrorHandler object for the Validator to provide some control over the kinds of validation errors that cause exceptions.
Note use of javax.xml package // This package contains just one class of constants.
Now parse the schema file to create a Schema object.
Get a SAXSource object for the document // We could use a DOMSource here as well.
XPath is a language for referring to specific nodes in an XML document.
The javax.xml.xpath package, new in Java 5.0, provides a way to find all nodes in a document that match an XPath expression.
Parse the document to a DOM tree // XPath can also be used with a SAX InputSource.
Or evaluate the expression to obtain a DOM NodeList of all matching // nodes.
You can obtain a Class object in Java in several ways:
Obtain a Class object for primitive types with various predefined constants.
Express a class literal as a type name followed by ".class"
Once you have a Class object, you can perform some interesting reflective operations with it:
If it is an array, figure out its base type.
If c is not a primitive type, print its class hierarchy.
Try to create a new instance of c; this requires a no-arg constructor // Handle InstantiationException, IllegalAccessException.
See if the class has a method named setText that takes a single String // If so, call it with a string argument.
These are varargs methods in Java 5.0 so the syntax is much cleaner.
Look for and invoke a method named "put" that takes two Object arguments.
In Java 5.0 we can use reflection on enumerated types and constants.
The VM discards generic type information at runtime, but it is stored // in the class file for the compiler and is accessible through reflection.
In Java 5.0, reflection can also be used on annotation types and to // determine the values of runtime visible annotations // Look for some meta-annotations.
Class also provides a simple mechanism for dynamic class loading in Java.
For more complete control over dynamic class loading, however, you should use a java.lang.ClassLoader object, typically a java.net.URLClassLoader.
Dynamically load a class specified by name in a config file config.getProperty("filterclass",  // The property name.
The preceding code works only if the class to be loaded is in the class path.
If this is not the case, you can create a custom ClassLoader object to load a class from a path (or URL) you specify yourself:
The Proxy class and InvocationHandler interface to the java.lang.reflect that allows you to dynamically create a new class or instance that implements a specified interface or set of interfaces.
It also dispatches invocations of the interface methods to an InvocationHandler object.
Object Persistence The Java platform provides two mechanisms for object persistence: the ability to save object state so that the object can later be recreated.
Both mechanisms involve serialization; the second is aimed particularly at JavaBeans.
One of the most important features of the java.io package is the ability to serialize objects: to convert an object into a stream of bytes that can later be deserialized back into a copy of the original object.
The following code shows how to use serialization to save an object to a file and later read it back:
Object o;  // The object we are serializing; it must implement Serializable File f;    // The file we are saving it to.
The previous example serializes to a file, but remember, you can write serialized objects to any type of stream.
Thus, you can write an object to a byte array, then read it back from the byte array, creating a deep copy of the object.
You can write the object’s bytes to a compression stream or even write the bytes to a stream connected across a network to another program!
Java 1.4 introduced a serialization mechanism intended for use with JavaBeans components.
Since it is based on the public API rather than on the internal state, the JavaBeans persistence mechanism allows interoperability between different implementations of the same API, handles version skew more robustly, and is suitable for longer-term storage of serialized objects.
A bean and any descendant beans or other objects that are serialized with java.beans.XMLEncoder can be deserialized with java.beans.XMLDecoder.
These classes write to and read from specified streams, but they are not stream classes themselves.
Create a JavaBean, and set some properties on it // Now save its encoded form to the file bean.xml.
Here is the corresponding code to decode the bean from its serialized form:
Security The java.security package defines quite a few classes related to the Java accesscontrol architecture, which is discussed in more detail in Chapter 6
These classes allow Java programs to run untrusted code in a restricted environment from which it can do no harm.
While these are important classes, you rarely need to use them.
The more interesting classes are the ones used for message digests and digital signatures; they are demonstrated in the sections that follow.
A message digest is a value, also known as cryptographic checksum or secure hash, that is computed over a sequence of bytes.
The length of the digest is typically much smaller than the length of the data for which it is computed, but any change, no matter how small, in the input bytes produces a change in the digest.
When transmitting data (a message), you can transmit a message digest along with it.
The recipient of the message can then recompute the message digest on the received data and, by comparing the computed digest to the received digest, determine whether the message or the digest was corrupted or tampered with during transmission.
We saw a way to compute a message digest earlier in the chapter when we discussed streams.
A similar technique can be used to compute a message digest for nonstreaming binary data:
Obtain an object to compute message digests using the "Secure Hash // Algorithm"; this method can throw a NoSuchAlgorithmException.
Create a keyed digest that can be verified if you know the secret bytes.
Verify a digest like this byte[] receivedData, receivedDigest;  // The data and the digest we received // Compare computed digest to the received digest.
A digital signature combines a message-digest algorithm with public-key cryptography.
The sender of a message, Alice, can compute a digest for a message and then encrypt that digest with her private key.
She then sends the message and the encrypted digest to a recipient, Bob.
Bob knows Alice’s public key (it is public, after all), so he can use it to decrypt the digest and verify that the message has not been tampered with.
In performing this verification, Bob also learns that the digest was encrypted with Alice’s private key since he was able to decrypt the digest successfully using Alice’s public key.
As Alice is the only one who knows her private key, the message must have come from Alice.
A digital signature is called such because, like a pen-and-paper signature, it serves to authenticate the origin of a document or message.
Unlike a pen-and-paper signature, however, a digital signature is very difficult, if not impossible, to forge, and it cannot simply be cut and pasted onto another document.
In order to create a digital signature, however, you need a java.security.PrivateKey object.
Assuming that a keystore exists on your system (see the keytool documentation in Chapter 8), you can get one with code like the following:
Here is some basic data we need PrivateKey key;  // This is the key we want to look up from the keystore.
Once you have a PrivateKey object, you can create a digital signature with a java.security.Signature object:
PrivateKey key;             // Initialized as shown previously byte[] data;                // The data to be signed // NoSuchAlgorithmException.
String signername;  // Who created the signature; initialized elsewhere KeyStore keystore;  // Where certificates stored; initialize as shown earlier.
The java.security.SignedObject class is a convenient utility for wrapping a digital signature around an object.
The SignedObject can then be serialized and transmitted to a recipient, who can deserialize it and use the verify( ) method to verify the signature:
Serializable o;  // The object to be signed; must be Serializable PrivateKey k;    // The key to sign with; initialized elsewhere.
The SignedObject encapsulates the object o; it can now be serialized // and transmitted to a recipient.
Here's how the recipient verifies the SignedObject SignedObject so;           // The deserialized SignedObject Object o;                  // The original object to extract from it PublicKey pk;              // The key to verify with if (so.verify(pk,s))       // If the signature is valid,
Cryptography The java.security package includes cryptography-based classes, but it does not contain classes for actual encryption and decryption.
This package supports symmetric-key cryptography, in which the same key is used for both encryption and decryption and must be known by both the sender and the receiver of encrypted data.
The SecretKey interface represents an encryption key; the first step of any cryptographic operation is to obtain an appropriate SecretKey.
Unfortunately, the keytool program supplied with the JDK cannot generate and store secret keys, so a program must handle these tasks itself.
Here is some code that shows various ways to work with SecretKey objects:
Use SecretKeyFactory to // convert to a transparent representation that can be manipulated: saved // to a file, securely transmitted to a receiving party, etc.
Convert the raw bytes of a key back to a SecretKey object.
For DES and DESede keys, there is an even easier way to create keys // SecretKeySpec implements SecretKey, so use it to represent these keys.
Once you have obtained an appropriate SecretKey object, the central class for encryption and decryption is Cipher.
SecretKey key;     // Obtain a SecretKey as shown earlier byte[] plaintext;  // The data to encrypt; initialized elsewhere.
Obtain an object to perform encryption or decryption // Initialize the cipher object for encryption // Now encrypt data.
If we had multiple chunks of data to encrypt, we can do this.
The Cipher class can also be used with CipherInputStream or CipherOutputStream to encrypt or decrypt while reading or writing streaming data:
Create a stream that encrypts bytes before sending them to that stream // See also CipherInputStream to encrypt or decrypt while reading bytes.
Finally, the javax.crypto.SealedObject class provides an especially easy way to perform encryption.
This class serializes a specified object and encrypts the resulting stream of bytes.
The SealedObject can then be serialized itself and transmitted to a recipient.
The recipient can retrieve the original object only if she knows the required SecretKey:
Serializable o;           // The object to be encrypted; must be Serializable SecretKey key;                              // The key to encrypt it with.
Object so is a wrapper around an encrypted form of the original object o; // it can now be serialized and transmitted to another party.
Miscellaneous Platform Features The following sections detail important but miscellaneous features of the Java platform, including properties, preferences, processes, and management and instrumentation.
A Properties object maintains a mapping between string keys and string values and defines methods that allow the mappings to be written to and read from a simple text file or (in Java 5.0) an XML file.
This makes the Properties class ideal for configuration and user preference files.
The Properties class is also used for the system properties returned by System.getProperty( ):
Note: many of these system properties calls throw a security exception if // called from untrusted code such as applets.
Query a property ("color"), specifying a default ("gray") if undefined.
Store the contents of the Properties object back into a file options.store(new FileOutputStream(configfile),  // Output stream.
Java 1.4 introduced the Preferences API, which is specifically tailored for working with user and systemwide preferences and is more useful than Properties for this purpose.
The Preferences API is defined by the java.util.prefs Preferences object that contains user-specific preferences with the static method methods take a java.lang.Class object as their sole argument and return a Preferences object shared by all classes in that package.
This means that the preference names you use must be unique within the package.) Once you have a Preferences object, use the get( ) method to query the string value of a named be passed for all methods.
This default value is returned if no preference with the specified name has been registered or if the file or database that holds the preference data cannot be accessed.
Get Preferences objects for user and system preferences for this package.
Look up a user preference using a system preference as the default sysprefs.get("dictionary",
If your application wants to be notified of user or system preference changes while the application is in progress, it may register a PreferenceChangeListener and values of its preferences as an XML file and can read preferences from such.
Methods for navigating this hierarchy exist but are not typically used by ordinary applications.
Earlier in the chapter, we saw how easy it is to create and manipulate multiple threads of execution running within the same Java interpreter.
Java also has a java.lang.Process class that represents an operating system process running externally to the interpreter.
A Java program can communicate with an external process using streams in the same way that it might communicate with a server running on some other computer on the network.
Using a Process is always platform-dependent and is rarely portable, but it is sometimes a useful thing to do:
Maximize portability by looking up the name of the command to execute // in a configuration file.
In Java 5.0 the java.lang.ProcessBuilder class provides a more flexible way to control of environment variables through a Map and makes it simple to set the working directory.
It also has an option to automatically redirect the standard error stream of the processes it launches to the standard output stream, which makes it much easier to read all output of a Process.
We use this to start commands // Our inherited environment vars.
We may modify these below // Our processes will merge error stream with standard output stream // Where we read the user's input from.
Now read and display output from the process // until there is no more output to read String line;
The process should be done now, but wait to be sure.
Java 5.0 includes the powerful JMX API for remote monitoring and management of running applications.
The full javax.management API is beyond the scope of this book.
The reference section does cover the java.lang.management package, however: this package is an application of JMX for the monitoring and management of the Java virtual machine itself.
In VMs that support it, java.lang.instrument can be used to redefine class files as they are loaded to add profiling or coverage testing code, for.
Class redefinition is beyond the scope of this chapter, but the following code uses the new instrumentation and management features of Java 5.0 to determine resource usages of a Java program.
This agent simply registers a shutdown hook to run when the VM exits // This code runs when the VM exits // Decide where to send our output PrintWriter out; else.
To monitor the resource usage of a Java program with this agent, you first must compile the class normally.
You then store the generated class files in a JAR file with manifest file that contains this line:
Finally, to use the agent, specify the JAR file and the agent arguments with the -javaagent flag to the Java interpreter:
Java programs can dynamically load Java classes from a variety of sources, including untrusted sources, such as web sites reached across an insecure network.
The ability to create and work with such mobile code is one of the great strengths and features of Java.
To make it work successfully, however, Java puts great emphasis on a security architecture that allows untrusted code to run safely, without fear of damage to the host system.
In the absence of a security system, an applet could wreak havoc on the user’s system by deleting files, installing a virus, stealing confidential information, and so on.
Somewhat more subtly, an applet could take advantage of the user’s system to forge email, generate spam, or launch hacking attempts on other systems.
Java’s main line of defense against such malicious code is access control: untrusted code is simply not given access to certain sensitive portions of the core Java API.
For example, an untrusted applet is not typically allowed to read, write, or delete files on the host system or connect over the network to any computer other than the web server from which it was downloaded.
This chapter describes the Java access control architecture and a few other facets of the Java security system.
Applets are documented in Java Foundation Classes in a Nutshell (O’Reilly) and are not covered in this book.
Security Risks Java has been designed from the ground up with security in mind; this gives it a great advantage over many other existing systems and platforms.
Nevertheless, no system can guarantee 100% security, and Java is no exception.
The Java security architecture was designed by security experts and has been studied and probed by many other security experts.
The consensus is that the architecture itself is strong and robust, theoretically without any security holes (at least none that have been discovered yet)
The implementation of the security architecture is another matter, however, and there is a long history of security flaws being found and patched in particular implementations of Java.
Microsoft fixed the problem, and no longer distributes their VM with the latest versions of their web browser.
In all likelihood, security flaws will continue to be discovered (and patched) in Java VM implementations.
Despite this, Java remains perhaps the most secure platform currently available.
Java VM Security and Class File Verification The lowest level of the Java security architecture involves the design of the Java Virtual Machine and the byte codes it executes.
The Java VM does not allow any kind of direct access to individual memory addresses of the underlying system, which prevents Java code from interfering with the native hardware and operating system.
These intentional restrictions on the VM are reflected in the Java language itself, which does not support pointers or pointer arithmetic.
The language does not allow an integer to be cast to an object reference or vice versa, and there is no way whatsoever to obtain an object’s address in memory.
Without capabilities like these, malicious code simply cannot gain a foothold.
In addition to the secure design of the Virtual Machine instruction set, the VM goes through a process known as byte-code verification whenever it loads an untrusted class.
This process ensures that the byte codes of a class (and their operands) are all valid; that the code never underflows or overflows the VM stack; that local variables are not used before they are initialized; that field, method, and class access control modifiers are respected; and so on.
The verification step is designed to prevent the VM from executing byte codes that might crash it or put it into an undefined and untested state where it might be vulnerable to other attacks by malicious code.
Byte-code verification is a defense against malicious handcrafted Java byte codes and untrusted Java compilers that might output invalid byte codes.
Authentication and Cryptography The java.security package (and its subpackages) provides classes and interfaces for authentication.
As described in Chapter 5, this piece of the security architecture allows Java code to create and verify message digests and digital signatures.
These technologies can ensure that any data (such as a Java class file) is authentic: that it originates from the person who claims to have originated it and has not been accidentally or maliciously modified in transit.
The Java Cryptography Extension, or JCE, consists of the javax.crypto package and its subpackages.
These packages define classes for encryption and decryption of data.
This is an important security-related feature for many applications, but is not directly relevant to the basic problem of preventing untrusted code from damaging the host system, so it is not discussed in this chapter.
Access Control As we noted at the beginning of this chapter, the heart of the Java security architecture is access control: untrusted code simply must not be granted access to the sensitive parts of the Java API that would allow it to do malicious things.
Since then, the access control model has been relatively stable; it has not changed significantly since Java 1.2
In this first release of Java, all Java code installed locally on the system is trusted implicitly.
When system code is about to perform a restricted operation, such as reading a file from the local filesystem, it first calls an appropriate method (such as checkRead( )) of the currently installed SecurityManager object.
If untrusted code is running, the SecurityManager throws a SecurityException that prevents the restricted operation from taking place.
The most common user of the SecurityManager class is a Java-enabled web browser, which installs a SecurityManager object to allow applets to run without damaging the host system.
The precise details of the security policy are an implementation detail of the web browser, of course, but applets are typically restricted in the following ways:
It cannot query the length or modification date of a file or even check whether a given file exists.
Similarly, an applet cannot create, list, or delete a directory.
An applet cannot connect to or accept a connection from any computer other than the one it was downloaded from.
It cannot use any privileged ports (i.e., ports below and including port 1024)
An applet cannot perform system-level functions, such as loading a native library, spawning a new process, or exiting the Java interpreter.
An applet cannot manipulate any threads or thread groups, except for those it creates itself.
In Java 1.1 and later, applets cannot use the Java Reflection API to obtain information about the nonpublic members of classes, except for classes that were downloaded with the applet.
It cannot initiate a print job or access the system clipboard or event queue.
In addition, all windows created by an applet typically display a prominent visual indicator that they are “insecure” to prevent an applet from spoofing the appearance of some other application.
An applet cannot read certain system properties, notably the user.home and user.dir properties, that specify the user’s home directory and current working directory.
An applet cannot circumvent these security restrictions by registering a new SecurityManager object.
Suppose that an applet (or some other untrusted code running in the sandbox) attempts to read the contents of the file /etc/passwd by passing this filename to the class were aware that the class provides access to a system resource (a file), so use of the class should therefore be subject to access control.
For this reason, they coded the FileInputStream( ) constructor to use the SecurityManager class.
Every time FileInputStream( ) is called, it checks to see if a SecurityManager object SecurityManager object, passing the filename (/etc/passwd, in this case) as the sole constructor simply proceeds with whatever initialization is necessary and returns.
Otherwise, it allows the SecurityException to propagate to the caller.
When this happens, no FileInputStream object is created, and the applet does not gain access to the /etc/passwd file.
Thus, web browsers and other Java installations can be configured to trust downloaded code that bears a valid digital signature of a trusted entity.
Such code is treated as if it were installed locally, so it is given full access to the Java APIs.
In this release, the javakey program manages keys and digitally signs JAR files of Java code.
Although Java 1.1 added the important ability to trust digitally signed code that would otherwise be untrusted, it sticks to the basic sandbox model: trusted code gets full access and untrusted code gets totally restricted access.
Java 1.2 introduced substantial access control features into the Java security architecture.
These features are implemented by classes in the java.security package.
The Policy class is one of the most important: it defines a Java security policy.
A Policy object maps CodeSource objects to associated sets of Permission objects.
A CodeSource object represents the source of a piece of Java code, which includes both the URL of the class file (and can be a local file) and a list of entities that have applied their digital signatures to the class file.
The Permission objects associated with a CodeSource in the Policy define the permissions that are granted to code from a given source.
Various Java APIs include subclasses of Permission that represent different types of permissions.
Under this access control model, the SecurityManager class continues to be the central class; access control requests are still made by invoking methods of a SecurityManager.
However, the default SecurityManager implementation delegates most of those requests to an AccessController class that makes access decisions based on the Permission and Policy architecture.
The Java 1.2 access control architecture has several important features:
Code from different sources can be given different sets of permissions.
In other words, the architecture supports fine-grained levels of trust.
Even locally installed code can be treated as untrusted or partially untrusted.
Under this architecture, only system classes and standard extensions run as fully trusted.
It is no longer necessary to define a custom subclass of SecurityManager to define a security policy.
Policies can be configured by a system administrator by editing a text file or using the policytool program, described in Chapter 8
The architecture is not limited to a fixed set of access control methods in the SecurityManager class.
Permission subclasses can be defined easily to govern access to system resources (which might be exposed, for example, by standard extensions that include native code)
Let’s return to the example of an applet that attempts to create a FileInputStream to read the file /etc/passwd.
What changed as of Java 1.2 is the default behavior of the checkRead( ) method.
Unless a program has replaced the default security manager with one of its own, the default implementation creates a FilePermission object to represent the access being requested.
This FilePermission object has a target of “/etc/passwd” and an.
It is the AccessController and its checkPermission( ) method that do the real work of access control as of Java 1.2
The method determines the CodeSource of each calling method and uses the current Policy object to determine the Permission objects associated with it.
With this information, the AccessController can determine whether read access to the /etc/passwd file should be allowed.
The Permission class represents both the permissions granted by a Policy and the requesting a permission, Java typically uses a FilePermission (or other Permission subclass) with a very specific target, like “/etc/passwd”
When granting a permission, however, a Policy commonly uses a FilePermission object with a wildcard target, such as “/etc/*”, to represent many files.
Security for Everyone Programmers, system administrators, and end users all have different security concerns and, thus, different roles to play in the Java security architecture.
System programmers are the people who define new Java APIs that allow access to sensitive system resources.
These programmers are typically working with native methods that have unprotected access to the system.
They need to use the Java access control architecture to prevent untrusted code from executing those native methods.
To do this, system programmers must carefully insert SecurityManager calls at appropriate places in their code.
A system programmer may choose to use an existing Permission subclass to govern access to the system resources exposed by her API, or she may decide to define a specialized subclass of Permission.
The system programmer carries a tremendous security burden: if she does not perform appropriate access control checks in her code, she compromises the security of the entire Java platform.
The details are complex and are beyond the scope of this book.
Fortunately, however, system programming that involves native methods is rare in Java; almost all of us are application programmers who can simply rely on the existing APIs.
Programmers who use the core Java APIs and standard extensions but do not define new extensions or write native methods can simply rely on the security efforts of the system programmers who created those APIs.
In other words, most of us Java programmers can simply use the Java APIs and need not worry about introducing security holes into the Java platform.
In fact, application programmers rarely have to use the access control architecture.
If you are writing Java code that may be run as untrusted code, you should be aware of the restrictions placed on untrusted code by typical security policies.
Keep in mind that some methods (such as methods that read or write files) can throw SecurityException objects, but don’t feel you must write your code to catch these exceptions.
Often, the appropriate response to a SecurityException is to allow it to propagate uncaught so that it terminates the application.
Sometimes, as an application programmer, you want to write an application (such as an applet viewer) that can load untrusted classes and run them subject to access control checks.
To do this in Java 1.2 and later, you must first install a security manager:
URLClassLoader assigns a default set of safe permissions to the classes it loads, but in some cases you may want to modify the permissions granted to the loaded code through the Policy and PermissionCollection classes.
In Java 1.2 and later, system administrators are responsible for defining the default security policy for the computers at their site.
The default policy is stored in the file lib/security/java.policy in the Java installation.
A system administrator can edit this text file by hand or use the policytool program from Sun to edit the file graphically.
While this default policy is adequate for many purposes, it may not be appropriate for all sites.
For example, at some organizations, it may be appropriate to grant extra permissions to code downloaded from a secure intranet.
In order to define effective security policies, a system administrator must understand the various Permission subclasses of the Java platform, the target and action names they support, and the security implications of granting any particular permission.
Most end users do not have to think about security at all: their Java programs should simply run in a secure way with no intervention from them.
Some sophisticated end users may want to define their own security policies, however.
An end user can do this by running policytool himself to define personal policy files that augment the system policy.
The default personal policy is stored in a file named .java.policy in the user’s home directory.
By default, Java loads this policy file and uses it to augment the system policy file.
In Java 1.2 and later, a user can specify an additional policy file to use when starting up the Java interpreter.
To do so, you use the -D option to define the java.security.policy property.
This line runs the class UntrustedApp after augmenting the default system and user policies with the policy specified in the file or URL policyfile.
To replace the system and user policies instead of augmenting them, use a double equals sign in the property specification:
Note, however, that specifying a policy file is useful only if there is a SecurityManager installed.
If a user doesn’t trust an application, he presumably doesn’t trust that application to voluntarily install its own security manager.
In this case, he can define the java.security.manager system property:
The value of this property does not matter; simply defining it is enough to tell the Java interpreter to automatically install a default SecurityManager object that subjects an application to the access control policies described in the system, user, and java.security.policy policy files.
Permission Classes Table 6-1 lists some important Permission subclasses defined by the core Java platform and summarizes the permissions they represent.
See the reference section for more information on the individual classes.
See http://java.sun.com/j2se/1.5.0/ docs/guide/security/permissions.html for a complete list and detailed description of these permissions classes, along with their target and action names and a list of methods and the permissions they require (this document is part of the standard documentation bundle that can be downloaded along with the JDK)
Controls the ability of a program to modify the logging configuration.
Many of the controlled methods are defined by java.lang.System and java.lang.Runtime.
This chapter explains a number of important and useful Java programming and documentation conventions.
Following them, however, will make your code easier to read and maintain, portable, and selfdocumenting.
Naming and Capitalization Conventions The following widely adopted naming conventions apply to packages, reference types, methods, fields, and constants in Java.
Because these conventions are almost universally followed and because they affect the public API of the classes you define, they should be followed carefully:
Packages Ensure that your publicly visible package names are unique by prefixing them with the inverted name of your Internet domain (e.g., com.davidflanagan.utils)
Packages of code used internally by applications distributed in self-contained JAR files are not publicly visible and need not follow this convention.
It is common in this case to use the application name as the package name or as a package prefix.
Reference types A type name should begin with a capital letter and be written in mixed case (e.g., String)
If a class name consists of more than one word, each word should begin with a capital letter (e.g., StringBuffer)
Since classes and enumerated types are designed to represent objects, you should choose class names that are nouns (e.g., Thread, Teapot, FormatConverter)
When an interface is used to provide additional information about the classes that implement it, it is common to choose an interface name that is an adjective (e.g., Runnable, Cloneable, Serializable)
When an interface works more like an abstract superclass, use a name that is a noun (e.g., Document, FileNameMap, Collection)
Methods A method name always begins with a lowercase letter.
If the name contains more than one word, every word after the first begins with a capital letter (e.g., chosen so that the first word is a verb.
Method names can be as long as is necessary to make their purpose clear, but choose succinct names where possible.
Fields and constants Nonconstant field names follow the same capitalization conventions as method names.
If a field is a static final constant, it should be written in uppercase.
If the name of a constant includes more than one word, the words should be separated with underscores (e.g., MAX_VALUE)
A field name should be chosen to best describe the purpose of the field or the value it holds.
The constants defined by enum types are also typically written in all capital letters.
Because other programming languages use lowercase or mixed case for enumerated values, however, this convention is not as strong as the convention for capital letters in the static final fields of classes and interfaces.
Parameters Method parameters follow the same capitalization conventions as nonconstant fields.
The names of method parameters appear in the documentation for a method, so you should choose names that make the purpose of the parameters as clear as possible.
Try to keep parameter names to a single word and use them consistently.
For example, if a WidgetProcessor class defines many methods that accept a Widget object as the first parameter, name this parameter widget or even w in each method.
Local variables Local variable names are an implementation detail and never visible outside your class.
Nevertheless, choosing good names makes your code easier to read, understand, and maintain.
Variables are typically named following the same conventions as methods and fields.
In addition to the conventions for specific types of names, there are conventions regarding the characters you should use in your names.
Java allows the $ character in any identifier, but, by convention, its use is reserved for synthetic names.
It is used by the Java compiler, for example, to make inner classes work.) Also, Java allows names to use any alphanumeric characters from the entire Unicode character set.
While this can be convenient for non-English-speaking programmers, the use of Unicode characters should typically be restricted to local variables, private methods and fields, and other names that are not part of the public API of a class.
Native methods Portable Java code can use any methods in the core Java APIs, including methods implemented as native methods.
However, portable code must not define its own native methods.
The Runtime.exec( ) method Calling the Runtime.exec( ) method to spawn a process and execute an external command on the native system is rarely allowed in portable code.
This is because the native OS command to be executed is never guaranteed to exist or behave the same way on all platforms.
The only time it is legal to use Runtime.exec( ) is when the user is allowed to specify the command to run, either by typing the command at runtime or by specifying the command in a configuration file or preferences dialog box.
Undocumented classes Portable Java code must use only classes and interfaces that are a documented part of the Java platform.
Most Java implementations ship with additional undocumented public classes that are part of the implementation but not part of the Java platform specification.
Nothing prevents a program from using and relying on these undocumented classes, but doing so is not portable because the classes are not guaranteed to exist in all Java implementations or on all platforms.
The java.awt.peer package The interfaces in the java.awt.peer package are part of the Java platform but are documented for use by AWT implementors only.
Implementation-specific features Portable code must not rely on features specific to a single implementation.
For example, Microsoft distributed a version of the Java runtime system that.
Any program that depends on such extensions is obviously not portable to other platforms.
Microsoft’s proprietary extension of the Java platform resulted in legal action between Sun and Microsoft and ultimately caused Microsoft to discontinue ongoing support for Java.
Implementation-specific bugs Just as portable code must not depend on implementation-specific features, it must not depend on implementation-specific bugs.
If a class or method behaves differently than the specification says it should, a portable program cannot rely on this behavior, which may be different on different platforms, and ultimately may be fixed.
Implementation-specific behavior Sometimes different platforms and different implementations present different behaviors, all of which are legal according to the Java specification.
Portable code must not depend on any one specific behavior.
For example, the Java specification does not indicate whether threads of equal priority share the CPU or if one long-running thread can starve another thread at the same priority.
If an application assumes one behavior or the other, it may not run properly on all platforms.
Standard extensions Portable code can rely on standard extensions to the Java platform, but, if it does so, it should clearly specify which extensions it uses and exit cleanly with an appropriate error message when run on a system that does not have the extensions installed.
Complete programs Any portable Java program must be complete and self-contained: it must supply all the classes it uses, except core platform and standard extension classes.
Defining system classes Portable Java code never defines classes in any of the system or standard extension packages.
Hardcoded filenames A portable program contains no hardcoded file or directory names.
This is because different platforms have significantly different filesystem organizations and use different directory separator characters.
If you need to work with a file or directory, have the user specify the filename, or at least the base directory beneath which the file can be found.
This specification can be done at runtime, in a configuration file, or as a command-line argument to the program.
When concatenating a file or directory name to a directory name, use the File( ) constructor or the File.separator constant.
Line separators Different systems use different characters or sequences of characters as line separators.
Java Documentation Comments Most ordinary comments within Java code explain the implementation details of that code.
By contrast, the Java language specification defines a special type of comment known as a doc comment that serves to document the API of your code.
A doc comment appears immediately before a type or member definition and contains documentation for that type or member.
The documentation can include simple HTML formatting tags and other special keywords that provide additional information.
Doc comments are ignored by the compiler, but they can be extracted and automatically turned into online HTML documentation by the javadoc program.
See Chapter 8 for more information about javadoc.) Here is an example class that contains appropriate doc comments:
Creates a new Complex object that represents the complex number x+yi.
Adds two Complex objects and produces a third object that represents * their sum.
The body of a doc comment should begin with a one-sentence summary of the type or member being documented.
This sentence may be displayed by itself as summary documentation, so it should be written to stand on its own.
The initial sentence may be followed by any number of other sentences and paragraphs that describe the class, interface, method, or field in full detail.
After the descriptive paragraphs, a doc comment can contain any number of other paragraphs, each of which begins with a special doc-comment tag, such as in a standard way.
The full set of doc-comment tags is listed in the next section.
Remember, however, that the material you write is embedded within a larger, more complex HTML document.
For this reason, doc comments should not contain major structural HTML tags, such as.
Avoid the use of the <a> tag to include hyperlinks or cross-references in your doc comments.
Instead, use the special {@link} doc-comment tag, which, unlike the other doc-comment tags, can appear anywhere within a doc comment.
As described in the next section, the {@link} tag allows you to specify hyperlinks to other classes, interfaces, methods, and fields without knowing the HTML-structuring conventions and filenames used by javadoc.
If you want to include an image in a doc comment, place the image file in a docfiles subdirectory of the source code directory.
Give the image the same name as the class, with an integer suffix.
For example, the second image that appears in the doc comment for a class named Circle can be included with this HTML tag:
Because the lines of a doc comment are embedded within a Java comment, any leading spaces and asterisks (*) are stripped from each line of the comment before processing.
Thus, you don’t need to worry about the asterisks appearing in the generated documentation or about the indentation of the comment affecting the indentation of code examples included within the comment with a <pre> tag.
These doc-comment tags allow you to encode specific information into your comments in a standardized way, and they allow javadoc to choose the appropriate output format for that information.
For example, the @param tag lets you specify the name and meaning of a single parameter for a method.
The following doc-comment tags are recognized by javadoc; a doc comment should typically use these tags in the order listed here:
This tag should be used for every class or interface definition but must not be used for individual methods and fields.
List the authors in chronological order, with the original author first.
If the author is unknown, you can use “unascribed.” javadoc does not output authorship information unless the -author command-line argument is specified.
This tag should be included in every class and interface doc comment but cannot be used for individual methods and fields.
This tag is often used in conjunction with the automated version-numbering capabilities of a version control system, such as SCCS, RCS, or CVS.
Adds the specified parameter and its description to the “Parameters:” section of the current method.
The doc comment for a method or constructor must contain one @param tag for each parameter the method expects.
These tags should appear in the same order as the parameters specified by the method.
The tag can be used only in doc comments for methods and constructors.
You are encouraged to use phrases and sentence fragments where possible to keep the descriptions brief.
However, if a parameter requires detailed documentation, the description can wrap onto multiple lines and include as much text as necessary.
For readability in source-code form, consider using spaces to align the descriptions with each other.
This tag should appear in every doc comment for a method, unless the method returns void or is a constructor.
The description can be as long as necessary, but consider using a sentence fragment to keep it short.
Adds a “Throws:” entry that contains the specified exception name and description.
A doc comment for a method or constructor should contain an For example:
The @exception tag can optionally be used to document unchecked exceptions (i.e., subclasses of RuntimeException) the method may throw, when these are exceptions that a user of the method may reasonably want to catch.
If a method can throw more than one exception, use multiple @exception tags on adjacent lines and list the exceptions in alphabetical order.
The description can be as short or as long as necessary to describe the significance of the exception.
This tag can be used only for method and constructor comments.
This tag can appear in any kind of doc comment.
This tag specifies that the following type or member has been deprecated and that its use should be avoided.
This text should specify when the class or member was deprecated and, if possible, suggest a replacement class or member and include a link to it.
Although the Java compiler ignores all comments, it does take note of the the deprecation in the class file it produces.
This allows it to issue warnings for other classes that rely on the deprecated feature.
Specifies when the type or member was added to the API.
This tag should be followed by a version number or other version specification.
Technically, the way a class is serialized is part of its public API.
If you write a class that you expect to be serialized, you should document its serialization format using @serial and the related tags listed below.
For classes that use the default serialization mechanism, this means all fields that are not declared transient, including fields declared purpose within a serialized object.
A Serializable class can define its serialized format by declaring an array of ObjectStreamField objects in a field named serialPersistentFields.
For such a class, the doc comment for serialPersistentFields should include an type, and description for a particular field in the serialized state of the class.
A Serializable class can define a writeObject( ) method to write data other than that written by the default serialization mechanism.
An Externalizable state of an object to the serialization stream.
The @serialData tag should be methods, and the description should document the serialization format used by the method.
In addition to the preceding tags, javadoc also supports several inline tags that may appear anywhere that HTML text appears in a doc comment.
Because these tags appear directly within the flow of HTML text, they require the use of curly braces as delimiters to separate the tagged text from the HTML text.
An {@link} tag can appear anywhere that HTML text appears in a doc comment.
This is most useful when reference contains both a feature to link to and a label that specifies alternate text to be displayed in the link.
This tag also allows you to inherit and augment the descriptive text of the comment.
To inherit the entire doc comment, including your own text before and after it, use the tag like this:
It is useful in hyperlinks that refer to an external file, such as an image or a copyright statement:
It does not retain whitespace formatting but is useful when used within a <pre> tag.
This tag was introduced in Java 1.4 and is used only for constant fields.
If it begins with a quote character, it is taken to be the name of a book or some other printed resource and is displayed as is.
This form of the @see tag can insert links to other online documents, such as a programmer’s guide or user’s manual.
If reference is not a quoted string or a hyperlink, it is expected to have the following form:
In this case, javadoc outputs the text specified by label and encodes it as a hyperlink to the specified feature.
If label is omitted (as it usually is), javadoc uses the name of the specified feature instead.
If the type is specified without its package name, it is resolved as described for typename.
This syntax is ambiguous if the method is overloaded or the class defines a field by the same name.
Use this concise form to refer to other methods in the same class.
This form works with overloaded methods because it lists the types of the method parameters explicitly.
If the type is specified without its package name, it is resolved as described for typename.
Documentation comments for classes, interfaces, methods, constructors, and fields appear in Java source code immediately before the definitions of the features they document.
The package.html file should contain simple HTML documentation for the.
In addition to defining a package.html file for each package, you can also provide high-level documentation for a group of packages by defining an overview.html file in the source tree for those packages.
When javadoc is run over that source tree, it uses overview.html as the highest level overview it displays.
JavaBeans Conventions JavaBeans is a framework for defining reusable modular software components.
The most common use of beans is for graphical user interface components, such as components of the java.awt and javax.swing packages, which are documented in Java Foundation Classes in a Nutshell and Java Swing, both from O’Reilly.
Although all beans can be manipulated visually, this does not mean every bean has its own visual representation.
For example, the javax.sql.RowSet class (documented in O’Reilly’s Java Enterprise in a Nutshell) is a JavaBeans component that represents the data resulting from a database query.
There are no limits on the simplicity or complexity of a JavaBeans component.
The simplest beans are typically basic graphical interface components, such as a java.awt.Button object.
But even complex systems, such as an embeddable spreadsheet application, can function as individual beans.
The JavaBeans component model consists of the java.beans, the java.beans.
These conventions are not part of the JavaBeans API itself but are in many ways more important to bean developers than the API itself.
The conventions are sometimes referred to as design patterns; they specify such things as method names and signatures for property accessor methods defined by a bean.
If the class you are writing is not intended to be a bean, suitable for visual manipulation in a builder tool, you don’t need to follow these conventions.
The JavaBeans conventions are widely used and wellunderstood, however, and you can improve the usability and reusabilty of your code by following the relevant ones.
This is particularly true of the property accessor method naming conventions.
First, however, an overview of the JavaBeans model is in order.
Any object that conforms to certain basic rules can be a bean; there is no Bean class that all beans are required to subclass.
Many beans are GUI components, but it is also quite possible, and often useful, to write “invisible” beans that do not have an onscreen appearance.
A bean is characterized by the properties, events, and methods it exports.
It is these properties, events, and methods that an application designer manipulates in a beanbox tool.
A property is a piece of the bean’s internal state that can be programmatically set and/or queried, usually through a standard pair of get and set accessor methods.
A bean communicates with the application in which it is embedded as well as with other beans by generating events.
The JavaBeans API uses the same event model that AWT and Swing components use.
The model is based on the java.util.EventObject class and the java.util.EventListener interface; it is described in detail in Java Foundation Classes in a Nutshell (O’Reilly)
A bean defines an event if it provides add and remove methods for registering and deregistering listener objects for that event.
An application that wants to be notified when an event of that type occurs uses these methods to register an event listener object of the appropriate type.
When the event occurs, the bean notifies all registered listeners by passing an event object that describes the event to a method defined by the event listener interface.
A unicast event is a rare kind of event for which there can be only a single registered listener object.
The add registration method for a unicast event throws a TooManyListenersException if an attempt is made to register more than a single listener.
The methods exported by a bean are simply any public methods defined by the bean, excluding those methods that get and set property values and register and remove event listeners.
In addition to the regular sort of properties described earlier, the JavaBeans API also supports several specialized property subtypes.
An indexed property is a property that has an array value, as well as getter and setter methods that access both individual elements of the array and the entire array.
A bound property is one that sends a PropertyChangeEvent to any interested PropertyChangeListener objects whenever the value of the property changes.
A constrained property is one that can have any changes vetoed by any interested listener.
When the value of a constrained property of a bean changes, the bean must send out a PropertyChangeEvent to the list of interested VetoableChangeListener objects.
If any of these objects throws a PropertyVetoException, the property value is not changed, and the PropertyVetoException is propagated back to the property setter method.
A bean class itself must adhere to the following conventions:
Class name There are no restrictions on the class name of a bean.
Beans are often AWT or Swing components, but there are no restrictions.
Instantiation A bean should provide a no-parameter constructor so bean manipulation tools can easily instantiate the bean.
A bean defines a property p of type T if it has accessor methods that follow these patterns (if T is boolean, a special form of getter method is allowed):
Exceptions Property accessor methods can throw any type of checked or unchecked exceptions.
An indexed property is a property of array type that provides accessor methods that get and set the entire array as well as methods that get and set individual elements of the array.
Exceptions Indexed property accessor methods can throw any type of checked or unchecked exceptions.
They should throw an ArrayIndexOutOfBoundsException if the supplied index is out of bounds.
A bound property is one that generates a PropertyChangeEvent when its value changes.
Accessor methods The getter and setter methods for a bound property follow the same conventions as a regular property.
Listener registration A bean that defines one or more bound properties must define a pair of methods for the registration of listeners that are notified when any bound property value changes.
Named property listener registration A bean can optionally provide additional methods that allow event listeners to be registered for changes to a single bound property value.
These methods are passed the name of a property and have the following signatures:
Per-property listener registration A bean can optionally provide additional event listener registration methods that are specific to a single property.
For a property p, these methods have the following signatures:
Methods of this type allow a beanbox to distinguish a bound property from an unbound property.
Notification When the value of a bound property changes, the bean should update its internal state to reflect the change and then pass a PropertyChangeEvent to the for the bean or the specific bound property.
Support java.beans.PropertyChangeSupport is a helpful class for implementing bound properties.
A constrained property is one for which any changes can be vetoed by registered listeners.
Getter The getter method for a constrained property is the same as the getter method for a regular property.
Setter The setter method of a constrained property throws a PropertyVetoException if the property change is vetoed.
For a property p of type T, the signature looks like this:
Listener registration A bean that defines one or more constrained properties must define a pair of methods for the registration of listeners that are notified when any.
Named property listener registration A bean can optionally provide additional methods that allow event listeners to be registered for changes to a single constrained property value.
These methods are passed the name of a property and have the following signatures:
Per-property listener registration A bean can optionally provide additional listener registration methods that are specific to a single constrained property.
For a property p, these methods have the following signatures:
Notification When the setter method of a constrained property is invoked, the bean must generate a PropertyChangeEvent that describes the requested change and pass that event to the vetoableChange( ) method of every VetoableChangeListener object registered for the bean or the specific constrained property.
If any listener vetoes the change by throwing a PropertyVetoException, the bean must send out another PropertyChangeEvent to revert the property to its original value.
If, on the other hand, the property change is not vetoed, the bean should update its internal state to reflect the change.
If the constrained property is also a bound property, the bean should notify PropertyChangeListener objects at this point.
Support java.beans.VetoableChangeSupport is a helpful class for implementing constrained properties.
In addition to PropertyChangeEvent events generated when bound and constrained properties are changed, a bean can generate other types of events.
Event class The event class should directly or indirectly extend java.util.EventObject and should be named EEvent.
Listener interface The event must be associated with an event listener interface that extends java.util.EventListener and is named EListener.
Listener methods The event listener interface can define any number of methods that take a single argument of type EEvent and return void.
Listener registration The bean must define a pair of methods for registering event listeners that want to be notified when an E event occurs.
Unicast events A unicast event allows only one listener object to be registered at a single time.
If E is a unicast event, the listener registration method should have this signature:
Sun’s implementation of Java includes a number of tools for Java developers.
Chief among these are the Java interpreter and the Java compiler, of course, but there are a number of others as well.
Notable omissions are the RMI and IDL tools that are specific to enterprise programming and which are documented in Java Enterprise in a Nutshell (O’Reilly)
The tools documented here are part of Sun’s development kit; they are implementation details and not part of the Java specification itself.
If you are using a Java development environment other than Sun’s JDK, you should consult your vendor’s tool documentation.
Some examples in this chapter use Unix conventions for file and path separators.
If Windows is your development platform, change forward slashes in filenames to backward slashes, and colons in path specifications to semicolons.
Any annotations it finds are passed to appropriate annotation processor factory objects, which can use the annotations to produce auxiliary source or resource files based on annotation content.
Annotation processor classes and factory classes are defined with the com.sun.mirror.apt API and other subpackages of com.sun.mirror.
If a command-line argument begins with @, apt treats it as a file and reads options and source files from that specified file.
Description extcheck checks to see if the extension contained in the specified jarfile (or a newer version of that extension) has already been installed on the system.
It does this by reading the Specification-Title and Specification-Version manifest attributes from the specified jarfile and from all of the JAR files found in the system extensions directory.
Without the -verbose option, it does not print the results of its check.
Instead, it sets its exit code to 0 if the specified extension does not conflict with any installed extensions and can be safely installed.
It sets its exit code to a nonzero value if an extension with the same name is already installed and has a specification version number equal to or greater than the version of the specified file.
Lists the installed extensions as they are checked and displays the results of the check.
Description jarsigner adds a digital signature to the specified jarfile, or, if the -verify option is specified, it verifies the digital signature or signatures already attached to the JAR file.
The specified signer is a case-insensitive nickname or alias for the entity whose signature is to be used.
The specified signer name is used to look up the private key that generates the signature.
When you apply your digital signature to a JAR file, you are implicitly vouching for the contents of the archive.
You are offering your personal word that the JAR file contains only nonmalicious code, files that do not violate copyright laws, and so forth.
When you verify a digitally signed JAR file, you can determine who the signer or signers of the file are and (if the verification succeeds) that the contents of the JAR file have not been changed, corrupted, or tampered with since the signature or signatures were applied.
Verifying a digital signature is entirely different from deciding whether or not you trust the person or organization whose signature you verified.
Options jarsigner defines a number of options, many of which specify how a private key is to be found for the specified signer.
Most of these options are unnecessary when using the -verify option to verify a signed JAR file:
Jjavaoption Passes the specified javaoption directly to the Java interpreter.
If this option is not specified, jarsigner prompts you for the password.
This option specifies the filename or URL of the keystore in which the private and public key certificates of the specified signer are looked up.
The default is the file named .keystore in the user’s home directory (the value of the system property user.home)
This is also the default location of the keystore managed by keytool.
If you leave this option unspecified, the base filename is chosen based on the signer name.
If this option is not specified, jarsigner overwrites the jarfile specified on the command line.
If this option is omitted, jarsigner prompts you for the password.
The default is the system-default keystore type, which on most systems is the Java Keystore type, known as JKS.
If you have the Java Cryptography Extension installed, you may want to use a JCEKS keystore instead.
Description jar is a tool that can create and manipulate Java Archive (JAR) files.
A JAR file is a ZIP file that contains Java class files, auxiliary resource files required by those classes, and optional meta-information.
This meta-information includes a manifest file that lists the contents of the JAR archive and provides auxiliary information about each file.
The jar command can create JAR files, list the contents of JAR files, and extract files from a JAR archive.
In Java 1.2 and later, it can also add files to an existing archive or update the manifest file of an archive.
In Java 1.3 and later, jar can also add an index entry to a JAR file.
The syntax of the jar command is reminiscent of the Unix tar (tape archive) command.
Most options to jar are specified as a block of concatenated letters passed as a single argument rather than as individual command-line arguments.
The first letter of the first argument specifies what action jar is to perform; it is required.
The various file arguments depend on which letters are specified.
As in javac, any command-line argument that begins with @ is taken to be the name of a file that contains options or filenames.
Command options The first letter of the first option to jar specifies the basic operation jar is to perform.
A list of input files and/or directories must be specified as the final arguments to jar.
The newly created JAR file has a META-INF/ MANIFEST.MF file as its first entry.
This automatically created manifest lists the contents of the JAR file and contains a message digest for each file.
The resulting index is stored in the JAR file as META-INF/INDEX.LIST and can be used by a Java interpreter or applet viewer to optimize its class and resource lookup algorithm and avoid downloading unnecessary JAR files.
This i option must be followed by the name of the JAR file to be indexed.
Any files listed on the command line are added to the archive.
When used with the m option, this adds the specified manifest information to the JAR file.
The files and directories specified on the command line are extracted and created in the current working directory.
If no file or directory names are specified, all the files and directories in the JAR file are extracted.
Modifier options Each of the four command specifier letters can be followed by additional letters that provide further detail about the operation to be performed:
If this option is not present, jar reads a JAR file from standard input and/or writes a JAR file to standard output.
If the f option is present, the command line must contain the name of the JAR file to operate on.
This default manifest simply lists the contents of the JAR file.
Many JAR files require additional information to be specified in the manifest; the m option tells the jar command that a manifest template is specified on the command line.
This m option should be used only with the c or u commands, not with the t or x commands.
Used with the c and u commands to tell jar to store files in the JAR archive without compressing them.
Note that this option is the digit zero, not the letter O.
Files The first option to jar consists of an initial command letter and various option letters.
This first option is followed by a list of files:
If the first option contains both the letters f and m, the JAR and manifest files should be listed in the same order the f and m options appear.
The manifest-file specified with the m option should contain additional manifest entries to be placed in the manifest in addition to the automatically generated entries.
Additional options In addition to all the options listed previously, jar also supports the following:
The subsequent file and directory names are interpreted relative to dir and are inserted into the JAR archive without dir as a prefix.
Any number of -C options can be used; each remains in effect until the next is encountered.
The directory specified by a -C option is interpreted relative to the current working directory, not the directory specified by the previous -C option.
Examples The jar command has a confusing array of options, but, in most cases, its use is quite simple.
To create a simple JAR file that contains all the class files in the current directory and all files in a subdirectory called images, you can type:
To extract the manifest file from a JAR file for examination or editing:
Description java is the Java byte-code interpreter; it runs Java programs.
The program to be run is the class specified by classname.
This must be a fully qualified name: it must include the package name of the class but not the .class file extension.
The specified class must define a main( ) method with exactly the following signature:
This method serves as the program entry point: the interpreter begins execution here.
In Java 1.2 and later, a program can be packaged in an executable JAR file.
To run a program packaged in this fashion, use the -jar option to specify the JAR file.
The manifest of an executable JAR file must contain a Main-Class attribute that specifies which class within the JAR file contains the main( ) method at which the interpreter is to begin execution.
Any command-line options that precede the name of the class or JAR file to execute are options to the Java interpreter itself.
Any options that follow the class name or JAR filename are options to the program; they are ignored by the Java interpreter and.
The Java interpreter runs until the main( ) method exits, and any threads (except for threads marked as daemon threads) created by the program have also exited.
Interpreter versions The java program is the basic version of the Java interpreter.
In addition to this program, however, there are several other versions of the Java interpreter.
Each of these versions is similar to java but has a specialized function.
This list includes all the interpreter versions, including those that are no longer in use.
Use javaw when you want to run a Java program (from a script, for example) without forcing a console window to appear.
Client or Server VM Sun’s “HotSpot” virtual machine comes in two versions: one is tuned for use with short-lived client applications and one is for use with long-running server code.
As of Java 1.4, you can select the server version of the VM with the -server option.
You can specify the client VM (which is the default) with the -client option.
Very few Java applications needed to use this version of the interpreter, and it was removed in Java 1.4
A JIT converts Java byte codes to native machine instructions at runtime and significantly speeds up the execution of a typical Java program.
If you want to use a different JIT compiler implementation, set the environment variable or system property to the name of the desired implementation.
This environment variable and property are no longer used as of Java 1.4, which uses the HotSpot VM, which includes efficient JIT technology.
To use nonnative, or green, threads (the default), you could specify -green.
Specifying -green or -native in Java 1.3 implicitly specified -classic as well.
These options are no longer supported (or necessary) as of Java 1.4
Common options The following options are the most commonly used.
In Java 1.2 and later, this option specifies only the location of application classes.
Defines propertyname to equal value in the system properties list.
Your Java program can then look up the specified value by its property name.
The manifest of the specified jarfile must which program execution is to begin.
Xbootclasspath:path Specifies a search path consisting of directories, ZIP files, and JAR files the java interpreter should use to look up system classes.
Xbootclasspath/p:path Prepends the specified path to the system boot classpath.
Assertion options The following options specify whether and where assertions are tested.
It is new in Java 1.4 and can be abbreviated -da.
Used alone, it disables all assertions (except those in the system classes), which is the default.
To disable assertions in a single class, follow the option with a colon and the fully qualified class name.
To disable assertions in an entire package (and all of its subpackages), follow this option with a colon, the name of the package, and three dots.
Used alone, it enables all assertions (except in system classes)
To enable assertions in a single class, follow the option with a colon and the full class name.
Performance tuning options The following options select which version of the VM is to be run and fine-tune its memory allocation, garbage collection, and incremental compilation.
Options beginning with -X are nonstandard and may change from release to release.
This option typically defers some compilation to favor quicker application launch times.
This option is valid in Java 1.4 and later but is currently implemented only for Solaris platforms.
This option is valid in Java 1.4 and later but is currently implemented only for Solaris platforms.
In Java 1.3, using this option also selects the -classic option.
Using native threads can be advantageous in some circumstances, such as when running on a multi-CPU computer.
In Java 1.3, the default HotSpot virtual machine uses native threads.
In general, this option results in slower startup time but better subsequent performance.
Xbatch Tells the HotSpot VM to perform all just-in-time compilation in the foreground, regardless of the time required for compilation.
Without this option, the VM compiles methods in the background while interpreting them in the foreground.
In this mode, the garbage collector runs continuously in the background, and a running program is rarely, if ever, subject to noticeable pauses while garbage collection occurs.
Using this option typically results in a 10% decrease in overall performance, however.
Xint Tells the HotSpot VM to operate in interpreted mode only, without performing any just-in-time compilation.
Xmixed Tells the HotSpot VM to perform just-in-time compilation on frequently used methods (“hotspots”) and execute other methods in interpreted mode.
Xms initmem[k|m] Specifies how much memory is allocated for the heap when the interpreter starts up.
You can specify it in kilobytes by appending the letter k or in megabytes by appending the letter m.
For large or memory-intensive applications (such as the Java compiler), you can improve runtime performance by starting the interpreter with a larger amount of memory.
You must specify an initial heap size of at least 1 MB.
Xmxmaxmem[k|m] Specifies the maximum heap size the interpreter uses for dynamically allocated objects and arrays.
You can specify maxmem in kilobytes by appending the letter k and in megabytes by appending the letter m.
You cannot specify a heap size less than 2 MB.
Xsssize[k|m] Sets the thread stack size in bytes, kilobytes, or megabytes.
Instrumentation options The following options support debugging, profiling, and other VM instrumentation.
Options beginning with -X are nonstandard and may change from release to release.
New in Java 5.0, this option specifies a JVMTI agent, and options for it, to be started along with the interpeter.
This means that the general -agentlib option will replace tool-specific options such as -Xdebug and -Xrunhprof.
Like -agentlib, but with an explicitly specified path to the agent library.
In Java 1.2 and later, this option has been replaced with -Xdebug.
The specified jarfile must have a manifest that includes an Agent-Class attribute.
This options will be passed to this premain( ) method along with a java.lang.
In Java 1.2 and later, you can use -verbose:class as a synonym.
Xdebug Starts the interpreter in a way that allows a debugger to communicate with it.
Deprecated in Java 5.0 in favor of the -agentlib option.
Xfuture Strictly checks the format of all class files loaded.
Without this option, java performs the same checks that were performed in Java 1.1
Xloggc:filename Logs garbage collection events with timestamps to the named file.
In Java 1.2, or when using the -classic option, use -Xrunhprof.
Deprecated in Java 5.0 in favor of the -agentlib option.
Advanced options The Java interpreter also supports quite a few advanced configuration options that begin with -XX.
Loading classes The Java interpreter knows where to find the system classes that comprise the Java platform.
In Java 1.2 and later, it also knows where to find the class files for all extensions installed in the system extensions directory.
However, the interpreter must be told where to find the nonsystem classes that comprise the application to be run.
Class files are stored in a directory that corresponds to their package name.
For example, the class com.davidflanagan.utils.Util is stored in a file com/davidflanagan/ utils/Util.class.
By default, the interpreter uses the current working directory as the root and looks for all classes in and beneath this directory.
The interpreter can also search for classes within ZIP and JAR files.
To tell the interpreter where to look for classes, you specify a classpath: a list of directories and ZIP and JAR archives.
When looking for a class, the interpreter searches each of the specified locations in the order in which they are specified.
The easiest way to specify a classpath is to set the CLASSPATH environment variable, which works much like the PATH variable used by a Unix shell or a Windows command-interpreter path.
To specify a classpath in Unix, you might type a command like this:
On a Windows system, you might use a command like the following:
Note that Unix and Windows use different characters to separate directory and path components.
You can also specify a classpath with the -classpath or -cp options to the Java interpreter.
A path specified with one of these options overrides any path specified by the CLASSPATH environment variable.
In Java 1.2 and later, the -classpath option specifies only the search path for application and user classes.
Prior to Java 1.2, or when using the oldjava interpreter, this option specified the search path for all classes, including system classes and extension classes.
Description javac is the Java compiler; it compiles Java source code (in .java files) into Java byte codes (in .class files)
Each source file can contain any number of classes, although only one can be a public top-level class.
The name of the source file (minus the .java extension) must match the name of the public class it contains.
Thus, if you keep a list of Java source files for a particular project in a file named project.list, you can compile all those files at once with the command:
To compile a source file, javac must be able to find definitions of all classes used in the source file.
It looks for definitions in both source-file and class-file form, automatically compiling any source files that have no corresponding class files or that have been modified since they were most recently compiled.
Common options The most commonly used compilation options include the following:
This option overrides any path specified by the CLASSPATH environment variable.
The path specified is an ordered list of directories, ZIP files, and JAR archives, separated by colons on Unix systems or semicolons on Windows systems.
If the -sourcepath option is not set, this option also specifies the search path for source files.
By default, javac stores the .class files it generates in the same directory as the .java files those classes were defined in.
If the -d option is specified, however, the specified directory is treated as the root of the class hierarchy, and .class files are placed in this directory or the appropriate subdirectory below it, depending on the package name of the class.
On the other hand, if the source file specifies that it is in a package:
When the -d option is specified, javac automatically creates any directories it needs to store its class files in the appropriate place.
The valid keywords are: source, which specifies sourcefile information; lines, which specifies line number information; and vars, which specifies local variable debugging information.
Jjavaoption Passes the argument javaoption directly through to the Java interpreter.
The files found in this source path are compiled if no corresponding class files are found or if the source files are newer than the class files.
By default, source files are searched for in the same places class files are searched for.
In particular, it causes javac to list all the source files it compiles, including files that did not appear on the command line.
Warning options The following options control the generation of warning messages by javac:
By default, javac issues only a single warning for each source file that uses deprecated APIs.
Xlint Enables all recommended warnings about program “lint.” At the time of this writing, all the warnings detailed below are recommended.
Xlint:warnings Enables or disables a comma-separated list of named warning types.
At the time of this writing, the available warning types are the following.
A named warning can be suppressed by preceding it with a minus sign:
Tells javac to send warning and error messages to the specified file instead of writing them to the console.
Cross-compilation options The following options are useful when using javac to compile class files intended to run under a different version of Java:
This option does not specify the system classes used to run the compiler itself, only the system classes read by the compiler.
Use of this flag sets the class file version number so that the resulting class file cannot be run by VMs from previous releases.
Specifies an ordered list (colon-separated on Unix, semicolon-separated on Windows systems) of directories, ZIP files, and JAR archives in which javac should look for user class files and source files.
Description javadoc generates API documentation for any number of packages and classes you specify.
The javadoc command line can list any number of package names and any number of Java source files.
For convenience, when working with a large number of command-line options, or a large number of package or class names, you can place them all in an auxiliary file and specify the name of that file on the command line, preceded by an @ character.
It uses the information it gleans from this processing to generate detailed API documentation.
Most importantly, the generated documentation includes the contents of all documentation comments included in the source files.
See Chapter 7 for information about writing doc comments in your own Java code.
When you specify a Java source file for javadoc to process, you must specify the name of the file that contains the source, including a complete path to the file.
It is more common, however, to use javadoc to create documentation for entire packages of classes.
When you specify a package for javadoc to process, you specify the package name, not the directory that contains the source code for the package.
In this case, you may need to specify the -sourcepath option so that javadoc can find your package source code correctly if it is not stored in a location already listed in your default classpath.
You can write your own doclets using the doclet API defined by the com.sun.javadoc bundle for Java 1.2 and later.
Here we document Java 1.2 and later versions of the program and do not distinguish these features from those in previous versions.
Some are standard options that are always recognized by javadoc.
Other options are defined by the doclet that produces the.
The options for the standard HTML doclet are included in the following list:
This depends on the encoding used in the documentation comments of your source code, of course.
The encoding value is used in a <meta> tag in the HTML output.
Because javadoc uses the javac compiler, it needs to be able to locate class files for all classes referenced by the packages being documented.
See java and javac for more information about this option and the default value provided by the CLASSPATH environment variable.
If this option is omitted, the current directory is used.
The name of the encoding specified here may not exactly match the name of the charset specified with the -charset option.
If this option is not specified, javadoc generates documentation using the default HTML doclet.
This file is often the first thing readers see when they browse the generated documentation.
This can be different from the desired output encoding specified by -docencoding.
This is useful for excluding version control directories, for example.
By default, these packages are listed in alphabetical order in a single table.
You can break them into groups of related packages with this option, however.
The javadoc command line can contain any number of -group options.
If this option is not specified, javadoc creates a default help file.
Jjavaoption Passes the argument javaoption directly through to the Java interpreter.
When processing a large number of packages, you may need to use this option to increase the amount of memory javadoc is allowed to use.
Note that because -J options are passed directly to the Java interpreter before javadoc starts up, they cannot be included in an external file specified on the command line with the @list syntax.
For example, when using javadoc to produce documentation for your own packages, you can use this option to link your documentation to the javadoc documentation for the core Java APIs.
The directory specified by url must contain a file named package-list, and javadoc must be able to read this file at runtime.
This file is automatically generated by a previous run of javadoc; it contains a list of all packages documented at the url.
More than one -link option can be specified, although this does not work properly in early releases of Java 1.2
If no -link option is specified, references in the generated documentation to classes and members that are external to the documentation are not hyperlinked.
This is useful when the directory specified by url does not have a package-list file or when that file is not available when javadoc is run.
This is used to look up a resource file that contains localized messages and text for the output files.
Otherwise, the single index file generated by javadoc will be too large to be useful.
Using this option is often easier than explicitly listing all desired.
This enables the use of simple custom tags (with the same syntax as @return and of doc comments in which this custom tag is allowed.
The characters and their meanings are a (all: valid everywhere), p (packages), t (types: classes and interfaces), c (constructors), m (methods), and f (fields)
A secondary purpose of the -tag option is to specify the order in which tags are processed and in which their output appears.
You can include the names of standard tags after the -tag option to specify this ordering.
Custom tags and taglets can be included within this list of standard -tag options.
This option does not tell javadoc to print its own version number.
This title typically appears as the title of the web browser window and in history and bookmark lists.
This environment variable specifies the default classpath javadoc uses to find the class files and source files.
See java and javac for further discussion of the classpath.
Description javah generates C header and source files (.h and .c files) that are used when implementing Java native methods in C.
In Java 1.1 and earlier, javah generated files for oldstyle native methods.
In Java 1.1, the -jni option specified that javah should generate new-style files.
In Java 1.2 and later, this option is the default.
A full description of how to implement Java native methods in C is beyond the scope of this book.
This option overrides any path specified by the CLASSPATH environment variable.
Prior to Java 1.2, this option can specify the location of the system classes and extensions.
In Java 1.2 and later, it specifies only the location of application classes.
This option is the default in Java 1.2 and later.
This option is only for the Java 1.0 native methods interface.
In Java 1.2 and later, this option is obsolete and has been removed.
In its place, you can use the -verbose:jni option of the Java interpreter.
Causes javah to print messages about what it is doing.
Specifies the default classpath javah searches to find the specified classes.
Description javap reads the class files specified by the class names on the command line and prints a human-readable version of the API defined by those classes.
Enables backward compatibility with the output of the Java 1.1 version of javap.
This option exists for programs that depend on the precise output format of javap.
This option always disassembles all methods, regardless of their visibility level.
This option overrides the path specified by the CLASSPATH environment variable.
Prior to Java 1.2, this argument specifies the path for all system classes, extensions, and application classes.
In Java 1.2 and later, it specifies only the application classpath.
See java and javac for more information on the classpath.
This option is typically useful only when used with -c.
The javac compiler does not include local variable information in its class files by default.
Jjavaoption Passes the specified javaoption directly to the Java interpreter.
Outputs additional information (in the form of Java comments) about each member of each specified class.
Description javaws is the command-line interface to the Java Web Start network application launcher.
When started without a url, javaws displays a graphical cache viewer which allows cached applications to be launched and Java Web Start to be configured.
If the URL of a JNLP (Java Network Launching Protocol) is specified on the command line, javaws launches the specified application.
Allows the creation of file associations during a -silent -import.
This is the default behavior if javaws is invoked with no arguments.
Description jconsole is a graphical interface to the memory, thread, class loading, and other monitoring tools provided by the java.lang.management package.
It can monitor one or more local or remote Java processes.
Processes can be monitored only if started with special system properties set.
To allow a Java VM to be monitored locally, start it with:
To allow a Java VM to be monitored remotely, start it with:
You may start jconsole with no local or remote process specified and use its Connection menu to establish connections.
This is the only way to connect jconsole to more than one Java process.
To connect jconsole to a local process when it starts up, simply list the process id on the command line.
To connect jconsole to a remote process when it starts up, specify the hostname and port number on the command line.
The port should be the same as that specified by the com.sun.management.jmxremote.port system property of the target process.
It is text-based, command-line-oriented, and has a command syntax like that of the Unix dbx or gdb debuggers used with C and C++ programs.
When jdb is invoked with the name of a Java class, it starts another copy of the java interpreter, using any interpreter options specified on the command line.
The new interpreter is started with special options that enable it to communicate with jdb.
The new interpreter loads the specified class file and then stops and waits for debugging commands before executing the first byte code.
Doing so requires that special options be passed to both the java interpreter and to jdb.
You can refer to classes by name, with or without their package names.
You can also refer to static class members by name.
You can refer to individual objects by object ID, which is an eightdigit hexadecimal integer.
Or, when the classes you are debugging contain local variable information, you can often use local variable names to refer to objects.
You can use normal Java syntax to refer to the fields of an object and the elements of an array; you can also use this syntax to write quite complex expressions.
As of Java 1.3, jdb even supports method invocation using standard Java syntax.
Options When invoking jdb with a specified class file, any of the java interpreter options can be specified.
See the java reference page for an explanation of these options.
In order to use jdb to connect to a running VM in this way, the VM must have been started with special command-line options.
The Java debugging architecture allows a complex set of interpreter-to-debugger connection options, and java and jdb provide a complex set of options and suboptions to enable it.
A detailed description of those options is beyond the scope of this book.
Specify the name of a connector (a Java class) form.
This avoids the need to explicitly use the run command to start it.
Each connector is a Java class and a list of arguments.
To make this work, the VM must be with options like these:
A shorthand command that is replaced with the text of the last command entered.
It can be followed with additional text to append to that command.
If no exception is specified, the command lists the exceptions currently being caught.
This command should be used when the current thread is stopped at a breakpoint.
Prints the value of all fields of the specified object or objects.
If you specify the name of a class, dump displays all class (static) methods and variables of the class and also displays the superclass and list of implemented interfaces.
Objects and classes can be specified by name or by their eight-digit hexadecimal ID numbers.
This command does not cause the Java interpreter to ignore exceptions; it merely tells jdb to ignore them.
If no line number is specified, uses the line number of the current stack frame of the current thread.
The lines listed are from the source file of the current stack frame of the current thread.
Use the use command to tell jdb where to find source files.
Java code must be compiled with the -g option in order to contain local variable information.
Use dump to list the instance variables of an object or the class (static) variables of a class.
Each item can be a class, object, field, or local variable, and can be specified by name or by eight-digit hexadecimal ID number.
You can also refer to threads with the special syntax t@thread-number.
If no threads are specified, all suspended threads are resumed.
If no class or arguments are specified, uses the class and arguments specified on the jdb command line.
If the line invokes a method, steps into that method and stops.
This thread is used implicitly by a number of other jdb commands.
If no thread group is specified, lists all threads in the current thread group (specified by threadgroup)
If no path is specified, displays the current source path.
If no thread is specified, displays a stack trace for the current thread.
If all is specified, displays a stack trace for all threads.
Specifies an ordered list (colon-separated on Unix, semicolon-separated on Windows systems) of directories, ZIP files, and JAR archives in which jdb should look for class definitions.
When a path is specified with this environment variable, jdb always implicitly appends the location of the system classes to the end of the path.
If this environment variable is not specified, the default path is the current directory and the system classes.
Description jinfo prints the system properties and JVM command-line options for a running Java process or core file.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name.
In Java 5.0, jinfo is experimental, unsupported, and not available on all platforms.
Options These options are mutually exclusive; only one may be specified.
Description jmap prints memory usage information for a local or remote Java process or a Java core file.
Depending on the option it is invoked with, jmap displays one of four memory usage reports.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name and @ sign.
In Java 5.0, jmap is experimental, unsupported, and not available on all platforms.
Options When invoked with no options, jmap prints a memory map of the shared objects or libraries loaded by the VM.
Other reports can be produced by using the options below.
These options are mutually exclusive; only one may be specified.
Description jps lists the Java processes running on the local host or on the specified remote host.
If a remote host is specified, it must be running the jstatd daemon.
For each Java process, it displays a process id and names the class or JAR file that the process is executing.
Process ids are used by a number of other Java tools, such as jconsole, jstat, and jmap.
The single-letter options, except for -q, may be combined into a single command-line argument, such as -lmv:
Description jsadebugd is a server process that allows remote invocations of jinfo, jmap, and jstack on a local Java process or core file.
Invoke jsadebugd by specifying either the process id of a running Java process or an executable file and core file pair on the command line.
If more than one jsadebugd server will run on the same host at the same time, follow these arguments with an identifying process name that remote clients can use to identify the desired process.
In Java 5.0, jsadebugd is experimental, unsupported, and not available on all platforms.
Description jstack prints stack traces for each of the Java threads running in the specified Java process.
Specify the process id of a Java process running locally to obtain configuration information about it.
To obtain post-mortem configuration information from a core file, specify the Java executable that produced the core file and the core file itself on the command line.
To obtain configuration information about a Java process running remotely, specify the name of the remote host, optionally prefixed by a remote process name and @ sign.
In Java 5.0, jstack is experimental, unsupported, and not available on all platforms.
Without this option, the default is to display Java stack frames only.
Description jstat probes a running JVM once or repeatedly and displays statistics about its class loading, just-in-time compilation, memory, or garbage collection performance.
The type of information to be displayed is specified by options.
A local process to be probed is specified by its process id, as returned, for example, by jps.
A remote Java process may be probed by specifying the remote process id, the remote host name, and the port number on which the remote host’s rmiregistry server is running (if other than the default of 1099)
The remote host must also be running the jstatd server.
You may also specify a probe interval, in milliseconds or seconds, to have it probe repeatedly.
If you do this, you may additionally specify a total number of probes it should conduct.
In Java 5.0, jinfo is experimental, unsupported, and not available on all platforms.
You must use one of the listed options each time you run jstat.
This option must follow one of the report type options below.
The column displays elapsed time (in seconds) since the target Java process was started.
The following options specify the type of statistics to be reported by jstat.
Unless you run jstat with -help, -options or -version, you must specify exactly one of these options, and it must be the first option on the command line.
Most of the options produce detailed reports of garbage collection minutiae.
Consult Sun’s tool documentation (part of the JDK documentation bundle) for the interpretation of these reports.
Description jstatd is a server that provides information about local Java processes to the jps and jstat programs running on remote hosts.
To start jstatd, create the following file and name it jstatd.policy:
This policy grants all permissions to any class loaded from the JDK’s tools.jar JAR file.
To launch jstatd with this policy, use this command line:
If an existing rmiregistry server is running, jstatd uses it.
Binds the jstatd remote object to the name rminame in the RMI registry.
The default name is “JStatRemoteHost”, which is what jps and jstat look for.
Use of this option requires rminame to be used in remote jps and jstat invocations.
Description keytool manages and manipulates a keystore, a repository for public and private keys and public key certificates.
The first option to keytool always specifies the basic command to be performed.
Subsequent options provide details about how the command is to be performed.
If a command requires an option that does not have a default value, keytool prompts you interactively for the value.
Generates a certificate signing request in PKCS#10 format for the specified alias.
The request is written to the specified file or to the standard output stream.
The request should be sent to a certificate authority (CA), which authenticates the requestor and sends back a signed certificate authenticating the requestor’s the -import command.
This command uses the following options: -alias, -file, -keypass, -keystore, -sigalg, -storepass, -storetype, and -v.
This command uses the following options: -alias, -keystore, -storepass, -storetype, and -v.
This command uses the following options: -alias, -file, -keystore, -rfc, -storepass, -storetype, and -v.
This command uses the following options: -alias, -dname, -keyalg, -keypass, -keysize, -keystore, -sigalg, -storepass, -storetype, -v, and -validity.
The identity database is read from the specified file or from standard input if no file is specified.
The keys and certificates are written into the specified keystore file, which is automatically created if it does not exist yet.
This command uses the following options: -file, -keystore, -storepass, -storetype, and -v.
This command uses the following options: -alias, -file, -keypass, -keystore, -noprompt, -storepass, -storetype, -trustcacerts, and -v.
This command uses the following options: -alias, -dest, -keypass, -keystore, -new, -storepass, -storetype, and -v.
This command uses the following options: -alias, -keypass, -new, -storetype, and -v.
With the -v option, prints certificate details in human-readable format.
With -rfc, prints certificate contents in a machine-readable, printableencoding format.
This command uses the following options: -alias, -keystore, -rfc, -storepass, -storetype, and -v.
Unlike most keytool commands, this one does not use a keystore.
This command uses the following options: -alias, -dname, -keypass, -keystore, -sigalg, -storepass, -storetype, -v, and -validity.
The new password must be at least six characters long.
This command uses the following options: -keystore, -new, -storepass, -storetype, and -v.
Options The various keytool commands can be passed various options from the following list.
A distinguished name is a highly qualified name intended to be globally unique.
The -genkey command of keytool prompts for a distinguished name if none is specified.
The -selfcert command uses the distinguished name of the current certificate if no replacement name is specified.
If left unspecified, keytool reads from the standard input or writes to the standard output.
In the default Java implementation shipped from Sun, the only supported algorithm is “DSA”; this is the default if this option is omitted.
If this option is unspecified, keytool first tries the -storepass password.
If that does not work, it prompts for the appropriate password.
If unspecified, a file named .keystore in the user’s home directory is used.
If unspecified, keytool prompts for the value of this option.
If this option is not specified, the -import command prompts the user.
If this option is not specified, -export outputs the certificate in binary format, and -list lists only the certificate fingerprint.
This option cannot be combined with -v in the -list command.
If omitted, the default for this option depends on the type of underlying public key.
If it is a DSA key, the default algorithm is “SHA1withDSA”
If the key is an RSA key, the default signature algorithm is “MD5withRSA”
This password also serves as a default password for any private keys that do not have their own -keypass specified.
If this option is not specified, the default is taken from the system security properties file.
This is helpful when you must edit a file of Java code but do not have an editor that can handle the encoding of the file.
If unspecified, standard input and standard output are used, making native2ascii suitable for use in pipes.
If this option is not specified, the encoding is taken from the file.encoding system property.
Notice that the output file is specified on the command line before the input JAR file.
Basic options All pack200 options exist in both a long form that begins with a double dash and a single-letter form that begins with a single dash.
When the option requires a value, the value should be separated from the long form of the option with an equals sign and no space or should immediately follow the short form with no intervening space or punctuation.
Specifies how hard to try to pack the JAR file.
Use this option if you want to apply a different compression filter, such as bzip2
If file ends with a /, all files in the directory are passed through without packing.
In this case, the outputfile specified on the command line should be the name of a JAR file.
It is because the pack/unpack cycle reorders some internal elements of a class file and invalidates any digital signatures or checksums in the JAR file manifest.
This makes it harder to debug the resulting JAR file.
Advanced packing options The following options provide fine control over the compression performed by pack200
Specifies whether pack200 should preserve the deflation status of each entry in the input JAR file.
A value of true places a hint in the packed archive that the unpacker should deflate all entries after unpacking them.
A value of true places a hint in the packed archive that the unpacker should store each entry in the JAR file without deflation.
Using a value of true or false reduces the packed file size slightly because deflation hints do not need to be stored for each entry.
With the default value of keep, pack200 transmits the modification time of each entry in the JAR file.
If you specify latest instead, only the most recent modification time is transmitted, and is applied to all entries when they are unpacked.
Pack200 files may be divided into separately packed segments in order to reduce the amount of memory required by the unpacker.
Larger segment sizes result in better compression ratios, but require additional memory to unpack.
The default action is pass, which specifies that the entire class file will be transmitted with no compression.
An action of error specifies that pack200 should produce an error message.
An action of strip says that the attribute should be stripped from the class file.
These four options specify how pack200 should handle specific named class, field, method, and code attributes in a class file.
The action may be any of the pass, strip, and error values supported by the --unknown-attribute option.
See the Pack200 specification for details on the layout language.
These options may be repeated to specify handling for more than one attribute.
Description policytool displays a Swing user interface that makes it easy to edit security policy configuration files.
The Java security architecture is based on policy files, which specify sets of permissions to be granted to code from various sources.
By default, the Java security policy is defined by a system policy file stored in the jre/lib/security/java.policy file and a user policy file stored in the .java.policy file in the user’s home directory.
System administrators and users can edit these files with a text editor, but the syntax of the file is somewhat complex, so it is usually easier to use policytool to define and edit security policies.
Selecting the policy file to edit When policytool starts up, it opens the .java.policy file in the user’s home directory by default.
Use the New, Open, and Save commands in the File menu to create a new policy file, open an existing file, and save an edited file, respectively.
Editing the policy file The main policytool window displays a list of the entries contained in the policy file.
Each entry specifies a code source and the permissions that are to be granted to code from that source.
The window also contains buttons that allow you to add a new entry, edit an existing entry, or delete an entry from the policy file.
If you add or edit an entry, policytool opens a new window that displays the details of that policy entry.
With the addition of the JAAS API to the core Java platform in Java 1.4, policytool allows the specification of a Principal to whom a set of permissions is granted.
Every policy file has an associated keystore from which it obtains the certificates it needs when verifying the digital signatures of Java code.
You can usually rely on the default keystore, but if you need to specify the keystore explicitly for a policy file, use the Change Keystore command in the Edit menu of the main policytool window.
Adding or editing a policy entry The policy entry editor window displays the code source for the policy entry and a list of permissions associated with that code source.
It also contains buttons that allow you to add a new permission, delete a permission, or edit an existing permission.
When defining a new policy entry, the first step is to specify the code source.
A code source is defined by a URL from which the code is downloaded and/or a list of digital signatures that must appear on the code.
Specify one or both of these values by typing in a URL and/or a comma-separated list of aliases.
These aliases identify trusted certificates in the keystore associated with the policy file.
After you have defined the code source for a policy entry, you must define the permissions to be granted to code from that source.
Use the Add Permission and Edit Permission buttons to add and edit permissions.
Defining a permission To define a permission in the permission editor window, first select the desired permission type from the Permission pulldown menu, then select an appropriate target value from the Target Name menu.
The choices in this menu are customized depending on the permission type you selected.
Some types of permissions, such as FilePermission, do not have a fixed set of possible targets, and you usually have to type in the target you want.
See the documentation of the individual Permission classes for a description of the targets they support.
Depending on the type of permission you select, you may also have to select one or more action values from the Actions menu.
When you have selected a permission and appropriate target and action values, click the Okay button to dismiss the window.
Description serialver displays the version number of a class or classes.
This version number is used for the purposes of serialization: the version number must change each time the serialization format of the class changes.
If the specified class declares a long serialVersionUID constant, the value of that field is displayed.
Otherwise, a unique version number is computed by applying the Secure Hash Algorithm (SHA) to the API defined by the class.
This program is primarily useful for computing an initial unique version number for a class, which is then declared as a constant in the class.
The output of serialver is a line of legal Java code, suitable for pasting into a class definition.
When using -show, no class names can be specified on the command line.
The specified classes are looked up relative to this classpath.
Specify the name of the packed file and the name of the JAR file to unpack it to on the command line.
Because unpack200 is used as part of the Java installation process, it is a native application that can run on a system without a Java interpreter.
Options All unpack200 options exist in both a long form that begins with a double dash and a single-letter form that begins with a single dash.
When the option requires a value, the value should be separated from the long form of the option with an equals sign and no space or should immediately follow the short form with no intervening space or punctuation.
Specifies whether unpack200 should compress individual entries in the resulting JAR file.
The default is keep, which specifies that each JAR entry should have the same compression that it had in the original JAR file.
Part II provides quick-reference material for the essential APIs of the Java platform.
Please read the following section, How to Use This Quick Reference, to learn how to get the most out of this material.
The quick-reference section that follows packs a lot of information into a small space.
This introduction explains how to get the most out of that information.
It describes how the quick reference is organized and how to read the individual quick-reference entries.
Finding a Quick-Reference Entry The quick reference is organized into chapters, each of which documents a single alphabetically within and between chapters, so you never really need to know which chapter documents which package: you can simply search alphabetically, as you might do in a dictionary.
The documentation for each package begins with a quick-reference entry for the package itself.
This entry includes a short overview of the package and a listing of the classes and interfaces included in the by general category (interfaces, eumerated types, classes and exceptions, for example)
Within each category, they are grouped by class hierarchy, with indentation to indicate the level of the hierarchy.
Finally, classes and interfaces at the same hierarchy level are listed alphabetically.
Each package overview is followed by individual quick-reference entries, in alphabetical order, for the types defined in the package.
The overall organization of the quick-reference is therefore alphabetical by the fully-qualified name of the type.
To look up a quick-reference entry for a particular type, you must also know the name of the package that defines that type.
Use the dictionary-style headers on the upper corner of each page to help you quickly find the package and class you need.
Usually, the package name of a type is obvious from its context, and you should have no trouble looking up the quick-reference entry you want.
Occasionally, you may need to look up a type for which you do not already know the package.
This index allows you to look up a class by class name and find out what package it is part of.
Reading a Quick-Reference Entry The quick-reference entries for classes and interfaces contain quite a bit of information.
The sections that follow describe the structure of a quick-reference entry, explaining what information is available, where it is found, and what it means.
While reading the descriptions that follow, you may find it helpful to flip through the reference section itself to find examples of the features being described.
Each quick-reference entry begins with a four-part title that specifies the name, left of the title.
The package name appears, in smaller print, in the lower left, below the class name.
The upper-right portion of the title indicates the availability of the class; it specifies the earliest release that contained the class.
The availability section of the title is also used to indicate whether a class has been deprecated, and, if so, in what release.
In the lower-right corner of the title you may find a list of flags that describe the class.
Java 5.0 annotations and meta-annotations are listed here, as are the following flags:
In other words, it must be declared in the throws clause of any method that may throw it.
The title of each quick-reference entry is followed by a short description of the most important features of the class or interface.
If a class or interface has a nontrivial class hierarchy, the “Description” section is followed by a figure that illustrates the hierarchy and helps you understand the class in the context of that hierarchy.
The name of each class or interface in the diagram appears in a box; classes and enumerated types appear in rectangles (except for abstract classes, which appear in skewed rectangles or parallelograms)
Interfaces and annotation types appear in rounded rectangles, in which the corners have been replaced by arcs.
The superclass-to-subclass hierarchy reads from left to right in the top row (or only row) of boxes in the figure.
Interfaces are usually positioned beneath the classes that implement them, although in simple cases an interface is sometimes positioned on the same line as the class that implements it, resulting in a more compact figure.
Note that the hierarchy figure shows only the superclasses of a class.
If a class has subclasses, those are listed in the cross-reference section at the end of the quick-reference entry for the class.
The most important part of every quick-reference entry is the synopsis, which follows the title and description.
The synopsis for a type looks a lot like the source code for the type, except that the method bodies are omitted and some additional.
If you know Java syntax, you know how to read the synopsis.
The first line of the synopsis contains information about the class itself.
It begins with a list of modifiers, such as public, abstract, and final.
These modifiers are followed by the class, interface, enum, or @interface keyword and then by the name of the class.
The class name may be followed by type variables, an extends clause that specifies the superclass, and an implements clause that specifies any interfaces the class implements.
The class definition line is followed by a list of the fields, methods, and nested types that the class defines.
Once again, if you understand basic Java syntax, you should have no trouble making sense of these lines.
The listing for each member includes the modifiers, type, and name of the member.
For methods, the synopsis also includes the type and name of each method parameter and an optional throws clause that lists the exceptions the method can throw.
The member names are in boldface, so it is easy to scan the list of members looking for the one you want.
The names of method parameters are in italics to indicate that they are not to be used literally.
The member listings are printed on alternating gray and white backgrounds to keep them visually separate.
Each member listing is a single line that defines the API for that member.
These listings use Java syntax, so their meaning is immediately clear to any Java programmer.
There is some auxiliary information associated with each member synopsis that requires explanation, however.
Recall that each quick-reference entry begins with a title section that includes the release in which the class was first defined.
When a member is introduced into a class after the initial release of the class, the version in which the member was introduced appears, in small print, to the left of the member synopsis.
Furthermore, if a member has been deprecated, that fact is indicated with a hash mark (#) to the left of the member synopsis.
The area to the right of the member synopsis is used to display a variety of flags that provide additional information about the member.
Some of these flags indicate additional specification details that do not appear in the member API itself.
This information can be quite useful in understanding the class and in debugging your code, but be aware that it may differ between implementations.
The implementation-specific flags displayed in this book are based on Sun’s Linux implementation of Java.
The following flags may be displayed to the right of a member synopsis:
Although native is a Java keyword and can appear in method.
Therefore, this information is included with the member flags, rather than as part of the member listing.
This flag is useful as a hint about the expected performance of a method.
Like the native keyword, the synchronized keyword is part of the method implementation, not part of the specification, so it appears as a flag, not in the method synopsis itself.
This flag is a useful hint that the method is probably implemented in a threadsafe manner.
Whether or not a method is thread-safe is part of the method specification, and this information should appear (although it often does not) in the method documentation.
There are a number of different ways to make a method threadsafe, however, and declaring the method with the synchronized keyword is only one possible implementation.
In other words, a method that does not bear the synchronized flag can still be threadsafe.
Overrides: This flag indicates that a method overrides a method in one of its superclasses.
The flag is followed by the name of the superclass that the method overrides.
As we’ll see in the next section, overriding methods are usually grouped together in their own section of the class synopsis.
The Overrides: flag is only used when an overriding method is not grouped in that way.
Implements: This flag indicates that a method implements a method in an interface.
The flag is followed by the name of the interface that is implemented.
As we’ll see in the next section, methods that implement an interface are usually grouped into a special section of the class synopsis.
The Implements: flag is only used for methods that are not grouped in this way.
This can be a hint to the programmer that the method may need to be overridden in a subclass.
Only methods with a void return type can be truly empty.
Any method declared to return a value must have at least a return statement.
The constant flag indicates that the method implementation is empty except for a return statement that returns a constant value.
Such a method might have a body like return null; or return false;
Like the empty flag, this flag may indicate that a method needs to be overridden.
The flag is followed by the default value of the property.
In practice, however, these defaults are not always documented, and care should be taken, because the default values may change between implementations.
A default value is determined by dynamically loading the class in question, instantiating it using a no-argument constructor, and then calling the method to find out what it returns.
This technique can be used only on classes that can be dynamically loaded and instantiated and that have no-argument constructors, so default values are shown for those classes only.
Furthermore, note that when a class is instantiated using a different constructor, the default values for its properties may be different.
Only constants of primitive and String types and constants with the value null are displayed.
Some constant values are specification details, while others are implementation details.
The reason that symbolic constants are defined, however, is so you can write code that does not rely directly upon the constant value.
Use this flag to help you understand the class, but do not rely upon the constant values in your own programs.
Within a class synopsis, the members are not listed in strict alphabetical order.
Instead, they are broken down into functional groups and listed alphabetically within each group.
Constructors, methods, fields, and inner classes are all listed separately.
Grouping members by category breaks a class down into smaller, more comprehensible segments, making the class easier to understand.
This grouping also makes it easier for you to find a desired member.
Functional groups are separated from each other in a class synopsis with Java comments, such as // Public Constructors, // Inner Classes, and // Methods Implementing DataInput.
The various functional categories are as follows (in the order in which they appear in a class synopsis):
Public constructors and protected constructors are displayed separately in subgroupings.
If a class defines no constructor at all, the Java compiler adds a default no-argument constructor that is displayed here.
Constructors are listed first because the first thing you do with most classes is instantiate them by calling a constructor.
Constants Displays all of the constants (i.e., fields that are declared static and final) defined by the class.
Constants are listed here, near the top of the class synopsis,
Inner classes Groups all of the inner classes and interfaces defined by the class or interface.
Each inner class also has its own quick-reference entry that includes a full class synopsis for the inner class.
Like constants, inner classes are listed near the top of the class synopsis because they are often used by a number of other members of the class.
Static methods Lists the static methods (class methods) of the class, broken down into subgroups for public static methods and protected static methods.
Event listener registration methods Lists the public instance methods that register and deregister event listener objects with the class.
The methods are typically defined in pairs, so the pairs are listed together.
The methods are listed alphabetically by event name rather than by method name.
Public instance methods Contains all of the public instance methods that are not grouped elsewhere.
Implementing methods Groups the methods that implement the same interface.
There is one subgroup for each interface implemented by the class.
Methods that are defined by the same interface are almost always related to each other, so this is a useful functional grouping of methods.
Overriding methods Groups the methods that override methods of a superclass broken down into subgroups by superclass.
This is typically a useful grouping, because it helps to make it clear how a class modifies the default behavior of its superclasses.
In practice, it is also often true that methods that override the same superclass are functionally related to each other.
Protected instance methods Contains all of the protected instance methods that are not grouped elsewhere.
Fields Lists all the nonconstant fields of the class, breaking them down into subgroups for public and protected static fields and public and protected instance fields.
For those that do, many object-oriented programmers prefer not to use those fields directly, but instead to use accessor methods when such methods are available.
Deprecated members Deprecated methods and deprecated fields are grouped at the very bottom of the class synopsis.
The synopsis section of a quick-reference entry is followed by a number of optional cross-reference sections that indicate other, related classes and methods that may be of interest.
Subclasses This section lists the subclasses of this class, if there are any.
Passed To This section lists all of the methods and constructors that are passed an object of this type as an argument.
This is useful when you have an object of a given type and want to figure out what you can do with it.
Methods defined by this type itself are not included in the list.
Returned By This section lists all of the methods (but not constructors) that return an object of this type.
This is useful when you know that you want to work with an object of this type, but don’t know how to obtain one.
Thrown By For checked exception classes, this section lists all of the methods and constructors that throw exceptions of this type.
This material helps you figure out when a given exception or error may be thrown.
Note, however, that this section is based on the exception types listed in the throws clauses of methods and constructors.
Subclasses of RuntimeException and Error do not have to be listed in throws clauses, so it is not possible to generate a complete cross-reference of methods that throw these types of unchecked exceptions.
Type Of This section lists all of the fields and constants that are of this type, which can help you figure out how to obtain an object of this type.
If the type defines self-typed fields or constants, they are not included on this list.
Throughout the quick reference, you’ll notice that classes are sometimes referred to by class name alone and at other times referred to by class name and package name.
If package names were always used, the class synopses would become long and hard to read.
On the other hand, if package names were never used, it would sometimes be difficult to know what class was being referred to.
The rules for including or omitting the package name are complex.
If the class name alone is ambiguous, the package name is always used.
The name Annotation is ambiguous, for example, because it can refer to either java.lang.annotation.Annotation or java.text.Annotation.
If the class is part of the java.lang package or is a very commonly used class, such as java.io.Serializable, the package name is omitted.
If the class being referred to is part of the current package (and has a quickreference entry in the current chapter), the package name is omitted.
The java.io package is large, but most of the classes it contains fall into a well-structured hierarchy.
Each of these stream subtypes has a specific purpose, and, despite its size, java.io is a straightforward package to understand and to use.
The java.nio package is totally new, although it included some compatibility with the classes in this package.
It was designed for high-performance I/O, particularly for use in servers and has a lowerlevel API than this package does.
The I/O facilities of java.io are still quite adequate for most of the I/O required by typical client-side applications.
Before we consider the stream classes that comprise the bulk of this package, let’s examine the important nonstream classes.
File represents a file or directory name in a system-independent way and provides methods for listing directories, querying file attributes, and renaming and deleting files.
FilenameFilter is an interface that defines a method that accepts or rejects specified filenames.
It is used by File to specify what types of files should be included in directory listings.
RandomAccessFile allows you to read from or write to arbitrary locations of a file.
Often, though, you’ll prefer sequential access to a file and should use one of the stream classes.
InputStream and OutputStream are abstract classes that define methods for reading and writing bytes.
Their subclasses allow bytes to be read from and written to a variety of sources and sinks.
ByteArrayInputStream and ByteArrayOutputStream read from and write to an array of bytes in memory.
PipedInputStream reads bytes from a PipedOutputStream, and PipedOutputStream writes bytes to a PipedInputStream.
These classes work together to implement a pipe for communication between threads.
FilterInputStream and FilterOutputStream are special; they filter input and output bytes.
When you create a FilterInputStream, you specify an InputStream for it to filter.
When you call the read( ) method of a FilterInputStream, it calls the read( ) method of its InputStream, processes the bytes it reads, and returns the filtered bytes.
Calling the write( ) method of a FilterOutputStream causes it to process your bytes in some way and then pass those filtered bytes to the write( ) method of its OutputStream.
FilterInputStream and FilterOutputStream do not perform any filtering themselves; this is done by their subclasses.
BufferedInputStream and BufferedOutputStream are filtered streams that provide input and output buffering and can increase I/O efficiency.
DataInputStream reads raw bytes from a stream and interprets them in various binary formats.
It has various methods to read primitive Java data types in their standard binary formats.
DataOutputStream allows you to write Java primitive data types in binary format.
These byte-stream classes are used for serializing and deserializing the internal state of objects for storage or interprocess communication.
The byte streams just described are complemented by an analogous set of character input and output streams.
Reader is the superclass of all character input streams, and Writer is the superclass of all character output streams.
Most of the Reader and Writer streams have obvious byte-stream analogs.
BufferedReader is a commonly used stream; it provides buffering for efficiency and also has a readLine( ) method to read a line of text at a time.
PrintWriter is another very common stream; its methods allow output of a textual representation of any primitive Java type or of any object (via the object’s toString( ) method)
Java 5.0 adds the Closeable and Flushable interfaces to identify types that have close( ) and flush( ) methods.
All streams have a close( ) method and implement the Closeable interface.
And all byte and character output streams have a flush( ) method and implement Flushable.
In a related change, all character output streams (and the byte stream PrintStream) implement the (new in Java 5.0) interface java.lang.Appendable, making them suitable for use with the java.util.Formatter class.
Similarly, all character input streams implement the java.lang.Readable interface, making them suitable for use with the java.util.Scanner class.
Finally, both PrintStream and PrintWriter have been enhanced in two ways for Java 5.0
Both now include constructors for creating a stream that writes directly to a file.
And both include formatted-text output methods printf( ) and format( )
This class is a FilterInputStream that provides input data buffering; efficiency is increased by reading in a large amount of data and storing it in an internal buffer.
When data is requested, it is usually available from the buffer.
Thus, most calls to read data do not actually have to read data from a disk, network, or other slow source.
Create a BufferedInputStream by specifying the InputStream that is to be buffered in the call to the constructor.
This class is a FilterOutputStream that provides output data buffering; output efficiency is increased by storing values to be written in a buffer and actually writing them out only when the buffer fills up or when the flush( ) method is called.
Create a BufferedOutputStream by specifying the OutputStream that is to be buffered in the call to the constructor.
This class applies buffering to a character input stream, thereby improving the efficiency of character input.
You create a BufferedReader by specifying some other character input stream from which it is to buffer input.
You can also specify a buffer size at this time, although the default size is usually fine.) Typically, you use this sort of buffering with a FileReader or InputStreamReader.
BufferedReader defines the standard set of Reader methods and provides a readLine( ) method that reads a line of text (not including the line terminator) and returns it as a String.
It also provides a replacement for the deprecated readLine( ) method of DataInputStream, which did not properly convert bytes into characters.
This class applies buffering to a character output stream, improving output efficiency by coalescing many small write requests into a single larger request.
You create a BufferedWriter by specifying some other character output stream to which it sends its buffered and coalesced output.
You can also specify a buffer size at this time, although the default size is usually satisfactory.) Typically, you use this sort of buffering with a FileWriter or OutputStreamWriter.
BufferedWriter defines the standard write( ), flush( ), and close( ) methods all output streams define, but it adds a newLine( ) method that outputs the platform-dependent line separator (usually a newline character, a carriage-return character, or both) to the stream.
This class is a subclass of InputStream in which input data comes from a specified array of byte values.
This is useful when you want to read data in memory as if it were coming from a file, pipe, or socket.
Note that the specified array of bytes is not copied when a ByteArrayInputStream is created.
This class is a subclass of OutputStream in which output data is stored in an internal byte array.
The internal array grows as necessary and can be retrieved with toByteArray( ) or toString( )
The reset( ) method discards any data currently stored in the internal array and stores data from the beginning again.
This class is a character input stream that uses a character array as the source of the characters it returns.
You create a CharArrayReader by specifying the character array (or portion of an array) it is to read from.
CharArrayReader defines the usual Reader methods and supports the mark( ) and reset( ) methods.
Note that the character array you pass to the CharArrayReader( ) constructor is not copied.
This means that changes you make to the elements of the array after you create the input stream affect the values read from the array.
CharArrayReader is the character-array analog of ByteArrayInputStream and is similar to StringReader.
This class is a character output stream that uses an internal character array as the destination of characters written to it.
When you create a CharArrayWriter, you may optionally specify an initial size for the character array, but you do not specify the character array itself; this array is managed internally by the CharArrayWriter and grows as necessary to accommodate all the characters written to it.
The toString( ) and toCharArray( ) methods return a copy of all characters written to the stream, as a string and an array of characters, respectively.
CharArrayWriter defines the standard write( ), flush( ), and close( ) methods all Writer subclasses define.
Finally, writeTo( ) writes the contents of the internal character array to some other specified character stream.
CharArrayWriter is the characterstream analog of ByteArrayOutputStream and is quite similar to StringWriter.
Signals an error when converting bytes to characters or vice versa.
This interface defines a close( ) method and is implemented by closeable objects such as java.io streams and java.nio channels.
This interface was added in Java 5.0 to enable java.util.Formatter to distinguish java.lang.Appendable objects that need to be closed (such as streams) from those that do not (such as StringBuilder objects)
This interface defines the methods required for streams that can read Java primitive data types in a machine-independent binary format.
This class is a type of FilterInputStream that allows you to read binary representations of Java primitive data types in a portable way.
Create a DataInputStream by specifying the InputStream that is to be filtered in the call to the constructor.
DataInputStream reads only primitive Java types; use ObjectInputStream to read object values.
Many of the methods read and return a single Java primitive type, in binary format, from the stream.
By contrast, readFully( ) reads data into an array of bytes, but blocks until all requested data becomes available.
The returned string is not terminated with a newline or carriage return.
This method is deprecated as of Java 1.1; see BufferedReader for an alternative.
UTF-8 is an ASCIIcompatible encoding of Unicode characters that is often used for the transmission and storage of Unicode text.
This class uses a modified UTF-8 encoding that never contains embedded null characters.
This interface defines the methods required for streams that can write Java primitive data types in a machine-independent binary format.
This class is a subclass of FilterOutputStream that allows you to write Java primitive data types in a portable binary format.
Create a DataOutputStream by specifying the OutputStream that is to be filtered in the call to the constructor.
DataOutputStream has methods that output only primitive types; use ObjectOutputStream to output object values.
Many of this class’s methods write a single Java primitive type, in binary format, to the output stream.
UTF-8 is an ASCII-compatible encoding of Unicode characters that is often used for the transmission and storage of Unicode text.
Except for the writeUTF( ) method, this class is used for binary output of data.
Textual output should be done with PrintWriter (or PrintStream in Java 1.0)
This interface defines the methods that must be implemented by an object that wants complete control over the way it is serialized.
The writeExternal( ) and readExternal( ) methods should be implemented to write and read object data in some arbitrary format, using.
Externalizable objects must serialize their own fields and are also responsible for serializing the fields of their superclasses.
Most objects do not need to define a custom output format and can use the Serializable interface instead of Externalizable for serialization.
This class supports a platform-independent definition of file and directory names.
It also provides methods to list the files in a directory; check the existence, readability, writability, type, size, and modification time of files and directories; make new directories; rename files and directories; delete files and directories; and create and delete temporary and lock files.
The constants defined by this class are the platform-dependent directory and path-separator characters, available as a String and a char.
If not, getAbsolutePath( ) returns an absolute filename created by appending the relative filename to the current working directory.
This can be useful when comparing two File objects to see if they refer to the same file or directory.
In Java 1.4 and later, the toURI( ) method returns a java.net.URI object that uses a file: scheme to name this file.
This file-to-URI transformation can be reversed by passing a file: URI object to the File( ) constructor.
Prior to Java 1.2, the File class doesn’t provide any way to create a file; that task is accomplished typically with FileOutputStream.
Two special-purpose file creation methods were added in Java 1.2
The static createTempFile( ) method returns a File object that refers to a newly created empty file with a unique name that begins with the specified prefix (which.
One version of this method creates the file in a specified directory, and the other creates it in the system temporary directory.
Applications can use temporary files for any purpose without worrying about overwriting files belonging to other applications.
The other file-creation method of Java 1.2 is createNewFile( )
This instance method attempts to create a new, empty file with the name specified by the File object.
When working with createTempFile( ) or createNewFile( ), consider using deleteOnExit( ) to request that the files be deleted when the Java VM exits normally.
This class is a platform-independent representation of a low-level handle to an open file or socket.
The static in, out, and err variables are FileDescriptor objects that represent the standard input, output, and error streams, respectively.
There is no public constructor method to create a FileDescriptor object.
You can obtain one with the getFD( ) method of FileInputStream, FileOutputStream, or RandomAccessFile.
This interface, added in Java 1.2, defines an accept( ) method that filters a list of files.
You can list the contents of a directory by calling the listFiles( ) method of the File object that represents the desired directory.
If you want a filtered listing, such as a listing of files but not subdirectories or a listing of files whose names end in .class, you can pass a FileFilter object to listFiles( )
For each entry in the directory, a File object is passed to the.
If accept( ) returns true, that File is included in the return value of listFiles( )
If accept( ) returns false, that entry is not included in the listing.
Use FilenameFilter if compatibility with previous releases of Java is required or if you prefer to filter filenames (i.e., String objects) rather than File objects.
This class is a subclass of InputStream that reads bytes from a file specified by name or by a File or FileDescriptor object.
To read binary data, you typically use this class in conjunction with a BufferedInputStream and DataInputStream.
To read text, you typically use it with an InputStreamReader and BufferedReader.
Call close( ) to close the file when input is no longer needed.
In Java 1.4 and later, use getChannel( ) to obtain a FileChannel object for reading from the underlying file using the New I/O API of java.nio and its subpackages.
This interface defines the accept( ) method that must be implemented by any object that filters filenames (i.e., selects a subset of filenames from a list of filenames)
There are no standard FilenameFilter classes implemented by Java, but objects that implement this interface are used by the java.awt.FileDialog object and the File.list( ) method.
A typical FilenameFilter object might check that the specified File represents a file (not a directory), is readable (and possibly writable as well), and that its name ends with some desired extension.
An IOException that signals that a specified file cannot be found.
This class is a subclass of OutputStream that writes data to a file specified by name or by a File or FileDescriptor object.
If the specified file already exists, a FileOutputStream can be configured to overwrite or append to the existing file.
To write binary data, you typically use this class in conjunction with a BufferedOutputStream and a DataOutputStream.
To write text, you typically use it with a PrintWriter, BufferedWriter and an OutputStreamWriter (or you use the convenience class FileWriter)
Use close( ) to close a FileOutputStream when no further output will be written to it.
In Java 1.4 and later, use getChannel( ) to obtain a FileChannel object for writing to the underlying file using the New I/O API of java.nio and its subpackages.
This class is a java.security.Permission that governs access to the local filesystem.
A FilePermission has a name, or target, which specifies what file or files it pertains to, and a commaseparated list of actions that may be performed on the file or files.
Read and write permission are required by any methods that read or write a file.
Delete permission is required by File.delete( ), and execute permission is required by Runtime.exec( )
The name of a FilePermission may be as simple as a file or directory name.
FilePermission also supports the use of certain wildcards, however, to specify a permission that applies to more than one file.
Programmers writing system-level code and system administrators configuring security policies may need to use it, however.
Restricting access (especially write access) to files is one of the cornerstones of the Java security model with regard to untrusted code.
FileReader is a convenience subclass of InputStreamReader that is useful when you want to read text (as opposed to binary data) from a file.
You create a FileReader by specifying the file to be read in any of three possible forms.
The FileReader constructor internally creates a FileInputStream to read bytes from the specified file and uses the functionality of its superclass, InputStreamReader, to convert those bytes from characters in the local encoding to the Unicode characters used by Java.
Because FileReader is a trivial subclass of InputStreamReader, it does not define any read( ) methods or other methods of its own.
FileWriter is a convenience subclass of OutputStreamWriter that is useful when you want to write text (as opposed to binary data) to a file.
You create a FileWriter by specifying the file to be written to and, optionally, whether the data should be appended to the end of an existing file instead of overwriting that file.
The FileWriter class creates an internal FileOutputStream to write bytes to the specified file and uses the functionality of its superclass, OutputStreamWriter, to convert the Unicode characters written to the stream into bytes using the default encoding of the default locale.
If you want to use an encoding other than the default, you cannot use FileWriter; in that case you must create your own OutputStreamWriter and FileOutputStream.) Because FileWriter is a trivial subclass of OutputStreamWriter, it does not define any methods of its own, but simply inherits them from its superclass.
This class provides method definitions required to filter data obtained from the InputStream specified when the FilterInputStream is created.
It must be subclassed to perform some sort of filtering operation and cannot be instantiated directly.
This class provides method definitions required to filter the data to be written to the OutputStream specified when the FilterOutputStream is created.
It must be subclassed to perform some sort of filtering operation and may not be instantiated directly.
This abstract class is intended to act as a superclass for character input streams that read data from some other character input stream, filter it in some way, and then.
FilterReader is declared abstract so that it cannot be instantiated.
But none of its methods are themselves abstract: they all simply call the requested operation on the input stream passed to the FilterReader( ) constructor.
If you were allowed to instantiate a FilterReader, you’d find that it is a null filter (i.e., it simply reads characters from the specified input stream and returns them without any kind of filtering)
Because FilterReader implements a null filter, it is an ideal superclass for classes that want to implement simple filters but do not want to override all the methods of Reader.
In order to create your own filtered character input stream, you should subclass FilterReader and override both its read( ) methods to perform the desired filtering operation.
Note that you can implement one of the read( ) methods in terms of the other, and thus only implement the filtration once.
Recall that the other read( ) methods defined by Reader are implemented in terms of these methods, so you do not need to override those.
In some cases, you may need to override other methods of FilterReader and provide methods or constructors that are specific to your subclass.
This abstract class is intended to act as a superclass for character output streams that filter the data written to them before writing it to some other character output stream.
FilterWriter is declared abstract so that it cannot be instantiated.
But none of its methods are themselves abstract: they all simply invoke the corresponding method on the output stream that was passed to the FilterWriter constructor.
If you were allowed to instantiate a FilterWriter object, you’d find that it acts as a null filter (i.e., it simply passes the characters written to it along, without any filtration)
Because FilterWriter implements a null filter, it is an ideal superclass for classes that want to implement simple filters without having to override all of the methods of Writer.
In order to create your own filtered character output stream, you should subclass FilterWriter and override all its write( ) methods to perform the desired filtering operation.
In some cases, you may want to override other Writer methods and add other methods or constructors that are specific to your subclass.
This interface defines a flush( ) method and is implemented by flushable objects such as java.io streams.
This interface was added in Java 5.0 to enable java.util.Formatter to distinguish java.lang.Appendable objects that need to be flushed (such as streams) from those that do not (such as StringBuilder objects)
This abstract class is the superclass of all input streams.
It defines the basic input methods all input stream classes provide.
It returns the bytes read, the number of bytes read, or –1 if the endof-file has been reached.
The stream should not be used after close( ) has been called.
If markSupported( ) returns true for a given InputStream, that stream supports mark( ) and reset( ) methods.
This class is a character input stream that uses a byte input stream as its data source.
It reads bytes from a specified InputStream and translates them into Unicode characters according to a particular platform- and locale-dependent character encoding.
This is an important internationalization feature in Java 1.1 and later.
It also has a getEncoding( ) method that returns the name of the encoding being used to convert bytes to characters.
When you create an InputStreamReader, you specify an InputStream from which the InputStreamReader is to read bytes and, optionally, the name of the character encoding used by those bytes.
If you do not specify an encoding name, the InputStreamReader uses the default encoding for the default locale, which is usually the correct thing to do.
In Java 1.4 and later, this class uses the charset conversion facilities of the java.nio.charset package and allows you to explicitly specify the Charset or CharsetDecoder to be used.
Prior to Java 1.4, the class allows you to specify only the name of the desired charset encoding.
An IOException that signals that an input or output operation was interrupted.
The bytesTransferred field contains the number of bytes read or written before the operation was interrupted.
Signals that the serialization mechanism has encountered one of several possible problems with the class of an object that is being serialized or deserialized.
The classname field should contain the name of the class in question, and the getMessage( ) method is overridden to return this class name with the message.
This exception should be thrown by the validateObject( ) method of an object that implements the ObjectInputValidation interface when a deserialized object fails an input validation test for any reason.
Thrown By ObjectInputStream.registerValidation( ), ObjectInputValidation.validateObject( ), java.text.AttributedCharacterIterator.Attribute.readResolve( ), java.text.DateFormat.Field.readResolve( ), java.text.MessageFormat.Field.readResolve( ), java.text.NumberFormat.Field.readResolve( )
Signals that an exceptional condition has occurred during input or output.
This class is a FilterInputStream that keeps track of the number of lines of data that have been read.
This class is deprecated as of Java 1.1 because it does not properly convert bytes to characters.
This class is a character input stream that keeps track of the number of lines of text that have been read from it.
It supports the usual Reader methods and also the readLine( ) method introduced by its superclass.
In addition to these methods, you can call getLineNumber( ) to query the number of lines set so far.
You can also call setLineNumber( ) to set the line number for the current line.
Subsequent lines are numbered sequentially from this specified starting point.
This class is a character-stream analog to LineNumberInputStream, which has been deprecated as of Java 1.1
It indicates that the invoked method was not invoked at the right time or in the correct context.
Typically, it means that an ObjectOutputStream or ObjectInputStream is not currently active and therefore the requested operation cannot be performed.
It is thrown when serialization is attempted on an instance of a class that does not implement the Serializable interface.
Note that it is also thrown when an attempt is made to serialize a Serializable object that refers to (or contains) an object that is not Serializable.
A subclass of a class that is Serializable can prevent itself from being serialized by throwing this exception from its writeObject( ) and/ or readObject( ) methods.
This interface extends the DataInput interface and adds methods for deserializing objects and reading bytes and arrays of bytes.
ObjectInputStream deserializes objects, arrays, and other values from a stream that was previously created with an ObjectOutputStream.
The readObject( ) method deserializes objects read primitive data values from the stream.
Note that only objects that implement the Serializable or Externalizable interface can be serialized and deserialized.
A class may implement its own private readObject(ObjectInputStream) method to customize the way it is deserialized.
If you define such a method, there are several ObjectInputStream methods you can use to help deserialize the object.
It reads the content of the object just as an ObjectInputStream would normally do.
If you wrote additional data before or after the default object contents, you should read that data before or after calling defaultReadObject( )
When working with multiple versions or implementations of a class, you may have to deserialize a set of fields that do not match the fields of your class.
In this case, give your class a static field named serialPersistentFields whose value is an array of ObjectStreamField objects that describe the fields to be deserialized.
If you do this, your readObject( ) method can call readFields( ) to read the specified fields from the stream and return them in a ObjectInputStream.GetField object.
Finally, you can call registerValidation( ) from a custom readObject( ) method.
This method registers an ObjectInputValidation object (typically the object being deserialized) to be notified when a complete tree of objects has been deserialized, and the original call to the readObject( ) method of the ObjectInputStream is about to return to its caller.
The remaining methods include miscellaneous stream-manipulation methods and several protected methods for use by subclasses that want to customize the deserialization behavior of ObjectInputStream.
This class holds the values of named fields read by an ObjectInputStream.
It gives the programmer precise control over the deserialization process and is typically used when implementing an object with a set of fields that do not match the set of fields (and the serialization stream format) of the original implementation of the object.
This class allows the implementation of a class to change without breaking serialization compatibility.
In order to use the GetField class, your class must implement a private readObject( ) method that is responsible for custom deserialization.
Typically, when using the GetField class, you have also specified an array of ObjectStreamField objects as the value of a private static field named serialPersistentFields.
This array specifies the names and types of all fields expected to be found when reading from a serialization stream.
If there is no serialPersistentField field, the array of ObjectStreamField objects is created from the actual fields (excluding static and transient fields) of the class.
Within the readObject( ) method of your class, call the readFields( ) method of ObjectInputStream( )
This method reads the values of all fields from the stream and stores them in an ObjectInputStream.GetField object that it returns.
This GetField object is essentially a mapping from field names to field values, and you can extract the values of whatever fields you need in order to restore the proper state of the object being deserialized.
The various get( ) methods return the values of named fields of specified types.
Each method takes a default value as an argument, in case no value for the named field was present in the serialization stream.
This can happen when deserializing an object written by an earlier version of the class, for example.) Use the defaulted( ) method to determine whether the GetField object contains a value for the named field.
If this method returns true, the named field had no value in the stream, so the get( ) method of the GetField object has to return the specified default value.
The getObjectStreamClass( ) method of a GetField object returns the ObjectStreamClass object for the object being deserialized.
This ObjectStreamClass can obtain the array of ObjectStreamField objects for the class.
A class implements this interface and defines the validateObject( ) method in order to validate itself when it and all the objects it depends on have been completely deserialized from an ObjectInputStream.
The validateObject( ) method is only invoked, however, if the object is passed object.
Note that if an object is deserialized as part of a larger object graph, its validateObject( ) method is not invoked until the entire graph is read, and the original call to ObjectInputStream.readObject( ) is about to return.
This stops object serialization, and the original call to ObjectInputStream.readObject( ) terminates with the InvalidObjectException exception.
This interface extends the DataOutput interface and adds methods for serializing objects and writing bytes and arrays of bytes.
The ObjectOutputStream serializes objects, arrays, and other values to a stream.
The writeObject( ) method serializes an object or array, and various other methods write primitive data values to the stream.
Note that only objects that implement the Serializable or Externalizable interface can be serialized.
A class that wants to customize the way instances are serialized should declare a being serialized and can use several additional methods of ObjectOutputStream.
An object can call this method to serialize itself and then use other methods of ObjectOutputStream to write additional data to the serialization stream.
The class must define a matching readObject( ) method to read that additional data, of course.
When working with multiple versions or implementations of a class, you may have to serialize a set of fields that do not precisely match the fields of your class.
In this case, give your class a static field named serialPersistentFields whose value is an array of ObjectStreamField objects that describe the fields to be serialized.
In your writeObject( ) method, call putFields( ) to obtain an ObjectOutputStream.PutField object.
Store field names and values into this object, and then call writeFields( ) to write them out to the serialization stream.
The remaining methods of ObjectOutputStream are miscellaneous stream-manipulation methods and protected methods for use by subclasses that want to customize its serialization behavior.
This class holds values of named fields and allows them to be written to an ObjectOutputStream during the process of object serialization.
It gives the programmer precise control over the serialization process and is typically used when the set of fields defined by a class does not match the set of fields (and the serialization stream format) defined by the original implementation of the class.
In other words, ObjectOutputStream.PutField allows the implementation of a class to change without breaking serialization compatibility.
In order to use the PutField class, you typically define a private static serialPersistentFields field that refers to an array of ObjectStreamField objects.
This array defines the set of fields written to the ObjectOutputStream and therefore defines the serialization format.
If you do not declare a serialPersistentFields field, the set of fields is all fields of the class, excluding static and transient fields.
In addition to the serialPersistentFields field, your class must also define a private writeObject( ) method that is responsible for the custom serialization of your class.
In this method, call the putFields( ) method of ObjectOutputStream to obtain an ObjectOutputStream.PutField object.
Once you have this object, use its various put( ) methods to specify the names and values of the field to be written out.
The set of named fields should match those specified by serialPersistentFields.
You may specify the fields in any order; the PutField class is responsible for writing them out in the correct order.
Once you have specified the values of all fields, call the write( ) method of your PutField object in order to write the field values out to the serialization stream.
Protected Instance Methods protected void annotateClass(Class<?> cl) throws IOException;  empty.
An ObjectStreamClass object contains the name of a class, its unique version identifier, and the name and type of the fields that constitute the serialization format for the class.
It returns either the value of the private serialVersionUID field of the class or a computed value that is based upon the public API of the class.
In Java 1.2 and later, getFields( ) returns an array of ObjectStreamField objects that represent the names and types of the fields of the class to be serialized.
By default, these methods use all the fields of a class except those that are static or transient.
However, this default set of fields can be overridden by declaring a private serialPersistentFields field in the class.
The value of this field should be the desired array of ObjectStreamField objects.
ObjectStreamClass class does not have a constructor; you should use the static lookup( ) method to obtain an ObjectStreamClass object for a given Class object.
The forClass( ) instance method performs the opposite operation; it returns the Class object that corresponds to a given ObjectStreamClass.
Deprecated Public Methods #  public abstract void write(ObjectOutput out) throws IOException;
This interface defines various constants used by the Java object-serialization mechanism.
In Java 1.2, you can pass either of these values to the useProtocolVersion( ) method of an ObjectOutputStream.
The other constants defined by this interface are low-level values used by the serialization protocol.
You do not need to use them unless you are reimplementing the serialization mechanism yourself.
This class is the superclass of a number of more specific exception types that may be raised in the process of serializing and deserializing objects with the ObjectOutputStream and ObjectInputStream classes.
Thrown By java.security.KeyRep.readResolve( ), java.security.cert.Certificate.writeReplace( ), java.security.cert.Certificate.CertificateRep.readResolve( ), java.security.cert.CertPath.writeReplace( ), java.security.cert.CertPath.CertPathRep.readResolve( )
This class represents a named field of a specified type (i.e., a specified Class)
When a class serializes itself by writing a set of fields that are different from the fields it uses in its own implementation, it defines the set of fields to be written with an array of ObjectStreamField objects.
This array should be the value of a private static field named serialPersistentFields.
The methods of this class are used internally by the serialization mechanism and are not typically used elsewhere.
Thrown by the readObject( ) method of an ObjectInputStream when it encounters primitive type data where it expects object data.
Despite the exception name, this data is not optional, and object deserialization is stopped.
This abstract class is the superclass of all output streams.
It defines the basic output methods all output stream classes provide.
The stream may not be used once close( ) has been called.
Returned By Process.getOutputStream( ), Runtime.getLocalizedOutputStream( ), java.net.CacheRequest.getBody( ), java.net.Socket.getOutputStream( ), java.net.SocketImpl.getOutputStream( ), java.net.URLConnection.getOutputStream( ), java.nio.channels.Channels.newOutputStream( ), javax.xml.transform.stream.StreamResult.getOutputStream( )
This class is a character output stream that uses a byte output stream as the destination for its data.
When characters are written to an OutputStreamWriter, it translates them into bytes according to a particular locale- and/or platform-specific character encoding and writes those bytes to the specified OutputStream.
This is a very important internationalization feature in Java 1.1 and later.
It also has a getEncoding( ) method that returns the name of the encoding being used to convert characters to bytes.
When you create an OutputStreamWriter, specify the OutputStream to which it writes bytes and, optionally, the name of the character encoding that should be used to convert characters to bytes.
If you do not specify an encoding name, the OutputStreamWriter uses the default encoding of the default locale, which is usually the correct thing to do.
In Java 1.4 and later, this class uses the charset conversion facilities of the java.nio.charset package and allows you to explicitly specify the Charset or CharsetEncoder to be used.
Prior to Java 1.4, the class allows you to specify only the name of the desired charset encoding.
This class is an InputStream that implements one half of a pipe and is useful for communication between threads.
A PipedInputStream must be connected to a PipedOutputStream object, which may be specified when the PipedInputStream is created or with the connect( ) method.
Data read from a PipedInputStream object is received from the PipedOutputStream to which it is connected.
See InputStream for information on the low-level methods for reading data from a PipedInputStream.
A FilterInputStream can provide a higher-level interface for reading data from a PipedInputStream.
This class is an OutputStream that implements one half a pipe and is useful for communication between threads.
A PipedOutputStream must be connected to a PipedInputStream, which may be specified when the PipedOutputStream is created or with the connect( ) method.
Data written to the PipedOutputStream is available for reading on the PipedInputStream.
See OutputStream for information on the low-level methods for writing data to a PipedOutputStream.
A FilterOutputStream can provide a higher-level interface for writing data to a PipedOutputStream.
PipedReader is a character input stream that reads characters from a PipedWriter character output stream to which it is connected.
PipedReader implements one half of a pipe and is useful for communication between two threads of an application.
A PipedReader cannot be used until it is connected to a PipedWriter object, which may be passed to the PipedReader( ) constructor or to the connect( ) method.
PipedWriter is a character output stream that writes characters to the PipedReader character input stream to which it is connected.
PipedWriter implements one half of a pipe and is useful for communication between two threads of an application.
A PipedWriter cannot be used until it is connected to a PipedReader object, which may be passed to the PipedWriter( ) constructor or to the connect( ) method.
This class is a byte output stream that implements a number of methods for displaying textual representations of Java primitive data types.
PrintStream converts characters to bytes using the platform’s default charset, or the charset or encoding named in the PrintStream( ) constructor invocation.
In Java 5.0, convenience constructors allow you to specify a file (either as a file name or a File object) as the destination of a PrintStream.
Prior to Java 5.0 the destination had to be another OutputStream object.
The print( ) methods output standard textual representations of each data type.
The println( ) methods do the same and follow the representations with newlines.
Each method converts a Java primitive type to a String representation and outputs the resulting string.
When an Object is passed to a print( ) or println( ), it is converted to a String by calling its toString( ) method.
In Java 5.0, you can also use the printf( ) methods (or the format( ) methods that behave identically) for formatted output.
These methods behave like the format( ) method of a java.util.Formatter object that uses the PrintStream as its destination.
This class implements the java.lang.Appendable interface in Java 5.0, which makes it suitable for use with a java.util.Formatter.
See also PrintWriter for a character output stream with similar functionality.
And see DataOutputStream for a byte output stream that outputs binary, rather than textual, representations of Java’s primitive types.
This class is a character output stream that implements a number of print( ) and println( ) methods that output textual representations of primitive values and objects.
When you create a PrintWriter object, you specify a character or byte output stream that it should write its characters to and, optionally, whether the PrintWriter stream should be automatically flushed whenever println( ) is called.
If you specify a byte output stream as the destination, the PrintWriter( ) constructor automatically creates the necessary OutputStreamWriter object to convert characters to bytes using the default encoding.
In Java 5.0, convenience constructors allow you to specify a file (either as a file name or a File object) as the destination.
You may optionally specify the name of a charset to use for character-to-byte conversion when writing to the file.
PrintWriter implements the normal write( ), flush( ), and close( ) methods all Writer subclasses define.
It is more common to use the higher-level print( ) and println( ) methods, each of which converts its argument to a string before outputting it.
In Java 5.0, you can also use the printf( ) methods (or the format( ) methods that behave identically) for formatted output.
These methods behave like the format( ) method of a java.util.Formatter object that uses the PrintWriter as its destination.
Instead, when errors occur, they set an internal flag you can check by calling checkError( )
Once an error has occurred on a PrintWriter object, all subsequent calls to checkError( ) return true; there is no way to reset the error flag.
PrintWriter is the character stream analog to PrintStream, which it supersedes.
You can usually easily replace any PrintStream objects in a program with PrintWriter objects.
The only valid remaining use for the PrintStream class is for the System.out and System.err standard output streams.
Passed To Throwable.printStackTrace( ), java.util.Properties.list( ), javax.xml.transform.TransformerException.printStackTrace( ), javax.xml.xpath.XPathException.printStackTrace( )
This class is a FilterInputStream that implements a one-byte pushback buffer or, as of Java 1.1, a pushback buffer of a specified length.
The unread( ) methods push bytes back into the stream; these bytes are the first ones read by the next call to a read( ) method.
This class is a character input stream that uses another input stream as its input source and adds the ability to push characters back onto the stream.
When you create a PushbackReader stream, you specify the stream to be read from and, optionally, the size of the pushback buffer (i.e., the number of characters that may be pushed back onto the stream or unread)
If you do not specify a size for this buffer, the default size is one character.
PushbackReader inherits or overrides all standard Reader methods and adds three unread( ) methods that push a single character, an array of characters, or a portion of an array of characters back onto the stream.
This class allows you to read and write arbitrary bytes, text, and primitive Java data types from or to any specified location in a file.
Because this class provides random, rather than sequential, access to files, it is neither a subclass of InputStream nor of OutputStream, but provides an entirely independent method for reading and writing data from or to files.
RandomAccessFile implements the same interfaces as DataInputStream and DataOutputStream, and thus defines the same methods for reading and writing data as those classes do.
The seek( ) method provides random access to the file; it is used to select the position in the file where data should be read or written.
The various read and write methods update this file position so that a sequence of read or write operations can be performed on a contiguous portion of the file without having to call the seek( ) method before each read or write.
In Java 1.4 and later, two other values for the mode argument are allowed as well.
The “rws” mode is similar, but requires synchronous updates to both the file’s content and its metadata (which includes things such as file access times)
Using “rws” mode may require that the file metadata be modified every time the file is read.
In Java 1.4 and later, use the getChannel( ) method to obtain a FileChannel object that you can use to access the file using the New I/O API of java.nio and its subpackages.
If the RandomAccessFile was opened with a mode of “r”, the FileChannel allows only reading.
This abstract class is the superclass of all character input streams.
It is an analog to InputStream, which is the superclass of all byte input streams.
Reader defines the basic methods that all character output streams provide.
If ready( ) returns true, the next call to read( ) is guaranteed not to block.
If markSupported( ) returns true, mark( ) marks a position in the stream and, if necessary, creates a look-ahead buffer of the specified size.
Future calls to reset( ) restore the stream to the marked position if they occur within the specified look-ahead limit.
Note that not all stream types support this mark-and-reset functionality.
To create a subclass of Reader, you need only implement the three-argument version of read( ) and the close( ) method.
This class provides a way of seamlessly concatenating the data from two or more input streams.
It provides an InputStream interface to a sequence of InputStream objects.
Data is read from the streams in the order in which the streams are specified.
When the end of one stream is reached, data is automatically read from the next stream.
This class might be useful, for example, when implementing an include file facility for a parser.
A class should implement this interface simply to indicate that it allows itself to be serialized and deserialized with ObjectOutputStream.writeObject( ) and ObjectInputStream.readObject( )
Objects that need special handling during serialization or deserialization may implement one or both of the following methods; note, however, that these methods are not part of the Serializable interface):
Typically, the writeObject( ) method performs any necessary cleanup or preparation for serialization, invokes the defaultWriteObject( ) method of the ObjectOutputStream to serialize the nontransient fields of the class, and optionally writes any additional data that is required.
Similarly, the readObject( ) method typically invokes the defaultReadObject( ) method of the ObjectInputStream, reads any additional data written by the corresponding writeObject( ) method, and performs any extra initialization required by the object.
The readObject( ) method may also register an ObjectInputValidation object to validate the object once it is completely deserialized.
This class is a java.security.Permission that governs the use of certain sensitive features of serialization.
SerializablePermission objects have a name, or target, but do not have an action list.
The name “enableSubclassImplementation” represents permission to serialize and deserialize objects using subclasses of ObjectOutputStream and ObjectInputStream.
This capability is protected by a permission because malicious code can define object stream subclasses that incorrectly serialize and deserialize objects.
The only other name supported by SerializablePermission is “enableSubstitution,” which represents permission for one object to be substituted for another during serialization or deserialization.
Permission of this type is required by the ObjectOutputStream.enableReplaceObject( ) and ObjectInputStream.enableResolveObject( ) methods.
Programmers writing system-level code may use it, and system administrators configuring security policies should be familiar with it.
Signals that the data stream being read by an ObjectInputStream has been corrupted and does not contain valid serialized object data.
This class performs lexical analysis of a specified input stream and breaks the input into tokens.
The public variables sval and nval contain the string and numeric values (if applicable) of the most recently read token.
The remaining methods allow you to specify how tokens are recognized.
If so, the TT_EOL constant is returned for end-of-lines; otherwise, they are treated as whitespace.
If so, no part of the comment is returned as a token.
When a string token is parsed, the quote character is returned as the token value, and the body of the string is stored in the sval variable.
This class is a subclass of InputStream in which input bytes come from the characters of a specified String object.
This class does not correctly convert the characters of a StringBuffer into bytes and is deprecated as of Java 1.1
Use StringReader instead to convert characters into bytes or use ByteArrayInputStream to read bytes from an array of bytes.
This class is a character input stream that uses a String object as the source of the characters it returns.
When you create a StringReader, you must specify the String to read from.
StringReader defines the normal Reader methods and supports mark( ) and reset( )
If reset( ) is called before mark( ) has been called, the stream is reset to the beginning of the specified string.
StringReader is a character stream analog to StringBufferInputStream, which is deprecated as of Java 1.1
Protected Instance Fields protected String buffer; protected int count; protected int pos;
This class is a character output stream that uses an internal StringBuffer object as the destination of the characters written to the stream.
When you create a StringWriter, you may optionally specify an initial size for the StringBuffer, but you do not specify the StringBuffer itself; it is managed internally by the StringWriter and grows as necessary to accommodate the characters written to it.
StringWriter defines the standard write( ), flush( ), and close( ) methods all Writer subclasses define, as well as two methods to obtain the characters that have been written to the stream’s internal buffer.
Note that getBuffer( ) returns a reference to the actual internal buffer, not a copy of it, so any changes you make to the buffer are reflected in subsequent calls to toString( )
StringWriter is quite similar to CharArrayWriter, but does not have a byte-stream analog.
Signals that a call to FileDescriptor.sync( ) did not complete successfully.
Signals that a requested character encoding is not supported by the current Java Virtual Machine.
An IOException that signals that a malformed UTF-8 string has been encountered by a class that implements the DataInput interface.
UTF-8 is an ASCII-compatible transformation format for Unicode characters that is often used to store and transmit Unicode text.
Thrown when reading a stream of data that is incomplete because an exception was thrown while it was being written.
The detail field may contain the exception that terminated the output stream.
In Java 1.4 and later, this exception can also be obtained with the standard Throwable getCause( ) method.
The getMessage( ) method has been overridden to include the message of this detail exception, if any.
This abstract class is the superclass of all character output streams.
It is an analog to OutputStream, which is the superclass of all byte output streams.
Writer defines the basic write( ), flush( ), and close( ) methods all character output streams provide.
The five versions of the write( ) method write a single character, a character array or subarray, or a string or substring to the destination of the stream.
By default, the other write( ) methods are implemented in terms of this abstract one.
The flush( ) method is another abstract method all subclasses must implement.
It should force any output buffered by the stream to be written to its destination.
If that destination is itself a character or byte output stream, it should invoke the flush( ) method of the destination stream as well.
A subclass must implement this method so that it flushes and then closes the current stream and also closes whatever destination stream it is connected to.
Once the stream is closed, any future calls to write( ) or flush( ) should throw an IOException.
In Java 5.0, this class has been modified to implement the Closeable and Flushable interfaces.
It has also changed to implement java.lang.Appendable, which means that any Writer object can be used as the destination for a java.util.Formatter.
This chapter covers the java.lang package which defines the core classes and interfaces that are indispensable to the Java platform and the Java programming language.
The java.lang package contains the classes that are most central to the Java language.
Object is the ultimate superclass of all Java classes and is therefore at the top of all class hierarchies.
There is one Class object for each class that is loaded into Java.
Void is a related class that defines a representation for the void method return type, but that defines no methods.
String is an immutable type, while StringBuffer can have its string changed in place.
In Java 5.0, StringBuilder is like StringBuffer but without synchronized methods, which makes it the preferred choice in most applications.
String, StringBuffer and StringBuilder implement the Java 1.4 interface CharSequence which allows instances of these classes to be manipulated through a simple shared API.
String and the various primitive type wrapper classes all implement the Comparable interface which defines an ordering for instances of those classes and enables sorting and searching algorithms (such as those of java.util.Arrays and java.util.Collections, for example)
Cloneable is an important marker interface that specifies that the Object.clone( ) method is allowed to make copies of an object.
The Math class (and, in Java 1.3, the StrictMath class) defines static methods for various floating-point mathematical functions.
The Thread class provides support for multiple threads of control running within the same Java interpreter.
The Runnable interface is implemented by objects that have a run( ) method that can serve as the body of a thread.
Runtime provides similar low-level methods, including an exec( ) method that, along with the Process class, defines a platform-dependent API for running external processes.
Java 5.0 allows Process objects to be created more easily with the ProcessBuilder class.
Throwable is the root class of the exception and error hierarchy.
Throwable objects are used with the Java throw and catch statements.
Exception and Error are the superclasses of all exceptions and errors.
Iterable marks types that have an iterator( ) method and enables iteration with the for/in looping statement introduced in Java 5.0
The Appendable interface is implemented by classes (such as StringBuilder and character output streams) that can have characters appended to them.
Implementing this interface enables formatted text output with a java.util.Formatter.
The Readable interface is implemented by classes (such as character input streams) that can sequentially copy characters into a buffer.
Also new in Java 5.0 is Enum, which serves as the superclass of all enumerated types declared with the new enum keyword.
Deprecated, Override, and SuppressWarnings are annotation types that provide metadata for the compiler.
This package-private class is the abstract superclass of StringBuffer and StringBuilder.
Because this class is not public, you may not use it directly.
It is included in this quickreference to fully document the shared API of its two subclasses.
Note that many of the methods of this class are declared to return an AbstractStringBuilder object.
StringBuilder and StringBuffer( ) override those methods and narrow the return type to StringBuilder or StringBuffer.
Objects that implement this interface can have characters or character sequences appended to them.
Appendable was added in Java 5.0 as a simple unifying API for StringBuffer and StringBuilder, java.nio.CharBuffer, and character output stream subclasses of java.io.Writer.
The java.util.Formatter class can send formatted output to any Appendable object.
Appendable append(char c) throws java.io.IOException; Appendable append(CharSequence csq) throws java.io.IOException; Appendable append(CharSequence csq, int start, int end) throws java.io.IOException;
A RuntimeException that signals an exceptional arithmetic condition, such as integer division by zero.
Signals that an array index less than zero or greater than or equal to the array size has been used.
Signals an attempt to store the wrong type of object into an array.
An instance of this class is thrown if when an assertion fails.
This happens when assertions are enabled, and the expression following an assert statement does not evaluate to true.
If an assertion fails, and the assert statement has a second expression separated from the first by a colon, then the second expression is evaluated and the resulting value is error message.
This class provides an immutable object wrapper around the boolean primitive type.
Note that the TRUE and FALSE constants are Boolean objects; they are not the same as the true and false boolean values.
As of Java 1.1, this class defines a Class constant that represents the boolean type.
The class method getBoolean( ) retrieves the boolean value of a named property from the system property list.
The static method valueOf( ) parses a string and returns the Boolean object it represents.
Java 1.4 added two static methods that convert primitive boolean values to Boolean and String objects.
In Java 5.0, the parseBoolean( ) method behaves like valueOf( ) but returns a primitive boolean value instead of a Boolean object.
Prior to Java 5.0, this class does not implement the Comparable interface.
This class provides an immutable object wrapper around the byte primitive type.
It defines useful constants for the minimum and maximum values that can be stored by the byte type and a Class object constant that represents the byte type.
It also provides various methods for converting Byte values to and from strings and other numeric types.
Most of the static methods of this class can convert a String to a Byte object or a byte value: the four parseByte( ) and valueOf( ) methods parse a number from the specified string using an optionally specified radix and return it in one of these two forms.
If it begins with “0”, it is interpreted as an octal number.
One is static and converts a byte primitive value to a string; the other is the usual toString( ) method that converts a Byte object to a string.
Most of the remaining methods convert a Byte to various primitive numeric types.
This class provides an immutable object wrapper around the primitive char data type.
The compareTo( ) method implements the Comparable interface so that Character objects can be ordered and sorted.
The static methods are the most interesting thing about this class, however: they categorize char values based on the categories defined by the Unicode standard.
Some of the methods are only useful if you have a detailed understanding of that standard.) Static methods beginning with “is” test whether a character is in a given category.
Note that these methods work for any Unicode character, not just with the familiar Latin letters and Arabic numbers of the ASCII character set.
In addition to testing the category of a character, this class also defines static methods for converting characters.
It works with any Unicode digit character, and also (for sufficiently large radix values) the ASCII letters a-z and A-Z.
Finally, the static toString( ) method returns a String of length 1 that contains the specified char value.
Finally, the various character type testing and case conversion methods such as isWhitespace( ) and toUpperCase( ) are available in new versions that take an int codepoint argument instead of a single char argument.
This class represents a named subset of the Unicode character set.
The toString( ) method returns the name of the subset.
Note, in particular, that it does not provide a way to list the members of the subset, nor a way to test for membership in the subset.
This subclass of Character.Subset defines a number of constants that represent named subsets of the Unicode character set.
The subsets and their names are the character blocks defined by the Unicode specification (see http://www.unicode.org/)
The static method of( ) takes a character or int codepoint and returns the Character.UnicodeBlock to which it belongs, or null if it is not part of any defined block.
When presented with an unknown Unicode character, this method provides a useful way to determine what alphabet it belongs to.
In Java 5.0, the forName( ) factory method allows lookup of a UnicodeBlock by name.
This interface defines a simple API for read-only access to sequences of characters.
In the core platform it is implemented by the String, StringBuffer and java.nio.CharBuffer classes.
Finally, toString( ) returns a String version of the sequence.
Note that CharSequence implementations do not typically have interoperable equals( ) or hashCode( ) methods, and it is not usually possible to compare two CharSequence objects or use multiple sequences in a set or hashtable unless they are instances of the same implementing class.
There is one Class object for each class that is loaded into the Java Virtual Machine, and, as of Java 1.1, there are special Class objects that represent the Java primitive types.
The TYPE constants defined by Boolean, Integer, and the other primitive wrapper classes hold these special Class objects.
Array types are also represented by Class objects in Java 1.1
You can obtain a Class object by calling the getClass( ) method of any instance of the desired class.
In Java 1.1 and later, you can also refer to a Class object by appending .class to the name of a class.
Finally, and most interestingly, a class can be dynamically loaded by passing its fully qualified name (i.e., the named class (if it is not already loaded) into the Java interpreter and returns a Class object for it.
The newInstance( ) method creates an instance of a given class; this allows you to create instances of dynamically loaded classes for which you cannot use the new keyword.
Note that this method works only when the target class has a no-argument constructor.
See newInstance( ) in java.lang.reflect.Constructor for a more powerful way to instantiate dynamically loaded classes.
In Java 5.0, Class is a generic type and the type variable T specifies the type that is returned by the newInstance( ) method.
In Java 1.2 and later, getPackage( ) returns a Package object that represents the package containing the class.
The various other get( ) and is( ) methods return other information about the represented class; they form part of the Java Reflection API, along with the classes in java.lang.reflect.
Java 5.0 adds a number of methods to support the new language features it defines.
Class implements java.lang.reflect.AnnotatedElement in Java 5.0 and the getAnnotation( ) and related methods allow the retrieval of annotations (with runtime retention) on the class.
Java 5.0 also adds methods that are useful for reflection on inner classes.
Finally, getSimpleName( ) returns the name of a type as it would appear in Java source code.
This is typically more useful than the Java VM formatted names returned by getName( )
Signals an invalid cast of an object to a type of which it is not an instance.
Signals that a circular dependency has been detected while performing initialization for a class.
Signals an error in the binary format of a class file.
This class is the abstract superclass of objects that know how to load Java classes into a Java VM.
Given a ClassLoader object, you can dynamically load a class by calling the resource associated with a class by calling getResource( ), getResources( ), and getResourceAsStream( )
Many applications do not need to use ClassLoader directly; these applications use the Class.forName( ) and Class.getResource( ) methods to dynamically load classes and resources using the ClassLoader object that loaded the application itself.
In order to load classes over the network or from any source other than the class path, you must use a custom ClassLoader object that knows how to obtain data from that source.
A java.net.URLClassLoader is suitable for this purpose for almost all applications.
Only rarely should an application need to define a ClassLoader subclass of its own.
When this is necessary, the subclass should typically extend java.security.SecureClassLoader and override the findClass( ) method.
This method must find the bytes that comprise the named class, then pass them to the defineClass( ) method and return the resulting Class object.
In Java 1.2 and later, the findClass( ) method must also define the Package object associated with the class, if it has not already been defined.
It can use getPackage( ) and definePackage( ) for this purpose.
Custom subclasses of ClassLoader should also override findResource( ) and findResources( ) to enable the public getResource( ) and getResources( ) methods.
In Java 1.4 and later you can specify whether the classes loaded through a ClassLoader should have assertions (assert statements) enabled.
Finally, clearAssertionStatus( ) sets the default status to false and discards the assertions status for any named packages and classes.
Signals that a class to be loaded cannot be found.
If an exception of this type was caused by some underlying exception, you can query that lower-level exeption with getException( ) or with the newer, more general getCause( )
This interface defines no methods or variables, but indicates that the class that implements it may be cloned (i.e., copied) by calling the Object method clone( )
Calling clone( ) for an object that does not implement this interface (and does not override clone( ) with its own implementation) causes a CloneNotSupportedException to be thrown.
Signals that the clone( ) method has been called for an object of a class that does not implement the Cloneable interface.
Thrown By Enum.clone( ), Object.clone( ), java.security.MessageDigest.clone( ), java.security.MessageDigestSpi.clone( ), java.security.Signature.clone( ), java.security.SignatureSpi.clone( ), java.util.AbstractMap.clone( ), java.util.EnumMap.clone( ), java.util.EnumSet.clone( ), javax.crypto.Mac.clone( ), javax.crypto.MacSpi.clone( )
This interface defines a single method, compareTo( ), that is responsible for comparing one object to another and determining their relative order, according to some natural ordering for that class of objects.
Any general-purpose class that represents a value that can be sorted or ordered should implement this interface.
Any class that does implement this interface can make use of various powerful methods such as java.util.Collections.sort( ) and java.util.Arrays.binarySearch( )
Many of the key classes in the Java API implement this interface.
The type variable T represents the type of the object that is passed to the compareTo( ) method.
The compareTo( ) method compares this object to the object passed as an argument.
It should assume that the supplied object is of the appropriate type; if it is not, it should throw a ClassCastException.
If this object is less than the supplied object or should appear before the supplied object in a sorted list, compareTo( ) should return a negative number.
If this object is greater than the supplied object or should come after the supplied object in a sorted list, compareTo( ) should return a positive integer.
If the two objects are equivalent, and their relative order in a sorted list does not matter, compareTo( ) should return 0
If compareTo( ) returns 0 for two objects, the equals( ) method should typically return true.
If this is not the case, the Comparable objects are not suitable for use in java.util.TreeSet and java.util.TreeMap classes.
See java.util.Comparator for a way to define an ordering for objects that do not implement Comparable or to define an ordering other than the natural ordering defined by a Comparable class.
The static methods of this class provide an interface to the just-in-time (JIT) byte-codeto-native code compiler in use by the Java interpreter.
If no JIT compiler is in use by the VM, these methods do nothing.
These methods return true if the compilation was successful, or false if it failed or if there is no JIT compiler on the system.
This annotation type marks the annotated program element as deprecated.
The Java compiler issues a warning if the annotated element is used or overrided in code that is not itself @Deprecated.
This annotation type has runtime retention and does not have an @Target meta-annotation, which means it may be applied to any program element.
Deprecated has an should be a documented part of the annotated element’s API.
This class provides an immutable object wrapper around the double primitive data type.
This class also provides some useful constants and static methods for testing double values.
Similarly, isNaN( ) tests whether a double or Double is not-a-number; this is a comparison that cannot be done directly because the NaN constant never tests equal to any other value, including itself.
The static parseDouble( ) method converts a String to a double.
The static valueOf( ) converts a String to a Double, and is basically equivalent to the Double( ) constructor that takes a String argument.
The static and instance toString( ) methods perform the opposite conversion: they convert a double or a Double to a String.
See also java.text.NumberFormat for more flexible number parsing and formatting.
The compareTo( ) method makes Double object Comparable which is useful for ordering and sorting.
The static compare( ) method is similar (its return values have the same meaning as those of Comparable.compareTo( )) but works on primitive values rather than objects and is useful when ordering and sorting arrays of double values.
This class is the common superclass of all enumerated types.
It is not itself an enum type, however, and a Java compiler does not allow other classes to extend it.
Subclasses of Enum may be only created with enum declarations.
Enum is a generic type, and the type variable E represents the concrete enumerated type that actually extends Enum.
This type variable exists so that Enum can implement Comparable<E>
The final methods name( ) and ordinal( ) return these values.
Most users of enumerated constants will use toString( ) instead of name( )
The implementation of toString( ) defined by Enum returns the same value as name( )
The toString( ) method is not final, however, and it can be overridden in enum declarations.
Enum implements a number of Object and Comparable methods and makes its implementations final so that they are inherited by all enum types and may not be overridden.
In order to make this identity-based equals( ) implementation work, Enum overrides the protected clone( ) method to throw CloneNotSupportedException, preventing additional copies of enumerated values from being created.
Finally, the compareTo( ) method of the Comparable interface is defined to compare enumerated values based on their ordinal( ) value.
It is like the getClass( ) method inherited from Object, but the return values of these two methods will be different for enumerated constants that have value-specific class bodies, since those constants are instances of an anonymous subclass of the enum type.
The static valueOf( ) method is passed the type and name of an enumerated constant and returns the object that represents that constant (or throws an IllegalArgumentException)
Subclasses Thread.State, java.lang.annotation.ElementType, java.lang.annotation.RetentionPolicy, java.lang.management.MemoryType, java.math.RoundingMode, java.net.Authenticator.RequestorType, java.net.Proxy.Type, java.security.KeyRep.Type, java.util.Formatter.BigDecimalLayoutForm, java.util.concurrent.TimeUnit, javax.net.ssl.SSLEngineResult.HandshakeStatus, javax.net.ssl.SSLEngineResult.Status.
This unchecked exception is thrown when Java code attempts to use an enum constant that no longer exists.
This can happen only if the enumerated constant was removed from its enumerated type after the referencing code was compiled.
The methods of the exception provide the Class of the enumerated type and the name of the nonexistent constant.
This class forms the root of the error hierarchy in Java.
Subclasses of Error, unlike subclasses of Exception, should not be caught and generally cause termination of the program.
Subclasses of Error need not be declared in the throws clause of a method definition.
This class inherits methods from Throwable but declares none of its own.
This class forms the root of the exception hierarchy in Java.
An Exception signals an abnormal condition that must be specially handled to prevent program termination.
An exception that is not a subclass of RuntimeException must be declared in the throws clause of any method that can throw it.
This class inherits methods from Throwable but declares none of its own.
Each of its constructors simply invokes the corresponding Throwable( ) constructor.
Passed To java.io.WriteAbortedException.WriteAbortedException( ), java.nio.charset.CoderMalfunctionError.CoderMalfunctionError( ), java.security.PrivilegedActionException.PrivilegedActionException( ), java.util.logging.ErrorManager.error( ), java.util.logging.Handler.reportError( ), javax.xml.parsers.FactoryConfigurationError.FactoryConfigurationError( ), javax.xml.transform.TransformerFactoryConfigurationError.TransformerFactoryConfigurationError( ), org.xml.sax.SAXException.SAXException( ), org.xml.sax.SAXParseException.SAXParseException( )
Returned By java.security.PrivilegedActionException.getException( ), javax.xml.parsers.FactoryConfigurationError.getException( ), javax.xml.transform.TransformerFactoryConfigurationError.getException( ), org.xml.sax.SAXException.getException( )
This error is thrown by the Java Virtual Machine when an exception occurs in the static initializer of a class.
You can use the getException( ) method to obtain the Throwable object that was thrown from the initializer.
In Java 1.4 and later, getException( ) has been superseded by the more general getCause( ) method of the Throwable class.
This class provides an immutable object wrapper around a primitive float value.
This class is very similar to Double, and defines the same set of useful methods and constants as that class does.
Signals an attempted use of a class, method, or field that is not accessible.
Subclasses IllegalThreadStateException, NumberFormatException, java.nio.channels.IllegalSelectorException, java.nio.channels.UnresolvedAddressException, java.nio.channels.UnsupportedAddressTypeException, java.nio.charset.IllegalCharsetNameException, java.nio.charset.UnsupportedCharsetException, java.security.InvalidParameterException, java.util.IllegalFormatException, java.util.regex.PatternSyntaxException.
It is thrown by the Object notify( ) and wait( ) methods used for thread synchronization.
Signals that a method has been invoked on an object that is not in an appropriate state to perform the requested operation.
Subclasses java.nio.InvalidMarkException, java.nio.channels.AlreadyConnectedException, java.nio.channels.CancelledKeyException, java.nio.channels.ClosedSelectorException, java.nio.channels.ConnectionPendingException, java.nio.channels.IllegalBlockingModeException, java.nio.channels.NoConnectionPendingException, java.nio.channels.NonReadableChannelException, java.nio.channels.NonWritableChannelException, java.nio.channels.NotYetBoundException, java.nio.channels.NotYetConnectedException, java.nio.channels.OverlappingFileLockException, java.util.FormatterClosedException, java.util.concurrent.CancellationException.
Signals that a thread is not in the appropriate state for an attempted operation to succeed.
This is the superclass of a group of related error types.
This class holds a thread-local value that is inherited by child threads.
Note that the inheritance referred to in the name of this class is not from superclass to subclass; it is inheritance from parent thread to.
Like its superclass, this class has been made generic in Java 5.0
The type variable T represents the type of the referenced object.
Suppose that an application has defined an InheritableThreadLocal object and that a certain thread (the parent thread) has a thread-local value stored in that object.
Whenever that thread creates a new thread (a child thread), the InheritableThreadLocal object is automatically updated so that the new child thread has the same value associated with it as the parent thread.
Note that the value associated with the child thread is independent from the value associated with the parent thread.
If the child thread subsequently alters its value by calling the set( ) method of the InheritableThreadLocal, the value associated with the parent thread does not change.
By default, a child thread inherits a parent’s values unmodified.
By overriding the childValue( ) method, however, you can create a subclass of InheritableThreadLocal in which the child thread inherits some arbitrary function of the parent thread’s value.
Signals an attempt to instantiate an interface or abstract class.
Signals an attempt to instantiate an interface or an abstract class.
This class provides an immutable object wrapper around the int primitive data type.
This class also contains useful minimum and maximum constants and useful conversion methods.
Each can take a radix argument to specify the base the value is represented in.
Other routines return the value of an Integer as various primitive types, and, finally, the getInteger( ) methods return the integer value of a named property from the system property list, or the specified default value.
Java 5.0 adds a number of static methods that operate on the bits of an int value.
This interface defines a single method for returning a java.util.Iterator object.
List, Set, and Queue collection interfaces of java.util extend this interface, making all collections other than maps Iterable.
You can implement this interface in your own classes if you want to allow them to be iterated with the for/in loop.
The type variable T specifies the type parameter of the returned Iterator object, which, in turn, specifies the element type of the collection being iterated over.
The superclass of a group of errors that signal problems linking a class or resolving dependencies between classes.
This class provides an immutable object wrapper around the long primitive data type.
This class also contains useful minimum and maximum constants and useful conversion methods.
Each can take a radix argument to specify the base the value is represented in.
Other routines return the value of a Long as various primitive types, and, finally, the getLong( ) methods return the long value of a named property or the value of the specified default.
Java 5.0 adds a number of static methods that operate on the bits of a long value.
Except for their argument type and return type, they are the same as the Integer methods of the same name.
This class defines constants for the mathematical values e and π and defines static methods for floating-point trigonometry, exponentiation, and other operations.
It also contains methods for computing minimum and maximum values and for generating pseudorandom numbers.
Most methods of Math operate on float and double floating-point values.
Remember that these values are only approximations of actual real numbers.
To allow implementations to take full advantage of the floating-point capabilities of a native platform, the methods of Math are not required to return exactly the same values on all platforms.
In other words, the results returned by different implementations may differ slightly in the least-significant bits.
As of Java 1.3, applications that require strict platform-independence of results should use StrictMath instead.
Signals an attempt to allocate an array with fewer than zero elements.
Signals that the definition of a specified class cannot be found.
This exception signals that the specified field does not exist in the specified class.
Signals that the specified method does not exist in the specified class.
Signals an attempt to access a field or invoke a method of a null object.
Returned By java.text.ChoiceFormat.parse( ), java.text.DecimalFormat.parse( ), java.text.NumberFormat.parse( ), javax.xml.datatype.Duration.getField( )
All classes are subclasses of Object, and thus all objects can invoke the public and protected methods of this class.
For classes that implement the Cloneable interface, clone( ) makes a byte-for-byte copy of an Object.
A number of these Object methods should be overridden by subclasses of Object.
For example, a subclass should provide its own definition of the toString( ) method so that it can be used with the string concatenation operator and with the PrintWriter.println( ) methods.
Defining the toString( ) method for all objects also helps with debugging.
Many subclasses override this method to compare the individual fields of two distinct objects (i.e., they override the method to test for the equivalence of distinct objects rather than the equality of object references)
Some classes, particularly those that override equals( ), may also want to override the hashCode( ) method to provide an appropriate hashcode to be used when storing instances in a Hashtable data structure.
A class that allocates system resources other than memory (such as file descriptors or windowing system graphic contexts) should override the finalize( ) method to release these resources when the object is no longer referred to and is about to be garbage-collected.
Signals that the interpreter has run out of memory (and that garbage collection is unable to free any memory)
Protected Instance Methods protected Object clone( ) throws CloneNotSupportedException;  native protected void finalize( ) throws Throwable;  empty.
An annotation of this type may be applied to methods and indicates that the programmer intends for the method to override a method from a superclass.
In effect, it is an assertion for the compiler to verify.
If a method annotated @Override does not, in fact, override another method (perhaps because the method name was misspelled or an argument was incorrectly typed), the compiler issues an error.
You can obtain the Package object for a given Class by calling the getPackage( ) method of the Class object.
The static Package.getPackage( ) method returns a Package object for the named package, if any such package has been loaded by the current class loader.
Similarly, the static Package.getPackages( ) returns all Package objects that have been loaded by the current class loader.
Note that a Package object is not defined unless at least one class has been loaded from that package.
Although you can obtain the Package of a given Class, you cannot obtain an array of Class objects contained in a specified Package.
If the classes that comprise a package are contained in a JAR file that has the appropriate attributes set in its manifest file, the Package object allows you to query the title, vendor, and version of both the package specification and the package implementation; all six values are strings.
It consists of one or more integers, separated from each other by periods.
Each integer can have leading zeros, but is not considered an octal digit.
The isCompatibleWith( ) method calls getSpecificationVersion( ) to obtain the specification version and compares it with the version string supplied as an argument.
If the package-specification version is the same as or greater than the specified string, isCompatibleWith( ) returns true.
This allows you to test whether the version of a application.
Packages may be sealed, which means that all classes in the package must come from the same JAR file.
If a package is sealed, the no-argument version of isSealed( ) returns true.
The one-argument version of isSealed( ) returns true if the specified URL represents the JAR file from which the package is loaded.
This class describes a process that is running externally to the Java interpreter.
Note that a Process is very different from a Thread; the Process class is abstract and cannot be instantiated.
Call one of the Runtime.exec( ) methods to start a process and return a corresponding Process object.
Specify the operating system command when you invoke the ProcessBuilder( ) constructor or with the.
Before launching the command you have specified, you can configure the ProcessBuilder.
Query the current working directory with the no-argument version of directory( ) and set it with the one-argument version of the method.
Query the mapping of environment variables to values with the environment( ) method.
You can alter the mappings in the returned Map to specify the environment you want the child process to run in.
Pass true to redirectErrorStream( ) if you would like both the standard output and the standard error stream of the child process to be merged into a single stream that you can obtain with Process.getInputStream( )
If you do so, you do not have to arrange to read two separate input streams to get the output of the process.
Once you have specified a command and configured your ProcessBuilder as desired, call the start( ) method to launch the process.
You then use methods of the returned Process to provide input to the process, read output from the process, or wait for the process to exit.
This may occur, for example, if the executable filename you have specified does not exist.
The command( ) and directory( ) methods do not perform error checking on the values you provide them; these checks are performed by the start( ) method, so it is also possible for start( ) to throw exceptions based on bad input to the configuration methods.
Note that a ProcessBuilder can be reused: once you have established a working directory and environment variables, you can change the command( ) and launch multiple processes with repeated calls to start( )
Objects that implement this interface can serve as a source of characters and can transfer one or more at a time to a java.nio.CharBuffer.
Readable was added in Java 5.0 as a simple unifying API for java.nio.CharBuffer and character input stream subclasses of java.io.Reader.
The java.util.Scanner class can parse input from any Readable object.
This interface specifies the run( ) method that is required to use with the Thread class.
Any class that implements this interface can provide the body of a thread.
The static method getRuntime( ) returns the Runtime object for the current platform; this object can perform system functions in a platform-independent way.
In Java 1.3, addShutdownHook( ) registers an unstarted Thread object that is run when the virtual machine shuts down, either through a call to exit( ) or through a user interrupt (a CTRL-C, for example)
The purpose of a shutdown hook is to perform necessary cleanup, such as shutting down network connections, deleting temporary files, and so on.
Any number of hooks can be registered with addShutdownHook( )
Before the interpreter exits, it starts all registered shutdown-hook threads and lets them run concurrently.
Any hooks you write should perform their cleanup operation and exit promptly so they do not delay the shutdown process.
To remove a shutdown hook before it is run, call removeShutdownHook( )
To force an immediate exit that does not invoke the shutdown hooks, call halt( )
Note that any processes run outside of Java may be system-dependent.
Similarly, runFinalization( ) forces the finalize( ) methods of unreferenced objects to be run immediately.
This may free up system resources those objects were holding.
These libraries generally contain native code definitions for native methods.
These methods are used for debugging or profiling an application.
It is not specified how the VM emits the trace information, and VMs are not even required to support this feature.
Note that some of the Runtime methods are more commonly called via the static methods of the System class.
This exception type is not used directly, but serves as a superclass of a group of runtime exceptions that need not be declared in the throws clause of a method definition.
These exceptions need not be declared because they are runtime conditions that can generally occur in any Java method.
Thus, declaring them would be unduly burdensome, and Java does not require it.
This class inherits methods from Throwable but declares none of its own.
Each of the RuntimeException constructors simply invokes the corresponding Exception( ) and Throwable( ) constructor.
This class is a java.security.Permission that represents access to various important system facilities.
A RuntimePermission has a name, or target, that represents the facility for which permission is being sought or granted.
The name of a RuntimePermission may use a “.*” suffix as a wildcard.
RuntimePermission does not use action list strings as some Permission classes do; the name of the permission alone is enough.
System administrators configuring security policies should be familiar with these permission names, the operations they govern access to, and with the risks inherent in granting any of them.
Although system programmers may need to work with this class, application programmers should never need to use RuntimePermssion directly.
Signals that an operation is not permitted for security reasons.
This class defines the methods necessary to implement a security policy for the safe execution of untrusted code.
Before performing potentially sensitive operations, Java calls methods of the SecurityManager object currently in effect to determine whether the operations are permitted.
These methods throw a SecurityException if the operation is not permitted.
Typical applications do not need to use or subclass SecurityManager.
It is typically used only by web browsers, applet viewers, and other programs that need to run untrusted code in a controlled environment.
Prior to Java 1.2, this class is abstract, and the default implementation of each check( ) method throws a SecurityException unconditionally.
The Java security mechanism has been overhauled as of Java 1.2
As part of the overhaul, this class is no longer abstract and its methods have useful default implementations, so there is rarely a need to subclass it.
In Java 1.2 and later, all other check( ) methods of SecurityManager are now implemented on top of checkPermission( )
This class provides an immutable object wrapper around the short primitive type.
It defines useful constants for the minimum and maximum values that can be stored by the short type, and also a Class object constant that represents the short type.
It also provides various methods for converting Short values to and from strings and other numeric types.
Most of the static methods of this class can convert a String to a Short object or a short value; the four parseShort( ) and valueOf( ) methods parse a number from the specified string using an optionally specified radix and return it in one of these two forms.
Note that this class has two different toString( ) methods.
One is static and converts a short primitive value to a string.
The other is the usual toString( ) method that converts a Short object to a string.
Most of the remaining methods convert a Short to various primitive numeric types.
Signals that a stack overflow has occurred within the Java interpreter.
Instances of this class are returned in an array by Throwable.getStackTrace( )
Each instance represents one frame in the stack trace associated with an exception or error.
If the class file contains sufficient information, getFileName( ) and getLineNumber( ) return the.
This class is identical to the Math class, but additionally requires that its methods strictly adhere to the behavior of certain published algorithms.
The methods of StrictMath are intended to operate identically on all platforms, and must produce exactly the same result (down to the very least significant bit) as certain well-known standard algorithms.
When strict platform-independence of floating-point results is not required, use the Math class for better performance.
A String object is created by the Java compiler whenever it encounters a string in double quotes; this method of creation is typically simpler than using a constructor.
The static valueOf( ) factory methods create new String objects that hold the textual representation of various Java primitive types.
There are also valueOf( ) methods, copyValueOf( ) methods and String( ) constructors for creating a String object that holds a copy of the text contained in another String, StringBuffer, StringBuilder, or a char or int array.
You can also use the String( ) constructor to create a String object from an array of bytes.
If you do this, you may explicitly specify the name of the charset (or character encoding) to be used to decode the bytes into characters, or you can rely on the default charset for your platform.
In Java 5.0, the static format( ) methods provide another useful way to create String objects that hold formatted text.
These utility methods create and use a new java.util.Formatter object and behave like the sprintf( ) function in the C programming language.
You can use these two methods to iterate through the characters of a string.
You can obtain a char array that holds the characters of a string with toCharArray( ), or use getChars( ) to copy just a selected region of the string into an existing array.
Use getBytes( ) if you want to obtain an array of bytes that contains the encoded form of the characters in a string, using either the platform’s default encoding or a named encoding.
This class defines many methods for comparing strings and substrings.
As of Java 1.4, the contentEquals( ) method compares a string to a specified StringBuffer object, returning true if they contain the same text.
A two-argument version of startsWith( ) allows you to specify a position within this string at which the prefix comparison is to be done.
The regionMatches( ) method is a generalized version of this startsWith( ) method.
It returns true if the specified region of the specified string matches the characters that begin at a specified position within this string.
The fiveargument version of this method allows you to perform this comparison ignoring the case of the characters being compared.
The final string comparison method is matches( ), which, as described below, compares a string to a regular expression pattern.
The CASE_INSENSITIVE_ORDER constant is a Comparator for sorting strings in a way that ignores the case of their characters.
The java.util.Comparator interface is similar to the Comparable interface but allows the definition of object orderings that are different from the default ordering defined by Comparable.) The compareTo( ) and compareToIgnoreCase( ) methods and the CASE_INSENSITIVE_ORDER Comparator object order strings based only on the numeric ordering of the Unicode encoding of their characters.
See java.text.Collator for a more general technique for collating strings.
They return the position of the match, or -1 if there is no match.
The one argument versions of these methods start at the beginning or end of the string, and the two-argument versions start searching from a specified character position.
Java 5.0 adds new comparison methods that work with any CharSequence.
A new version of contentEquals( ) enables the comparison of a string with any CharSequence, including StringBuilder objects.
The contains( ) method returns true if the string contains any sequence of characters equal to the specified CharSequence.
A one-argument version returns all characters from (and including) the specified start position to the end of the string.
As of Java 1.4, the String class implements the CharSequence interface and defines the subSequence( ) method, which works just like the two-argument version of substring( ) but returns the specified characters as a CharSequence rather than as a String.
Several methods return new strings that contain modified versions of the text held by the original string (the original string remains unchanged)
Java 5.0 adds a generalized version of replace( ) that replaces all occurrences of one CharSequence with another.
More general methods, replaceAll( ) and replaceFirst( ), use regular expression pattern matching; they are described later in this section.
String concatenation is more commonly done, however, with the + operator.
Note that String objects are immutable; there is no setCharAt( ) method to change the contents.
The methods that return a String do not modify the string they are invoked on but instead return a new String object that holds a modified copy of the text of the original.
Use a StringBuffer if you want to manipulate the contents of a string or call toCharArray( ) or getChars( ) to convert a string to an array of char values.
Java 1.4 introduced support for pattern matching with regular expressions.
The split( ) methods return an array of substrings of this string, formed by splitting this string at positions that match the specified regular expression.
These regular expression methods are all convenience methods that simply call methods of the same name in the java.util.regex package.
See the Pattern and Matcher classes in that package for further details.
Many programs use strings as commonly as they use Java primitive values.
Because the String type is an object rather than a primitive value, however, you cannot in general use immutable, you must use the more expensive equals( ) method.
For programs that perform a lot of string comparison, the intern( ) provides a way to speed up those comparisons.
The String class maintains a set of String objects that includes all doublequoted string literals and all compile-time constant strings defined in a Java program.
The set is guaranteed not to contain duplicates, and the set is used to ensure that duplicate String objects are not created unnecessarily.
The intern( ) method looks up a string in or adds a new string to this set of unique strings.
It searches the set for a string that contains exactly the same characters as the string you invoked the method on.
If such a string is found, intern( ) returns it.
If no matching string is found, the string you invoked intern( ) on is itself stored in the set (”interned”) and becomes the return value of the method.
What this means is that you can safely compare any strings can also successfully compare any string returned by intern( ) to any string constant with.
String methods for working with supplementary characters, such as codePointAt( ), codePointCount( ), and offsetByCodePoints( ), are similar to those defined by Character.
This class represents a mutable string of characters that can grow or shrink as necessary.
Its mutability makes it suitable for processing text in place, which is not possible with the immutable String class.
You may pass a String that contains the initial text for the buffer to this constructor, but if you do not, the buffer will start out empty.
You may also specify the initial capacity for the buffer if you can estimate the number of characters the buffer will eventually hold.
The methods of this class are synchronized, which makes StringBuffer objects suitable for use by multiple threads.
In Java 5.0 and later, when working with a single thread, StringBuilder is preferred over this class because it does not have the overhead of synchronized methods.
StringBuilder implements the same methods as StringBuffer and can be used in the same way.
Query the character stored at a given index with charAt( ) and set or delete that character with setCharAt( ) or deleteCharAt( )
Use length( ) to return the length of the buffer, and use setLength( ) to set the length of the buffer, truncating it or filling it with null characters (’\u0000’) as necessary.
If you expect a StringBuffer to grow substantially and can approximate its eventual size, you can use ensureCapacity( ) to preallocate sufficient internal storage.
Use the various append( ) methods to append text to the end of the buffer.
Use insert( ) to insert text at a specified position within the buffer.
Note that in addition to strings, primitive values, character arrays, and arbitrary objects may be passed to append( ) and insert( )
These values are converted to strings before they are appended or inserted.
Use delete( ) to delete a range of characters from the buffer and use replace( ) to replace a range of characters with a specified String.
Use substring( ) to convert a portion of a StringBuffer to a String.
The two versions of this method work just like the same-named methods of String.
Call toString( ) to obtain the contents of a StringBuffer as a String object.
Or use getChars( ) to extract the specified range of characters from the StringBuffer and store them into the specified character array starting at the specified index of that array.
As of Java 1.4, StringBuffer implements CharSequence and so also defines a subSequence( ) method that is like substring( ) but returns its value as a CharSequence.
Java 1.4 also added indexOf( ) and lastIndexOf( ) methods that search forward or backward (from the optionally specified index) in a StringBuffer for a sequence of characters that matches the specified String.
These methods return the index of the matching string or -1 if no match was found.
See also the similarly named methods of String after which these methods are modeled.
In Java 5.0, this class has a new constructor and new methods for working with CharSequence objects.
It implements the Appendable interface for use with java.util.Formatter and includes new methods for working with 21-bit Unicode characters as int codepoints.
After a string is processed in a StringBuffer object, it can be efficiently converted to a String object for subsequent use.
The StringBuffer.toString( ) method is typically implemented so that it does not copy the internal array of characters.
Instead, it shares that array with the new String object, making a new copy for itself only if and when further modifications are made to the StringBuffer object.
This class defines the same methods as StringBuffer but does not declare those methods synchronized, which can result in better performance in the common case in which only a single thread is using the object.
StringBuilder is a drop-in replacement for StringBuffer and should be used in preference to StringBuffer except where thread safety is required.
See StringBuffer for an overview of the methods shared by these two classes.
Signals that the index used to access a character of a String or StringBuffer is less than zero or is too large.
An annotation of this type tells the Java compiler not to generate specified kinds of warning messages for code within the annotated program element.
Annotations of this type have source retention and may be applied to any program element except packages and other annotation types.
An @SuppressWarnings annotation has an array of String objects as its value.
These strings specify the names of the warnings to be suppressed.
The available warnings (and their names) depend on the compiler implementation, and compilers will ignore warning names they do not support.
Compiler vendors are expected to cooperate in defining at least a core set of common warning names.
This class defines a platform-independent interface to system facilities, including system properties and system input and output streams.
All methods and variables of this class are static, and the class cannot be instantiated.
Because the methods defined by this class are low-level system methods, most require special permissions and cannot be executed by untrusted code.
In Java 1.2 and later, setProperty( ) sets the value of a system property.
In Java 5.0, you can clear a property setting with clearProperty( )
The following table lists system properties that are always defined.
Untrusted code may be unable to read some or all of these properties.
Additional properties can be defined using the -D option when invoking the Java interpreter.
The in, out, and err fields hold the standard input, output, and error streams for the system.
These fields are frequently used in calls such as System.out.println( )
In Java 1.1, setIn( ), setOut( ), and setErr( ) allow these streams to be redirected.
In Java 5.0, nanoTime( ) returns a time in nanoseconds.
The one-argument version of getenv( ) was previously deprecated but has been restored in Java 5.0
It does this regardless of whether or how the hashCode( ) method has been overridden.
In Java 5.0, inheritedChannel( ) returns a java.nio.channels.Channel object that represents a network connection passed to the Java process by the invoking process.
This allows Java programs to be used with the Unix inetd daemon, for example.
Finally, getSecurityManager( ) and setSecurityManager( ) get and set the system SecurityManager object responsible for the system security policy.
See also Runtime, which defines several other methods that provide low-level access to system facilities.
This class encapsulates all information about a single thread of control running on the Java interpreter.
To create a thread, you must either pass a Runnable object (i.e., an object that implements the Runnable interface by defining a run( ) method) to the Thread constructor or subclass Thread so that it defines its own run( ) method.
The run( ) method of the Thread or of the specified Runnable object is the body of the thread.
It begins executing when the start( ) method of the Thread object is called.
The static methods of this class operate on the currently running thread.
The instance methods may be called by one thread to operate on a different thread.
A thread can test its own interrupted flag with the static interrupted( ) method or can test the flag of another thread with isInterrupted( )
Calling interrupted( ) implicitly clears the interrupted flag, but calling isInterrupted( ) does not.
Methods related to sleep( ) and interrupt( ) are the wait( ) and notify( ) methods defined by the Object class.
Calling wait( ) causes the current thread to block until the object’s notify( ) method is called by another thread.
Java does not specify what happens to multiple threads of equal priority; some systems perform time-slicing and share the CPU between such threads.
On other systems, one compute-bound thread that does not call yield( ) may starve another thread of the same priority.
The Java VM keeps running as long as at least one nondaemon thread is running.
Call getThreadGroup( ) to obtain the ThreadGroup of which a thread is part.
In Java 1.2 and later, use setContextClassLoader( ) to specify the ClassLoader to be used to load any classes required by the thread.
If a thread must be stoppable, have it periodically check a flag and exit if the flag is set.
Typically, larger stack sizes allow threads to recurse more deeply before running out of stack space.
Smaller stack sizes reduce the fixed per-thread memory requirements and may allow more threads to exist concurrently.
The meaning of this argument is implementation dependent, and implementations may even ignore it.
Register a handler of this type with setUncaughtExceptionHandler( ) or register a default handler with the static methods setDefaultUncaughtExceptionHandler( )
Obtain a snapshot of a thread’s current stack trace with getStackTrace( )
This returns an array of StackTraceElement objects: the first element of the array is the most recent method invocation and the last element is the least recent.
The static getAllStackTraces( ) returns stack traces for all running threads (the traces may be obtained at different times for different threads)
Returned By java.util.concurrent.ThreadFactory.newThread( ), java.util.concurrent.locks.AbstractQueuedSynchronizer.getFirstQueuedThread( ), java.util.concurrent.locks.ReentrantLock.getOwner( ), java.util.concurrent.locks.ReentrantReadWriteLock.getOwner( )
This enumerated type defines the possible states of a thread.
Call the getState( ) method of a Thread object to obtain one of the enumerated constants defined here.
A NEW thread has not been started yet, and a TERMINATED thread has exited.
A BLOCKED thread is waiting to enter a synchronized method or block.
A WAITING thread is waiting in Object.wait( ), Thread.join( ), or a similar method.
A TIMED_WAITING thread is waiting but is subject to a timeout, such as in Thread.sleep( ) or the timed versions of Object.wait( ) and Thread.join( )
Finally, a thread that has been started and has not yet exited and is not blocked or waiting is RUNNABLE.
This does not mean that the operating system is currently running it or that it is even making any forward progress, but that it is at least available to run when the operating system gives it the CPU.
This interface defines a handler to be invoked when a thread throws an exception that remains uncaught.
When this happens, the uncaughtException( ) method of the registered handler is invoked with the Thread object that threw the exception and the Throwable exception object as arguments.
The handler is run by the thread that received the exception, and that thread will exit as soon as the handler exits.
If uncaughtException( ) itself throws an exception, that exception will be ignored.
An object that implements this interface may be registered for a Thread with the setUncaughtExceptionHandler( ) method.
A default UncaughtExceptionHandler may be registered with the static method Thread.setDefaultUncaughtExceptionHandler( )
If no handler or default handler is registered, the uncaughtException( ) method of the containing ThreadGroup is used instead.
This error is thrown in a thread when the Thread.stop( ) method is called for that thread.
This is an unusual Error type that simply causes a thread to be terminated, but does not print an error message or cause the interpreter to exit.
You can catch ThreadDeath errors to do any necessary cleanup for a thread, but if you do, you must rethrow the error so that the thread actually terminates.
This class represents a group of threads and allows that group to be manipulated as a whole.
A ThreadGroup can contain Thread objects, as well as other child ThreadGroup objects.
ThreadGroup objects are created as children of some other ThreadGroup, and thus there is a parent/child hierarchy of ThreadGroup objects.
Use getParent( ) to obtain the parent ThreadGroup, and use activeCount( ), activeGroupCount( ), and the various enumerate( ) methods to list the child Thread and ThreadGroup objects.
Most applications can simply rely on the default system thread group.
System-level code and applications such as servers that need to create a large number of threads may find it convenient to create their own ThreadGroup objects, however.
The method throws a SecurityException if the current thread does not have access.
This class provides a convenient way to create thread-local variables.
When you declare a static field in a class, there is only one value for that field, shared by all objects of the class.
When you declare a nonstatic instance field in a class, every object of the class has its own separate copy of that variable.
If you declare a static field to hold a ThreadLocal object, that ThreadLocal holds a different value for each thread.
Objects running in the same thread see the same value when they call the get( ) method of the ThreadLocal object.
Objects running in different threads obtain different values from get( ), however.
In Java 5.0, this class has been made generic and the type variable T represents the type of the object referenced by this ThreadLocal.
The set( ) method sets the value held by the ThreadLocal object for the currently running thread.
Note that there is no way to obtain the value of the ThreadLocal object for any thread other than the one that calls get( )
To understand the ThreadLocal class, you may find it helpful to think of a ThreadLocal object as a hashtable or java.util.Map that maps from Thread objects to arbitrary values.
Calling set( ) creates an association between the current Thread (Thread.currentThread( )) and the specified value.
Calling get( ) first looks up the current thread, then uses the hashtable to look up the value associated with that current thread.
If a thread calls get( ) for the first time without having first called set( ) to establish a thread-local value, get( ) calls the protected initialValue( ) method to obtain the initial value to return.
The default implementation of initialValue( ) simply returns null, but subclasses can override this if they desire.
See also InheritableThreadLocal, which allows thread-local values to be inherited from parent threads by child threads.
This is the root class of the Java exception and error hierarchy.
The getMessage( ) method retrieves any error message associated with the exception or error.
The default implemenation of getLocalizedMessage( ) simply calls getMessage( ), but subclasses may override this method to return an error message that has been localized for the default locale.
It is often the case that an Exception or Error is generated as a direct result of some other exception or error, perhaps one thrown by a lower-level API.
If there is a cause, pass it to the Throwable( ) constructor, or to the initCause( ) method.
When you catch a Throwable object, you can obtain the Throwable that caused it, if any, with getCause( )
Every Throwable object has information about the execution stack associated with it.
This information is initialized when the Throwable object is created.
If the object will be thrown somewhere other than where it was created, or if it caught and will be rethrown, you can use fillInStackTrace( ) to capture the current execution stack before throwing it.
In Java 1.4, you can also obtain this information with getStackTrace( ) which returns an array of StackTraceElement objects describing the execution stack.
This unchecked exception signals that a class file associated with a java.lang.reflect.Type could not be found.
It typically results when a class depends on a type that has changed or been removed and indicates version skew that requires recompilation or code refactoring.
Signals that an unknown error has occurred at the level of the Java Virtual Machine.
Signals that Java cannot satisfy all the links in a class that it has loaded.
Every Java class file contains a version number that specifies the version of the class file format.
This error is thrown when the Java Virtual Machine attempts to read a class file with a version number it does not support.
Signals that a method you have called is not supported, and its implementation does not do anything (except throw this exception)
This exception is used most often by the Java collection framework of java.util.
Immutable or unmodifiable collections throw this exception when a modification method, such as add( ) or delete( ), is called.
Signals that a class has not passed the byte-code verification procedures.
An abstract error type that serves as superclass for a group of errors related to the Java Virtual Machine.
The Void class cannot be instantiated and serves merely as a placeholder for its static TYPE field, which is a Class object constant that represents the void type.
It includes the base Annotation interface that all annotation types extend, meta-annotation types, their associated enumerated types, and exception and error classes related to annotations.
A type declared with the @interface syntax is an annotation type that implicitly extends this interface.
Note that the Annotation interface is not itself an annotation type.
Furthermore, if you define an interface (rather than an @interface) that explicitly extends Annotation, the result is not an annotation type either.
The only way to define an annotation type is with an @interface definition.
When an annotation is queried with the java.lang.reflect.AnnotatedElement API, the object returned implements this interface as well as the interface defined by the specific annotation type.
This interface defines the annotationType( ) method, which returns the Class of the annotation type for any annotation object.
It also includes the equals( ) and hashCode( ) methods of Object to require an implementation to compare annotations by the values of their method to require implementations to provide some meaningful string representation of an annotation.
The format of the returned string is not specified, but you can expect implementations to produce a string using a syntax similar to that used to encode annotations in Java source code.
An error of this type indicates that a class file includes a malformed annotation.
An exception of this type indicates version skew in an annotation type.
It occurs when the Java VM attempts to read an annotation from a class file and discovers that the type of an annotation member has changed since the class file (and the annotation it contains) was compiled.
A meta-annotation of this type indicates that the annotated type should be documented by Javadoc and similar documentation tools.
The constants declared by this enumerated type represent the types of program elements that can be annotated.
The value of an @Target annotation is an array of ElementType constants.
Most of the constants have obvious meanings, but some require additional explanation.
ANNOTATION_TYPE represents only annotation types and is used for metaannotations.
An exception of this type indicates version skew in an annotation type.
It occurs when the Java VM attempts to read an annotation from a class file and discovers that the annotation type has added a new member since the class file was compiled.
Note that this exception does not occur if a new member with a default clause is added to the annotation type.
When an annotation type that has an @Inherited meta-annotation is applied to a class, that annotation should be inherited by subclasses and descendants of the annotated class.
If an @Inherited annotation type is applied to a method or program element other than a class, no inheritance applies.
If the through java.lang.reflect.AnnotatedElement manages the inheritance of the annotation.
A meta-annotation of this type specifies how long the annotated annotation type should be retained.
The value( ) of this annotation type is one of the three RetentionPolicy enumerated constants.
If an annotation type does not have an @Retention meta-annotation, its default retention is RetentionPolicy.CLASS.
The constants declared by the enumerated type specify the possible retention values for an @Retention meta-annotation.
Annotations with SOURCE retention appear in Java source code only and are discarded by the compiler.
This is the default retention for annotation types that do not have an @Retention meta-annotation.) Finally, annotations with RUNTIME retention are stored in the class file and loaded by the Java interpreter at runtime.
A meta-annotation of this type specifies what program elements the annotated annotation type can be applied to.
The value( ) of a Target annotation is an array of ElementType enumerated constants.
If an annotation type does not have an @Target meta-annotation, it can be applied to any program element.
This package defines the API for instrumenting a Java VM by transforming class files to add profiling support, code coverage testing, or other features.
The -javaagent command-line option to the Java interpreter provides a hook for running the premain( ) method of a Java instrumentation agent.
An Instrumentation object passed to the premain( ) method provides an entry point into this package, and methods of Instrumentation allow loaded classes to be redefined and ClassFileTransformer objects to be registered for classes not yet loaded.
This class is a simple wrapper around a Class object and an array of bytes that represents a class file for that class.
An array of ClassDefinition objects is passed to the redefineClasses( ) method of the Instrumentation class.
Class redefinitions are allowed to change method implementations, but not the members or inheritance of a class or the signature of the methods.
A ClassFileTransformer registered through an Instrumentation object is offered a chance to transform every class that is subsequently loaded or redefined.
The final argument to transform( ) is a byte array that contains the raw bytes of the class file (or bytes returned by a previously invoked ClassFileTransformer)
If the transform( ) method wishes to transform the class, it should return the transformed bytes in a newly allocated array.
The array passed to transform( ) should not be modified.
If the transform( ) method does not wish to transform a given class, it should return null.
A ClassFileTransformer should throw an exception of this type from its transform( ) method if it believes that the class file bytes it has been passed are malformed (this could happen, for example, if a defective ClassFileTransformer had previously transformed a valid class file)
This interface is the main entry point to the java.lang.instrument API.
A Java instrumentation agent specified on the Java interpreter command line with the -javaagent argument must be a class that defines the following method:
The Java interpreter invokes the premain( ) method during startup before calling the main( ) method of the program.
Any arguments specified with the -javaagent command line are passed in the first premain( ) argument, and an Instrumentation object is passed as the second argument.
The most powerful feature of the Instrumentation object is the ability to register ClassFileTransformer objects to augment or rewrite the byte code of Java class files as they are loaded into the interpreter.
If isRedefineClassesSupported( ) returns true, you can also redefine already-loaded classes on the fly with redefineClasses( )
An exception of this type is thrown from Instrumentation.redefineClasses( ) if a requested redefinition cannot be performed.
This might occur, for example, if the redefinition attempts to add or remove members from the class.
It relies on the JMX API of the javax.management API; it defines static factory methods for obtaining instances of the various management bean interfaces.
These instances can then be queried for specific information about the Java VM.
The jconsole tool shipped with the Java 5.0 JDK demonstrates the capabilites of this package.
This MXBean interface defines methods for determining how many classes are currently loaded in the Java VM, how many have ever been loaded, and how many have ever been unloaded.
The setVerbose( ) method turns verbose class loading output from the VM on or off.
This MXBean interface defines methods for querying the just-in-time compiler of the Java virtual machine.
If the implementation tracks compilation time, getTotalCompilationTime( ) returns the approximate total compilation time in milliseconds.
This MXBean interface allows monitoring of the number of garbage collections that have occurred and the approximate time they consumed in milliseconds.
The methods return -1 to indicate that the garbage collector does not maintain those statistics.
Note that VM implementations commonly have more than one garbage collector and use different collection strategies for new objects and old objects.
This class provides the main entry point into the java.lang.management API.
The static factory methods provide a convenient way to obtain instances of the various MXBean interfaces for the currently running Java virtual machine.
The returned instances can then be queried to monitor memory usage, class loading, and other details of virtual machine performance.
To obtain an MXBean for a Java virtual machine running in another process, use the newPlatformMXBeanProxy( ) method, specifying a javax.management.MBeanServerConnection as well as the name and type of the desired MXBean.
The constant fields of this class define the names of the available beans.
Note that the javax.management package is beyond the scope of this quick reference.
This java.security.Permission subclass governs access to the Java VM monitoring and management capabilities of this package.
The two defined targets for this permission are control, which grants permission to manage the VM, and monitor, which grants permission to monitor VM state.
This MXBean interface allows monitoring of a single memory manager (such as a garbage collector) in a Java VM.
A VM implementation typically has more than one memory manager, and the ManagementFactory method getMemoryManagerMXBeans( ) returns a List of objects of this type.
Some or all of the objects in the returned list will also implement the GarbageCollectorMXBean subinterface.
Each memory manager may manage one or more memory pools, and getMemoryPoolNames( ) returns the names of these pools.
This MXBean interface allows monitoring of current memory usage information for heap memory (allocated objects) and nonheap memory (loaded classes and libraries)
It also allows the garbage collector to be explicitly invoked and verbose garbagecollection related output to be turned on or off.
See MemoryUsage for details on how memory usage information is returned.
See also MemoryPoolMXBean for a way to obtain both current and peak memory usage for individual memory pools.
This class holds information about memory usage in a given memory pool and is generated when that usage crosses a threshold specified by a MemoryPoolMXBean.
Use the from( ) method to construct a MemoryNotificationInfo object from the user data of a javax.management.Notification object.
Notifications and the javax.management package are beyond the scope of this book.
This MXBean interface allows monitoring of the current and peak memory usage for a single memory pool.
Typical Java VM implementations segregate garbage-collected heap memory into two or more memory pools based on the age of the objects.
If isUsageThresholdSupported( ) returns true, you can use setUsageThreshold( ) to define a memory usage threshold.
The MemoryPoolMXBean then keeps track of threshold crossings and issues notifications through the javax.management.NotificationEmitter API.
Note that the javax.management package is not covered in this book.) Use setCollectionUsageThreshold( ) instead to receive notifications when memory usage exceeds a specified threshold after a garbage collection pass.
The constants defined by this enumerated type define the type of a memory pool as either heap or nonheap memory.
A MemoryUsage object represents a snapshot of memory usage for a specified type or pool of memory.
Memory usage is measured as four long values, each of which represents a number of bytes.
These bytes may not all be in use, but they are not available to other processes running on the system.
This MXBean interface allows queries of the operating system name, version, and CPU architecture as well as the number of available CPUs.
This MXBean interface provides access to the runtime configuration of the Java virtual machine, including system properties, command-line arguments, class path, virtual machine vendor and version, and so on.
This class represents information about a thread from a ThreadMXBean.
Some information, such as thread name, id, state, and stack trace are also available through the java.lang.Thread object.
Other more useful information includes the object upon which a thread is waiting and the owner of the lock that the thread is trying to acquire.
If ThreadMXBean indicates that thread contention monitoring is supported and enabled, the ThreadInfo methods getBlockedCount( ) and getBlockedTime( ) return the number of times the thread has blocked or waited and the amount of time it has spent in the blocked and waiting states.
This MXBean interface allows monitoring of thread usage in a Java VM.
A number of methods, such as getThreadCount( ) and getPeakThreadCount( ), return information about all running threads.
Threads are identified by their thread id, which is a long integer.
Complete information, including stack trace, about a thread or set of threads can be obtained with the getThreadInfo( ) methods, which return ThreadInfo objects.
If isThreadCpuTimeSupported( ) returns true, you can enable thread timing with setThreadCpuTimeEnabled( ) and query the runtime of a specific thread with getThreadCpuTime( ) and getThreadUserTime( )
The values returned by these methods are measured in nanoseconds.
One of the potentially most useful methods of this interface is findMonitorDeadlockedThreads( )
It looks for cycles of threads that are deadlocked waiting to lock objects whose locks are held by other threads in the cycle.
The java.lang.ref package defines classes that allow Java programs to interact with the Java garbage collector.
A Reference represents an indirect reference to an arbitrary object, known as the referent.
SoftReference, WeakReference, and PhantomReference are three concrete subclasses of Reference that interact with the garbage collector in different ways, as explained in the individual class descriptions that follow.
Any Reference object may have a ReferenceQueue associated with it.
A Reference object is enqueued on its ReferenceQueue at some point after the garbage collector determines that the referent object has become appropriately unreachable.
The exact level of unreachability depends on the type of Reference being used.) An application can monitor a ReferenceQueue to determine when referent objects enter a new reachability status.
Using the mechanisms defined in this package, you can implement a cache that grows and shrinks in size according to the amount of available system memory.
Or, you can implement a hashtable that associates auxiliary information with arbitrary objects, but does not prevent those objects from being garbage-collected if they are otherwise unused.
The mechanisms provided by this package are low-level ones, however, and typical applications do not use java.lang.ref directly.
Instead, they rely on higher-level utilities built on top of the package.
In Java 5.0, the classes in this package have all been made into generic types.
The type variable T represents the type of the object that is referred to.
This class represents a reference to an object that does not prevent the referent object from being finalized by the garbage collector.
When (or at some point after) the garbage collector determines that there are no more hard (direct) references to the referent object, that there are no SoftReference or WeakReference objects that refer to the referent, and that the referent has been finalized, it enqueues the PhantomReference object on the ReferenceQueue specified when the PhantomReference was created.
This serves as notification that the object has been finalized and provides one last opportunity for any required cleanup code to be run.
To prevent a PhantomReference object from resurrecting its referent object, its get( ) method always returns null, both before and after the PhantomReference is enqueued.
Nevertheless, a PhantomReference is not automatically cleared when it is enqueued, so when you remove a PhantomReference from a ReferenceQueue, you must call its clear( ) method or allow the PhantomReference object itself to be garbage-collected.
This class provides a more flexible mechanism for object cleanup than the finalize( ) method does.
Note that in order to take advantage of it, it is necessary to subclass PhantomReference and define a method to perform the desired cleanup.
Furthermore, since the get( ) method of a PhantomReference always returns null, such a subclass must also store whatever data is required for the cleanup operation.
This abstract class represents some type of indirect reference to a referent.
The garbage collector handles these subclasses differently and clears their references under different circumstances.
Each of the subclasses of Reference defines a constructor that allows a ReferenceQueue to be associated with the Reference object.
The garbage collector places Reference objects onto their associated ReferenceQueue objects to provide notification about the state of the referent object.
This class represents a queue (or linked list) of Reference objects that have been enqueued because the garbage collector has determined that the referent objects to which they refer are no longer adequately reachable.
Use poll( ) to return the first Reference object on the queue; the method returns null if the queue is empty.
Use remove( ) to return the first element on the queue, or, if the queue is empty, to wait for a Reference object to be enqueued.
ReferenceQueue for a Reference object by passing it to the SoftReference( ), WeakReference( ), or PhantomReference( ) constructor.
It is optional with SoftReference and WeakReference objects; for these classes, the get( ) method returns null if the referent object is no longer adequately reachable.
A SoftReference is not cleared while there are any remaining hard (direct) references to the referent.
Once the referent is no longer in use (i.e., there are no remaining hard references to it), the garbage collector may clear the SoftReference to the referent at any time.
However, the garbage collector does not clear a SoftReference until it determines that system memory is running low.
In particular, the Java VM never throws an OutOfMemoryError without first clearing all soft references and reclaiming the memory of the referents.
The VM may (but is not required to) clear soft references according to a least-recently-used ordering.
If a SoftReference has an associated ReferenceQueue, the garbage collector enqueues the SoftReference at some time after it clears the reference.
SoftReference is particularly useful for implementing object-caching systems that do not have a fixed size, but grow and shrink as available memory allows.
This class refers to an object in a way that does not prevent that referent object from being finalized and reclaimed by the garbage collector.
When the garbage collector determines that there are no more hard (direct) references to the object, and that there are no SoftReference objects that refer to the object, it clears the WeakReference and marks the referent object for finalization.
WeakReference on its associated ReferenceQueue, if there is one, in order to provide notification that the referent has been reclaimed.
WeakReference is used by java.util.WeakHashMap to implement a hashtable that does not prevent the hashtable key object from being garbage-collected.
WeakHashMap is useful when you want to associate auxiliary information with an object but do not want to prevent the object from being reclaimed.
The java.lang.reflect package contains the classes and interfaces that, along with java.lang.Class, comprise the Java Reflection API.
The Constructor, Field, and Method classes represent the constructors, fields, and methods of a class.
Because these types all represent members of a class, they each implement the Member interface, which defines a simple set of methods that can be invoked for any class member.
These classes allow information about the class members to be obtained, methods and constructors to be invoked, and fields to be queried and set.
Class member modifiers are represented as integers that specify a number of bit flags.
The Modifier class defines static methods that help interpret the meanings of these flags.
The Array class defines static methods for creating arrays and reading and writing array elements.
As of Java 1.3, the Proxy class allows the dynamic creation of new Java classes that implement a specified set of interfaces.
When an interface method is invoked on an instance of such a proxy class, the invocation is delegated to an InvocationHandler object.
There have been a number of changes to this package to support the new language features of Java 5.0
The most important changes are support for querying the generic signature of classes, methods, constructors, and fields.
Class, Method and Constructor implement the new GenericDeclaration interface, which provides access to the TypeVariable declarations of generic classes, methods, and constructors.
In general, the package has been modified to add new generic versions of methods like Field.getType( ) and Method.getParameterTypes( )
Instead of returning Class objects, the new generic methods, like Field.getGenericType( ) and Method.getGenericParameterTypes( ), return Type objects.
The Type interface is new in Java 5.0, and represents any kind of generic or nongeneric type.
Class implements Type, so a Type object may simply be an ordinary Class.
Type is also the super-interface for four other new interfaces: ParameterizedType, TypeVariable, WildcardType and GenericArrayType.
A Type object that is not a Class should be an instance of one of these other interfaces, representing a generic type of some sort.
Support for reflection on annotations is provided by the AnnotatedElement interface which is implemented by Class, Package, Method, Constructor and Field.
Method and Constructor also have new getParameterAnnotations( ) for querying annotations on method parameters.
Other, more minor changes in Java 5.0 include the isEnumConstant( ) method of Field and the isVarArgs( ) method of Method and Constructor.
This class is the superclass of the Method, Constructor, and Field classes; its methods provide a mechanism for trusted applications to work with private, protected, and default visibility members that would otherwise not be accessible through the Reflection API.
To use the java.lang.reflect package to access a member to which your code would not normally have access, pass true to the setAccessible( ) method.
If your code has an appropriate ReflectPermission (such as “suppressAccessChecks”), this allows access to the member as if it were declared public.
The static version of setAccessible( ) is a convenience method that sets the accessible flag for an array of members but performs only a single security check.
This interface is implemented by the classes representing program elements that can be annotated in Java 5.0: java.lang.Class, java.lang.Package, Method, Constructor, and Field.
The methods of this interface allow you to test for the presence of a specific annotation, query an annotation object of a specific type, or query all annotations present on an annotated element.
See the java.lang.annotation.Inherited meta-annotation.) If no annotations are present, getAnnotations( ) and getDeclaredAnnotations( ) return an array of length zero rather than null.
It is safe to modify the arrays returned by these methods.
See also the getParameterAnnotations( ) methods of Method and Constructor, which provide access to annotations on method parameters.
This class contains methods that allow you to set and query the values of array elements, to determine the length of an array, and to create new instances of arrays.
Note that the Array class can manipulate only array values, not array types; Java data types, including array types, are represented by java.lang.Class.
Since the Array class represents a Java value, unlike the Field, Method, and Constructor classes, which represent class members, the Array class is significantly different (despite some surface similarities) from those other classes in this package.
Most notably, all the methods of Array are static and apply to all array values, not just a specific field, method, or constructor.
The get( ) method returns the value of the specified element of the specified array as an Object.
If the array elements are of a primitive type, the value is converted to a wrapper object before being returned.
You can also use getInt( ) and related methods to query array elements and return them as specific primitive types.
The set( ) method and its primitive type variants perform the opposite operation.
Also, the getLength( ) method returns the length of the array.
One version of this method is passed the number of elements in the array and the type of those elements.
Besides specifying the component type of the array, it is passed an array of numbers.
The length of this array specifies the number of dimensions for the array to be created, and the values of each of the array elements specify the size of each dimension of the created array.
Instances of Constructor are obtained by calling getConstructor( ) and related methods of java.lang.Class.
Constructor implements the Member interface, so you can use the methods of that interface to obtain the constructor name, modifiers, and declaring class.
In addition, getParameterTypes( ) and getExceptionTypes( ) also return important information about the represented constructor.
In addition to these methods that return information about the constructor, the newInstance( ) method allows the constructor to be invoked with an array of arguments in order to create a new instance of the class that declares the constructor.
If any of the arguments to the constructor are of primitive types, they must be converted to their corresponding wrapper object types to be passed to newInstance( )
If the constructor causes an exception, the Throwable object it throws is wrapped within the InvocationTargetException that is thrown by newInstance( )
Note that newInstance( ) is much more useful than the newInstance( ) method of java.lang.Class because it can pass arguments to the constructor.
Constructor has been modified in Java 5.0 to support generics, annotations, and varargs.
The changes are the same as the Java 5.0 changes to the Method class.
Additionally, Constructor has been made a generic type in Java 5.0
The type variable T represents the type that the constructor constructs, and is used as the return type of the newInstance( ) method.
Instances of Field are obtained by calling the getField( ) and related methods of java.lang.Class.
Field implements the Member interface, so once you have obtained a Field object, you can use getName( ), getModifiers( ), and getDeclaringClass( ) to determine the name, modifiers, and class of the field.
The set( ) method sets the value of the represented field for a specified object.
If the represented field is static, no object need be specified, of course.) If the field is of a primitive type, its value can be specified using a wrapper object of type Boolean, Integer, and so on, or it can be set using the setBoolean( ), setInt( ), and related methods.
Similarly, the get( ) method queries the value of the represented field for a specified object and returns the field value as an Object.
Various other methods query the field value and return it as various primitive types.
In Java 5.0, Field implements AnnotatedElement to support reflection on field annotations.
The new getGenericType( ) method supports reflection on the generic type of fields, and isEnumConstant( ) supports fields of enum types.
This interface extends Type and represents a one-dimensional array of some element Type.
Note that in the case of multidimensional arrays, the Type returned by getGenericComponentType( ) is itself a GenericArrayType.
This interface is implemented by the classes that represent program elements that can be made generic: java.lang.Class as well as Method and Constructor.
It provides access to the type variables declared by the generic type, method, or constructor.
An error of this type is thrown if the Java interpreter tries to load a class file that contains malformed generic signature information.
This interface defines a single invoke( ) method that is called whenever a method is invoked on a dynamically created Proxy object.
Every Proxy object has an associated InvocationHandler object that is specified when the Proxy is instantiated.
All method invocations on the proxy object are translated into calls to the invoke( ) method of the InvocationHandler.
The first argument to invoke( ) is the Proxy object through which the method was invoked.
The second argument is a Method object that represents the method that was invoked.
Call the getDeclaringClass( ) method of this Method object to determine the interface in which the method was declared.
This may be a superinterface of one of the specified interfaces or even java.lang.Object when the method invoked is toString( ), hashCode( ), or one of the other Object methods.
The third argument to invoke( ) is the array of method arguments.
Any primitive type arguments are wrapped in their corresponding object wrappers (e.g., Boolean, Integer, Double)
The value returned by invoke( ) becomes the return value of the proxy object method invocation and must be of an appropriate type.
If the proxy object method returns a primitive type, invoke( ) should return an instance of the corresponding wrapper class.
If invoke( ) throws a checked exception that is not declared by the proxy object, that exception is wrapped within an unchecked UndeclaredThrowableException that is thrown in its place.
An object of this class is thrown by Method.invoke( ) and Constructor.newInstance( ) when an exception is thrown by the method or constructor invoked through those methods.
The InvocationTargetException class serves as a wrapper around the object that was thrown; that object can be retrieved with the getTargetException( ) method.
An exception of this type is thrown during reflection if the generic type information contained in a class file is syntactically correct but semantically wrong.
An example would be if the number of type parameters in a ParameterizedType differs from the number of type variables declared by the generic type.
Although this type is not an Error, it does indicate a malformed class file and should not arise in common practice.
This interface defines the methods shared by all members (fields, methods, and constructors) of a class.
Instances of Method are obtained by calling the getMethod( ) and related methods of java.lang.Class.
Method implements the Member interface, so you can use the methods of that interface to obtain the method name, modifiers, and declaring class.
In addition, getReturnType( ), getParameterTypes( ), and getExceptionTypes( ) also return important information about the represented method.
Perhaps most importantly, the invoke( ) method allows the method represented by the Method object to be invoked with a specified array of argument values.
If any of the arguments are of primitive types, they must be converted to their corresponding wrapper object types in order to be passed to invoke( )
If the represented method is an instance method (i.e., if it is not static), the instance on which it should be invoked must also be passed to invoke( )
The return value of the represented method is returned by invoke( )
If the return value is a primitive value, it is first converted to the corresponding wrapper type.
If the invoked method causes an exception, the Throwable object it throws is wrapped within the InvocationTargetException that is thrown by invoke( )
In Java 5.0, Method implements GenericDeclaration to support reflection on the type variables defined by generic methods and AnnotatedElement to support reflection on method annotations.
The new methods getGenericReturnType( ), getGenericParameterTypes( ), and getGenericExceptionTypes( ) support reflection on generic method signatures.
Finally, the new isVarArgs( ) method returns true if the method was declared using Java 5.0 varargs syntax.
This class defines a number of constants and static methods that can interpret the integer values returned by the getModifiers( ) methods of the Field, Method, and Constructor classes.
The isPublic( ), isAbstract( ), and related methods return true if the modifier value includes the specified modifier; otherwise, they return false.
The constants defined by this class specify the various bit flags used in the modifiers value.
You can use these constants to test for modifiers if you want to perform your own boolean algebra.
This class defines a simple but powerful API for dynamically generating a proxy class.
A proxy class implements a specified list of interfaces and delegates invocations of the methods defined by those interfaces to a separate invocation handler object.
The newly created class is defined in the context of the specified ClassLoader.
The Class returned by getProxyClass( ) is a subclass of Proxy.
Every class that is dynamically generated by getProxyClass( ) has a single create an instance of the dynamic proxy class by using the Constructor class to invoke this constructor.
Or, more simply, you can combine the call to getProxyClass( ) with the constructor call by calling the static newProxyInstance( ) method, which both defines and instantiates a proxy class.
Every instance of a dynamic proxy class has an associated InvocationHandler object.
All method calls made on a proxy class are translated into calls to the invoke( ) method of this InvocationHandler object, which can handle the call in any way it sees fit.
The static getInvocationHandler( ) method returns the InvocationHandler object for a given proxy object.
The static isProxyClass( ) method returns true if a specified Class object is a dynamically generated proxy class.
This class is a java.security.Permission that governs access to private, protected, and defaultvisibility methods, constructors, and fields through the Java Reflection API.
This permission is required to call the setAccessible( ) method of AccessibleObject.
Unlike some Permission subclasses, ReflectPermission does not use a list of actions.
System administrators configuring security policies should be familiar with this class, but application programmers should never need to use it directly.
This interface has no members but is implemented or extended by any type that represents a generic or nongeneric type.
Type is also extended by four interfaces that represent four specific kinds of generic types: ParameterizedType, TypeVariable, WildcardType, and GenericArrayType.
This interface extends Type and represents the generic type represented by a type variable.
The returned array is never empty: if the type variable has no bounds declared, the single element of the array is Object.class.
The getGenericDeclaration( ) method returns the Class, Method, or Constructor that declared this type variable (each of these classes implements the GenericDeclaration interface)
Note that TypeVariable is itself a generic type and is parameterized with the kind of GenericDeclaration that declared the variable.
Thrown by a method of a Proxy object if the invoke( ) method of the proxy’s InvocationHandler throws a checked exception not declared by the original method.
This class serves as an unchecked exception wrapper around the checked exception.
Use getUndeclaredThrowable( ) to obtain the checked exception thrown by invoke( )
This interface extends Type and represents a generic type declared with a bounded or unbounded wildcard.
If no upper bound is declared, Object.class is the implicit upper bound.
If no lower bound is declared, this method returns an empty array.
The java.math package contains the BigInteger class for arbitrary-precision integer arithmetic, which is useful for cryptography.
It also contains the BigDecimal class for arbitrary precision decimal floating-point arithmetic, which is useful for financial applications that need to be careful about rounding errors.
The BigDecimal class is greatly enhanced in Java 5.0 and is accompanied by the new types MathContext and RoundingMode.
This subclass of java.lang.Number represents a floating-point number of arbitrary size and precision.
Because it uses a decimal rather than binary floating-point representation, it is not subject to the rounding errors that the float and double types are.
BigDecimal provides add( ), subtract( ), multiply( ), and divide( ) methods to support basic arithmetic.
In Java 5.0, this class has been expanded to define many more methods, including pow( ) for exponentiation.
Many of the new methods use a MathContext to specify the desired precision of the result and the RoundingMode to be used to achieve that precision.
A BigDecimal object is represented as an integer of arbitrary size and an integer scale that specifies the number of decimal places in the value.
When working with BigDecimal values, you can explicitly specify the precision (i.e., the number of decimal places) you are interested in.
Also, whenever a BigDecimal method can discard precision (e.g., in a division operation), you are required to specify what sort of rounding should be performed on the digit to the left of the discarded digit or digits.
The eight constants defined by this class specify the available rounding modes.
In Java 5.0, however, the preferred way to specify a rounding mode is with the enumerated type RoundingMode.
This subclass of java.lang.Number represents integers that can be arbitrarily large (i.e., integers that are not limited to the 64 bits available with the long data type)
BigInteger defines methods that duplicate the functionality of the standard Java arithmetic and bit-manipulation operators.
The gcd( ), modPow( ), modInverse( ), and isProbablePrime( ) methods perform advanced operations and are used primarily in cryptographic and related algorithms.
This simple class represents a precision (number of significant digits) and a RoundingMode to be used in BigDecimal arithmetic.
The constants are predefined MathContext objects that can be used to select unlimited precision arithmetic or to select specific operating modes that match decimal floating-point modes defined by the IEEE 754R standard.
The constants defined by this enumerated type represent possible ways of rounding numbers.
In this case, they round up, down, or to the “even” neighbor.
The java.net package provides a powerful and flexible infrastructure for networking.
This introduction describes the most commonly used classes in brief.
Note that as of Java 1.4, the New I/O API of java.nio and java.nio.channels can be used for high-performance nonblocking networking.
See also the javax.net.ssl package for classes for secure networking using SSL.
The URL class represents an Internet uniform resource locator (URL)
It provides a very simple interface to networking: the object referred to by the URL can be downloaded with a single call, or streams may be opened to read from or write to the object.
At a slightly more complex level, a URLConnection object can be obtained from a given URL object.
The URLConnection class provides additional methods that allow you to work with URLs in more sophisticated ways.
Java 1.4 introduced the URI class; it provides a powerful API for manipulating URI and URL strings but does not have any networking capabilities itself.
Java 5.0 defines APIs for defining and registering cache, cookie, and proxy handlers to be used by built-in protocol handlers when network resources are requested through the URL class.
If you want to do more than simply download an object referenced by a URL, you can do your own networking with the Socket class.
This class allows you to connect to a specified port on a specified Internet host and read and write data using the InputStream and OutputStream classes of the java.io package.
If you want to implement a server to accept connections from clients, you can use the related ServerSocket class.
Both Socket and ServerSocket use the InetAddress address class, which represents an Internet address.
Java 1.4 also introduced the SocketAddress class as a high-level representation of a network address that is not tied to a specific networking protocol.
An IP-specific InetSocketAddress subclass encapsulates an InetAddress and a port number.
The java.net package allows you to do low-level networking with DatagramPacket objects, which may be sent and received over the network through a DatagramSocket object.
This abstract class defines a customizable mechanism for requesting and performing password authentication when required in URL-based networking.
An Authenticator implementation can obtain the required authentication information from the user however it wants (e.g., through a text- or a GUI-based interface)
When an application or the Java runtime system requires password authentication (to read the contents of a specified URL, for example), it calls the static requestPasswordAuthentication( ) method, passing arguments that specify the host and port for which the password is required and a prompt that may be displayed to the user.
This method looks up the default Authenticator for the system and calls its getPasswordAuthentication( ) method.
Authenticator is an abstract class; its default implementation of getPasswordAuthentication( ) always returns null.
To create an Authenticator, you must override this method so that it prompts the user to enter a username and password and returns that information in the form of a PasswordAuthentication object.
Your implementation of getPasswordAuthentication( ) may call the various getRequesting( ) methods to find out who is requesting the password and what the recommended user prompt is.
Java 1.4 added a version of the static requestPasswordAuthentication( ) method that allows specification of the requesting hostname.
Java 5.0 adds yet another version of requestPasswordAuthentication( ), and corresponding methods to query the URL that requires the password and the RequestorType of the request.
RequestorType is a nested enum type that specifies whether the request comes from an HTTP server or a proxy server.
The constants defined by this enumerated type specify whether an authentication request comes from an HTTP origin server or a proxy server.
Signals that a socket cannot be bound to a local address and port.
This often means that the port is already in use.
When a URLStreamHandler reads a network resource, it should call the put( ) method of the currently installed ResponseCache, if there is one.
If the cache wants to save a local copy of the resource, it will return a CacheRequest object to the URLStreamHandler.
The handler should then write the resource to the OutputStream returned by the getBody( ) method.
This class is used by the implementors of URLStreamHandler, not by casual users of the java.net package.
If a ResponseCache holds a local copy of a network resource, it returns a CacheResponse object from the ResponseCache.get( ) method.
The resource can then be read from the java.io.InputStream returned by getBody( )
The protocol response headers are available in the form of java.util.Map from getHeaders( )
Note that this class is intended for use in URLStreamHandler implementations, not by casual users of the java.net package.
Signals that a socket cannot be connected to a remote address and port.
This means that the remote host can be reached, but is not responding, perhaps because there is no process on that host that is listening on the specified port.
This abstract class defines a method that reads data from a URLConnection and returns an object that represents that data.
Each subclass that implements this method is responsible for handling a different type of content (i.e., a different MIME type)
Applications never create ContentHandler objects directly; they are created, when necessary, by the registered ContentHandlerFactory object.
Applications should also never call ContentHandler methods directly; they should call URL.getContent( ) or URLConnection.getContent( ) instead.
You need to subclass ContentHandler only if you are writing a web browser or similar application that needs to parse and understand some new content type.
This interface defines a method that creates and returns an appropriate ContentHandler object for a specified MIME type.
A systemwide ContentHandlerFactory interface may be specified using the URLConnection.setContentHandlerFactory( ) method.
Normal applications never need to use or implement this interface.
This abstract class defines an API to be implemented by an application that wants to manage HTTP cookies for networking done via the URL class.
Install an implementation of this class with the setDefault( ) method.
The default HTTP protocol handler uses getDefault( ) to obtain the CookieHandler implementation.
The protocol handler then calls get( ) when it wants the CookieHandler to copy cookie values into HTTP request headers and calls put( ) when it wants the CookieHandler to read a set of response headers and store the cookies they contain.
This class is intended to be subclassed by advanced users of the package; it is not intended for casual users.
This class implements a packet of data that may be sent or received over the network through a DatagramSocket.
Create a DatagramPacket to be sent over the network with one of the consructor methods that includes a network address.
Create a DatagramPacket into which data can be received using one of the constructors that does not include a network address argument.
The receive( ) method of DatagramSocket waits for data and stores it in a DatagramPacket created in this way.
The contents and sender of a received packet can be queried with the DatagramPacket instance methods.
New constructors and methods were added to this class in Java 1.4 to support the SocketAddress abstraction of a network address.
This class defines a socket that can receive and send unreliable datagram packets over the network using the UDP protocol.
A datagram is a very low-level networking interface: it is simply an array of bytes sent over the network.
Datagram packets are called unreliable because the protocol does not make any attempt to ensure they arrive or to resend them if they don’t.
Thus, packets sent through a DatagramSocket are not guaranteed to arrive in the order sent or even to arrive at all.
On the other hand, this lowoverhead protocol makes datagram transmission very fast.
The packet must contain the destination address to which it should be sent.
Once close( ) has been called, the DatagramSocket should not be used again, except to call the isClosed( ) method which returns true if the socket has been closed.
Each time a packet is sent or received, the system must perform a security check to ensure that the calling code has permission to send data to or receive data from the specified host.
In Java 1.2 and later, if you are sending multiple packets to or receiving multiple packets from a single host, use connect( ) to specify the host with which you are communicating.
This causes the security check to be done a single time, but does not allow the socket to communicate with any other host until disconnect( ) is called.
Use getRemoteSocketAddress( ) or getInetAddress( ) and getPort( ) to obtain the network address, if any, that the socket is connected to.
Use isConnected( ) to determine if the socket is currently connected in this way.
By default, a DatagramSocket sends data through a local address assigned by the system.
If desired, however, you can bind the socket to a specified local address.
Do this by using one of the constructors other than the no-arg constructor.
Or, bind the DatagramSocket to a local SocketAddress with the bind( ) method.
You can determine whether a DatagramSocket is bound with isBound( ), and you can obtain the local address of the socket with getLocalSocketAddress( ) or with getLocalAddress( ) and getLocalPort( )
In Java 1.4 and later, getChannel( ) returns a java.nio.channels.DatagramChannel associated with this DatagramSocket.
Sockets created with one of the DatagramSocket( ) constructors always return null from this method.
This abstract class defines the methods necessary to implement communication through datagram and multicast sockets.
System programmers may create subclasses of this class when they need to implement datagram or multicast sockets in a nonstandard network environment, such as behind a firewall or on a network that uses a nonstandard transport protocol.
Normal applications never need to use or subclass this class.
You can register an instance of this factory interface with the static setDatagramSocketImplFactory( ) method of DatagramSocket.
Application-level code never needs to use or implement this interface.
This interface defines a single method that is called to obtain the MIME type of a file based on the name of the file.
The fileNameMap field of the URLConnection class refers to an object that implements this interface.
The filename-to-file-type map it implements is used by the static URLConnection.guessContentTypeFromName( )  method.
An exception of this type is thrown when an HTTP request needs to be retried (due to a server redirect or authentication request, for example) but the protocol handler cannot automatically retry it because the HttpURLConnection has been placed in streaming mode.
See the setFixedLengthStreamingMode( ) and setChunkedStreamingMode( ) methods of HttpURLConnection.) The methods of the exception provide details about how the request should be retried.
An instance of this class is returned when the openConnection( ) method is called for a URL object that uses the HTTP protocol.
The many constants defined by this class are the status codes returned by HTTP servers.
The contents of this request must be sent through the OutputStream returned by the getOutputStream( ) method of the superclass.
Once an HTTP request has been sent, getResponseCode( ) returns the HTTP server’s response code as an integer, and getResponseMessage( ) returns the server’s response message.
The static setFollowRedirects( ) specifies whether URL connections that use the HTTP protocol should automatically follow redirect responses sent by HTTP servers.
In order to successfully use this class, you need to understand the details of the HTTP protocol.
See RFC 2373 for complete details about internet addresses of this type.
In Java 5.0, you can also use the getByAddress( ) factory methods of this class directly.
The class does not have a public constructor but instead supports static factory methods for obtaining InetAddress objects.
Once you have obtained an InetAddress object, its instance methods provide various sorts of information about it.
Two of the most important are getHostName( ), which returns the hostname, and getAddress( ), which returns the IP address as an array of bytes, with the highest-order byte as the first element of the array.
The various methods whose names begin with “is” determine whether the address falls into any of the named categories.
Java 5.0 adds isReachable( ) for testing whether the address describes a reachable (and responsive) host.
InetSocketAddress represents an the combination of an IP (Internet Protocol) address and a port number.
The constructors allow you to specify the IP address as an InetAddress or as a hostname, and they also allow you to omit the IP address, in which case the wildcard address is used (this is useful for server sockets)
This class is a specialized URLConnection that represents a connection to a jar: URL.
A jar: URL is a compound URL that includes the URL of a JAR archive and, optionally, a reference to a file or directory within the JAR archive.
The jar: URL syntax uses the ! character to separate the pathname of the JAR archive from the filename within the JAR archive.
Note that a jar: URL contains a subprotocol that specifies the protocol that retrieves the JAR file itself.
To obtain a JarURLConnection, define a URL object for a jar: URL, open a connection to it with openConnection( ), and cast the returned URLConnection object to a JarURLConnection.
The various methods defined by JarURLConnection allow you to read the manifest file of the JAR archive and look up attributes from that manifest for the archive as a whole or for individual entries in the archive.
These methods make use of various classes from the java.util.jar package.
Signals that an unparseable URL specification has been passed to a method.
This subclass of DatagramSocket can send and receive multicast UDP packets.
It extends DatagramSocket by adding joinGroup( ) and leaveGroup( ) methods to join and leave multicast groups.
You do not have to join a group to send a packet to a multicast address, but you must join the group to receive packets sent to that address.
Note that the use of a MulticastSocket is governed by a security manager.
Use setTimeToLive( ) to set a time-to-live value for any packets sent through a MulticastSocket.
This constrains the number of network hops a packet can take and controls the scope of a multicast.
Use setInterface( ) or setNetworkInterface( ) to specify the InetAddress or the NetworkInterface that outgoing multicast packets should use: this is useful for servers or other computers that have more than one internet address or network interface.
This method should really be named require) that the system disable loopback packets.
This class is a java.security.Permission that represents various permissions required for Java’s URL-based networking system.
See also SocketPermission, which represents permissions to perform lower-level networking operations.
A NetPermission is defined solely by its name; no actions list is required or supported.
The target “*” is a wildcard that represents all defined NetPermission targets.
System administrators configuring security policies must be familiar with this class and the permissions it represents.
System programmers may use this class, but application programmers never need to use it explicitly.
Instances of this class represent a network interface on the local machine.
Obtain a NetworkInterface object with one of the static methods defined by this class.
This class is typically only used in advanced networking applications.
This exception signals that a socket cannot be connected to a remote host because the host cannot be contacted.
Typically, this means that some link in the network between the local machine and the remote host is down or that the host is behind a firewall.
This simple immutable class encapsulates a username and a password.
The password is stored as a character array rather than as a String object so that the caller can erase the contents of the array after use for increased security.
Note that the PasswordAuthentication( ) constructor clones the specified password character array, but getPassword( ) returns a reference to the object’s internal array.
Application programmers defining an Authenticator object for their application need to create and return a PasswordAuthentication object from the getPasswordAuthentication( ) method of that object.
System programmers writing URLStreamHandler implementations or otherwise interacting with a network server that requests password authentication may obtain a PasswordAutentication object representing the user’s name and password by calling the static Authenticator.requestPasswordAuthentication( ) method.
An instance of this class represents a set of proxy server settings: a network address and a proxy server type.
Proxy objects may be passed to the Socket( ) constructor or to the URL.openConnection( ) method to connect through a specific proxy server.
The ProxySelector class provides a way to automate the selection of proxy servers based on requested URLs.
The constants of this enumerated type represent a type of proxy server.
An implementation of this abstract class can be used to automatically select one or more Proxy objects to use to connect to a specified URL.
Install an implementation of this class with the setDefault( ) method.
URLConnection implementations use the installed ProxySelector, if there is one, and call select( ) to obtain a list of suitable Proxy objects for the connection.
If a URLConnection cannot contact the proxy server specified in a Proxy object, it calls the connectFailed( ) method to notify the ProxySelector object of the failure.
This class is intended to be implemented by advanced users of java.net and is not for casual use.
This abstract class defines an API for low-level caching of network resources retrieved through the URL and URLConnection classes.
This class is intended for use by URLStreamHandler implementations, not by casual users of the java.net package.
Clients that wish to enable local caching should register a ResponseCache implementation with setDefault( ) and enable caching with URLConnection.setDefaultUseCaches( )
The static getDefault( ) and setDefault( ) methods query and set a ResponseCache for the system.
If there is a ResponseCache installed, protocol handlers should call put( ) to offer a network resource to the cache.
If the cache is interested, it returns a CacheRequest object into which the URLStreamHandler can write its data.
A URLStreamHandler that wants to query the cache should call get( )
If the ResponseCache holds a cached copy of the requested resource, it returns a CacheResponse from which the URLStreamHandler can read the resource.
This subclass of CacheResponse represents a cached network resource that was retreived through a secure protocol such as HTTPS.
Its methods return certificates and other details about the secure transfer.
This class is not intended for casual users of the java.net package.
This class is used by servers to listen for connection requests from clients.
Before you can use a ServerSocket, it must be bound to the local network address that it is to listen on.
In Java 1.4 and later, the no-argument ServerSocket( ) constructor allows you to create an unbound socket.
Doing this allows you to bind the socket using the bind( ) method which uses a SocketAddress object rather than a port number.
It also allows you to call setReuseAddress( ), which is only useful when done before the socket is bound.
Call isBound( ) to determine whether a server socket has been bound.
If it has, use getLocalSocketAddress( ) or getLocalPort( ) and getInetAddress( ) to obtain the local address it is bound to.
Once a ServerSocket has been bound, you can call the accept( ) method to listen on the specified port and block until the client requests a connection on the port.
When this happens, accept( ) accepts the connection, creating and returning a Socket the server can use to communicate with the client.
A typical server starts a new thread to handle the communication with the client and calls accept( ) again to listen for another connection.
ServerSocket defines several methods for setting socket options that affect the socket’s behavior.
A value of 0 means that it should block forever.
Like all sockets, a ServerSocket should be closed with the close( ) method when it is no longer needed.
Once closed, a ServerSocket should not be used, except to call the isClosed( ) method which returns true if it has been closed.
The getChannel( ) method is a link between this ServerSocket class and the New I/O java.nio.channels.ServerSocketChannel class.
It returns the ServerSocketChannel associated with this ServerSocket if there is one.
Note, however, that this method always returns null for sockets created with any of the ServerSocket( ) constructors.
If you create a ServerSocketChannel object, and obtain a ServerSocket from it, however, then the getChannel( ) method provides a way to link back to the parent channel.
Protected Instance Methods 1.1 protected final void implAccept(Socket s) throws java.io.IOException;
This class implements a socket for stream-based communication over the network.
See URL for a higher-level interface to networking and DatagramSocket for a lower-level interface.
Before you can use a socket for communication, it must be bound to a local address and connected to a remote address.
Binding and connection are done automatically for you when you call any of the Socket( ) constructors except the no-argument constructor.
These constructors allow you to specify either the name or the InetAddress of the computer to connect to, and also require you to specify the port number to connect to.
Two of these constructors also allow you to specify the local InetAddress and port number to bind the socket to.
Most applications do not need to specify a local address, and can simply use one of the two-argument versions of Socket( ) and can allow the constructor to choose an ephemeral local port to bind the socket to.
The no-argument Socket( ) constructor is different from the others: it creates an unbound and unconnected socket.
In Java 1.4 and later, you can explicitly call bind( ) and connect( ) to bind and connect the socket.
It can be useful to do this when you want to set a socket option (described below) that must be set before binding or connection.
There is also a version of connect( ) that takes a timeout value in milliseconds: if the connection attempt takes longer than the specified amount of time, connect( ) throws an IOException.
See ServerSocket for a description of how to write server code that accepts socket connection requests from client code.) Java 5.0 includes a constructor that takes a Proxy object as its sole argument.
Like the no-argument constructor, this creates an unbound and unconnected socket.
When you attempt to connect it, the connection will be made through the specified Proxy.
Use isBound( ) and isConnected( ) to determine whether a Socket is bound and connected.
Use getInetAddress( ) and getPort( ) to determine the IP address and port number that the socket is connected to.
Or, in Java 1.4 and later, use getRemoteSocketAddress( ) to obtain the remote address as a SocketAddress object.
Similarly, use getLocalAddress( ) and getLocalPort( ) or use getLocalSocketAddress( ) to find out what address a socket is bound to.
Once you have a Socket object that is bound and connected, use getInputStream( ) and getOutputStream( ) to obtain InputStream and OutputStream objects you can use to communicate with the remote host.
You can use these streams just as you would use similar streams for file input and output.
When you are done with a Socket, use close( ) to close it.
Once a socket has been closed, it is not possible to call connect( ) again to reuse it, and you should not call any of its methods except isClosed( )
Because networking code can throw many exceptions, it is common practice to close( ) a socket in the finally clause of a try/catch statement to ensure that the socket always gets closed.
Note, however, that the close( ) method itself can throw an IOException, and you may need to put it in its own try block.
In Java 1.3 and later shutdownInput( ) and shutdownOutput( ) allow you to close the input and output communication channels individually without closing the entire socket.
In Java 1.4 and later, isInputShutdown( ) and isOutputShutdown( ) allow you to test for this.
The default value of 0 specifies that the stream blocks indefinitely.
If lingering is turned on, the close( ) call blocks for up to the specified number of seconds while attempting to transmit the remaining data.
Calling setTcpNoDelay( ) with an argument of true causes data to be sent through the socket as soon as it is available, instead of waiting for the TCP packet to become more full before sending it.
In Java 1.3, use setKeepAlive( ) to enable or disable the periodic exchange of control messages across an idle socket connection.
The keepalive protocol enables a client to determine if its server has crashed without closing the socket and vice versa.
This can be used to receive bytes sent with sendUrgentData( )
Java 1.4 also adds setReuseAddress( ) which you can use before binding the socket to specify that the socket should be allowed to bind to a port that is still nominally in use by another socket that is in the process of shutting down.
The getChannel( ) method is a link between this Socket class and the New I/O java.nio.channels.SocketChannel class.
It returns the SocketChannel associated with this Socket if there is one.
Note, however, that this method always returns null for sockets created with any of the Socket( ) constructors.
If you create a SocketChannel object, and obtain a Socket from it, then the getChannel( ) method provides a way to link back to the parent channel.
Public Instance Methods 1.4 public void bind(SocketAddress bindpoint) throws java.io.IOException;
Returned By ServerSocket.accept( ), java.nio.channels.SocketChannel.socket( ), javax.net.SocketFactory.createSocket( ), javax.net.ssl.SSLSocketFactory.createSocket( )
Instances of this abstract class are opaque representations of network socket addresses.
The only concrete subclass in the core Java platform is InetSocketAddress which represents an internet address and port number.
This abstract class defines the methods necessary to implement communication through sockets.
Different subclasses of this class may provide different implementations suitable in different environments (such as behind firewalls)
These socket implementations are used by the Socket and ServerSocket classes.
Normal applications never need to use or subclass this class.
SocketImplFactory objects may be registered to create SocketImpl objects for the Socket and ServerSocket classes.
Normal applications never need to use or implement this interface.
This interface defines constants that represent low-level BSD Unix-style socket options and methods that set and query the value of those options.
Any custom socket implementations you define should also provide meaningful implementations for the getOption( ) and setOption( ) methods.
Your implementation may support options other than those defined here.
All other code can use methods defined by Socket, ServerSocket, DatagramSocket, and MulticastSocket to set specific socket options for those socket types.
This class is a java.security.Permission that governs all networking operations performed with sockets.
Like all permissions, a SocketPermission consists of a name, or target, and a list of actions that may be performed on that target.
The target of a SocketPermission is the host and, optionally, the port or ports for which permission is being granted or requested.
The target consists of a hostname optionally followed by a colon and a port specification.
The host may be a DNS domain name, a numerical IP address, or the string “localhost”
If you specify a host domain name, you may use * as a wildcard as the leftmost portion of the hostname.
The port specification, if present, must be a single port number or a range of port numbers in the form n1-n2
If no port is specified, the socket permission applies to all ports of the specified host.
In addition to a target, each SocketPermission must have a comma-separated list of actions, which specify the operations that may be performed on the specified host(s) and port(s)
This action is only valid when used for ports on “localhost”
Finally, the “resolve” action indicates permission to use the DNS name service to resolve domain names into IP addresses.
This action is required for and implied by all other actions.
System administrators configuring security policies must be familiar with this class and understand the risks of granting the various permissions it represents.
System programmers writing new low-level networking libraries or connecting to native code that performs networking may need to use this class.
Application programmers, however, should never need to use it directly.
Signals that a timeout value was exceeded for a socket read or accept operation.
Signals that the name of a specified host could not be resolved.
Signals an attempt to use an unsupported service of a network connection.
A URI is a generalization of the URLs or Uniform Resource Locators used on the world wide web.
The URI supports parsing and textual manipulation of URI strings, but does not have any direct networking capabilities the way that the URL class does.
The advantages of the URI class over the URL class are that it provides more general facilities.
Obtain a URI with one of the constructors, which allow a URI to be parsed from a single string, or allow the specification of the individual components of a URI.
These constructors can throw URISyntaxException, which is a checked exception.
When using hard-coded URIs (rather than URIs based on user input) you may prefer to use the static create( ) method which does not throw any checked exceptions.
Once you have created a URI, object you can use the various get methods to query the various portions of the URI.
The getRaw( ) methods are like the get( ) methods except that they do not decode hexadecimal escape sequences of the form %xx that appear in the URI.
It returns a new URI which represents the same resource as the specified URI argument, but which is relative to this URI.
Finally, the toURL( ) method converts an absolute URI object to the equivalent URL.
Since the URI class provides superior textual manipulation capabilities for URLs, it can be useful to use the URI class to resolve relative URLs (for example) and then convert those URI objects to URL objects when they are ready for networking.
Signals that a string could not be parsed as a valid URI.
This is a checked exception thrown by all the URI( ) constructors.
If you are parsing a hard-coded URI that you do not believe to contain any syntax errors, and wish to avoid the checked exception, you can use the URI.create( ) factory method instead of the one-argument version of the URI( ) constructor.
This class represents a uniform resource locator and allows the data referred to by the URL to be downloaded.
A URL can be specified as a single string or with separate protocol, host, port, and file specifications.
Relative URLs can also be specified with a String and the URL object to which it is relative.
Use openConnection( ) to obtain a URLConnection object with which you can download the content of the URL.
In Java 5.0, you can explicitly specify a Proxy object through which the connection should be opened.
For simple cases, however, the URL class defines shortcut methods that create and invoke methods on a URLConnection internally.
In Java 1.3 and later, you can pass an array of Class objects that specify the type of objects that you are willing to accept as the return value of this method.
If you wish to parse the URL content yourself, call openStream( ) to obtain an InputStream from which you can read the data.
This ClassLoader provides a useful way to load untrusted Java code from a search path of arbitrary URLs, where each URL represents a directory or JAR file to search.
Use the inherited loadClass( ) method to load a named class with a URLClassLoader.
Classes loaded by a URLClassLoader have whatever permissions are granted to their java.security.CodeSource by the system java.security.Policy, plus they have one additional permission that allows the class loader to read any resource files associated with the class.
If the class is loaded from a local file: URL that represents a directory, the class is given permission to read all files and directories below that directory.
If the class is loaded from a local file: URL that represents a JAR file, the class is given permission to read that JAR file.
If the class is loaded from a URL that represents a resource on another host, that class is given permission to connect to and accept network connections from that host.
Note, however, that loaded classes are not granted this additional permission if the code that created the URLClassLoader in the first place would not have had that permission.
You can obtain a URLClassLoader by calling one of the URLClassLoader( ) constructors or one of the static newInstance( ) methods.
If you call newInstance( ), the loadClass( ) method of the returned URLClassLoader performs an additional check to ensure that the caller has permission to access the specified package.
This abstract class defines a network connection to an object specified by a URL.
You should use a URLConnection object when you want more control over the downloading of data than is available through the simpler URL methods.
Some methods must be called before the connection is made, and others depend on being connected.
The methods that depend on being connected call connect( ) themselves if no connection exists yet, so you never need to call this method explicitly.
The getContent( ) methods are just like the same-named methods of the URL class: they download the data referred to by the URL and parse it into an appropriate type of object (such as a string or an image)
In Java 1.3 and later, there is a version of getContent( ) that allows you to specify the types of parsed objects that you are willing to accept by passing an array of Class objects.
If you prefer to parse the URL content yourself instead of calling getContent( ), you can call getInputStream( ) (and getOutputStream( ) if the URL protocol supports writing) to obtain a stream through which you can read (or write) data from (or to) the resource identified by the URL.
Before a connection is established, you may want to set request fields (such as HTTP request headers) to refine the URL request.
Use setRequestProperty( ) to set a new value for a named header.
In Java 1.4 and later, you can use addRequestProperty( ) to add a new comma-separated item to an existing header.
Java 1.4 also added getRequestProperties( ), a method that returns the current set of request properties in the form of an unmodifiable Map object that maps request header names to List objects that contain the string value or values for the named header.
In Java 1.4 and later, getHeaderFields( ) returns an unmodifiable Map object that maps response header names to an unmodifiable List that contains the string value or values for the named header.
There are a number of options you can specify to control how the URLConnection behaves.
These options are set with the various set( ) methods and may be queried with corresponding get( ) methods.
The options must be set before the connect( ) method is called.
You can set this to false to force a URL to be reloaded.
In Java 5.0 and later, you can specify how long a URLConnection should wait while connecting or reading data with setConnectTimeout( ) and setReadTimeout( )
This class defines a static decode( ) method that reverses the encoding performed by URLEncoder.encode( )
This class defines a single static method that converts a string to its URL-encoded form.
That is, spaces are converted to +, and nonalphanumeric characters other than underscore are output as two hexadecimal digits following a percent sign.
This method canonicalizes a URL specification so that it uses only characters from an extremely portable subset of ASCII that can be correctly handled by computers around the world.
Protected Instance Fields protected boolean allowUserInteraction; protected boolean connected; protected boolean doInput; protected boolean doOutput; protected long ifModifiedSince; protected URL url; protected boolean useCaches;
This chapter documents the New I/O API defined by the java.nio package and its subpackages.
This package defines buffer classes that are fundamental to the java.nio API.
See Buffer for an overview of buffers, and see ByteBuffer (the most important of the buffer classes) for full documentation of byte buffers.
The other type-specific buffer classes are close analogs to ByteBuffer and are documented in terms of that class.
This class is the abstract superclass of all buffer classes in the java.nio API.
A buffer is a linear (finite) sequence of prmitive values.
The java.nio package defines a Buffer subclass for each primitive type in Java except for boolean.
Buffer itself defines the common, type-independent features of all buffers.
Buffer and its subclasses are intended for use by a single thread at a time, and contain no synchronization code to make them thread-safe.
The purpose of a buffer is to store data, and buffer classes must define methods for reading data from a buffer and writing data into a buffer.
Because each Buffer subclass stores data of a different primitive type, however, the get( ) and put( ) methods that read and write data must be defined by each of the individual subclasses.
See ByteBuffer (the most similar methods which differ only in the datatype of the values being read or written.
The capacity is specified when a buffer is created, and may not be changed; it can be queried with the capacity( ) method.
Data cannot be read from or written into a buffer beyond the limit.
When data is being written into a buffer, the limit is usually the same as the capacity.
When data is being read from a buffer, the limit may be less than the capacity, and indicates the amount of valid data contained in the buffer.
Two limit( ) methods exist: one to query a buffer’s limit, and one to set it.
It is used and updated by the relative get( ) and put( ) methods defined by ByteBuffer and the other Buffer subclasses.
Two position( ) methods exist to query and set the current position of the buffer.
The remaining( ) method returns the number of elements between the position and the limit and hasRemaining( ) returns true if this number is greater than zero.
Call mark( ) to set the mark to the current position.
Call reset( ) to restore the buffer’s position to the marked position.
Buffer defines several methods that perform important operations on a buffer:
This prepares the buffer to have new data written into it.
After data has been written into a buffer, this method “flips” the purpose of the buffer and prepares it for reading.
It does not alter the limit, and can be used to restart a read operation at the beginning of the buffer.
Buffer objects may be read-only, in which case any attempt to store data in the buffer results in a ReadonlyBufferException.
The isReadOnly( ) method returns true if a buffer is read-only.
Signals that a relative put( ) operation on a buffer could not complete because the number of elements to write exceeds the number of remaining elements between the buffer’s position and its limit.
Signals that a relative get( ) operation on a buffer could not complete because the number of elements to read exceeds the number of remaining elements between the buffer’s position and its limit.
ByteBuffer holds a sequence of bytes for use in an I/O operation.
ByteBuffer is an abstract class, so you cannot instantiate one by calling a constructor.
Instead, you must use allocate( ), allocateDirect( ), or wrap( )
The position of this new buffer is zero, and its limit is set to its capacity.
If you have already allocated an array of bytes, you can use the wrap( ) method to create a ByteBuffer that uses the byte array as its storage.
In the one-argument version of wrap( ) you specify only the array; the buffer capacity and limit are set to the array length, and the position is set to zero.
In the other form of wrap( ) you specify the array, as well as an offset and length that specify a portion of that array.
The capacity of the resulting ByteBuffer is again set to the total array length, but its position is set to the specified offset, and its limit is set to the offset plus length.
Once you have obtained a ByteBuffer, you can use the various get( ) and put( ) methods to read data from it or write data into it.
Several versions of these methods exist to read and write single bytes or arrays of bytes.
Relative get( ) and put( ) methods query or set the byte at the current position and then increment the position.
The absolute forms of the methods take an additional arguement that specifies the buffer element that is to be read or written and do not affect the buffer position.
Two other relative forms of the get( ) method exist to read as sequence of bytes (starting at and incrementing the buffer’s position) into a specified byte array or a specified sub-array.
These methods throw a BufferUnderflowException if there are not enough bytes left in the buffer.
Two relative forms of the put( ) method copy bytes from a specified array or sub-array into the buffer (starting at and incrementing the buffer’s position)
They throw a BufferOverflowException if there is not enough room left in the buffer to hold the bytes.
One final form of the put( ) method transfers all the remaining bytes from one ByteBuffer into this buffer, incrementing the positions of both buffers.
In addition to the get( ) and put( ) methods, ByteBuffer also defines another operation that affect the buffer’s content.
The position is then set to the new limit, and the limit is set to the capacity.
This method compacts a buffer by discarding elements that have already been read, and then prepares the buffer for appending new elements to those that remain.
All Buffer subclasses, such as CharBuffer, IntBuffer and FloatBuffer have analogous methods which are just like these get( ) and put( ) methods except that they operate on different data types.
ByteBuffer is unique among Buffer subclasses in that it has additional methods for reading and writing values of other primitive types from and into the byte buffer.
These methods have names like getInt( ) and putChar( ), and there are methods for all primitive types except byte and boolean.
Like the get( ) and put( ) methods, they come in relative and absolute variations: the relative methods start with the byte at the buffer’s position, and increment the position by the appropriate number of bytes (two bytes for a char, four bytes for an int, eight bytes for a double, etc.)
The absolute methods take an buffer index (it is a byte index and is not multiplied by the size of the primitive value) as an argument and do not modify the buffer position.
The byte order used by these primitive-type get and put methods is specified by a ByteOrder object.
The byte order for a ByteBuffer can be queried and set with the two forms of the order( ) method.
The default byte order for all newly-created ByteBuffer objects is ByteOrder.BIG_ENDIAN.
Other methods that are unique to ByteBuffer( ) are a set of methods that allow a buffer of bytes to be viewed as a buffer of other primitive types.
The returned buffers have position, limit, and mark values that are independent of those of the underlying buffer.
The initial position of the returned buffer is zero, and the limit and capacity are the number of bytes between the position and limit of the original buffer divided by the size in bytes of the relevant primitive type (two for char and short, four for int and float, and eight for long and double)
Note that the returned view buffer is a view of the bytes between the position and limit of the byte buffer.
Subsequent changes to the position and limit of the byte buffer do not change the size of the view buffer, but changes to the bytes themselves to change the values that are viewed through the view buffer.
View buffers use the byte ordering that was current in the byte buffer when they were created; subsequent changes to the byte order of the byte buffer do not affect the view buffer.
If the underlying byte buffer is direct, then the returned buffer is also direct; this is important because ByteBuffer is the only buffer class with an allocateDirect( ) method.
ByteBuffer defines some additional methods, which, like the get( ) and put( ) methods have analogs in all Buffer subclasses.
The two buffers have independent position, limit, and mark values, although the duplicate buffer starts off with the same values as the original buffer.
The duplicate buffer is direct if the original is direct and is read-only if the original is readonly.
The buffers share content, and content changes made to either buffer are visible through the other.
If this buffer has a backing array and is not a read-only buffer (e.g., if it was created with the allocate( ) or wrap( ) methods) then hasArray( ) returns true, array( ) returns the backing array, and arrayOffset( ) returns the offset within that array of the first element of the buffer.
If hasArray( ) returns false, then array( ) and arrayOffset( ) may throw an UnsupportedOperationException or a ReadOnlyBufferException.
Finally, ByteBuffer and other Buffer subclasses override several standard object methods.
The equals( ) methods compares the elements between the position and limit of two buffers and returns true only if there are the same number and have the same value.
Note that elements before the position of the buffer are not considered.
The hashCode( ) method is implemented to match the equals( ) method: the hashcode is based only upon the elements between the position and limit of the buffer.
This means that the hashcode changes if either the contents or position of the buffer changes.
This means that instances of ByteBuffer and other Buffer subclasses are not usually useful as keys for hashtables or java.util.Map objects.
ByteBuffer and each of the other Buffer subclasses also implement the Comparable interface and define a compareTo( ) method that performs an element-by-element comparison operation on the buffer elements between the position and the limit of the buffer.
This class is a type-safe enumeration of byte orders, and is used by the ByteBuffer class.
The two constant fields define the two legal byte order values: BIG_ENDIAN byte order means most-significant-byte first.
The static nativeOrder( ) method returns whichever of these two constants represents the native byte order of the underlying operating system and hardware.
CharBuffer holds a sequence of Unicode character values for use in an I/O operation.
In addition to the ByteBuffer analogs, this class also implements the java.lang.CharSequence interface so that it can be used with java.util.regex regular expression operations or anywhere else a CharSequence is expected.
In Java 5.0, CharBuffer adds the append( ) and read( ) methods of the java.lang.Appendable and java.lang.Readable interfaces, making CharBuffer objects suitable for use with the Formatter and Scanner classes of java.util.
Note that CharBuffer is an abstract class and does not defined a constructor.
Note that there is no allocateDirect( ) method as there is for ByteBuffer.
By calling one of the static wrap( ) methods to create a CharBuffer that uses the specified char array or CharSequence for its content.
Note that wrapping a CharSequence results in a read-only CharBuffer.
By calling the asCharBuffer( ) method of a ByteBuffer to obtain a CharBuffer “view” of the underlying bytes.
If the underlying ByteBuffer is direct, then the CharBuffer view will also be direct.
Note that this class holds a sequence of 16-bit Unicode characters, and does not represent text in any other encoding.
Classes in the java.nio.charset package can be used to encode a CharBuffer of Unicode characters into a ByteBuffer, or decode the bytes in a ByteBuffer into a CharBuffer of Unicode text.
Note that CharBuffer does not include any utility methods for working with int codepoints or surrogate pairs.
DoubleBuffer holds a sequence of double values for use in an I/O operation.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” DoubleBuffer by calling the asDoubleBuffer( ) method of an underlying ByteBuffer.
FloatBuffer holds a sequence of float values for use in an I/O operation.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” FloatBuffer by calling the asFloatBuffer( ) method of an underlying ByteBuffer.
IntBuffer holds a sequence of int values for use in an I/O operation.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” IntBuffer by calling the asIntBuffer( ) method of an underlying ByteBuffer.
Signals that a buffer’s position cannot be reset( ) because there is no mark defined.
LongBuffer holds a sequence of long values for use in an I/O operation.
Most of the methods of this class are directly analogous to methods defined by ByteBuffer except that.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” LongBuffer by calling the asLongBuffer( ) method of an underlying ByteBuffer.
This class is a ByteBuffer that represents a memory-mapped portion of a file.
Create a MappedByteBuffer by calling the map( ) method of a java.nio.channels.FileChannel.
If it returns true, then operations on the buffer will probably execute very quickly.
For buffers that are mapped in read/write mode, the force( ) method outputs any changes that have been made to the buffer contents to the underlying file.
If the file is on a local device, then it is guaranteed to be updated before force( ) returns.
No such guarantees can be made for mapped network files.
Note that the underlying file of a MappedByteBuffer may be shared, which means that the contents of such a buffer can change asynchronously if the contents of the file are modified by another thread or another process (such asynchronous changes to the underlying file may or may not be visible through the buffer; this is a platform-dependent, and should not be relied on)
Furthermore, if another thread or process truncates the file, some or all of the elements of the buffer may no longer map to any content of the file.
An attempt to read or write such an inaccesible element of the buffer will cause an implementation-defined exception, either immediately or at some later time.
Signals that a buffer is read-only and that its put( ) or compact( ) methods are not allowed to modify the buffer contents.
ShortBuffer holds a sequence of short values for use in an I/O operation.
Create one by calling the static allocate( ) or wrap( ) methods, which are also analogs of ByteBuffer methods.
Or, create a “view” ShortBuffer by calling the asShortBuffer( ) method of an underlying ByteBuffer.
This package is at the heart of the NIO API.
A channel is a communication channel for transferring bytes from or to a java.nio.ByteBuffer.
Channels serve a similar purpose to the InputStream and OutputStream classes of the java.io package, but are completely unrelated to those classes, and provide important features not available with the java.io API.
The Channels class defines methods that bridge the java.io and java.nio.channels APIs, by returning channels based on streams and streams based on channels.
The Channel interface simply defines methods for testing whether a channel is open and for closing a channel.
The other interfaces in the package extend Channel and define read( ) and write( ) methods for reading bytes from the channel into one or more byte buffers and for writing bytes from one or more byte buffers to the channel.
The FileChannel class defines an channel-based API for reading and writing from files (and also provides other important file functionality such as file locking and memory mapping that is not available through the java.io package)
SocketChannel, ServerSocketChannel, and DatagramChannel are channels for communication over a network, and Pipe defines two inner classes that use the channel abstraction for communication between threads.
The network and pipe channels are all subclasses of the SelectableChannel class, and may be put into nonblocking mode, in which calls to read( ) and write( ) return immediately, even if the channel is not ready for reading or writing.
The Selector class is crucial to the efficient use of nonblocking channels: it allows a program to register interested in I/O operations on several different channels at once.
A call to the select( ) method of a Selector will block until one of those channels becomes ready for I/O, and will then wake up.
This technique is important for writing scalable high-performance network servers.
Finally, this package allows for very fine-grained error handling by defining a large number of exception classes, several of which may be thrown by only a single method within the java.nio API.
Thrown by a call to connect( ) on a SocketChannel that is already connected.
Signals the termination of a blocked I/O operation because another thread closed the channel asynchronously.
This interface extends ReadableByteChannel and WritableByteChannel but adds no methods or constants of its own.
It exists simply as a convience that to unify the two interfaces.
Signals an attempt to use a SelectionKey whose cancel( ) method has previously been called.
This interface defines a communication channel for input and output.
The Channel interface is a high-level generic interface which is extended by more specific interfaces, such as ReadableByteChannel and WritableByteChannel.
Channel defines only two methods: isOpen( ) determines whether a channel is open, and close( ) closes a channel.
Once closed, a channel remains closed forever, and no further I/O operations may take place through it.
Many channel implementations are interruptible and asynchonously closeable, and implement the InterruptibleChannel interface to advertise this fact.
This class defines static methods that provide a bridge between the byte stream and character stream classes of the java.io package and the channel classes of java.nio.channels.
Channels is never intended to be instantiated: it serves solely as a placeholder for static methods.
These methods create byte channels based on java.io byte streams, and create java.io byte streams based on byte channels.
Note that the channel objects returned by the newChannel( ) methods may not implement InterruptibleChannel, and so may not be asynchonously closeable and interruptible like other channel classes in this package.
Channels also defines methods to create character streams (java.io.Reader and java.io.Writer) based on the combination of a byte channel and a character encoding.
The encoding may be specified by charset name, or with a CharsetDecoder or CharsetEncoder (see java.nio.charset)
An exception of this type is thrown by a thread blocked in an I/O operation on a channel when another thread calls its interrupt( ) method.
This exception is a subclass of AsynchronousCloseException and the channel will be closed as a side-effect of the thread interruption.
Signals an attempt to perform I/O on a channel that has been closed with the close( ) method, or that is closed for a particular type of I/O operation (a SocketChannel, for example, may have its read and write halves shut down independently.) Channels may be closed asynchronously, and threads blocking to complete an I/O operation will throw a subclass of this exception type.
Signals an attempt to use a Selector object whose close( ) method has been called.
Signals a call to the connect( ) method of a SocketChannel when there is already a connection pending for that channel.
This class implements a communication channel based on network datagrams.
Obtain a DatagramChannel by calling the static open( ) method.
Call socket( ) to obtain the java.net.DatagramSocket object on which the channel is based if you need to set any socket options to control low-level networking details.
The send( ) method sends the remaining bytes of the specified ByteBuffer to the host and port specified in the java.net.SocketAddress in the form of a datagram.
The send( ) and receive( ) methods typically perform security checks on each invocation to see if the application has permissions to communicate with the remote host.
If your application will use a DatagramChannel to exchange datagrams with a single remote host and port, use the connect( ) method to connect to a specified SocketAddress.
The connect( ) method performs the required security checks once and allows future communication with the specified address without the overhead.
Once a DatagramChannel is connected, you can use the standard read( ) and write( ) methods defined by the ReadableByteChannel, WritableByteChannel, GatheringByteChannel and ScatteringByteChannel interfaces.
Like the receive( ) method, the read( ) methods silently discard any received bytes that do not fit in the specified ByteBuffer.
The read( ) and write( ) methods throw a NotYetConnected exception if connect( ) has not been called.
DatagramChannel is a SelectableChannel; its validOps( ) method specifies that read and write operations may be selected.
Read and write operations may proceed concurrently, but the class ensures that only one thread may read and one thread write at a time.
This class implements a communication channel for efficiently reading and and writing files.
It implements the standard read( ) and write( ) methods of the ReadableByteChannel, WritableByteChannel, GatheringByteChannel and ScatteringByteChannel methods.
In addition, however, FileChannel provides methods for: random-access to the file, efficient transfer of bytes between the file and another channel, file locking, memory mapping, querying and setting the file size and forcing buffered updates to be written to disk.
Note that since file operations do not typically block for extended periods the way network operations can, FileChannel does not subclass SelectableChannel (it is the only channel class that does not) and cannot be used with Selector objects.
FileChannel has no public constructor and no static factory methods.
To obtain a FileChannel, first create a FileInputStream, FileOutputStream, or RandomAccessFile object (see the java.io package) and then call the getChannel( ) method of that object.
If you use a FileInputStream, the resulting channel will allow reading but not writing, and if you use a FileOutputStream, the channel will allow writing but not reading.
If you obtain a FileChannel from a RandomAccessFile, then the channel will allow reading, or both reading and writing, depending on the mode argument to the RandomAccessFile constructor.
A FileChannel has a position or file pointer that specifies the current point in the file.
You can set or query the file position with two methods, both of which share the name position( )
The position of a FileChannel and of the stream or RandomAccessFile from which it is derived are always the same: changing the position of the channel changes the position of the stream, and vice versa.
The initial position of a FileChannel is the position of the stream or RandomAccessFile when the getChannel( ) method was called.
If you create a FileChannel from a FileOutputStream that was opened in append mode, then any output to the channel always occurs at the end of the file, and sets the file position to the end end of the file.
Once you have a FileChannel object, you can use the standard read( ) and write( ) methods defined by the various channel interfaces.
In addition to updating the buffer position as they read and write bytes, these methods also update the file position to or from which those bytes are written or read.
These standard read( ) methods return the number of bytes actually read, and return -1 if there are no bytes left in the file to read.
The write( ) methods enlarge the file if they write past the current end-of-file.
FileChannel also defines position-independent read( ) and write( ) methods that take a file position as an explicit argument: they read or write starting at that position of the file, does not read any bytes and returns -1, and the write( ) method enlarges the file, leaving any bytes between the old end-of-file and the specified position undefined.
It is common to read bytes from a FileChannel and then immediately write them out to some other channel (such as a SocketChannel: think of a web server, for example), or to read bytes from a channel and immediately write them to a FileChannel (consider an FTP client)
FileChannel provides two methods, transferTo( ) and transferFrom( ) that do this very efficiently, without the need for a temporary ByteBuffer.
It does not alter the file position of the FileChannel, and it returns the number of bytes actually transferred.
For both methods, if the destination or source channel is a FileChannel itself, then the file position of that channel is updated.
The size( ) method returns the size (in bytes) of the underlying file.
If the specified size is greater than or equal to the current file size, the file is unchanged.
If the file position is greater than the new size of the file, it the position is changed to the new size.
Use the force( ) method to force any buffered modifications to the file to be written to the underlying storage device.
If the file resides on a local device, (as opposed to a network filesystem, for example) then force( ) guarantees that any changes to the file made since the channel was opened or since a previous call to force( ) will have been written to the device.
The argument to this method is a hint as to whether file metadata (such as last modification time) is to be forced out in addition to file content.
If this argument is true, the system will force content and meta-data.
Note that force( ) is only required to output change made directly through the FileChannel.
File updates made through a MappedByteBuffer returned by the map( ) method (described below)y should be forced out with the force( ) method of MappedByteBuffer.
FileChannel defines two blocking lock( ) and two nonblocking tryLock( ) methods for locking a file or a region of a file against concurrent access by another program.
These methods are not suitable for preventing concurrent access to a file by two threads within the same Java virtual machine.) The no-argument versions of these methods attempt to acquire an exclusive lock on the entire file.
The three-argument versions of the methods attempt to lock a specified region of the file, and may acquire shared locks in addition to exclusive locks.
A shared lock prevents any other process from acquiring an exclusive lock, but does not prevent other shared locks: typically, you acquire a shared lock when reading a file that should not be concurrently updated, and acquire an exclusive lock before writing file content to ensure that no one else is trying to read it at the same time.) The tryLock( ) methods return a FileLock object, or null if there was already a conflicting lock on the file.
The lock( ) methods block if there is already a conflicting lock and never return null.
The FileChannel file locking mechanism uses whatever locking capability is provided by the underlying platform.
Some operating systems enforce file locking: if one process holds a lock, other processes are prevented by the operating system from accessing the file.
Other operating systems merely prevent other processes from acquiring a conflicting lock: in this case, successful file locking requires the cooperation of all processes.
Some operating systems do not support shared locks: on these systems an exclusive lock is returned even when a shared lock is requested.
The map( ) method returns a MappedByteBuffer that represents the specified region of the file.
File contents can be read directly from the buffer, and (if the mapping is done in read/write mode) bytes placed in the buffer will be written to the file.
The mapping represented by a MappedByteBuffer remains valid until the buffer is garbage collected; the buffer continues to function even if the FileChannel from which it was created is closed.
File mappings can be done in three different modes which specify whether bytes can be written into the buffer and what happens when this is done.
The map( ) method relies on the memory-mapping facilities provided by the underlying operating system.
This means that a number of details may vary from implementation to implementation.
In particular, it is not specified whether changes to the underlying file made after the call to map( ) are visible through the MappedByteBuffer.
Using a mapped file is typically more efficient that an unmapped file only when the file is a large one.
Returned By java.io.FileInputStream.getChannel( ), java.io.FileOutputStream.getChannel( ), java.io.RandomAccessFile.getChannel( ), FileLock.channel( )
This class defines three constants that define the legal values of the mode argument to the map( ) method of the FileChannel class.
The contents of the MappedByteBuffer returned by the map( ) method may be read but may not be modified.
READ_WRITE The memory mapping is bidirectional: The contents of the returned buffer can be modified, and any modifications will (eventually) be written to the underlying file.
The FileChannel must have been created from a java.io.RandomAccessFile opened in read/ write mode.
A FileLock object is returned by the lock( ) and tryLock( ) methods of FileChannel and represents a lock on a file or a region of a file.
See FileChannel for more information on file locking with those methods.
When a lock is no longer required, it should be released with the release( ) method.
A lock will also be released if the channel is closed, or when the virtual machine terminates.
The channel( ), position( ), size( ) and isShared( ) methods return basic information about the lock: the FileChannel that was locked, the region of the file that was locked, and whether the lock is shared or exclusive.
If the entire file is locked, then the size( ) method returns a value (Long.MAX_VALUE) that is much greater than the actual file size.
If the underlying operating system does not support shared locks, then isShared( ) may return false even if a shared lock was requested.
Signals that the interrupt( ) method of a thread blocked waiting to acquire a file lock was called.
This interface extends WritableByteChannel and adds two additional write( ) methods that can “gather” bytes from one or more buffers and write them out to the channel.
These methods are passed an array of ByteBuffer objects, and, optionally, an offset and length that define the relevant sub-array to be used.
The write( ) method attempts to write all the remaining bytes from all the specified buffers (in the order in which they appear in the buffer array) to the channel.
The return value of the method is the number of bytes actually written.
See WritableByteChannel for a discussion of exceptions and thread-safety that apply to these write( ) methods as well.
Signals an attempt to use a channel in the wrong blocking mode.
An exception of this type is thrown by SelectableChannel.register( ) if the channel is not in nonblocking mode.
Signals an attempt to register a SelectableChannel with a Selector when the channel and the selector were not created by the same java.nio.channels.spi.SelectorProvider.
Channels that implement this marker interface have two important properties that are relevant to multithreaded programs: they are asynchonously closeable and interruptible.
When the close( ) method of an InterruptibleChannel is called, any other thread that is blocked waiting for an I/O operation to complete on that channel will stop blocking and receive an AsynchronousCloseException.
Furthermore, if a thread is blocked waiting for an I/O operation to complete on an InterruptibleChannel, then another thread may call the interrupt( ) method of the blocked thread.
This causes the interrupt status of the blocked thread to be set and causes the thread to wake up and receive an ClosedByInterruptException (a subclass of AsynchronousCloseException)
As the name of this interrupt implies, the channel that the thread was blocked on is closed as a side-effect of the thread interruption.
There is no way to interrupt a blocked thread without closing the channel upon which it is blocked.
This ability to interrupt a blocked thread is particularly noteworthy because it has never worked reliably with the older java.io API.
All the concrete channel implementations that are part of this package implement InterruptibleChannel.
Note, however, that methods such as Channels.newChannel( ) may return channel objects that are not interruptible.
You can use the instanceof to determine whether an unknown channel object implements this interface.
Signals that SocketChannel.finishConnect( ) was called without a previous call to SocketChannel.connect( )
Signals a call to the read( ) method of a readable channel that is not open for reading, such as a FileChannel created from a FileOutputStream.
Signal a call to a write( ) method of a writable channel that is not open for writing, such as a FileChannel created from a FileInputStream.
Signals a call to ServerSocketChannel.accept( ) before the underlying server socket has been bound to a local port.
Call socket( ).bind( ) to bind the java.net.ServerSocket that underlies the ServerSocketChannel.
Signals an attempt to read( ) or write( ) on a SocketChannel that is not yet connected to a remote host.
This exception is thrown by the lock( ) and tryLock( ) methods of FileChannel if the requested lock region overlaps a file lock that is already held by some thread in this JVM, or if there is already a thread in this JVM waiting to lock an overlapping region of the same file.
The FileChannel file locking mechanism is designed to lock files against concurrent access by two separate processes.
Two threads within the same JVM should not attempt to acquire a lock on overlapping regions of the same file, and any attempt to do so causes an exception of this type to be thrown.
A pipe is an abstraction that allows the one-way transfer of bytes from one thread to another.
Create a new pipe with the static Pipe.open( ) method.
Call the sink( ) method to obtain the Pipe.SinkChannel object that represents the write end of the pipe, and call the source( ) method to obtain the Pipe.SourceChannel object that represents the read end of the pipe.
Programmers familiar with Unix-style pipes may find the names and return values of the sink( ) and source( ) methods confusing.
A Unix pipe is an interprocess communication mechanism that is tied to two specific processes, one of which is a source of bytes and one of which is a destination, or sink, for those bytes.
With this conceptual model of a pipe, you would expect the source to obtain the channel it writes to with the source( ) method and the sink to obtain the channel it reads from with the sink( ) method.
While it can be used for communication between two threads, the ends of the pipe are not tied to those threads, and there need not be a single source thread and a single sink thread.
Therefore, in the Pipe API it is the pipe itself that serves as the source and the sink of bytes: bytes are read from the source end of the pipe, and are written to the sink end.
This public inner class is represents the write end of a pipe.
Bytes written to a Pipe.SinkChannel become available on the corresponding Pipe.SourceChannel of the pipe.
Obtain a Pipe.SinkChannel by creating a Pipe object with Pipe.open( ) and then calling the sink( ) method of that object.
Pipe.SinkChannel implements WritableByteChannel and GatheringByteChannel and defines the write( ) methods of those interfaces.
This class subclasses SelectableChannel, so that it can be used with a Selector.
It overrides the abstract validOps( ) method of SelectableChannel to return SelectionKey.OP_WRITE, but defines no new methods of its own.
This public inner class is represents the read end of a pipe.
Bytes that are written to the corresponding write end of the pipe (see Pipe.SinkChannel) become available for reading through this channel.
Obtain a Pipe.SourceChannel by creating a Pipe object with Pipe.open( ) and then calling the source( ) method of that object.
Pipe.SourceChannel implements ReadableByteChannel and ScatteringByteChannel and defines the read( ) methods of those interfaces.
This class subclasses SelectableChannel, so that it can be used with a Selector.
It overrides the abstract validOps( ) method of SelectableChannel to return SelectionKey.OP_READ, but defines no new methods of its own.
This subinterface of Channel defines a single key read( ) method which reads bytes from the channel and stores them in the specified ByteBuffer, updating the buffer position as it does so.
If the channel is a nonblocking channel, for example, the read( ) will return immediately, even if there are no bytes available to be read.
More specifically, it may throw a ClosedChannelException if the channel is closed.
If the channel is closed asynchronously, or if a blocked thread is interrupted, the read( ) method may terminate with an AsynchronousCloseException or a ClosedByInterruptException.
ReadableByteChannel implementations are required to be thread-safe: only one thread may perform a read operation on a channel at a time.
If a read operation is in progress, then any call to read( ) will block until the in-progress operation completes.
Some channel implementations may allow read and write operations to proceed concurrently, but none will allow two read operations to proceed at the same time.
This interface extends ReadableByteChannel and adds two additional read( ) methods that read bytes for a channel and “scatter” them to an array (or subarray) of buffers.
These methods are passed an array of ByteBuffer objects, and, optionally, an offset and length that define the region of the array to be used.
The read( ) method attempts to read enough bytes from the channel to fill each of the specified buffers in the order in which they appear in the buffer array (the “scattering” process is actually much more orderly and linear than the name implies)
The return value of the method is the number of bytes actually read, which may be different than the sum of the remaining bytes in the buffers.
See ReadableByteChannel for a discussion of exceptions and thread-safety that apply to these read( ) methods as well.
This abstract class defines the API for channels that can be used with a Selector object to allow a thread to block while waiting for activity on any of a group of channels.
All channel classes in the java.nio.channels package except for FileChannel are subclasses of SelectableChannel.
A selectable channel may only be registered with a Selector if it is nonblocking, so this class defines the configureBlocking( ) method.
Pass false to this method to put a channel into nonblocking mode, or pass true to make calls to its read( ) and/or write( ) methods block.
Use isBlocking( ) to determine the current blocking mode of a selectable channel.
Register a SelectableChannel with a Selector by calling the register( ) method of the channel (not of the selector)
There are two versions of this method: both take a Selector object and a bitmask that specifies the set of channel operations that are to be “selected” on that channel.
Both methods return a SelectionKey object that represents the registration of the channel with the selector.
One version of the register( ) method also takes an arbitrary object argument which serves as an “attachment” to the SelectionKey and allows you to associate arbitrary data with it.
The validOps( ) method returns a bitmask that specifies the set of operations that a particular channel object allows to be selected.
The bitmask passed to register( ) may only contain bits that are set in this validOps( ) value.
Note that SelectableChannel does not define a deregister( ) method.
Instead, to remove a channel from the set of channels being monitored by a Selector, you must call the cancel( ) method of the SelectionKey returned by register( )
Call isRegistered( ) to determine whether a SelectableChannel is registered with any Selector.
Note that a single channel may be registered with more than one Selector.) If you did not keep track of the SelectionKey returned by a call to register( ), you can query it with the keyFor( ) method.
See Selector and SelectionKey for further details on multiplexing selectable channels.
A SelectionKey represents the registration of a SelectableChannel with a Selector, and serves to identify a selected channel and the operations that are ready to be performed on that channel.
After a call to the select( ) method of a selector, the selectedKeys( ) method of the selector returns a Set of SelectionKey objects to identify the channel or channels that are ready for reading, for writing, or for another operation.
Create a SelectionKey by passing a Selector object to the register( ) method of a SelectableChannel.
The channel( ) and selector( ) methods of the returned SelectionKey return the SelectableChannel and Selector objects associated with that key.
When you no longer wish the channel to be registered with the selector, call the cancel( ) method of the SelectionKey.
Both sets are represented as integer bitmasks (not java.util.Set objects) formed by OR-ing together any of the OP_ constants defined by this class.
OP_READ In the interest set, this bit specifies an interest in read operations.
In the ready set, this bit specifies that the channel has bytes available for reading, has reached the end-of-stream, has been remotely closed, or that an error has occurred.
OP_WRITE In the interest set, this bit specifies an interest in write operations.
In the ready set, this bit specifies that the channel is ready to have bytes written, or has been closed, or that an error has occurred.
OP_CONNECT In the interest set, this bit specifies an interest in socket connection operations.
In the ready set, it indicates that a socket channel is ready to connect, or that an error has occurred.
OP_ACCEPT In the interest set, this bit specifies an interest in server socket accept operations.
In the ready set, it indicates that a server socket channel is ready to accept a connection or that an error has occurred.
The no-argument version of the interestOps( ) method allows you to query the interest set.
The inital value of the interest set the bitmask that was passed to the register( ) method of the channel.
It can be changed, however, by passing a new bitmask to the one-argument version of interestOps( )
Note that the same method name is used to both query and set the interest set.) The current state of the ready set can be queried with readyOps( )
You can also use the convenience methods isReadable( ), isWritable( ) isConnectable( ) and isAcceptable( ) to test whether individual operation bits are set in the ready set bitmask.
There is no way to explicitly set the state of the ready set--each call to select( ) method updates the ready set for you.
Note, however, that you must remove a SelectionKey object from the Set returned by Selector.selectedKeys( ) for the bits of the ready set to be cleared at the start of the next.
If you never remove the SelectionKey from the set of selected keys, the Selector assumes that none of the I/O readyness conditions represented by the ready set have been handled yet, and leaves their bits set.
Use attach( ) to associate an arbitrary object with a SelectionKey, and call attachment( ) to query that object.
This ability to associate data with a selection key is often useful when using a Selector with multiple channels: it can provide the context necessary to process a SelectionKey that has been selected.
A Selector is an object that monitors multiple nonblocking SelectableChannel objects and (after blocking if necessary) “selects” the channel that is (or the channels that are) ready for I/O.
Create a new Selector with the static open( ) method.
Next register the channels that it is to monitor: a channel is registered by passing the Selector to the register( ) method of the channel (register( ) is defined by the abstract SelectableChannel class)
In addition to the Selector you must also pass a bitmask that specifies which I/O operations (reading, writing, connecting, and accepting) that the Selector is to monitor for that channel.
Each call to this register( ) method returns a SelectionKey object.
The SelectionKey class also defines the constants that are used to form the bitmask of I/O operations.) Note that before a SelectableChannel can be registered, it must be in nonblocking mode, which can be accomplished with the configureBlocking( ) method of SelectableChannel.
Once the channels are registered with the Selector, call select( ) to block until one or more of the channels is ready for I/O.
One version of select( ) takes a timeout value and.
These methods also return if any of the channels is closed, if an error occurs on any channel, if the wakeup( ) method of the Selector is called, or if the interrupt( ) method of the blocked thread is called.
There is also a selectNow( ) method which is like select( ) except that it does not block: it simply polls each of the channels and determines which have become ready for I/O.
The return value of selectNow( ) and of both select( ) methods is the number of channels ready for I/O.
It is possible for this return value to be zero.
The select( ) and selectNow( ) methods returns the number of channels that are ready for I/O; they do not return the channels themselves.
To obtain this information, you must call the selectedKeys( ) method, which returns a java.util.Set containing SelectionKey objects.
After calling select( ) and selectedKeys( ), applications typically obtain a java.util.Iterator for the Set and use it to loop through the SelectionKey objects that represent the channels that are ready for I/O.
Use the channel( ) method of the SelectionKey to determine which channel is ready, and call readyOps( ), isReadable( ), isWritable( ) or related methods of the SelectionKey to determine what kind of I/O operation is ready on the channel.
SelectionKey objects remain in the selectedKeys( ) set until explicitly removed, so after performing the I/O operation for a given SelectionKey, you should remove that key from the Set returned by selectedKeys( ) (use the remove( ) method of the Set of its Iterator)
In addition to the selectedKeys( ) method, Selector also defines a keys( ) method, which also returns a Set of SelectionKey objects.
This set represents the complete set of channels that are being monitored by the Selector and may not be modified, except by closing the channel or deregistring the channel by calling the cancel( ) method of the associated SelectionKey.
Cancelled keys are removed from the keys( ) set on the next call to select( ) or selectNow( )
Call wakeup( ) to cause another thread blocked in a call to select( ) to wake up and return immediately.
If wakeup( ) is called but no thread is currently blocked in a select( ) call, then the next call to select( ) or selectNow( ) will return immediately.
When a Selector object is no longer needed, close it by calling close( )
If any thread is blocked in a select( ) call, it will return immediately as if wakeup( ) had been called.
After calling close( ), you should not call any other methods of a Selector.
Note, however, that the Set object returnd by selectedKeys( ) is not: it should be used by only one thread at a time.
It is a selectable channel that can be used by servers to accept connections from clients.
Unlike other channel classes in this any of the ByteChannel interfaces, and exists only to accept and establish connections with clients, not to communicate with those clients.
ServerSocketChannel differs from java.net.ServerSocket in two important ways: it can put into nonblocking mode and used with a Selector, and its accept( ) method returns a SocketChannel rather than a Socket, so that communication with the client whose connection was just accepted can be done using the java.nio APIs.
Create a new ServerSocketChannel with the static open( ) method.
Next, call socket( ) to obtain the associated ServerSocket object, and use its bind( ) method to bind the server socket to a specific port on the local host.
You can also call any other ServerSocket methods to configure other socket options at this point.
To accept a new connection through this ServerSocketChannel, simply call accept( )
If the channel is in blocking mode, this method will block until a client connects, and will then return a SocketChannel that is connected to the client.
In nonblocking mode, (see the inherited configureBlocking( ) method) accept( ) returns a SocketChannel only if there is a client currently waiting to connect, and otherwise immediately returns null.
To be notified when a client is waiting to connect, use the inherited register( ) method to register nonblocking a ServerSocketChannel with a Selector and specify an interest in accept operations with the SelectionKey.OP_ACCEPT constant.
Note that the SocketChannel object returned by the accept( ) method is always in nonblocking mode, regardless of the blocking mode of the ServerSocketChannel.
ServerSocketChannel is thread-safe; only one thread may call the accept( ) method at a time.
When a ServerSocketChannel is no longer required, close it with the inherited close( ) method.
This class is a channel for communicating over a java.net.Socket.
It is a subclass of SelectableChannel and can be used with a Selector.
Create a new SocketChannel with one of the static open( ) methods.
The no-argument version of open( ) creates a new SocketChannel but does not connect it to a remote host.
The other version of open( ) opens a new channel and connects it to the specified java.net.SocketAddress.
If you create an unconnected socket, you can explictly connect it with the connect( ) method.
The main reason to open the channel and connect to the remote host in separate steps is if you want to do a nonblocking connect.
To do this, first put the channel into nonblocking mode with the inherited configureBlocking( ) method.
Then, call connect( ): it will return immediately, without waiting for the connection to be established.
Then register the channel with a Selector specifying that you are interested in SelectionKey.OP_CONNECT operations.
When you are notified that your channel is ready to connect (see Selector and SelectionKey for details) simply call the nonblocking finishConnect( ) method to complete the connection.
Once you have opened and connected a SocketChannel, you can read and write bytes to it with the various read( ) and write( ) methods.
SocketChannel is thread-safe: read and write operations may proceed concurrently, but SocketChannel will not allow more than one read operation and more than one write operation to proceed at the same time.
The socket( ) method returns the java.net.Socket that is associated with the SocketChannel.
You can use this Socket object to configure socket options, bind the socket to a specific local address, close the socket, or shutdown its input or output sides.
Note that although all SocketChannel objects have associated Socket objects, the reverse is not true: you cannot obtain a SocketChannel from a Socket unless the Socket was created along with the SocketChannel by a call to SocketChannel.open( )
When you are done with a SocketChannel, close it with the close( ) method.
You can also independently shut down the read and write portions of the channel with socket( ).shutdownInput( ) and socket( ).shutdownOutput( )
When the input is shut down, any future reads (and any blocked read operation) will return -1 to indicate that the end-ofstream has been reached.
When the output is shut down, any future writes throw a ClosedChannelException, and any write operation that was blocked at the time of shut down throws a AsynchronousCloseException.
Signals the use of a java.net.SocketAddress that could not be resolved: for example a java.net.InetSocketAddress that contains an unknown hostname.
Signals the use of a java.net.SocketAddress subclass that is unknown to or not supported by the implementation.
It is safe to assume that addresses of the type java.net.InetSocketAddress are universally supported.
This subinterface of Channel defines a single key write( ) method which writes bytes from a specified ByteBuffer (updating the buffer position as it goes) to the channel.
If possible, it writes all remaining bytes in the buffer (see Buffer.remaining( ))
This is not always possible (with nonblocking channels, for example) so the write( ) method returns the number of bytes that it was actually able to write to the channel.
More specifically, it may throw a ClosedChannelException if the channel is closed.
If the channel is closed asynchronously, or if a blocked thread is interrupted, the write( ) method may terminate with an AsynchronousCloseException or a ClosedByInterruptException.
WritableByteChannel implementations are required to be thread-safe: only one thread may perform a write operation on a channel at a time.
If a write operation is in progress, then any call to write( ) will block until the in-progress operation completes.
Some channel implementations may allow read and write operations to proceed concurrently; some may not.
This package defines four classes that are used by implementors of channels and selector classes of java.nio.channels.
It also defines the SelectorProvider class which allows a custom implementation of channels and selectors to be specified for use instead of the default implementation.
This class exists as a convenience for implementors of new Channel classes.
Application programmers should never need to subclass or use it.
This class exists as a convenience for implementors of new selectable channel classes: it defines common methods of SelectableChannel in terms of protected methods whose names begin with impl.
Application programmers should never need to use or subclass this class.
Protected Instance Methods protected final void end(boolean completed) throws java.nio.channels.AsynchronousCloseException; protected abstract void implCloseChannel( ) throws java.io.IOException;
This class exists as a convenience for implementors of new SelectionKey classes.
Application programmers should never need to use or subclass this class.
This class exists as a convenience for implementors of new Selector classes.
Application programmers should never need to use or subclass this class.
This class is the central service-provider class for the channels and selectors of the java.nio.channels API.
A concrete subclass of SelectorProvider implements factory methods that return open socket channels, server socket channels, datagram channels, pipes (with their two internal channels) and Selector objects.
There is one default SelectorProvider object per JVM: this object can be obtained with the static SelectorProvider.provider( ) method.
You can specify a custom SelectorProvider implementation by setting its class name as the value of the system property java.nio.channels.spi.SelectorProvider.
Or, you can put the class name in a file named META-INF/services/java.nio.channels.spi.SelectorProvider, in your application’s JAR file.
The provider( ) method first looks for the system property, then looks for the JAR file entry.
If it finds neither, it instantiates the implementation’s default SelectorProvider.
Applications are not required to use the default SelectorProvider exclusively.
It is legal to instantiate other SelectorProvider objects and explictly invoke their open( ) methods to create channels in that way.
Passed To java.nio.channels.DatagramChannel.DatagramChannel( ), java.nio.channels.Pipe.SinkChannel.SinkChannel( ), java.nio.channels.Pipe.SourceChannel.SourceChannel( ), java.nio.channels.ServerSocketChannel.ServerSocketChannel( ), java.nio.channels.SocketChannel.SocketChannel( ), AbstractSelectableChannel.AbstractSelectableChannel( ), AbstractSelector.AbstractSelector( )
Returned By java.nio.channels.SelectableChannel.provider( ), java.nio.channels.Selector.provider( ), AbstractSelectableChannel.provider( ), AbstractSelector.provider( )
This package contains classes that represent character sets or encodings, and defines methods that encode characters into bytes and decode bytes into characters.
The key class is Charset, and you can obtain a Charset object for a named character encoding with the static forName( ) method.
Charset defines encode( ) and decode( ) convenience methods, but for full control over the encoding and decoding process, you can also obtain a CharsetEncoder or CharsetDecoder object from the Charset.
The Java platform has had a character encoding and decoding facility since Java 1.1, and defines a number of classes and methods that perform character encoding or decoding.
Some of these classes and methods are specified to use the default charset for the locale; others take the name of a charset as a method or constructor argument.
See, for example, the String( ), java.io.InputStreamReader( ) and java.io.OutputStreamWriter( ) constructors.
In Java 1.4, the java.nio.charset package defines a public API to the character encoding and decoding facility and allows applications to work with it explicitly.
Most applications will not have to do this, however, and can simply continue to rely on the default charset, or can continue to supply charset names where needed.
Even applications that use the java.nio.channels package can avoid explicit character encoding and decoding by passing the name of a desired charset to the newReader( ) and newWriter( ) methods of java.nio.channels.Channels.
Note that the one-argument versions of CharsetEncoder.encode( ) and CharsetDecoder.decode( ) may throw an exception of this type, but that the three-argument versions of the same method instead report encoding problems through their CoderResult return value.
Note also that the encode( ) and decode( ) convenience methods of Charset do not throw this exception because they specify that malformed input and unmappable characters or bytes should be replaced.
Each Charset has a cannonical name, returned by name( ), and a set of aliases, returned by aliases( )
You can look up a Charset by name or alias with the static Charset.forName( ) method, which throws an UnsupportedCharsetException if the named charset is not installed on the system.
In Java 5.0, you can obtain the default Charset used by the Java VM with the static defaultCharset( ) method.
Check whether a charset specified by name or alias is supported with the static isSupported( )
Obtain the complete set of installed charsets with availableCharsets( ) which returns a sorted map from canonical names to Charset objects.
Note that charset names are not casesensitive, and you can use any capitialization for charset names you pass to isSupported( ) and forName( )
Note that there are a number of classes and methods in the Java platform that specify charsets by name rather than by Charset object.
See, for example, java.io.InputStreamReader, java.io.OutputStreamWriter, String.getBytes( ), and java.nio.channels.Channels.newWriter( )
When working with classes and methods such as these, there is no need to use a Charset object.
All implementations of Java are required to support at least the following 6 charsets:
Once you have obtained a Charset with forName( ) or availableCharsets( ), you can use the encode( ) method to encode a String or CharBuffer of text into a ByteBuffer, or you can use the decode( ) method to convert the bytes in a ByteBuffer into characters in a CharBuffer.
These convenience methods create a new CharsetEncoder or CharsetDecoder, specify that malformed input or unmappable characters or bytes should be replaced with the default replacement string or bytes, and then invoke the encode( ) or decode( ) method of the encoder or decoder.
For full control over the encoding and decoding process, you may prefer to obtain your own CharsetEncoder or CharsetDecoder object with newEncoder( ) or newDecoder( )
Instead of using a Charset, CharsetEncoder, or CharsetDecoder directly, you may also pass an encoder or decoder to the static methods of java.nio.channels.Channels to obtain a java.io.Reader or java.io.Writer that you can use to read or write characters from or to a byte-oriented Channel.
Note that not all Charset objects support encoding (“auto-detect” charsets can determine the source charset when decoding, but have no way to encode)
Use canEncode( ) to determine whether a given Charset can encode.
The equals( ) method compares two charsets by comparing their canonical.
Assumes big-endian when decoding if there is no byte order mark.
Encodes using bigendian byte order and outputs an appropriate byte order mark.
Charset implements Comparable, and its compareTo( ) method orders charsets by their canonical name.
That is, if every character that can be represented in the specified charset can also be represented in this charset.
Note that those representations need not be the same, however.
Passed To java.io.InputStreamReader.InputStreamReader( ), java.io.OutputStreamWriter.OutputStreamWriter( ), CharsetDecoder.CharsetDecoder( ), CharsetEncoder.CharsetEncoder( )
Obtain a CharsetDecoder from the Charset that represents the charset to be decoded.
If you have a complete sequence of bytes to be decoded in a ByteBuffer you can pass that buffer to the one-argument version of decode( )
This convenience method decodes the bytes and stores the resulting characters into a newly allocated CharBuffer, resetting and flushing the decoder as necessary.
It throws an exception if there are problems with the bytes to be decoded.
Typically, however, the three-argument version of decode( ) is used in a multistep decoding process:
Call the reset( ) method, unless this is the first time the CharsetDecoder has been used.
Call the three-argument version of decode( ) one or more times.
The third argument should be true on, and only on, the last invocation of the method.
The first argument to decode( ) is a ByteBuffer that contains bytes to be decoded.
The second argument is a CharBuffer into which the resulting characters are stored.
The return value of the method is a CoderResult object that specifies the state of the ongoing the decoding operation.
In a typical case, however, decode( ) returns after it has decoded all of the bytes in the input buffer.
In this case, you would then typically fill the input buffer with more bytes to be decoded, and read characters from the output buffer, calling its compact( ) method to make room for more.
If an unexpected problem arises in the CharsetDecoder implementation, decode( ) throws a CoderMalfunctionError.
Pass the output CharBuffer to the flush( ) method to allow any remaining characters to be output.
The decode( ) method returns a CoderResult that indicates the state of the decoding operation.
If the return value is CoderResult.UNDERFLOW, then it means that decode( ) returned because all bytes from the input buffer have been read, and more input is required.
If the return value is CoderResult.OVERFLOW, then it means that decode( ) returned because the output CharBuffer is full, and no more characters can be decoded into it.
Otherwise, the reurn value is a CoderResult whose isError( ) method returns true.
If isMalformed( ) returns true then the input included bytes that are not legal for the charset.
These bytes start at the position of the input buffer, and continue for length( ) bytes.
Otherwise, if isUnmappable( ) returns true, then the input bytes include a character for which there is no representation in Unicode.
The relevant bytes start at the position of the input buffer and continue for length( ) bytes.
By default a CharsetDecoder reports all malformed input and unmappable character errors by returning a CoderResult object as described above.
This behavior can be altered, however, by passing a CodingErrorAction to onMalformedInput( ) and onUnmappableCharacter( )
Query the current action for these types of errors with malformedInputAction( ) and unmappableCharacterAction( ).) CodingErrorAction defines three constants that represent the three possible actions.
The REPLACE action tells the CharsetDecoder to replace malformed input and unmappable characters with the replacement string.
This replacement string can be set with replaceWith( ), and can be queried with replacement( )
These values can be used to help you choose the size of the CharBuffer to allocate for decoding.
Only one thread should use an instance at a time.
Implementors defining new charsets will need to subclass CharsetDecoder and define the abstract decodeLoop( ) method, which is invoked by decode( )
Obtain a CharsetEncoder with the newEncoder( ) method of the Charset that represents the desired encoding.
Use the encode( ) method to encode characters read from a CharBuffer into bytes stored in a ByteBuffer.
Signals a malfunction--typically an unknown and unrecoverable error--in a CharsetEncoder or CharsetDecoder.
An error of this type is thrown by the encode( ) and decode( ) methods when the protected encodeLoop( ) or decodeLoop( ) methods upon which they are implemented throws an exception of an unexpected type.
A CoderResult object specifies the results of a call to CharsetDecoder.decode( ) or CharsetEncoder.encode( )
There are four possible reasons why a call to the decode( ) or encode( ) would return:
If all the bytes have been decoded or all the characters have been encoded, and the input buffer is empty, then the return value is the constant object CoderResult.UNDERFLOW, indicating that coding stopped because there was no more data to code.
Calling the isUnderflow( ) method on the returned object returns true and calling isError( ) returns false.
If there is more data to be coded, but there is no more room in the output buffer to store the coded data, then the return value is the constant object CoderResult.OVERFLOW.
Calling isOverflow( ) on the returned object returns true, and calling isError( ) returns false.
If the input data was malformed, containing characters or bytes that are not legal for the charset, and the CharsetEncoder or CharsetDecoder has not specified that malformed input should be ignored or replaced, then the returned value is a CoderResult object.
The position of the input buffer is at the first malformed character or byte, and the length( ) method of the returned object specifies how many characters or bytes are malformed.
If the input was well-formed, but contains characters or bytes that are “unmappable"--that cannot be encoded or decoded in the specified charset--and if the CharsetEncoder or CharsetDecoder has not specified that unmappable characters should be ignored or replaced, then the returned value is a CoderResult object whose isError( ) and isUnmappable( ) methods both return true.
The input buffer is positioned at the first unmappable character or byte, and the length( ) method of the CoderResult specifies the number of unmappable characters or bytes.
This class is a typesafe enumeration that defines three constants that serve as the legal argument values to the onMalformedInput( ) and onUnmappableCharacter( ) methods of CharsetDecoder and CharsetEncoder.
These constants specify how malformed input and unmappable error conditions should be handled.
This is done by returning a CoderResult object from the three-argument version of decode( ) or encode( ) or by throwing a MalformedInputException or UnmappableCharacterException from the one-argument version of decode( ) or encode( )
This is the default action for both error types for both CharsetDecoder and CharsetEncoder.
CodingErrorAction.IGNORE Specifies that the malformed input or unmappable input character should simply be skipped, with no output.
CodingErrorAction.REPLACE Specifies that the malformed input or unmappable character should be skipped and the replacement string or replacement bytes should be appended to the output.
Signals that a charset name (for example one passed to Charset.forName( ) or Charset.isSupported( )) is not legal.
They must begin with a letter or a digit, not with a punctuation character.
Signals that input to the CharsetDecoder.decode( ) or CharsetEncoder.encode( ) method was malformed.
Signals that input to the CharsetDecoder.decode( ) or CharsetEncoder.encode( ) method contained a character or byte sequence that is not mappable in the specified charset.
Signals that the requested charset is not supported on the current platform.
This exception is thrown by Charset.forName( ) when no Charset object can be obtained for the named charset.
This package defines a “provider” class for system developers who are defining new Charset implementations and want to make them available to the system.
Application programmers never need to us this package or the class it defines.
System programmers developing new Charset implementations should implement this class to make those charsets available to the system.
A CharsetProvider and its associated Charset implementations should be packaged in a JAR file and made available to the system in the jre/lib/ext/ extensions directory (or some other extensions location.) The JAR file should contain a file named METAINF/services/java.nio.charset.spi.CharsetProvider which contains the class name of the CharsetProvider implementation.
It defines classes that should work with any type of certificate, and type-specific subclasses for X.509 certificates and CRLs.
Instances of these classes can be used with any security provider.
The java.security.acl package is part of the Java platform, but has been superseded by access-control classes in java.security.
The java.security package contains the classes and interfaces that implement the Java security architecture.
Second, there are authentication classes that implement message digests and digital signatures and can authenticate Java classes and other objects.
The central access control class is AccessController; it uses the currently installed Policy object to decide whether a given class has Permission to access a given system resource.
The Permissions and ProtectionDomain classes are also important pieces of the Java access control architecture.
The key classes for authentication are MessageDigest and Signature; they compute and verify cryptographic message digests and digital signatures.
These classes use public-key cryptography techniques and rely on the PublicKey and PrivateKey interfaces.
They also rely on an infrastructure of related classes, such as SecureRandom for producing cryptographic-strength pseudorandom numbers, KeyPairGenerator for generating pairs of public and private keys, and KeyStore for managing a collection of keys and certificates.
The CodeSource class unites the authentication classes with the access control classes.
It represents the source of a Java class as a URL and a set of java.security.cert.Certificate objects that contain the digital signatures of the code.
The AccessController and Policy classes look at the CodeSource of a class when making access control decisions.
All the cryptographic-authentication features of this package are provider-based, which means they are implemented by security provider modules that can be plugged easily into any Java 1.2 (or later) installation.
Thus, in addition to defining a security API, this package also defines a service provider interface (SPI)
Various classes with names that end in Spi are part of this SPI.
Security provider implementations must subclass these Spi classes, but applications never need to use them.
Each security provider is represented by a Provider class, and the Security class allows new providers to be dynamically installed.
For example, DigestInputStream and DigestOutputStream make it easy to compute message digests.
SignedObject protects the integrity of an arbitrary Java object by attaching a digital signature, making it easy to detect any tampering with the object.
Although the java.security package contains cryptographic classes for authentication, it does not contain classes for encryption or decryption.
Instead, this functionality is part of the Java Cryptography Extension or JCE which defines the javax.crypto package and its subpackages.
The checkPermission( ) method can make access-control decisions based on the saved state of the call stack.
Access-control checks are usually performed by the AccessController.checkPermission( ) method, which checks that the current call stack has the required permissions.
Sometimes, however, it is necessary to make access-control decisions based on a previous state of the call stack.
Call AccessController.getContext( ) to create an AccessControlContext for a particular call stack.
In Java 1.3, this class has constructors that specify a custom context in the form of an array of ProtectionDomain objects and that associate a DomainCombiner object with an existing AccessControlContext.
This class is used only by system-level code; typical applications rarely need to use it.
Thrown by AccessController to signal that an access request has been denied.
The static methods of this class implement the default access-control mechanism as of Java 1.2
If so, checkPermission( ) returns, and the operation can proceed.
As of Java 1.2, the checkPermission( ) method of the default java.lang.SecurityManager calls AccessController.checkPermission( )
System-level code that needs to perform an access check should invoke the SecurityManager method rather than calling the AccessController method directly.
Unless you are writing system-level code that must control access to system resources, you never need to use this class or the SecurityManager.checkPermission( ) method.
The various doPrivileged( ) methods run blocks of privileged code encapsulated in a PrivilegedAction or PrivilegedExceptionAction object.
When checkPermission( ) is traversing the call stack of a thread, it stops if it reaches a privileged block that was executed with doPrivileged( )
This means that privileged code can run with a full set of privileges, even if it was invoked by untrusted or lower-privileged code.
The getContext( ) method returns an AccessControlContext that represents the current security context of the caller.
Such a context might be saved and passed to a future call (perhaps a call made from a different thread)
Use the two-argument version of doPrivileged( ) to force permission checks to check the AccessControlContext as well.
This class defines a generic API for generating parameters for a cryptographic algorithm, typically a Signature or a javax.crypto.Cipher.
Create an AlgorithmParameterGenerator by calling one of the static getInstance( ) factory methods and specifying the name of the algorithm and, optionally, the name or Provider object of the desired provider.
Once you have obtained a generator, initialize it by calling the init( ) method and specifying an algorithm-independent parameter size (in bits) or an algorithm-dependent AlgorithmParameterSpec object.
You may also specify a SecureRandom source of randomness when you call init( )
Once you have created and initialized the AlgorithmParameterGenerator, call generateParameters( ) to generate an AlgorithmParameters object.
This abstract class defines the service-provider interface for algorithm-parameter generation.
A security provider must implement a concrete subclass of this class for each algorithm it supports.
This class is a generic, opaque representation of the parameters used by some cryptographic algorithm.
You can create an instance of the class with one of the static getInstance( ) factory methods, specifying the desired algorithm and, optionally, the desired provider.
Once you have obtained an AlgorithmParameters object, initialize it by passing an algorithm-specific java.security.spec.AlgorithmParameterSpec object or the encoded parameter values as a byte array to the init( ) method.
You can also create an AlgorithmParameters object with an AlgorithmParameterGenerator.
Passed To javax.crypto.Cipher.init( ), javax.crypto.CipherSpi.engineInit( ), javax.crypto.EncryptedPrivateKeyInfo.EncryptedPrivateKeyInfo( ), javax.crypto.ExemptionMechanism.init( ), javax.crypto.ExemptionMechanismSpi.engineInit( )
Returned By AlgorithmParameterGenerator.generateParameters( ), AlgorithmParameterGeneratorSpi.engineGenerateParameters( ), Signature.getParameters( ), SignatureSpi.engineGetParameters( ), javax.crypto.Cipher.getParameters( ), javax.crypto.CipherSpi.engineGetParameters( ), javax.crypto.EncryptedPrivateKeyInfo.getAlgParameters( )
A security provider must implement a concrete subclass of this class for each cryptographic algorithm it supports.
This class is a Permission subclass whose implies( ) method always returns true.
This means that code that has been granted AllPermission is granted all other possible permissions.
This class exists to provide a convenient way to grant all permissions to completely trusted code.
Applications typically do not need to work directly with Permission objects.
An implementation of the login( ) method should use the supplied javax.security.auth.callback.CallbackHandler class to request the user’s password or other authentication credentials.
If no callback handler is passed to login( ), it should use the one registered with setCallbackHandler( ) or a default.
This Permission class is the abstract superclass for a number of simple permission types.
BasicPermission is typically subclassed to implement named permissions that have a name, or target, string, but do not support actions.
The implies( ) method of BasicPermission defines a simple wildcarding capability.
Applications typically do not need to work directly with Permission objects.
Subclasses java.io.SerializablePermission, RuntimePermission, java.lang.management.ManagementPermission, java.lang.reflect.ReflectPermission, java.net.NetPermission, SecurityPermission, java.util.PropertyPermission, java.util.logging.LoggingPermission, javax.net.ssl.SSLPermission, javax.security.auth.AuthPermission, javax.security.auth.kerberos.DelegationPermission.
This interface was used in Java 1.1 to represent an identity certificate.
This class encapsulates the certificate path of a code signer and a signed timestamp.
This class represents the source of a Java class, as defined by the URL from which the class was loaded and the set of digital signatures attached to the class.
A CodeSource object is created by specifying a java.net.URL and an array of java.security.cert.Certificate objects.
In Java 5.0, the class has been generalized to accept an array of CodeSigner objects instead of Certificate objects.
Only applications that create custom ClassLoader objects should ever need to use or subclass this class.
When a CodeSource represents a specific piece of Java code, it includes a fully qualified URL and the actual set of certificates used to sign the code.
When a CodeSource object defines a ProtectionDomain, however, the URL may include wildcards, and the array of certificates is a minimum required set of signatures.
The implies( ) method of such a CodeSource tests whether a particular Java class comes from a matching URL and has the required set of signatures.
This class is a byte input stream with an associated MessageDigest object.
When bytes are read with any of the read( ) methods, those bytes are automatically passed to the update( ) method of the MessageDigest.
When you have finished reading bytes, you can call the digest( ) method of the MessageDigest to obtain a message digest.
If you want to compute a digest just for some of the bytes read from the stream, use on( ) to turn the digesting function on and off.
Digesting is on by default; call on(false) to turn it off.
This class is a byte output stream with an associated MessageDigest object.
When bytes are written to the stream with any of the write( ) methods, those bytes are automatically passed to the update( ) method of the MessageDigest.
When you have finished writing bytes, you can call the digest( ) method of the MessageDigest to obtain a message digest.
If you want to compute a digest just for some of the bytes written to the stream, use on( ) to turn the digesting function on and off.
Digesting is on by default; call on(false) to turn it off.
This interface defines a single combine( ) method that combines two arrays of ProtectionDomain objects into a single equivalent (and perhaps optimized) array.
You can associate a DomainCombiner with an existing AccessControlContext by calling the two-argument AccessControlContext( ) constructor.
Then, when the checkPermission( ) method of the AccessControlContext is called or when the AccessControlContext is passed to a doPrivileged( ) method of AccessController, the specified DomainCombiner merges the protection domains of the current stack frame with the protection domains encapsulated in the AccessControlContext.
This class is used only by system-level code; typical applications rarely need to use it.
This class is the superclass of most of the exceptions defined by the java.security package.
The checkGuard( ) method is passed an object to which access has been requested.
If access should be granted, checkGuard( ) should return silently.
Otherwise, if access is denied, checkGuard( ) should throw a java.lang.SecurityException.
The Guard object is used primarily by the GuardedObject class.
This class uses a Guard object to guard against unauthorized access to an arbitrary encapsulated object.
Create a GuardedObject by specifying an object and a Guard for it.
The getObject( ) method calls the checkGuard( ) method of the Guard to determine whether access to the object should be allowed.
If access is allowed, getObject( ) returns the encapsulated object.
The Guard object used by a GuardedObject is often a Permission.
In this case, access to the guarded object is granted only if the calling code is granted the specified permission by the current security policy.
This deprecated class was used in Java 1.1 to represent an entity or Principal with an associated PublicKey object.
In Java 1.1, the public key for a named entity could be retrieved from the system keystore with a line like the following:
As of Java 1.2, the Identity class and the related IdentityScope and Signer classes have been deprecated in favor of KeyStore and java.security.cert.Certificate.
This deprecated class was used in Java 1.1 to represent a group of Identity and Signer objects and their associated PublicKey and PrivateKey objects.
As of Java 1.2, it has been replaced by the KeyStore class.
Signals that one or more algorithm parameters (usually specified by a java.security.spec.AlgorithmParameterSpec object) are not valid.
This subclass of java.lang.IllegalArgumentException signals that a parameter passed to a security method is not valid.
This interface defines the high-level characteristics of all cryptographic keys.
Returned By KeyFactory.translateKey( ), KeyFactorySpi.engineTranslateKey( ), KeyStore.getKey( ), KeyStoreSpi.engineGetKey( ), javax.crypto.Cipher.unwrap( ), javax.crypto.CipherSpi.engineUnwrap( ), javax.crypto.KeyAgreement.doPhase( ), javax.crypto.KeyAgreementSpi.engineDoPhase( )
This class translates asymmetric cryptographic keys between the two representations used by the Java Security API.
KeyFactory is used with public and private keys; see javax.crypto.SecretKeyFactory if you are working with symmetric or secret keys.
To convert a Key to a KeySpec or vice versa, create a KeyFactory by calling one of the static getInstance( ) factory methods specifying the name of the key algorithm (e.g., DSA or RSA) and optionally specifying the name or Provider object for the desired provider.
Then, use generatePublic( ) or generatePrivate( ) to create a PublicKey or PrivateKey object from a corresponding KeySpec.
Or use getKeySpec( ) to obtain a KeySpec for a given Key.
Because there can be more than one KeySpec implementation used by a particular cryptographic algorithm, you must also specify the Class of the KeySpec you desire.
If you do not need to transport keys portably between applications and/or systems, you can use a KeyStore to store and retrieve keys and certificates, avoiding KeySpec and KeyFactory altogether.
A security provider must implement a concrete subclass of this class for each cryptographic algorithm it supports.
In Java 1.2, this exception is only thrown by deprecated methods.
This class is a simple container for a PublicKey and a PrivateKey object.
Because a KeyPair contains an unprotected private key, it must be used with as much caution as a PrivateKey object.
This class generates a public/private key pair for a specified cryptographic algorithm.
To create a KeyPairGenerator, call one of the static getInstance( ) methods, specifying the name of the algorithm and, optionally, the name or Provider object of the security provider to use.
Once you have created a KeyPairGenerator, initialize it by calling initialize( )
You can perform an algorithm-independent initialization by simply specifying the desired key size in bits.
Alternatively, you can do an algorithm-dependent initialization by providing an appropriate AlgorithmParameterSpec object for the key-generation algorithm.
In either case, you may optionally provide your own source of randomness in the guise of a SecureRandom object.
Once you have created and initialized a KeyPairGenerator, call genKeyPair( ) to create a KeyPair object.
Remember that the KeyPair contains a PrivateKey that must be kept private.
Applications should not use any methods inherited from that class.
A security provider must implement a concrete subclass of this class for each cryptographic algorithm for which it can generate key pairs.
This class defines a serialized representation for Key implementations and is typically used only by security providers, not users of the java.security package.
The constants defined by this enumerated type represent the general types of cryptographic keys: public keys, private keys, and secret keys.
This class represents a mapping of names, or aliases, to Key and java.security.cert.Certificate objects.
Obtain a KeyStore object by calling one of the static getInstance( ) methods, specifying the desired key store type and, optionally, the desired provider.
Once you have created a KeyStore, use load( ) to read its contents from a stream, supplying an optional password that verifies the integrity of the stream data.
Keystores are typically read from a file named .keystore in the user’s home directory.
The KeyStore API has been substantially enhanced in Java 5.0
A KeyStore may contain both public and private key entries.
A public key entry is represented by a Certificate object.
Use getCertificate( ) to look up a named public key certificate and setCertificateEntry( ) to add a new public key certificate to the keystore.
A private key entry in the keystore contains both a password-protected Key and an array of Certificate objects that represent the certificate chain for the public key that corresponds to the private key.
Use getKey( ) and getCertificateChain( ) to look up the key and certificate chain.
Use setKeyEntry( ) to create a new private key entry.
You must provide a password when reading or writing a private key from the keystore; this password encrypts the key data, and each private key entry should have a different password.
If you are using the JCE, you may also store javax.crypto.SecretKey objects in a KeyStore.
Secret keys are stored like private keys, except that they do not have a certificate chain associated with them.
To delete an entry from a KeyStore, use deleteEntry( )
If you modify the contents of a KeyStore, use store( ) to save the keystore to a specified stream.
You may specify a password that is used to validate the integrity of the data, but it is not used to encrypt the keystore.
In Java 5.0 the KeyStore.Entry interface defines a keystore entry.
You can get or set an entry of any type with the new methods getEntry( ) and setEntry( )
These methods accept a KeyStore.ProtectionParameter object, such as a password represented as a KeyStore.PasswordProtection object.
Java 5.0 also defines new load( ) and store( ) methods that specify a password indirectly through a KeyStore.LoadStoreParameter.
Passed To KeyStore.Builder.newInstance( ), java.security.cert.PKIXBuilderParameters.PKIXBuilderParameters( ), java.security.cert.PKIXParameters.PKIXParameters( ), javax.net.ssl.KeyManagerFactory.init( ), javax.net.ssl.KeyManagerFactorySpi.engineInit( ), javax.net.ssl.TrustManagerFactory.init( ), javax.net.ssl.TrustManagerFactorySpi.engineInit( )
An instance of this class encapsulates the parameters necessary to obtain a KeyStore object at some later time.
This class is useful when you want to defer the initialization of a KeyStore (which may require the user to enter a password) until it is needed.
This class is a KeyStore.ProtectionParameter implementation that wraps a javax.security.auth.callback.CallbackHandler for prompting the user for a password or other authentication credentials.
This interface represents an object passed to the load( ) or store( ) methods of KeyStore.
Note that getPassword( ) returns a reference to the internal array, not a clone of it.
The first element of the returned array is the certificate of the ultimate certificate authority (CA)
This marker interface should be implemented by classes that provide some form of protection for the entries in a KeyStore.
This implementation of KeyStore.Entry represents a certificate that contains and certifies a.
A security provider must implement a concrete subclass of this class for each KeyStore type it supports.
This class computes a message digest (also known as a cryptographic checksum) for an arbitrary sequence of bytes.
Obtain a MessageDigest object by calling one of the static getInstance( ) factory methods and specifying the desired algorithm (e.g., SHA or MD5) and, optionally, the desired provider.
Next, specify the data to be digested by calling any of the update( ) methods one or more times.
In Java 5.0 and later, however, you can also use a java.nio.ByteBuffer.
This facilitates the computation of message digests when using the New I/O API.
After you pass data to update( ), call digest( ), which computes the message digest and returns it as an array of bytes.
If you have only one array of bytes to be digested, you can pass it directly to digest( ) and skip the update( ) step.
When you call digest( ), the MessageDigest( ) object is reset and is then ready to compute a new digest.
You can also explicitly reset a MessageDigest without computing the digest by calling reset( )
To compute a digest for part of a message without resetting the MessageDigest, clone the MessageDigest and call digest( ) on the cloned copy.
Note that not all implementations are cloneable, so the clone( ) method may throw an exception.
The MessageDigest class is often used in conjunction with DigestInputStream and DigestOutputStream, which automate the update( ) calls for you.
A security provider must implement a concrete subclass of this class for each message-digest algorithm it supports.
Thrown by getInstance( ) factory methods throughout the java.security package.
Signals that a requested cryptographic service provider is not available.
Thrown by getInstance( ) factory methods throughout the java.security package.
This abstract class represents a system resource, such as a file in the filesystem, or a system capability, such as the ability to accept network connections.
Concrete subclasses of Permission, such as java.io.FilePermission and java.net.SocketPermission, represent specific types of resources.
Permission objects are used by system code that is requesting access to a resource.
They are also used by Policy objects that grant access to resources.
The AccessController.checkPermission( ) method considers the source of the currently running Java code, determines the set of permissions that are granted to that code by the current Policy, and then checks to see whether a specified Permission object is included in that set.
As of Java 1.2, this is the fundamental Java access-control mechanism.
Each permission has a name (sometimes called the target) and, optionally, a commaseparated list of actions.
For example, the name of a FilePermission is the name of the file or directory for which permission is being granted.
The interpretation of the name and action strings is entirely up to the implementation of Permission.
A number of implementations support the use of wildcards; for example, a FilePermission can have a name of “/tmp/*”, which represents access to any files in a /tmp directory.
Permission objects must be immutable, so an implementation must never define a setName( ) or setActions( ) method.
One of the most important abstract methods defined by Permission is implies( )
This method must return true if this Permission implies another Permission.
In general, only system-level code needs to work directly with Permission and its concrete subclasses.
System administrators who are configuring security policies need to understand the various Permission subclasses.
Applications that want to extend the Java accesscontrol mechanism to provide customized access control to their own resources should subclass Permission to define custom permission types.
This class is used by Permissions to store a collection of Permission objects that are all the same type.
Like the Permission class itself, PermissionCollection defines an implies( ) method that can determine whether a requested Permission is implied by any of the Permission objects in the collection.
Some Permission types may require a custom PermissionCollection type in order to correctly implement the implies( ) method.
In this case, the Permission subclass should override newPermissionCollection( ) to return a Permission of the appropriate type.
PermissionCollection is used by system code that manages security policies.
When Permission objects are added with the add( ) method, they are grouped into an internal set of PermissionCollection objects that contain only a single type of Permission.
Use the elements( ) method to obtain an Enumeration of the Permission objects in the collection.
Use implies( ) to determine if a specified Permission is implied by any of the Permission objects in the collection.
Permissions is used by system code that manages security policies.
This class represents a security policy that determines the permissions granted to code based on its source and signers, and, in Java 1.4 and later, based on the user on whose behalf that code is running.
There is only a single Policy in effect at any one time.
Obtain the system policy by calling the static getPolicy( ) method.
Code that has appropriate permissions can specify a new system policy by calling setPolicy( )
The refresh( ) method is a request to a Policy object to update its state (for example, by rereading its configuration file)
Applications should not need to use this class unless they implement some kind of custom access-control mechanism.
Prior to Java 1.4, this class provides a mapping from CodeSource objects to PermissionCollection objects.
As of Java 1.4, you can use a ProtectionDomain object to encapsulate a CodeSource and a set of users on whose behalf the code is running.
In this release, there is a new getPermissions( ) method that returns a PermissionsCollection appropriate for the specified ProtectionDomain.
In addition, there is a new implies( ) method that dynamically queries the Policy to see if the specified permission is granted to the specific ProtectionDomain.
This interface represents any entity that may serve as a principal in a cryptographic transaction of any kind.
A Principal may represent an individual, a computer, or an organization, for example.
It extends the Key interface, but does not add any new methods.
The interface exists in order to create a strong distinction between private and public keys.
This interface defines a block of code (the run( ) method) that is to be executed as privileged code by the AccessController.doPrivileged( ) method.
In Java 5.0 this interface is generic and the type variable T represents the return type of the run( ) method.
When privileged code is run with the doPrivileged( ) method, the AccessController looks only at the permissions of the immediate caller, not the permissions of the entire call stack.
The immediate caller is typically fully trusted system code that has a full set of permissions, and therefore the privileged code runs with that full set of permissions, even if the system code is invoked by untrusted code with no permissions whatsoever.
Privileged code is typically required only when you are writing a trusted system library (such as a Java extension package) that must read local files or perform other restricted actions, even when called by untrusted code.
For example, a class that must call System.loadLibrary( ) to load native methods should make the call to loadLibrary( ) within the run( ) method of a PrivilegedAction.
If your privileged code may throw a checked exception, implement it in the run( ) method of a PrivilegedExceptionAction instead.
To minimize the possibility of security holes, keep the body of the run( ) method as short as possible.
This exception class is a wrapper around an arbitrary Exception thrown by a PrivilegedExceptionAction executed by the AccessController.doPrivileged( ) method.
Or, in Java 1.4 and later, use the more general getCause( ) method.
This interface is like PrivilegedAction, except that its run( ) method may throw an exception.
Use the getProtectionDomain( ) of a Class object to obtain the ProtectionDomain that the class is part of.
Prior to Java 1.4, a ProtectionDomain simply associates a CodeSource with the PermissionCollection granted to code from that source by a Policy.
The set of permissions is static, and the implies( ) method checks to see whether the specified Permission is implied by any of the permissions granted to this ProtectionDomain.
In Java 1.4 and later, a ProtectionDomain can also be created with the four-argument constructor which associates a PermissionCollection with a ClassLoader and an array of Principal objects in addition to a CodeSource.
A ProtectionDomain of this sort represents permisssions granted to code loaded from a specified source, through a specified class loader, and running under the auspices of one or more specified principals.
When a ProtectionDomain is instantiated with this four-argument constructor, the PermissionCollection is not static, and the implies( ) method calls the implies( ) method of the current Policy object before checking the specified collection of permissions.
This allows security policies to be updated (for example to add new permissions for specific users) without having to restart long-running programs such as servers.
It specifies class names for implementations of one or more algorithms for message digests, digital signatures, key generation, key conversion, key management, secure random number generation, certificate conversion, and algorithm parameter management.
The getName( ), getVersion( ), and getInfo( ) methods return information about the provider.
Provider inherits from Properties and maintains a mapping of property names to property values.
These name/value pairs specify the capabilities of the Provider implementation.
The corresponding property value is the name of the class that implements the named algorithm.
The values of these properties are the // Public Constructors.
In Java 5.0, the individual services provided by a Provider are described by the nested Service class, and various methods for querying and setting the Service objects of a Provider are available.
For Sun’s implementation, the ${java.home}/lib/security/java.security file specifies the class names of all installed Provider implementations.
An application can also install its own custom Provider with the addProvider( ) and insertProviderAt( ) methods of the Security class.
Most applications do not need to use the Provider class directly.
Typically, only security-provider implementors need to use the Provider class.
Some applications may explicitly specify the name of a desired Provider when calling a static getInstance( ) factory method, however.
Only applications with the most demanding cryptographic needs require custom providers.
This nested class represents a single service (such as a hash algorithm) provided by a security Provider.
The various methods return information about the service, including the name of the implementing class.
Signals that an exception has occurred inside a cryptographic service provider.
Note that ProviderException extends RuntimeException and is therefore an unchecked exception that may be thrown from any method without being declared.
It extends the Key interface, but does not add any new methods.
The interface exists in order to create a strong distinction between public and private keys.
Returned By java.security.Certificate.getPublicKey( ), Identity.getPublicKey( ), KeyFactory.generatePublic( ), KeyFactorySpi.engineGeneratePublic( ), KeyPair.getPublic( ), java.security.cert.Certificate.getPublicKey( ), java.security.cert.PKIXCertPathValidatorResult.getPublicKey( ), java.security.cert.TrustAnchor.getCAPublicKey( ), java.security.cert.X509CertSelector.getSubjectPublicKey( )
This class adds protected methods to those defined by ClassLoader.
It calls the getPermissions( ) method to obtain a PermissionCollection for that CodeSource and then uses the CodeSource and PermissionCollection to create a ProtectionDomain, which is passed to the defineClass( ) method of its superclass.
The default implementation of the getPermissions( ) method uses the default Policy to determine the appropriate set of permissions for a given code source.
The value of SecureClassLoader is that subclasses can use its defineClass( ) method to load classes without having to work explicitly with the ProtectionDomain and Policy classes.
A subclass of SecureClassLoader can define its own security policy by overriding getPermissions( )
In Java 1.2 and later, any application that implements a custom class loader should do so by extending SecureClassLoader, instead of subclassing ClassLoader directly.
Most applications can use java.net.URLClassLoader, however, and never have to subclass this class.
Although SecureRandom defines public constructors, the preferred technique for obtaining a SecureRandom object is to call one of the static getInstance( ) factory methods, specifying the desired pseudorandom number-generation algorithm, and, optionally, the desired provider of that algorithm.
Once you have obtained a SecureRandom object, call nextBytes( ) to fill an array with pseudorandom bytes.
You can also call any of the methods defined by the Random superclass to obtain random numbers.
The first time one of these methods is called, the SecureRandom( ) method uses its generateSeed( ) method to seed itself.
If you have a source of random or very high-quality pseudorandom bytes, you may provide your own seed by calling setSeed( )
Repeated calls to setSeed( ) augment the existing seed instead of replacing it.
You can also call generateSeed( ) to generate seeds for use with other pseudorandom generators.
A security provider must implement a concrete subclass of this class for each pseudorandom number-generation algorithm it supports.
This class defines static methods both for managing the list of installed security providers and for reading and setting the values of various properties used by the Java security system.
It is essentially an interface to the ${java.home}/lib/security/java.security properties file that is included in Sun’s implementation of Java.
Use getProperty( ) and setProperty( ) to query or set the value of security properties whose default values are stored in that file.
One of the important features of the java.security properties file is that it specifies a set of security provider implementations and a preference order in which they are to be used.
In Java 1.3 and later, versions of this method exist that only return providers that implement the algorithm or algorithms specified in a String or Map object.
You can also look up a single named Provider object by name with getProvider( )
Note that a provider name is the string returned by getName( ) method of the Provider class, not the classname of the Provider.
You can alter the set of providers installed by default from the java.security file.
Use addProvider( ) to add a new Provider object to the list, placing it at the end of the list, with a lower preference than all other providers.
Use insertProviderAt( ) to insert a provider into the list at a specified position.
Specify a position of 1 to make the provider the most preferred one.
A service name specifies the category of security service you are querying.
This class is a Permission subclass that represents access to various methods of the Policy, Security, Provider, Signer, and Identity objects.
SecurityPermission objects are defined by a name only; they do not use a list of actions.
Obtain a Signature object by calling one of the static getInstance( ) factory methods and specifying the desired digital signature algorithm and, optionally, the desired provider of that algorithm.
A digital signature is essentially a message digest encrypted by a public-key encryption algorithm.
Thus, to specify a digital signature algorithm, you must specify both the digest algorithm and the encryption algorithm.
Once you have obtained a Signature object, you must initialize it before you can create or verify a digital signature.
To initialize a digital signature for creation, call initSign( ) and specify the private key to be used to create the signature.
To initialize a signature for verification, call initVerify( ) and specify the public key of the signer.
Once the Signature object has been initialized, call update( ) one or more times to specify the data to be signed or verified.
Prior to Java 5.0, the data must be specified as an array of bytes.
In Java 5.0 and later, you can also pass a ByteBuffer to update( ), and this facilitates the use of the Signature class with the java.nio package.
Finally, to create a digital signature, call sign( ), passing a byte array into which the signature is stored.
Or, pass the bytes of the digital signature to verify( ), which returns true if the signature is valid or false otherwise.
After calling either sign( ) or verify( ), the Signature object is reset internally and can be used to create or verify another signature.
Signals a problem while creating or verifying a digital signature.
A security provider must implement a concrete subclass of this class for each digital signature algorithm it supports.
This class applies a digital signature to any serializable Java object.
Create a SignedObject by specifying the object to be signed, the PrivateKey to use for the signature, and the Signature object to create the signature.
The SignedObject( ) constructor serializes the specified object into an array of bytes and creates a digital signature for those bytes.
After creation, a SignedObject is itself typically serialized for storage or transmission to another Java thread or process.
Once the SignedObject is reconstituted, the integrity of the object it contains can be verified by calling verify( ) and supplying the PublicKey of the signer and a Signature that performs the verification.
Whether or not verification is performed or is successful, getObject( ) can be called to deserialize and return the wrapped object.
This deprecated class was used in Java 1.1 to represent an entity or Principal that has an associated PrivateKey that enables it to create digital signatures.
As of Java 1.2, this class and the related Identity and IdentityScope classes have been replaced by KeyStore and java.security.cert.Certificate.
An instance of this class is an immutable signed timestamp.
An exception of this type is thrown if a KeyStore.Entry cannot be recovered from a KeyStore.
This exception is thrown if a Key cannot be retrieved from a KeyStore.
Thrown By KeyStore.getKey( ), KeyStoreSpi.engineGetKey( ), javax.net.ssl.KeyManagerFactory.init( ), javax.net.ssl.KeyManagerFactorySpi.engineInit( )
This class is used internally to provide a mechanism for delayed resolution of permissions (such as those whose implementation is in an external JAR file that has not been loaded yet)
An UnresolvedPermission holds a representation of a Permission object that can later be used to create the actual Permission object.
Java 5.0 adds methods to obtain details about the unresolved permission.
The java.security.cert package contains classes for working with identity certificates, certificate chains (also known as certification paths) and certificate revocation lists (CRLs)
The CertPath class represents a certificate chain, and CertPathValidator provides the ability to validate a certificate chain.
The CertificateFactory class serves as a certificate parser, providing the ability to convert a stream of bytes (or the base64 encoding of those bytes) into a Certificate, a CertPath or a CRL object.
In addition to the algorithm-independent API of CertificateFactory, this chains using the PKIX standards.
This package replaces the deprecated java.security.Certificate interface, and it also replaces the deprecated javax.security.cert package used by early versions of the JAAS API before javax.security.auth and its subpackages were added to the core Java platform.
A certificate is an object that contains the name of an entity and a public key for that entity.
Certificates are issued by, and bear the digital signature of, a (presumably trusted) third party, typically a certificate authority (CA)
By issuing and signing the certificate, the CA is certifying that, based on their research, the entity named on the certificate really is who they say they are and that the public key in the certificate really does belong to that entity.
Sometimes the signer of a certificate is not a trusted CA, and the certificate is accompanied by the signer’s certificate which may be signed by a CA, or by another untrusted intermediary who provides his or her own certificate.
Use a CertificateFactory to parse a stream of bytes into a Certificate object; getEncoded( ) reverses this process.
Use verify( ) to verify the digital signature of the entity that issued the certificate.
If the signature cannot be verified, the certificate should not be trusted.
Call getPublicKey( ) to obtain the java.security.PublicKey of the subject of the certificate.
Note that this class does not define a method for obtaining the Principal that is associated with the PublicKey.
That functionality is dependent on the type of the certificate.
Protected Instance Methods 1.3 protected Object writeReplace( ) throws java.io.ObjectStreamException;
This protected inner class provides an alternate representation of a certificate that can be used for serialization purposes by the writeReplace( ) method of some Certificate implementations.
This class is the superclass of several more specific exception types that may be thrown when working with certificates.
Signals that a certificate has expired or will have expired by a specified date.
This class defines methods for parsing certificates, certificate chains (certification paths) and certificate revocation lists (CRLs) from byte streams.
Obtain a CertificateFactory by calling one of the static getInstance( ) factory methods and specifying the type of certificate or CRL to be parsed, and, optionally, the desired service provider to perform the parsing.
Once you have obtained a CertificateFactory for the desired type of certificate, call generateCertificate( ) to parse a Certificate from a specified byte stream, or call generateCertificates( ) to parse a group of unrelated certificates (i.e.
Similarly, call generateCRL( ) to parse a single CRL object from a stream, and call generateCRLs( ) to parse a Collection of CRL objects from the stream.
These CertificateFactory methods read to the end of the specified stream.
If the stream supports mark( ) and reset( ), however, the CertificateFactory resets the stream to the position after the end of the last certificate or CRL read.
A certificate factory for X.509 certificates can parse certificates encoded in binary or printable hexadecimal form.
The generateCertPath( ) methods return a CertPath object representing a certificate chain.
These methods can create a CertPath object from a List of Certificate object, or by reading the chained certificates from a stream.
Specify the encoding of the certificate chain by passing the name of the encoding standard to generateCertPath( )
The first encoding returned by the iterator is the default used when no encoding is explicitly specified.
This abstract class defines the service provider interface, or SPI, for the CertificateFactory class.
A security provider must implement this class for each type of certificate it wishes to support.
Signals that a certificate is not yet valid or will not yet be valid on a specified date.
Signals an error or other problem while parsing a certificate.
Use a CertPathValidator to validate a certificate chain and establish trust in the public key presented in the certificate of the end entity.
Also, for X.509 certificate paths, the List returned by getCertificates( ) starts with the certificate of of the end entity, and ends with a certificate signed by the trust anchor.
The signer of any certificate but the last must be the subject of the next certificate in the List.
If the end entity presents a certificate that is directly signed by a trust anchor (which is a not uncommon occurrence) then the List returned by getCertificates( ) consists of only that single certificate.
Note that the list of certificates does not include the certificate of the trust anchor.
The public keys of trusted CAs must be known by the system in advance.
In Sun’s JDK implementation, the publickey certificates of trusted CAs are stored in the file jre/lib/security/cacerts.
CertPath objects can be created with a CertificateFactory, or at a lower level with a CertPathBuilder object.
A CertificateFactory can parse or decode a CertPath object from a binary stream.
The getEncoded( ) methods reverse the process and encode a CertPath into an array of bytes.
The first returned encoding name is the default one, but you can use any supported encoding by using the oneargument version of getEncoded( )
CertPath objects are immutable as is the List object returned by getCertificates( ) and the Certificate objects contained in the list.
This protected inner class defines an implementation-independent representation of a CertPath for serialization purposes.
CertPathBuilder attempts to build a certification path from a specified certificate to a trust anchor.
Unlike the CertificateFactory.generateCertPath( ) method, which might be used by a server to parse a certificate chain presented to it by a client, this class is used to create a new certificate chain, and might be used by a client that needs to send a certificate chain to a server.
The CertPathBuilder API is provider-based, and is algorithm independent, although the use of any algorithms other than the “PKIX” standards (which work.
Obtain a CertPathBuilder object by calling one of the static getInstance( ) methods, specifying the desired algorithm and, optionally, the desired provider.
Once you have a CertPathBuilder, you create a CertPath object by passing a CertPathParameters object to the build( ) method.
CertPathParameters is a marker interfaces that defines no method of its own, so you must use an algorithm-specific implementation such as PKIXBuilderParameters to supply the information required to build a CertPath.
Use the getCertPath( ) method of this returned object to obtain the CertPath that was built.
The algorithm-specific implementation PKIXCertPathBuilderResult has additional methods that return further algorithm-specific results.
Signal a problem while building a certification path with CertPathBuilder.
An object of this type is returned by the build( ) method of a CertPathBuilder.
The getCertPath( ) method returns the CertPath object that was built; this method will never return null.
Security providers must implement this interface, but applications never need to use it.
CertPathParamters is a marker interface for objects that hold parameters (such as the set of trust anchors) for validating or building a certification path with CertPathValidator and CertPathBuilder.
It defines no methods of its own, but requires that all implementations include a working clone( ) method.
You must use an algorithm-specific implementation of this interface, such as PKIXParameters or PKIXBuilderParameters when validating or building a CertPath, and it is rarely useful to work with this interface directly.
This class validates certificate chains, establishing a chain of trust from the end entity to a trust anchor, and thereby establishing the validity of the public key presented in the end entity’s certificate.
To obtain a CertPathValidator instance, call one of the static getInstance( ) methods specifying the name of the desired validation algorithm and, optionally, the provider to use.
Once you have a CertPathValidator object, you can use it to validate certificate chains by passing the CertPath object to be validated to the validate( ) method along with a CertPathParameters object that specifies valid trust anchors and other validation parameters.
CertPathParameters is simply a marker interface, and you must use an application-specific implementation such as PKIXParameters.
If validation fails, the validate( ) method throws a CertPathValidatorException which may include the index in the chain of the certificate that failed to validate.
Otherwise, if validation is successful, the validate( ) method returns a CertPathValidatorResult.
If you are interested in the details of the validation (such as the trust anchor that was used or the public key of the end entity), you may cast this returned value to an algorithm-specific subtype such as PKIXCertPathValidatorResult and use its methods to find out more about the result.
Signals a problem while validating a certificate chain with a CertPathValidator.
This marker interface defines the type of the object returned by the validate( ) method of a CertPathValidator, but does not define any of the contents of that object, other to specify that it must be Cloneable.
If you want any details about the results of validating a CertPath, you must cast the return value of validate( ) to an algorithm-specific types implementation of this interface, such as PKIXCertPathValidatorResult.
Security providers must implement this interface, but applications never need to use it.
This interface defines an API for determining whether a Certificate meets some criteria.
Implementations are used to specify critera by which a certificate or certificates should be selected from a CertStore object.
The match( ) method should examine the Certificate it is passed and return true if it “matches” based on whatever criteria the implementation defines.
See CRLSelector for a similar interface for use when selecting CRL objects from a CertStore.
A CertStore object is a repository for Certificate and CRL objects.
You may query a CertStore for a java.util.Collection of Certificate or CRL objects that match specified criteria by passing a CertSelector or CRLSelector to getCertificates( ) or getCRLs( )
A CertStore is conceptually similar to a java.security.KeyStore, but there are significant differences in how the two classes are intended to be used.
A KeyStore is designed to store a relatively small local collection of database (in the form of an LDAP server, for examle) of untrusted certificates.
Obtain a CertStore object by calling a getInstance( ) method and specifying the name of the desired CertStore type and a CertStoreParameters object that is specific to that type.
Optionally, you may also specify the desired provider of your CertStore object.
The CertStore class may be directly useful to applications that want to query a LDAP server for certificates.
It is also used by PKIXParameters.addCertStore( ) and PKIXParameters.setCertStores( ) to specify a source of certificates to by used by the CertPathBuilder and CertPathValidator classes.
Signals a problem while querying a CertStore for certificates or CRLs.
This marker interface defines the type, but not the content, of the parameters object that is passed to the CertStore.getInstance( ) methods.
It does not define any methods of its own and simply requires that all implementing classes be cloneable.
Security providers must implement this interface, but applications never need to use it.
This concrete implementation of CertStoreParameters is used when creating a CertStore object of type “Collection”
Pass the Collection of Certificate and CRL objects to be searched by the CertStore to the constructor method.
A CRL is an object issued by a certificate authority (or other certificate signer) that lists certificates that have been revoked, meaning that they are now invalid and should be rejected.
Use a CertificateFactory to parse a CRL from a byte stream.
Use the isRevoked( ) method to test whether a specified Certificate is listed on the CRL.
Note that type-specific CRL subclasses, such as X509CRL, may provide access to substantially more information about the revocation list.
Signals an error or other problem while working with a CRL.
This interface defines an API for determining whether a CRL object meets some criteria.
Implementations are used to specify critera by which a CRL objects should be selected from a CertStore.
The match( ) method should examine the CRL it is passed and return true if it “matches” based on whatever criteria the implementation defines.
See CertSelector for a similar interface for use when selecting Certificate objects from a CertStore.
This concrete implementation of CertStoreParameters is used when creating a CertStore object of type “LDAP”
It specifies the hostname of the LDAP server to connect to and, optionally, the port to connect on.
Instances of this class are used to specify parameters to the build( ) method of a CertPathBuilder object.
These parameters must include the two mandatory ones passed to the constructors.
The first is a source of trust anchors, which may be supplied as a Set of TrustAnchor objects or as a java.security.KeyStore object.
The second required parameter is a CertSelector object (typically an X509CertSelector) that specifies the selection criteria for the certificate that is to have the certification path built.
In addition to these parameters that are passed to the constructor, this class also inherits a number of methods for setting other parameters, and defines setMaxPathLength( ) for specifying the maximum length of the certificate chain that is built.
An instance of this class is retured by the build( ) method of a CertPathBuilder created for the “PKIX” algorithm.
This abstract class defines an extension mechanism for the PKIX certification path building and validation algorithms.
You may pass one or more PKIXCertPathChecker objects to the setCertPathCheckers( ) or addCertPathChecker( ) methods of the PKIXParameters or PKIXBuilderParameters object that is passed to the build( ) or validate( ) methods of a CertPathBuilder or CertPathValidator.
The check( ) method of all PKIXCertPathChecker objects registered in this way will be invoked for each certificate considered in the building or validation algorithms.
The init( ) method is invoked to tell the checker to reset its internal state and to notify it of the direction in which certificates will be presented.
Checkers are not required to support the forward direction, and should return false from isForwardCheckingSupported( ) if they do not.
An instance of this class is returned upon successful validation by the validate( ) method of a CertPathValidator created for the “PKIX” algorithm.
This implementation of CertPathParameters defines parameters that are passed to the validate( ) method of a PKIX CertPathValidator and defines a subset of the parameters that are passed to the build( ) method of a PKIX CertPathBuilder.
A full understanding of this class requires a detailed discussion of the PKIX certification path building and validation algorithms, which is beyond the scope of this book.
When you create a PKIXParameters object, you must specify which trust anchors are to be used.
You can do this by passing a Set of TrustAnchor objects to the constructor, or by passing a KeyStore containing trust anchor keys to the constructor.
Once a PKIXParameters object is created, you can modify the set of TrustAnchor objects with setTrustAnchors( )
Specify a Set of CertStore objects to be searched for certificates with setCertStores( ) or add a single CertStore to the set with addCertStore( )
If certificate validity is to be checked for some date and time other than the current time, use setDate( ) to specify this date.
This class represents a node in the policy tree created by the PKIX certification path validation algorithm.
A discussion of X.509 policy extensions and their use in the PKIX certification path algorithms is beyond the scope of this reference.
This class is a low-level representation of a policy qualifier information from a X.509 certificate extension.
A discussion of X.509 policy extensions and their use in the PKIX certification path algorithms is beyond the scope of this reference.
A TrustAnchor represents a certificate authority that is trusted to “anchor” a certificate chain.
The format and meaning of such name constraints is beyond the scope of this reference, and most applications can simply specify null for this constructor argument.
Its various methods provide complete access to the contents of the certificate.
A full understanding of this class requires detailed knowledge of the X.509 standard which is beyond the scope of this reference.
Some of the more important methods are described here, however.
Note that verify( ) and getPublicKey( ) are inherited from Certificate.
Finally, cast the Certificate returned by this method to an X509Certificate.
Its various set methods allow you to specify values for various certificate fields and extensions.
The match( ) method will only return true for certificates that have the specified values for those fields and extensions.
A full understanding of this class requires detailed knowledge of the X.509 standard which is beyond the scope of this reference.
Some of the more important methods are described here, however.
When you want to match exactly one specific certificate, simply pass the desired X509Certificate to setCertificate( )
Constrain the subject of the certificate with setSubject( ), setSubjectAlternativeNames( ), of addSubjectAlternativeName( )
Constrain the public key of the certificate with setPublicKey( )
Constrain the certificate to be valid on a given date with setCertificateValid( )
And specify a specific issuer’s serial number for the certificate with setSerialNumber( )
The various methods of this class provide access to the full details of the CRL, and require a complete understanding of the X.509 standard, which is beyond the scope of this reference.
Use verify( ) to check the digital signature of the CRL to ensure that it does indeed originate from the the source it specifies.
Use the inherited isRevoked( ) method to determine whether a given certificate has been revoked.
If you are curious about the revocation date for a revoked certificate, obtain the X509CRLEntry for that certificate by calling getRevokedCertificate( )
Call getThisUpdate( ) to obtain the date this CRL was issued.
Use getNextUpdate( ) to find if the CRL has been superseded by a newer version.
Use getRevokedCertificates( ) to obtain a Set of all X509CRLEntry objects from this CRL.
Finally, cast the CRL returned by this method to an X509CRL.
It contains the serial number and revocation date for a revoked certificate.
The various set methods allow you to specify criteria that the match( ) method will use to accept or reject CRL objects.
Use addIssuerName( ) to specify the distinguished name of an acceptable issuer for the CRL, or use setIssuerNames( ) or setIssuers( ) to specify a Collection of valid issuers.
Use setDateAndTime( ) to specify a Date for which the CRL must be valid.
Use setMinCRLNumber( ) and setMaxCRLNumber( ) to set bounds on the sequence number of the CRL.
If you are selecting a CRL in order to check for revocation of a particular X509Certificate, pass that certificate to setCertificateChecking( )
This method does not actually constrain the returned CRL objects, but it may help a CertStore optimize its search for a relevant CRL.
This interface defines methods for handling a set of extensions to X.509 certificates and CRLs.
Each extension has a name, or OID (object identifier), that identifies the type of the extension.
Noncritical extensions whose OIDs are not recognized can safely be ignored.
However, if a critical exception is not recognized, the Certificate or CRL should be rejected.
Each extension in the set has a byte array of data as its value.
The interpretation of these bytes depends on the OID of the extension, of course.
Specific extensions are defined by the X.509 and related standards and their details are beyond the scope of this reference.
As its name implies, the java.security.interfaces package contains only interfaces.
These interfaces define methods that provide algorithm-specific information (such as key values and initialization parameter values) about DSA, RSA, and EC public and private keys.
If you are using the RSA algorithm, for example, and working with a java.security.PublicKey object, you can cast that PublicKey to an RSAPublicKey object and use the RSA-specific methods defined by RSAPublicKey to query the key value directly.
As of Java 1.2, the java.security.spec package is the preferred way for obtaining algorithm-specific information about keys and algorithm parameters.
This package remains useful in Java 1.2 and later, however, for identifying the type of a given PublicKey or PrivateKey object.
The interfaces in this package are typically of interest only to programmers who are implementing a security provider or who want to implement cryptographic algorithms themselves.
Use of this package typically requires some familiarity with the mathematics underlying DSA and RSA public-key cryptography.
This interface defines a method that must be implemented by both public and private DSA keys.
This interface defines algorithm-specific KeyPairGenerator initialization methods for DSA keys.
To generate a pair of DSA keys, use the static getInstance( ) factory method of java.security.KeyPairGenerator and specify “DSA” as the desired algorithm name.
If you wish to perform DSA-specific initialization, cast the returned KeyPairGenerator to a DSAKeyPairGenerator and call one of the initialize( ) methods defined by this interface.
Finally, generate the keys by calling generateKeyPair( ) on the KeyPairGenerator.
This interface defines methods for obtaining the DSA parameters g, p, and q.
These methods are useful only if you wish to perform cryptographic computation yourself.
Using these methods requires a detailed understanding of the mathematics underlying DSA public-key cryptography.
This interface represents a DSA private key and provides direct access to the underlying key value.
If you are working with a private key you know is a DSA key, you can cast the PrivateKey to a DSAPrivateKey.
This interface represents a DSA public key and provides direct access to the underlying key value.
If you are working with a public key you know is a DSA key, you can cast the PublicKey to a DSAPublicKey.
This interface defines the API that must be implemented by all elliptic curve keys.
This interface defines an API that must be implemented by all elliptic curve private keys.
This interface defines an API that must be implemented by all elliptic curve public keys.
This is a superinterface for RSAPublicKey and RSAPrivateKey; it defines a method shared by both classes.
Prior to Java 1.3, the getModulus( ) method was defined independently by RSAPublicKey and RSAPrivateKey.
This interface extends RSAPrivateKey and provides a decomposition of the private key into the various numbers used to create it.
This interface is very similar to RSAPrivateCrtKey, except that it is used to represent RSA private keys that are based on more than two prime factors, and implements the addition getOtherPrimeInfo( ) method to return information about these additional prime numbers.
This interface extends RSAPrivateKey and provides a decomposition (based on the Chinese remainder theorem) of the private-key value into the various pieces that comprise it.
This interface is useful only if you plan to implement your own cryptographic algorithms.
To use this interface, you must have a detailed understanding of the mathematics underlying RSA public-key cryptography.
Given a java.security.PrivateKey object, you can use the instanceof operator to determine whether you can safely cast it to an RSAPrivateCrtKey.
This interface represents an RSA private key and provides direct access to the underlying key values.
If you are working with a private key you know is an RSA key, you can cast the PrivateKey to an RSAPrivateKey.
This interface represents an RSA public key and provides direct access to the underlying key values.
If you are working with a public key you know is an RSA key, you can cast the PublicKey to an RSAPublicKey.
It also defines a transparent representation for DSA algorithm parameters.
The classes in this package are used in conjunction with java.security.KeyFactory and java.security.AlgorithmParameters for converting opaque Key and AlgorithmParameters objects to and from transparent representations.
To make use of it, you must be somewhat familiar with the mathematics that underlies DSA and RSA public-key encryption and the encoding standards that specify how keys are encoded as byte streams.
This interface defines no methods; it marks classes that define a transparent representation of cryptographic parameters.
You can use an AlgorithmParameterSpec object to initialize an opaque java.security.AlgorithmParameters object.
Returned By java.security.AlgorithmParameters.getParameterSpec( ), java.security.AlgorithmParametersSpi.engineGetParameterSpec( ), PSSParameterSpec.getMGFParameters( ), javax.crypto.Cipher.getMaxAllowedParameterSpec( ), javax.crypto.spec.OAEPParameterSpec.getMGFParameters( )
This class represents algorithm parameters used with DSA public-key cryptography.
This class is a transparent representation of a DSA private key.
This class is a transparent representation of a DSA public key.
This class specifies parameters for generating elliptic curve domain parameters.
This class defines an immutable representation for a set of parameters for elliptic curve cryptography.
This class defines an immutable representation of a point on an elliptic curve, using affine coordinates.
This class is an immutable representation of a private key for elliptic curve cryptography.
This class is an immutable representation of a public key for elliptic curve cryptography.
This class is an immutable representation of an elliptic curve.
This abstract class represents a public or private key in an encoded format.
This interface defines no methods; it marks classes that define a transparent representation of a cryptographic key.
Use a java.security.KeyFactory to convert a KeySpec to and from an opaque java.security.Key.
Returned By java.security.KeyFactory.getKeySpec( ), java.security.KeyFactorySpi.engineGetKeySpec( ), javax.crypto.SecretKeyFactory.getKeySpec( ), javax.crypto.SecretKeyFactorySpi.engineGetKeySpec( )
The constants represent predefined instances of the class, whose digest algorithm matches the constant name.
This class represents a private key, encoded according to the PKCS#8 standard.
This class represents parameters that generate public/private key pairs for RSA cryptography.
This class is a transparent representation of a multi-prime RSA private key.
It is very similar to RSAPrivateCrtKeySpec, but adds an additional method for obtaining information about the other primes associated with the key.
This class is a transparent representation of an RSA private key including, for convenience, the Chinese remainder theorem values associated with the key.
This class is a transparent representation of an RSA private key.
This class is a transparent representation of an RSA public key.
This class represents a public or private key encoded according to the X.509 standard.
The java.text package consists of classes and interfaces that are useful for writing internationalized programs that handle local customs, such as date and time formatting and string alphabetization, correctly.
The NumberFormat class formats numbers, monetary quantities, and percentages as appropriate for the default or specified locale.
The concrete DecimalFormat and SimpleDateFormat subclasses of these classes can be used for customized number, date, and time formatting.
MessageFormat allows substitution of dynamic values, including formatted numbers and dates, into static message strings.
ChoiceFormat formats a number using an enumerated set of string values.
See the Format superclass for a general description of formatting and parsing strings with these classes.
Collator compares strings according to the customary sorting order for a locale.
BreakIterator scans text to find word, line, and sentence boundaries following locale-specific rules.
This class is a wrapper for a the value of a text attribute that represents an annotation.
Annotations differ from other types of text attributes in two ways.
First, annotations are linked to the text they are applied to, so changing the text invalidates or corrupts the meaning of the annotation.
Second, annotations cannot be merged with adjacent annotations, even if they have the same value.
Putting an annotation value in an Annotation wrapper serves to indicate these special characteristics.
Note that two of the attribute keys defined by AttributedCharaterIterator.Attribute, READING and INPUT_METHOD_SEGMENT, must be used with Annotation objects.
This interface extends CharacterIterator for working with text that is marked up with attributes in some way.
It defines an inner class, AttributedCharaterIterator.Attribute, that represents attribute keys.
AttributedCharacterIterator defines methods for querying the attribute keys, values, and runs for the text being iterated over.
A run is a string of adjacent characters for which an attribute has the same value or is undefined (i.e., has a value of null)
A run can also be defined for a set of attributes, in which case it is a set of adjacent characters for which all attributes in the set hold a constant value (which may include null)
Programs that process or display attributed text must usually work with it one run at a time.
The no-argument versions of getRunStart( ) and getRunLimit( ) return the start and end of the run that includes the current character and all attributes that are applied to the current character.
The other versions of these methods return the start and end of the run of the specified attribute or set of attributes that includes the current character.
The AttributedString class provides a simple way to define short strings of attributed text and obtain an AttributedCharacterIterator over them.
Most applications that process attributed text are working with attributed text from specialized data sources, stored in some specialized data format, so they need to define a custom implementation of AttributedCharacterIterator.
This class defines the types of the attribute keys used with AttributedCharacterIterator and AttributedString.
It defines several constant Attribute keys that are commonly used with multilingual text and input methods.
The LANGUAGE key represents the language of the underlying text.
The value of this key should be a Locale object.
The READING key represents arbitrary reading information associated with text.
The INPUT_METHOD_SEGMENT key serves to define text segments (usually words) that an input method operates on.
The value of this attribute should be an Annotation object that contains null.
Other classes may subclass this class and define other attribute keys that are useful in other circumstances or problem domains.
An AttributedString can be defined in terms of an underlying AttributedCharacterIterator or an underlying String.
Additional attributes can be specified with the addAttribute( ) and addAttributes( ) methods.
Note that two of the getIterator( ) methods take an array of Attribute keys as an argument.
These methods return an AttributedCharacterIterator that ignores all attributes that are not in the specified array.
If the array argument is null, however, the returned iterator contains all attributes.
It is named after the first four letters of “bidirectional.” A full description of the bidirectional text handling and the bidirectional algorithim is beyond the scope of this book, but the simplest use case for this class is outlined here.
Create a Bidi object by passing an AttributedCharacterIterator or a String and one of the DIRECTION constants (to indicate the base direction of the text) to the Bidi( ) constructor.
Or use createLineBidi( ) to return a substring of an existing Bidi object (this is usually done when formatting a paragraph of text to fit on individual lines)
Once you have a Bidi object, use isLeftToRight( ) and isRightToLeft( ) to determine whether all the text has the same direction.
If both of these methods return false (which is the same as isMixed( ) returning true) then you cannot treat the text as a single run of uni-directional text.
In this case, you must break it into two or more runs of unidirectional text.
For each such numbered run, getRunStart( ) returns the index of the first character of the run, and getRunLimit( ) returns the index of the first character past the end of the run.
Even levels represent left-to-right text, and odd levels represent right-to-left text.
The level divided by two is the nesting level of the text.
For example, left-to-right text embedded within right-to-left text has a level of 2
This class determines character, word, sentence, and line breaks in a block of text in a way that is independent of locale and text encoding.
Instead, you must use one of the class methods getCharacterInstance( ), getWordInstance( ), getSentenceInstance( ), or getLineInstance( ) to return an instance of a nonabstract subclass of BreakIterator.
These various factory methods return a BreakIterator object that is configured to locate the requested boundary types and is localized to work for the optionally specified locale.
Once you have obtained an appropriate BreakIterator object, use setText( ) to specify the text in which to locate boundaries.
To locate boundaries in a Java String object, simply specify the string.
To locate boundaries in text that uses some other encoding, you must specify a CharacterIterator object for that text so that the BreakIterator object can locate the individual characters of the text.
Having set the text to be searched, you can determine the character positions of characters, words, sentences, or line breaks with the first( ), last( ), next( ), previous( ), current( ), and following( ) methods, which perform the obvious functions.
Note that these methods do not return text itself, but merely the position of the appropriate word, sentence, or line break.
This interface defines an API for portably iterating through the characters that make up a string of text, regardless of the encoding of that text.
Such an API is necessary because the number of bytes per character is different for different encodings, and some encodings even use variable-width characters within the same string of text.
In addition to allowing iteration, a class that implements the CharacterIterator interface for non-Unicode text also performs translation of characters from their native encoding to standard Java Unicode characters.
CharacterIterator is similar to java.util.Enumeration, but is somewhat more complex than that interface.
The first( ) and last( ) methods return the first and last characters in the text, and the next( ) and prev( ) methods allow you to loop forward or backwards through the characters of the text.
These methods return the DONE constant when they go beyond the first or last character in the text; a test for this constant can be used to terminate a loop.
The CharacterIterator interface also allows random access to the characters in a string of text.
The getBeginIndex( ) and getEndIndex( ) methods return the character positions for the start and end of the string, and setIndex( ) sets the current position.
This class is a subclass of Format that converts a number to a String in a way reminiscent of a switch statement or an enumerated type.
When the format( ) method is called to format a number x, the ChoiceFormat finds an index i such that:
If x is less than the first element of the array, the first element is used, and if it is greater than the last, the last element is used.
Once the index i has been determined, it is used as the index into the array of strings, and the indexed string is returned as the result of the format( ) method.
A ChoiceFormat object may also be created by encoding its limits and formats into a single string known as its pattern.
A typical pattern looks like the one below, used to return the singular or plural form of a word based on the numeric value passed to the format( ) method:
You can use the applyPattern( ) method to change the pattern used by a ChoiceFormat object; use toPattern( ) to query the pattern it uses.
A CollationElementIterator object is returned by the getCollationElementIterator( ) method of the RuleBasedCollator object.
The purpose of this class is to allow a program to iterate (with the next( ) method) through the characters of a string, returning ordering values for.
Note that collation keys are not exactly the same as characters.
This numeric value can be directly compared to the value returned by next( ) for other CollationElementIterator objects.
The value returned by next( ) can also be decomposed into primary, secondary, and tertiary ordering values with the static methods of this class.
This class is used by RuleBasedCollator to implement its compare( ) method and to create CollationKey objects.
CollationKey objects compare strings more quickly than is possible with Collation.compare( )
To compare two CollationKey objects, invoke the compareTo( ) method of key A, passing the key B as an argument (both CollationKey objects must be created through the same Collation object)
The return value of this method is less than zero if the key A is collated before the key B, equal to zero if they are equivalent for the purposes of collation, or greater than zero if the key A is collated after the key B.
Use getSourceString( ) to obtain the string represented by a CollationKey.
This class compares, orders, and sorts strings in a way appropriate for the default locale or some other specified locale.
Because it is an abstract class, it cannot be instantiated directly.
Instead, you must use the static getInstance( ) method to obtain an instance of a Collator subclass that is appropriate for the default or specified locale.
You can use getAvailableLocales( ) to determine whether a Collator object is available for a desired locale.
Once an appropriate Collator object has been obtained, you can use the compare( ) method to compare strings.
The equals( ) method is a convenient shortcut for testing two strings for collation equivalence.
When sorting an array of strings, each string in the array is typically compared more than once.
Using the compare( ) method in this case is inefficient.
A more efficient method for comparing strings multiple times is to use getCollationKey( ) for each string to create CollationKey objects.
These objects can then be compared to each other more quickly than the strings themselves can be compared.
You can customize the way the Collator object performs comparisons by calling setStrength( )
If you pass the constant PRIMARY to this method, the comparison looks only at primary differences in the strings; it compares letters but ignores accents and case differences.
If you pass the constant SECONDARY, it ignores case differences but does not ignore accents.
And if you pass TERTIARY (the default), the Collator object takes both accents and case differences into account in its comparison.
This class formats and parses dates and times in a locale-specific way.
As an abstract class, it cannot be instantiated directly, but it provides a number of static methods that return instances of a concrete subclass you can use to format dates in a variety of ways.
The getDateInstance( ) methods return a DateFormat object suitable for formatting dates in either the default locale or a specified locale.
A formatting style may also optionally be specified; the constants FULL, LONG, MEDIUM, SHORT, and DEFAULT specify this style.
Similarly, the getTimeInstance( ) methods return a DateFormat object that formats and parses times, and the getDateTimeInstance( ) methods return a DateFormat object that formats both dates and times.
These methods also optionally take a format style constant and a Locale.
Finally, getInstance( ) returns a default DateFormat object that formats both dates and times in the SHORT format.
Once you have created a DateFormat object, you can use the setCalendar( ) and setTimeZone( ) methods if you want to format the date using a calendar or time zone other than the default.
The various format( ) methods convert java.util.Date objects to strings using whatever format is encapsulated in the DateFormat object.
The parse( ) and parseObject( ) methods perform the reverse operation; they parse a string formatted according to the rules of the DateFormat object and convert it into to a Date object.
The DEFAULT, FULL, MEDIUM, LONG, and SHORT constants specify how verbose or compact the formatted date or time should be.
The remaining constants, which all end with _FIELD, specify various fields of formatted dates and times and are used with the FieldPosition object that is optionally passed to format( )
This class defines a typesafe enumeration of AttributedCharacterIterator.Attribute objects that may be used by the AttributedCharacterIterator returned by the formatToCharacterIterator( ) inherited from Format, or that may be used when creating a FieldPosition object with which to obtain the bounds of a specific date field in formatted output.
Note that the constants defined by this class correspond closely to the integer constants defined by java.util.Calendar, and that this class defines methods for converting between the two sets of constants.
This class defines accessor methods for the various pieces of data, such as names of months and days, used by SimpleDateFormat to format and parse dates and times.
You do not typically need to use this class unless you are formatting dates for an unsupported locale or in some highly customized way.
This is the concrete Format class used by NumberFormat for all locales that use base 10 numbers.
Most applications do not need to use this class directly; they can use the static methods of NumberFormat to obtain a default NumberFormat object for a desired locale and then perform minor locale-independent customizations on that object.
Applications that require highly customized number formatting and parsing may create custom DecimalFormat objects by passing a suitable pattern to the DecimalFormat( ) constructor method.
A pattern consists of a string of characters from the table below.
A DecimalFormatSymbols object can be specified optionally when creating a DecimalFormat object.
If one is not specified, a DecimalFormatSymbols object suitable for the default locale is used.
In Java 5.0, DecimalFormat can return java.math.BigDecimal values from its parse( ) method.
This is useful when working with very large numbers, very precise numbers, or financial applications that use BigDecimal to avoid rounding errors.
Separates positive number format (on left) from optiona negative number format (on right)
Quotes a reserved character, so it appears literally in the output (apostrophe)
This class defines the various characters and strings, such as the decimal point, percent sign, and thousands separator, used by DecimalFormat when formatting numbers.
You do not typically use this class directly unless you are formatting dates for an unsupported locale or in some highly customized way.
FieldPosition objects are optionally passed to the format( ) methods of the Format class and its subclasses to return information about the start and end positions of a specific part or “field” of the formatted string.
This kind of information is often useful for aligning formatted strings in columns—for example, aligning the decimal points in a column of numbers.
The field of interest is specified when the FieldPosition( ) constructor is called.
The NumberFormat and DateFormat classes define integer various constants (which end with the string _FIELD) that can be used here.
In Java 1.4 and later you can also construct a FieldPosition by specifying the Format.Field object that identifies the field.
After a FieldPosition has been created and passed to a format( ) method, use getBeginIndex( ) and getEndIndex( ) methods of this class to obtain the starting and ending character positions of the desired field of the formatted string.
This abstract class is the base class for all number, date, and string formatting classes in the java.text package.
It defines the key formatting and parsing methods that are implemented by all subclasses.
Status information for these two operations is returned in FieldPosition and ParsePosition objects.
Java 1.4 defined a variant on the format( ) method.
The attribute keys are all instances of the Format.Field inner class.
Each of the Format subclasses define a Field subclass that defines a set of Field constants, (such as NumberFormat.Field.DECIMAL_SEPARATOR) for use by the character iterator returned by this method.
See ChoiceFormat, DateFormat, MessageFormat, and NumberFormat for subclasses that perform specific types of formatting.
This inner class extends AttributedCharacterIterator.Attribute and serves as the common superclass for DateFormat.Field, MessageFormat.Field, and NumberFormat.Field.
This class formats and substitutes objects into specified positions in a message string (also known as the pattern string)
It provides the closest Java equivalent to the printf( ) function of the C programming language.
If a message is to be displayed only a single time, the simplest way to use the MessageFormat class is through the static format( ) method.
This method is passed a message or pattern string and an array of argument objects to be formatted and substituted into the string.
If the message is to be displayed several times, it makes more sense to create a MessageFormat object, supplying the pattern string, and then call the format( ) instance method of this object, supplying the array of objects to be formatted into the message.
The message or pattern string used by the MessageFormat contains digits enclosed in curly braces to indicate where each argument should be substituted.
If the object to be inserted is not a string, MessageFormat checks to see if it is a Date or a subclass of Number.
If so, it uses a default DateFormat or NumberFormat object to convert the value to a string.
If not, it simply invokes the object’s toString( ) method to convert it.
Any of these keywords can additionally be followed by a comma and additional pattern information to be used in formatting the date, time, number, or choice.
You can pass a Locale to the constructor or call setLocale( ) to specify a nondefault locale that the MessageFormat should use when obtaining DateFormat and NumberFormat objects to format dates, time, and numbers inserted into the pattern.
You can change the Format object used at a particular position in the pattern with the setFormat( ) method, or change all Format objects with setFormats( )
Both of these methods depend on the order of in which arguments are displayed in the pattern string.
The pattern string is often subject to localization and the arguments may appear in different orders in different localizations of the pattern.
You can set a new pattern for the MessageFormat object by calling applyPattern( ), and you can obtain a string that represents the current formatting pattern by calling toPattern( )
MessageFormat also supports a parse( ) method that can parse an array of objects out of a specified string, according to the specified pattern.
This class defines an ARGUMENT AttributedCharacterIterator.Attribute constant that is be used by the AttributedCharacterIterator returned by MessageFormat.formatToCharacterIterator( ) to identify portions of the formatted message that are derived from the arguments passed to formatToCharacterIterator( )
The value associated with this ARGUMENT attribute will be an Integer specifying the argument number.
This class formats and parses numbers in a locale-specific way.
As an abstract class, it cannot be instantiated directly, but it provides a number of static methods that return instances of a concrete subclass you can use for formatting.
The getInstance( ) method returns a NumberFormat object suitable for normal formatting of numbers in either the default locale or in a specified locale.
These methods return a NumberFormat suitable for the default locale, or for the specified Locale object.
In Java 1.4 and later, use setCurrency( ) to provide a java.util.Currency object for use when formating monetary values.
Note that the NumberFormat class is not intended for the display of very large or very small numbers that require exponential notation, and it may not gracefully handle infinite or NaN (not-a-number) values.
Once you have created a suitable NumberFormat object, you can customize its localeindependent behavior with setMaximumFractionDigits( ), setGroupingUsed( ), and similar set methods.
In order to customize the locale-dependent behavior, you can use instanceof to test if the NumberFormat object is an instance of DecimalFormat, and, if so, cast it to that type.
Note, however, that a NumberFormat customized in this way may no longer be appropriate for the desired locale.
After creating and customizing a NumberFormat object, you can use the various format( ) methods to convert numbers to strings or string buffers, and you can use the parse( ) or parseObject( ) methods to convert strings to numbers.
You can also use the formatToCharacterIterator( ) method inherited from Format (and overridden by DecimalFormat) in place of format( )
The constants defined by this class are to be used by the FieldPosition object.
This class defines a typesafe enumeration of AttributedCharacterIterator.Attribute objects that may be used by the AttributedCharacterIterator returned by formatToCharacterIterator( ) method inherited from the Format class, or that may be used when creating a FieldPosition object to pass to format( ) in order to obtain the bounds of a specific number field (such as the decimal point for aligning numbers) in formatted output.
Signals that a string has an incorrect format and cannot be parsed.
It is typically thrown by the parse( ) or parseObject( ) methods of Format and its subclasses, but is also thrown by certain methods in the java.text package that are passed patterns or other rules in string form.
The getErrorOffset( ) method of this class returns the character position at which the parsing error occurred in the offending string.
ParsePosition objects are passed to the parse( ) and parseObject( ) methods of Format and its subclasses.
The ParsePosition class represents the position in a string at which parsing should begin or at which parsing stopped.
Before calling a parse( ) method, you can specify the starting position of parsing by passing the desired index to the ParsePosition( ) constructor or by calling the setIndex( ) of an existing ParsePosition object.
When parse( ) returns, you can determine where parsing ended by calling getIndex( )
When parsing multiple objects or values from a string, a single ParsePosition object can be used sequentially.
This class is a concrete subclass of the abstract Collator class.
It performs collations using a table of rules that are specified in textual form.
Most applications do not use this class directly; instead they call Collator.getInstance( ) to obtain a Collator object (typically a RuleBasedCollator object) that implements the default collation order for a specified or default locale.
You should need to use this class only if you are collating strings for a locale that is not supported by default or if you need to implement a highly customized collation order.
This is the concrete Format subclass used by DateFormat to handle the formatting and parsing of dates.
Most applications should not use this class directly; instead, they should obtain a localized DateFormat object by calling one of the static methods of DateFormat.
SimpleDateFormat formats dates and times according to a pattern, which specifies the positions of the various fields of the date, and a DateFormatSymbols object, which specifies.
This creates a SimpleDateFormat object that uses the DateFormatSymbols object for the default locale.
You may also specify an locale explicitly, to use the DateFormatSymbols object for that locale.
You can even provide an explicit DateFormatSymbols object of your own if you need to format dates and times for an unsupported locale.
You can use the applyPattern( ) method of a SimpleDateFormat to change the formatting pattern used by the object.
The syntax of this pattern is described in the following table.
Any characters in the format string that do not appear in this table appear literally in the formatted date.
This class is a trivial implementation of the CharacterIterator interface that works for text stored in Java String objects.
This chapter documents the java.util package, and each of its subpackages.
In Java 5.0 the collection classes and interfaces have been converted into generic types.
They are based on the classes of the java.util.zip package.
The java.util package defines a number of useful classes, primarily collections classes that are useful for working with groups of objects.
This package should not be considered merely a utility package that is separate from the rest of the language; it is an integral and frequently used part of the Java platform.
The most important classes in java.util are the collections classes.
Prior to Java 1.2, these were Vector, a growable list of objects, and Hashtable, a mapping between arbitrary key and value objects.
Java 1.2 adds an entire collections framework consisting of the Collection, Map, Set, List, SortedMap, and SortedSet interfaces and the classes that implement them.
Other important classes and interfaces of the collections framework are Comparator, Collections, Arrays, Iterator, and ListIterator.
Java 1.4 extends the Collections framework with the addition of new Map and Set implementations, and a new RandomAccess marker interface used by List implementations.
It also adds EnumSet and EnumMap which efficiently implement the Set and Map interfaces for use with enumerated types.
BitSet is a related class that is not actually part of the Collections framework (and is not even a set)
It provides a very compact representation of an arbitrary-size array or list of boolean values or bits.
The other classes of the package are also quite useful.
Locale represents the language and related text formatting conventions of a country, region, or culture.
ResourceBundle and its subclasses represent a bundle of localized resources that are read in by an internationalized program at runtime.
Random generates and returns pseudorandom numbers in a variety of forms.
StringTokenizer is a simple parser that breaks a string into tokens.
In Java 1.3 and later, Timer and TimerTask provide a powerful API for scheduling code to be run by a background thread, once or repetitively, at a specified time in the future.
In Java 5.0, the Formatter class enables poweful formatted text output in the style of the C programming language’s printf( ) function.
The Java 5.0 Scanner class is a text tokenizer or scanner that can also parse numbers and match tokens based on regular expressions.
This abstract class is a partial implementation of Collection that makes it easy to define custom Collection implementations.
To create an unmodifiable collection, simply override size( ) and iterator( )
The Iterator object returned by iterator( ) has to support only the hasNext( ) and next( ) methods.
To define a modifiable collection, you must additionally override the add( ) method of AbstractCollection and make sure the Iterator returned by iterator( ) supports the remove( ) method.
Some subclasses may choose to override other methods to tune performance.
In addition, it is conventional that all subclasses provide two constructors: one that takes no arguments and one that accepts a Collection argument that specifies the initial contents of the collection.
Note that if you subclass AbstractCollection directly, you are implementing a bag—an unordered collection that allows duplicate elements.
If your add( ) method rejects duplicate elements, you should subclass AbstractSet instead.
This abstract class is a partial implementation of the List interface that makes it easy to define custom List implementations based on random-access list elements (such as objects stored in an array)
If you want to base a List implementation on a sequentialaccess data model (such as a linked list), subclass AbstractSequentialList instead.
To create an unmodifiable List, simply subclass AbstractList and override the (inherited) size( ) and get( ) methods.
To create a modifiable list, you must also override set( ) and, optionally, add( ) and remove( )
These three methods are optional, so unless you override them, they simply throw an UnsupportedOperationException.
All other methods of the List interface are implemented in terms of size( ), get( ), set( ), add( ), and remove( )
In some cases, you may want to override these other methods to improve performance.
By convention, all List implementations should define two constructors: one that accepts no arguments and another that accepts a Collection of initial elements for the list.
This abstract class is a partial implementation of the Map interface that makes it easy to define simple custom Map implementations.
To define an unmodifiable map, subclass AbstractMap and override the entrySet( ) method so that it returns a set of Map.Entry objects.
Note that you must also implement Map.Entry, of course.) The returned set should not support add( ) or remove( ), and its iterator should not support remove( )
In order to define a modifiable Map, you must additionally override the put( ) method and provide support for the remove( ) method of the iterator returned by entrySet( ).iterator( )
In addition, it is conventional that all Map implementations define two constructors: one that accepts no arguments and another that accepts a Map of initial mappings.
AbstractMap defines all Map methods in terms of its entrySet( ) and put( ) methods and the remove( ) method of the entry set iterator.
Note, however, that the implementation is based on a linear search of the Set returned by entrySet( ) and is not efficient when the Map contains more than a handful of entries.
Some subclasses may want to override additional AbstractMap methods to improve performance.
HashMap and TreeMap use different algorithms are are substantially more efficient.
This abstract class provides a framework for simple Queue implementations.
A concrete subclass must implement offer( ), peek( ), and poll( ) and must also implement the inherited size( ) and iterator( ) methods of the Collection interface.
The Iterator returned by iterator( ) must support the remove( ) operation.
This abstract class is a partial implementation of the List interface that makes it easy to define List implementations based on a sequential-access data model, as is the case with the LinkedList subclass.
To implement a List based on an array or other random-access model, subclass AbstractList instead.
To implement an unmodifiable list, subclass this class and override the size( ) and listIterator( ) methods.
If you want to allow the list to be modified, the ListIterator should also support the set( ) method and, optionally, the add( ) and remove( ) methods.
AbstractSequentialList implements all other List methods in terms of these methods.
Some subclasses may want to override additional methods to improve performance.
In addition, it is conventional that all List implementations define two constructors: one that accepts no arguments and another that accepts a Collection of initial elements for the list.
This abstract class is a partial implementation of the Set interface that makes it easy to create custom Set implementations.
Since Set defines the same methods as Collection, you can subclass AbstractSet exactly as you would subclass AbstractCollection.
Note, however, that when subclassing AbstractSet, you should be sure that your add( ) method and your constructors do not allow duplicate elements to be added to the set.
This class is a List implementation based on an array (that is recreated as necessary as the list grows or shrinks)
ArrayList implements all optional List and Collection methods and allows list elements of any type (including null)
Because ArrayList is based on an array, the get( ) and set( ) methods are very efficient.
This is not the case for the LinkedList implementation, for example.) ArrayList is a general-purpose implementation of List and is quite commonly used.
ArrayList is very much like the Vector class, except that its methods are not synchronized.
If you are using an ArrayList in a multithreaded environment, you should explicitly synchronize any modifications to the list, or wrap the list with Collections.synchronizedList( )
See List and Collection for details on the methods of ArrayList.
An ArrayList has a capacity, which is the number of elements in the internal array that contains the elements of the list.
When the number of elements exceeds the capacity, a new array, with a larger capacity, must be created.
In addition to the List and Collection methods, ArrayList defines a couple of methods that help you manage this capacity.
If you know in advance how many elements an ArrayList will contain, you can call ensureCapacity( ), which can increase efficiency by avoiding incremental reallocation of the internal array.
You can also pass an initial capacity value to the ArrayList( ) constructor.
Finally, if an ArrayList has reached its final size and will not change in the future, you can call trimToSize( ) to reallocate the internal array with a capacity that matches the list size exactly.
When the ArrayList will have a long lifetime, this can be a useful technique to reduce memory usage.
This class defines static methods for sorting, searching, and performing other useful operations on arrays.
It also defines the asList( ) method, which returns a List wrapper around a specified array of objects.
Any changes made to the List are also made to the underlying array.
This is a powerful method that allows any array of objects to be manipulated in any of the ways a List can be manipulated.
It provides a link between arrays and the Java collections framework.
The various sort( ) methods sort an array (or a specified portion of an array) in place.
Variants of the method are defined for arrays of each primitive type and for arrays of Object.
For arrays of primitive types, the sorting is done according to the natural ordering of the type.
For arrays of objects, the sorting is done according to the specified Comparator, or, if the array contains only java.lang.Comparable objects, according to the ordering defined by that interface.
When sorting an array of objects, a stable sorting algorithm is used so that the relative ordering of equal objects is not disturbed.
This allows repeated sorts to order objects by key and subkey, for example.)
The binarySearch( ) methods perform an efficient search (in logarithmic time) of a sorted array for a specified value.
If a match is found in the array, binarySearch( ) returns the index of the match.
If no match is found, the method returns a negative number.
For a negative return value r, the index –(r+1) specifies the array index at which the specified value can be inserted to maintain the sorted order of the array.
When the array to be searched is an array of objects, the elements of the array must all implement java.lang.Comparable, or you must provide a Comparator object to compare them.
The equals( ) methods test whether two arrays are equal.
Two arrays of primitive type are equal if they contain the same number of elements and if corresponding pairs of they contain the same number of elements and if corresponding pairs of elements are equal according to the equals( ) method defined by those objects.
The fill( ) methods fill an array or a specified range of an array with the specified value.
Java 5.0 adds hashCode( ) methods that compute a hashcode for the contents of the array.
These methods are compatible with the equals( ) methods: equal( ) arrays will always have the same hashCode( )
Java 5.0 also adds deepEquals( ) and deepHashCode( ) methods that handle multi-dimensional arrays.
Finally, the Java 5.0 toString( ) and deepToString( ) methods convert arrays to strings.
The returned strings are a comma-separated list of elements enclosed in square brackets.
This class implements an array or list of boolean values storing them using a very compact representation that requires only about one bit per value stored.
It implements methods for setting, querying, and flipping the values stored at any given position within the list, for counting the number of true values stored in the list, and for finding the next true or false value in the list.
It also defines a number of methods that perform bitwise boolean operations on two BitSet objects.
Despite its name, BitSet does not implement the Set interface, and does not even have the behavior associated with a set; it is a list or vector for boolean values, but is not related to the List interface or Vector class.
You may optionally specify a size (the number of bits) for the BitSet, but this merely provides an optimization since a BitSet will grow as needed to accomodate any number of boolean values.
BitSet does not define a precise notion of the size of a “set.” The size( ) method returns the number of boolean values that can be stored before more internal storage needs to be allocated.
The length( ) method returns one more than the highest index of a set bit (i.e., a true value)
This means that a BitSet that contains all false values will have a length( ) of zero.
If your code needs to remember the index of the highest value stored in a BitSet, regardless of whether that value was true or false, then you should maintain that length information separately from the BitSet.
Set values in a BitSet with the set( ) method.
Two set the value at a specific index, and two set values for a range of indexes.
Two of the set( ) methods do not take a value argument to set: they “set” the specified bit or range of bites, which means they store the value true.
The other two methods take a boolean argument, allowing you to set the specified value or range of values to true (a set bit) or.
There are also two clear( ) methods that “clear” (or set to false) the value at the specified index or range of indexes.
The flip( ) methods flip, or toggle (change true to false and false to true), the value or values at the specified index or range.
The set( ), clear( ), and flip( ) methods, as well as all other BitSet methods that operate on a range of values specify the range with two index values.
They define the range as the values starting from, and including, the value stored at the first specified index up to, but not including, the value stored at the second specified index.
A number of methods of String and related classes follow the same convention for specifying a range of characters.)
To test the value stored at a specified location, use get( ), which returns true if the specified bit is set, or false if it is not set.
There is also a get( ) method that specifies a range of bits, and returns their state in the form of a BitSet: this get( ) method is analogous to the substring( ) method of a String.
Because a BitSet does not define a maximum index, it is legal to pass any non-negative value to get( )
If the index you specify is greater than or equal to the value returned by length( ), then the returned value will always be false.
You can use this method in a loop to iterate through the indexes of true values.
The intersects( ) method returns true if the target BitSet and the argument BitSet intersect: that is if there is at least one index at which both BitSet objects have a true value.
These methods combine the BitSet on which they are invoked (called the “target” BitSet below) with the BitSet passed as an argument, and store the result in the target BitSet.
If you want to perform a Boolean operation without altering the original BitSet, you should first make a copy of the original with the clone( ) method and invoke the method on the copy.
The and( ) method preforms a bitwise Boolean AND operation, much like the & does when applied to integer arguments.
A value in the target BitSet will be true only if it was originally true and the value at the same index of argument BitSet is also true.
For all false values in the argument BitSet, and( ) sets the corresponding value in the target BitSet to false, leaving other values unchanged.
The andNot( ) method combines a Boolean AND operation with a Boolean NOT operation on the argument BitSet (it does not alter the contents of that argument BitSet, hoever)
The result is that for all true values in the argument BitSet, the corresponding values in the target BitSet are set to false.
The or( ) method performs a bitwise Boolean OR operation like the | operator: a value in the BitSet will be set to true if its original value was true or the corresponding value in the argument BitSet was true.
For all true values in the argument BitSet, the or( ) method sets the corresponding value in the target BitSet to true, leaving the other values unchanged.
If both values were false, or if both values were true, however, it sets the value to false.
Finally, the toString( ) method returns a String representation of a BitSet that consists of a list within curly braces of the indexes at which true values are stored.
This abstract class defines methods that perform date and time arithmetic.
It also includes methods that convert dates and times to and from the machine-usable millisecond format used by the Date class and units such as minutes, hours, days, weeks, months, and years that are more useful to humans.
Instead, it provides static getInstance( ) methods that return instances of a Calendar subclass suitable for use in a specified or default locale with a specified or default time zone.
Some of these are values that represent days of the week and months of the year.
Other constants, such as HOUR and DAY_OF_WEEK, represent various fields of date and time information.
These field constants are passed to a number of Calendar methods, such as get( ) and set( ), in order to indicate what particular date or time field is desired.
The add( ) method adds (or subtracts) values to a calendar field, incrementing the next larger field when the field being set rolls over.
Many of the methods of the Calendar class are replacements for methods of Date that have been deprecated as of Java 1.1
While the Calendar class converts a time value to its various hour, day, month, and other fields, it is not intended to present those fields in a form suitable for display to the end user.
That function is performed by the java.text.DateFormat class, which handles internationalization issues.
Calendar implements Comparable in Java 5.0, but not in earlier releases.
In Java 5.0 this is a generic interface and the type variable E represents the type of the objects in the collection.
The objects may or may not be ordered, and the collection may or may not contain duplicate objects.
Instead, most collection classes implement one of the more specific subinterfaces: Set, an unordered collection that does not allow duplicates, or List, an ordered collection that does allow duplicates.
The Collection type provides a general way to refer to any set, list, or other collection of objects; it defines generic methods that work with any collection.
Another version of toArray( ) takes an array as an argument and stores all elements of the Collection (which must all be compatible with the array) into that array.
If the array is not big enough, the method allocates a new, larger array of the same type.
If the array is too big, the method stores null into the first empty element of the array.
This version of toArray( ) returns the array that was passed in or the new array, if one was allocated.
The previous methods all query or extract the contents of a collection.
The Collection interface also defines methods for modifying the contents of the collection.
All these modification methods except clear( ) return true if the collection was modified as a result of the call.
An interface cannot specify constructors, but it is conventional that all implementations of Collection provide at least two standard constructors: one that takes no arguments and creates an empty collection, and a copy constructor that accepts a Collection object that specifies the initial contents of the new Collection.
Implementations of Collection and its subinterfaces are not required to support all operations defined by the Collection interface.
All modification methods listed above are optional; an implementation (such as an immutable Set implementation) that does not support them simply throws java.lang.UnsupportedOperationException for these methods.
Furthermore, implementations are free to impose restrictions on the types of objects that can be members of a collection.
Some implementations might require elements to be of a particular type, for example, and others might not allow null as an element.
This class defines static methods and constants that are useful for working with collections and maps.
One of the most commonly used methods is sort( ), which sorts a List in place (the list cannot be immutable, of course)
The sorting algorithm is stable, which means that equal elements retain the same relative order.
One version of sort( ) uses a specified Comparator to perform the sort; the other relies on the natural ordering of the list elements and requires all the elements to implement java.lang.Comparable.
It efficiently (in logarithmic time) searches a sorted List for a specified object and returns the index at which a matching object is found.
If no match is found, it returns a negative number.
For a negative return value r, the value –(r+1) specifies the index at which the specified object can be inserted into the list to maintain the sorted order of the list.
As with sort( ), binarySearch( ) can be passed a Comparator that defines the order of the sorted list.
See Arrays for methods that perform sorting and searching operations on arrays instead of collections.
The various methods whose names begin with synchronized return a threadsafe collection object wrapped around the specified collection.
Vector and Hashtable are the only two collection objects threadsafe by default.
Use these methods to obtain a synchronized wrapper object if you are using any other type of Collection or Map in a multithreaded environment where more than one thread can modify it.
The various methods whose names begin with unmodifiable function like synchronized methods.
They return a Collection or Map object wrapped around the specified collection.
The returned object is unmodifiable, however, so its add( ), remove( ), set( ), put( ), etc.
In Java 5.0, the emptySet( ), emptyList( ), and emptyMap( ) methods are preferred alternatives to these constants, because they are generic methods and return correctly parameterized empty collections.
The Collections class also defines methods that mutate a collection.
These methods throw an UnsupportedOperationException if the target collection is does not allow mutation.
Specifying a negative rotation rotates the list in the other direction.) shuffle( ) randomizes the order of elements in a list, using either an internal source of randomness or the Random pseudorandom number generator you provide.
In Java 5.0, the addAll( ) method adds the specified elements to the specified collection.
This method is a varargs method and allows elements to be specified in an array or listed individually in the argument list.
Finally, Collections defines methods (in addition to the binarySearch( ) methods described above) that search the elements of a collection: min( ) and max( ) methods search an unordered Collection for the minimum and maximum elements, according either to a specified Comparator or to the natural order defined by the Comparable elements themselves.
They return the start index of any such matching sublist, or return -1 if no match was found.
These methods are like the indexOf( ) and lastIndexOf( ) methods of String, and do not require the List to be sorted, as the binarySearch( ) methods do.
This interface defines a compare( ) method that specifies a total ordering for a set of objects, allowing those objects to be sorted.
The Comparator is used when the objects to be ordered do not have a natural ordering defined by the Comparable interface, or when you want to order them using something other than their natural ordering.
Comparator has been made generic in Java 5.0 and the type variable T represents the type of objects being compared.
If the first argument is less than the second argument or should be placed before the second argument in a sorted list, compare( ) should return a negative integer.
If the first argument is greater than the second argument or should be placed after the second argument in a sorted list, compare( ) should return a positive integer.
If the two objects are equivalent or if their relative position in a sorted list does not matter, compare( ) should return 0
Comparator implementations may assume that both Object arguments are of appropriate types and cast them as desired.
If either argument is not of the expected type, the compare( ) method throws a ClassCastException.
Note that the magnitude of the numbers returned by compare( ) does not matter, only whether they are less than, equal to, or greater than zero.
This is particularly important when using a Comparator to impose an ordering on a TreeSet or a TreeMap.
See Collections and Arrays for various methods that use Comparator objects for sorting and searching.
Signals that a modification has been made to a data structure at the same time some other operation is in progress and that, as a result, the correctness of the ongoing operation cannot be guaranteed.
It is typically thrown by an Iterator or ListIterator object to stop an iteration if it detects that the underlying collection has been modified while the iteration is in progress.
Once you have a Currency object, use getSymbol( ) to obtain the currency symbol (which is often different from the currency code) for the default locale or for a specified Locale.
If no symbol is known, this method returns the currency code.
Use getDefaultFractionDigits( ) to determine how many fractional digits are conventionally used with the currency.
This class represents dates and times and lets you work with them in a system-independent way.
Years are specified as the number of years since 1900
If you call the Date constructor with no arguments, the Date is initialized to the current time and date.
The instance methods of the class allow you to get and set the various date and time fields, to compare dates and times, and to convert dates to and from string representations.
As of Java 1.1, many of the date methods have been deprecated in favor of the methods of the Calendar class.
As of Java 1.2, the Map interface replaces the functionality of this class.
An IllegalFormatException of this type is thrown by a Formatter when the format string contains duplicate format flags for the same conversion specifier.
This interface defines the methods necessary to enumerate, or iterate, through a set of values, such as the set of values contained in a hashtable.
This interface is superseded in Java 1.2 by the Iterator inteface.
In Java 5.0 this interface has been made generic and defines the type variable E to represent the type of the objects being enumerated.
An Enumeration is usually not instantiated directly, but instead is created by the object that is to have its values enumerated.
A number of classes, such as Vector and Hashtable, have methods that return Enumeration objects.
To use an Enumeration object, you use its two methods in a loop.
Within a loop, a call to nextElement( ) returns a value from the enumeration.
An Enumeration makes no guarantees about the order in which the values are returned.
The values in an Enumeration can be iterated through only once; there is no way to reset it to the beginning.
This class is a Map implementation for use with enumerated types.
The key type K must be an enumerated type, and all keys must be enumerated constants defined by that type.
The value type V is unrestricted and null values are permitted.
The EnumMap implementation is based on an array of elements of type V.
The length of this array is the same as the number of constants defined by the enumerated type K.
The iterators of the keySet( ), entrySet( ), and values( ) collections iterate their elements in the ordinal order of the enumerated constants.
EnumMap is not threadsafe, but its iterators are based on a snapshot of the underlying array and never throw ConcurrentModificationException.
This Set implementation is specialized for use with enumerated constants.
The element type E must be an enumerated type, and null is not allowed as a member of the set.
Instead, it defines various static factory methods for creating sets.
Use one of the of( ) methods for creating an EnumSet and initializing its elements.
For efficiency, versions of this method that accept one through five arguments are defined.
If you pass more than five arguments, the varargs version will be invoked.
The allOf( ) and noneOf( ) methods define full and empty sets but require the Class of the enumerated type since they do not have any other arguments to define the element type.
The range( ) factory creates a set that includes the two specified values and any enumerated constants that fall between them in the enumerated type declaration.
Note that this definition of a range includes both endpoints and differs from most Java methods, in which the second argument specifies the first value past the end of the range.)
The EnumSet implementation is based on a bit vector that includes one bit for each constant defined by the enumerated type E.
Because of this compact and efficient representation, basic Set operations occur in constant time, and the Iterator returns.
EnumSet is not threadsafe, but the Iterator uses a copy of the internal bit vector and never throws ConcurrentModificationException.
EventListener is a base interface for the event model that is used by AWT and Swing in Java 1.1 and later.
This interface defines no methods or constants; it serves simply as a tag that identifies objects that act as event listeners.
The event listener interfaces in the java.awt.event, java.beans, and javax.swing.event packages extend this interface.
This abstract class serves as the superclass for event listener proxy objects.
Subclasses of this class implement an event listener interface and serve as a wrapper around an event listener of that type, defining methods that provide additional information about the listener.
See java.beans.PropertyChangeListenerProxy for an explanation of how event listener proxy objects are used.
This class defines a generic type of event; it is extended by the more specific event classes in the java.awt, java.awt.event, java.beans, and javax.swing.event packages.
The only common feature shared by all events is a source object, which is the object that, in some way, generated the event.
The source object is passed to the EventObject( ) constructor and is returned by the getSource( ) method.
An IllegalFormatException of this type is thrown by a Formatter when a conversion specifier and a format flag specified with it are incompatible.
This interface should be implemented by classes that want to interact with the Formatter class more intimately than is possible with the toString method.
The flags argument is a bitmask of zero or more FormattableFlags constants.
Each flag provides information about the format specification that resulted in the invocation of formatTo( )
FormattableFlags.ALTERNATE indicates that the # flag was used and that the Formattable should format itself using some alternate form.
The interpretation of the alternate form is entirely up to the Formattable implementation.
LEFT_JUSTIFY means that the - flag was used and that the Formattable should pad its output on the right, instead of on the left.
The Formattable object should treat these values the same way that Formatter does.
The text to be output should first be truncated to fit within precision characters and then padded on the left (or right if the LEFT_JUSTIFY flag is set) with spaces for a total length of width characters.
Note that a Formattable implementation may fulfill the obligations imposed by the LEFT_JUSTIFY and UPPERCASE flags and the width and precision arguments by constructing a suitable format string to pass back to the specified Formatter.
If a Formattable implementation wants to perform locale-specific formatting, it can query the Locale of the Formatter with the locale( ) method.
Note, however, that the returned value is the locale specified when the Formatter was created, not the Locale, if any, passed to the format( ) method.
There is no way for a Formattable object to access that Locale.
This class defines three constants representing flags that may be passed as a bitmask to the Formattable.formatTo( ) method.
The Formatter class is a utility for formatting text in the style of the printf( ) method of the C programming language.
Every Formatter has an associated java.lang.Appendable object (such as a StringBuilder or PrintWriter) that is specified when the Formatter is created.
The format string uses a grammar, described in detail later in the entry, to specify how the arguments that follow are to be converted to strings.
After the arguments are converted, they are substituted into the format string, and the resulting text is appended to the Appendable.
A variant of the format( ) method accepts a Locale object that can affect the argument conversions.
For ease of use, a Formatter never throws a java.io.IOException, even when the underlying Appendable throws one.
When using a Formatter with a stream-based Appendable object that may throw an IOException, you can use the ioException( ) method to obtain the most recently thrown exception, or null if no exception has been thrown by the Appendable.
Formatter implements the Closeable and Flushable interfaces of the java.io package, and its close( ) and flush( ) methods call the corresponding methods on its Appendable object, if that object itself implements Closeable or Flushable.
When a Formatter sends its output to a stream or similar Appendable, remember to call close( ) when you are done with it.
It is always safe to call close( ) even if the underlying Appendable is not Closeable.
Note that once a Formatter has been closed, no other method except ioException( ) may be called.
This is useful when the Appendable is a StringBuilder, for example, as it is when the no-argument version of the Formatter( ) constructor is used.
If the Appendable is a stream class, however, the toString( ) method is not typically useful.
Note that the Java 5.0 API provides a number of convenience methods that use the Formatter class, and in many cases it is unnecessary to create a Formatter object explicitly.
See the static String.format( ) method and the format( ) and printf( ) methods of java.io.PrintWriter and java.io.PrintStream.
If you do need to create a Formatter object explicitly, you can choose from a number of constructors.
The most general case is to pass the desired Appendable or the desired Locale and Appendable objects to the constructor.
The no-argument constructor is a convenience that creates a StringBuilder to append to.
Obtain this StringBuilder with out( ) or obtain its contents as a String with toString( )
If you specify a single Locale argument, the resulting Formatter uses the specified locale with a StringBuilder.
You can use a Formatter to write formatted output to a file by specifying either the File object or filename as a String.
Variants of these constructors allow you to specify the name of the charset to use for character-to-byte conversion and also a Locale.
Note that these methods overwrite existing files rather than appending to them.
Other constructors create an Appendable object for you based on the java.io.OutputStream or java.io.PrintStream you specify.
In the OutputStream case, you may optionally specify the charset to use or the charset and a Locale.
The power of these formatting methods lies in the format string that is the first argument (or second argument if a Locale is specified) to the various format( ) and printf( ) methods.
The format string may contain any amount of regular text, which is printed or appended literally to the destination Appendable object.
This plain text may be interspersed with format specifiers which specify how a subsequent argument is to be formatted as a string.
In contrast to the simple API, the grammar for these format specifiers is surprisingly complex.
Experienced C programmers will find that the grammar is largely compatible with the printf( ) format string grammar of the standard C library.
Each format specifier begins with a percent sign and ends with a one- or two-character conversion type that specifies most of the details of the conversion and formatting.
In between these two are optional flags that provide additional details about how the formatting should be done.
The general syntax of a format specifier is as follows.
Note that the percent sign and the type are the only two required portions of a format specifier.
We begin, therefore, with a listing of conversion types (see Table 16-1)
In the table of conversion types below, if uppercase and lowercase variants of the type specifier are listed together, the uppercase variant produces the same output as the lowercase variant except that all lowercase letters are converted to uppercase.
Note that format( ) never throws NullPointerException because of null arguments following the format string.
Outputs a single percent sign.This is simply an escape sequence used to embed percent signs literally in the output string.
If the argument implements Formattable, its formatTo( ) method is called to perform the formatting.
Otherwise, its toString( ) method is called to convert it to a string.
The argument value must represent a valid Unicode code point.
The argument may be of any type and any value.
If it is a Boolean argument, the output reflects the argument value.
Note that this differs from normal Java conversions in which boolean values are not convertible to or from any other type.
The allowed argument types are the same as for %d.
For any argument type other than BigInteger, the value is treated as unsigned.
The allowed argument types and values are the same as for %d.
For any argument type other than BigInteger, the value is treated as unsigned.
The output consists of a single digit, a locale-specific decimal point, and the number of fractional digits specified by the precision of the format specifier, or six fractional digits if no precision is specified.
These digits are followed by the letter e or E and the exponent of the number.
If the number is large, this may produce quite a few digits.
Because exponential notation is never used, the output will never include a letter, and there is no uppercase variant of this conversion.
Legal argument types and special-case values are as for %e.
If the value has more than the allowed number of significant digits, it is printed using exponential notation (see %e) to limit the display to the specified number of digits.
Otherwise, all digits of the value are printed explicitly as they would be with the %f conversion type.
Legal argument types and special case values are as for %e.
Legal argument types and special case values are as for %e.
The specific format types are listed below, in alphabetical order, using %t as the prefix.
Upper- and lowercase variants of the second letter of a time or date format type are sometimes completely unrelated.
Other times, the lowercase conversion produces an abbreviation of the value produced by the uppercase conversion.
The argument for a date or time conversion must be a Date, Calendar, or Long.
In the case of Long, the value is interpreted as milliseconds since the epoch, as in System currentTimeMillis( )
These arguments follow the format string in the call to format( ) or printf( )
By default, a format specifier uses the next unused argument.
In the following printf( ) call, the first and second %s format specifiers format the second and third arguments, respectively:
This allows the same object (such as a date) to be formatted more than once (yielding a formatted date and time, for example):
It is an error to use < in the first format specifier of a format string.
For example %1$d specifies that the first argument following the format string should be formatted as an integer.
Absolute argument numbers are particularly useful for localization since the different translations of a message may need to interpolate the arguments in a different order.
The following example includes a format string that might be used in a locale where a person’s family name is typically printed (in uppercase) before the given name.
Note that the arguments are not passed in the same order that they are formatted.
Note that platforms are not required to able to resolve times with nanosecond precision.
The code above could be rewritten like this, for example:
Flags Following the optional argument specifier, a format specifier may include one or more flag characters.
The defined flags, their effects, and the format types for which they are legal are specified in Table 16-2:
Width The width portion of a format specifier is one or more digits that specify the minimum number of characters to be produced.
If the formatted value is narrower than the specified width, (by default) it is padded on the left with spaces, producing a right-justified value.
The - and 0 flags can be used to specify left-justification or padding with zeros instead.
A width may be specified with any format type except %n.
A hyphen specifies that the formatted value should be left-justified within the specified width.
This flag can be used with any conversion type except %n as long as the conversion specifier also includes a width (see below)
When a width is specified without this flag, the formatted string is padded on the left to produce right-justified output.
In this case, the flag is passed on to the formatTo( ) method of the argument, and it is up to that formatTo( ) method to produce its output in some alternate form.
This flag specifies that numeric output should always include a sign: a value that is nonnegative will have “+” added in front of it.
This flag may be used with any numeric conversion that may yield a signed result.
The space character is a (hard-to-read) flag that specifies that non-negative values should be prefixed with a space.
This flag may be used with the same conversion and argument types as the + flag, and is useful when aligning positive and negative numbers in a column.
This flag specifies that negative numbers should be enclosed in parentheses, as is commonly done in financial statements, for example.
The digit zero, used as a flag, specifies that numeric values should be padded on the left (after the sign character, if any) with zeros.
This flag may be used only if a width is specified, and may not be used in conjunction with the - flag.
This flag specifies that numbers should be formatted using the locale-specific grouping separator.
In the US locale, for example, a comma would appear every three digits to separate the number into thousands, millions, and so on.
Precision The precision portion of a format specifier is one or more digits following a decimal point.
The meaning of this number depends on which format type it is used with:
As a corollary, it specifies the largest and smallest values that can be displayed without resorting to exponential notation.
If the formatted output would exceed the precision of characters, it is truncated.
If precision is smaller than width, the formatted value is first truncated as necessary and then padded within the specified width.
Specifying a precision for any other conversion type causes an exception at runtime.
This enumerated type is intended for internal use by the Formatter class, but was inadvertently declared public.
This type serves no useful purpose and should not be used.
An exception of this type is thrown when an attempt is made to use a Formatter whose close( ) method has been called.
This concrete subclass of Calendar implements the standard solar calendar with years numbered from the birth of Christ that is used is most locales throughout the world.
You do not typically use this class directly, but instead obtain a Calendar object suitable for the default locale by calling Calendar.getInstance( )
There is a discontinuity in the Gregorian calendar that represents the historical switch from the Julian calendar to the Gregorian calendar.
This class implements the Map interface using an internal hashtable.
It supports all optional Map methods, allows key and value objects of any types, and allows null to be used as a key or a value.
Because HashMap is based on a hashtable data structure, the get( ) and put( ) methods are very efficient.
HashMap is much like the Hashtable class, except that the HashMap methods are not synchronized (and are therefore faster), and HashMap allows null to be used as a key or a value.
If you are working in a multithreaded environment, or if compatibility with previous versions of Java is a concern, use Hashtable.
If you know in advance approximately how many mappings a HashMap will contain, you can improve efficiency by specifying initialCapacity when you call the HashMap( ) constructor.
The initialCapacity argument times the loadFactor argument should be greater.
A good value for loadFactor is 0.75; this is also the default value.
It supports all optional Set and Collection methods and allows any type of object or null to be a member of the set.
Because HashSet is based on a hashtable, the basic add( ), remove( ), and contains( ) methods are all quite efficient.
HashSet makes no guarantee about the order in which the set elements are enumerated by the Iterator returned by iterator( )
If you are using it in a multithreaded environment, you must explicitly synchronize all code that modifies the set or obtain a synchronized wrapper for it by calling Collections.synchronizedSet( )
If you know in advance approximately how many mappings a HashSet will contain, you can improve efficiency by specifying initialCapacity when you call the HashSet( ) constructor.
The initialCapacity argument times the loadFactor argument should be greater than the number of mappings the HashSet will contain.
A good value for loadFactor is 0.75; this is also the default value.
See Set and Collection for details on the methods of HashSet.
This class implements a hashtable data structure, which maps key objects to value objects and allows the efficient lookup of the value associated with a given key.
In Java 1.2 and later Hashtable has been modified to impement the Map interface.
The HashMap class is typically preferred over this one, although the synchronized methods of this class are useful in multi-threaded applications.
But see java.util.concurrent.ConcurrentHashMap.) In Java 5.0 this class has been made generic along with the Map interface.
The type variable K represents the type of the hashtable keys and the type variable V represents the type of the hashtable values.
Objects used as keys in a Hashtable must have valid equals( ) and hashCode( ) methods (the versions inherited from Object are okay)
This Map implementation has a API that is very similar to HashMap, and uses an internal hashtable, like HashMap does.
However, it behaves differently from HashMap in one very operator to determine whether the two key objects are identical--whether they are exactly the same object.
This one difference in how key equality is tested has profound ramifications for the behavior of the Map.
In most cases, the equality testing of a HashMap, LinkedHashMap or TreeMap is the appropriate behavior, and you should use one of those classes.
For certain purposes, however, the identity testing of IdentityHashMap is what is required.
An IllegalFormatException of this type is thrown by a Formatter when an int used to represent a Unicode character is out of range.
An IllegalFormatException of this type is thrown by a Formatter when the type of the format( ) or printf( ) argument does not match the type required by the corresponding conversion specifier in the format string.
An exception of this type is thrown by a Formatter when there is problem with the format string.
This package defines many subclasses of this exception type to describe particular format string problems.
An IllegalFormatException of this type is thrown by a Formatter when a format string contains an illegal combination of flags.
An IllegalFormatException of this type is thrown by a Formatter when the precision of a format string is illegal.
An IllegalFormatException of this type is thrown by a Formatter when the width of a format string is illegal.
An exception of this type is thrown by a Scanner that is not of the expected type or is out of range.
Note that the Scanner implements the Iterator interface, and this exception is a subclass of NoSuchElementException, which is thrown by Iterator.next( ) when no more elements are available.
An exception of this type is thrown by Properties.loadFromXML( ) if the specified input stream does not contain appropriate XML.
This interface defines methods for iterating, or enumerating, the elements of a collection.
It has been made generic in Java 5.0 and the type variable E represents the type of the elements in the collection.
The hasNext( ) method returns true if there are more elements to be enumerated or false if all elements have already been returned.
These two methods make it easy to loop through an iterator with code such as the following:
In Java 5.0, collections and other classes that can return an Iterator implement the java.lang.Iterable interface, which allows them to be iterated much more simply with the for/in looping statement.
In Java 1.2, Iterator is preferred over Enumeration because it provides a well-defined way to safely remove elements from a collection while the iteration is in progress.
The remove( ) method removes the object most recently returned by next( ) from the collection that is being iterated through.
Note, however, that support for remove( ) is optional; if an Iterator does not support remove( ), it throws a java.lang.UnsupportedOperationException when you call it.
While you are iterating through a collection, you are allowed to modify the collection only by calling the remove( ) method of the Iterator.
If the collection is modified in any other way while an iteration is ongoing, the Iterator may fail to operate correctly, or it may throw a ConcurrentModificationException.
This class is a Map implementation based on a hashtable, just like its superclass HashMap.
It defines no new public methods, and can be used exactly as HashMap is used.
What is unique about this Map is that in addition to the hashtable data structure, it also uses a.
You can iterate through the keys or values of a LinkedHashMap by calling entrySet( ), keySet( ), or values( ) and then obtaining an Iterator for the returned collection, just as you would for a HashMap.
When you do this, however, the keys and/or values are returned in a welldefined order rather than the essentially random order provided by a HashMap.
The default ordering for LinkedHashMap is the insertion order of the key: the first key inserted into the Map is enumerated first (as is the value associated with it), and the last entry inserted is enumerated last.
The iteration order of a value in the map is the iteration order of the key with which it is associated.
Insertion order is the default iteration order for this class, but if you instantiate a LinkedHashMap with the three-argument constructor, and pass true for the third argument, then the iteration order will be based on access order: the first key returned by an iterator is the one that was least-recently used in a get( ) or put( ) operation.
The last key returned is the one that has been most-recently used.
As with insertion order, the values( ) collection is iterated in the order defined by the keys with which those values are associated.
To facilitate this use, LinkedHashMap defines the protected removeEldestEntry( ) method.
Each time the put( ) method is called (or for each mapping added by putAll( )) the LinkedHashMap calls removeEldestEntry( ) and passes the least-recently used (or first inserted if insertion order is being used) Map.Entry object.
If the method returns true, then that entry will be removed from the map.
In LinkedHashMap, removeEldestEntry( ) always returns false, and old entries are never automatically removed, but you can override this behavior in a subclass.
The decision to remove an old entry might be based on the content of the entry itself, or might more simply be based on the size( ) of the LinkedHashMap.
Note that removeEldestEntry( ) need simply return true or false; it should not remove the entry itself.
This subclass of HashSet is a Set implementation based on a hashtable.
It defines no new methods and is used just like a HashSet is used.
What is unique about a LinkedHashSet is that in addition to the hashtable data structure, it also uses a doubly-linked list to connect the elements of the set into an internal list in the order in which they were inserted.
This means that the Iterator returned by the inherited iterator( ) method always enumerates the elements of the set in the order which they were inserted.
By contrast, the elements of a HashSet are enumerated in an order that is essentially random.
Note that the iteration order is not affected by reinsertion of set elements.
That is, if you attempt to add an element that already exists in the set, the iteration order of the set is not modified.
If you delete an element and then reinsert it, the insertion order, and therefore the iteration order, does change.
This class implements the List interface in terms of a doubly linked list.
In Java 5.0, it also implements the Queue interface and uses its list as a first-in, first-out (FIFO) queue.
LinkedList is a generic type, and the type variable E represents the type of the elements of the list.
LinkedList supports all optional methods of List, Queue and Collection and allows list elements of any type, including null (in this it differs from most Queue implementations, which prohibit null elements)
Because LinkedList is implemented with a linked list data structure, the get( ) and set( ) methods are substantially less efficient than the same methods for an ArrayList.
However, a LinkedList may be more efficient when the add( ) and remove( ) methods are used frequently.
If you are using a LinkedList in a multithreaded environment, you must explicitly synchronize any code that modifies the list or obtain a synchronized wrapper object with Collections.synchronizedList( )
In addition to the methods defined by the List interface, LinkedList defines methods to get the first and last elements of the list, to add an element to the beginning or end of the list, and to remove the first or last element of the list.
These convenient and efficient methods make LinkedList well-suited for use as a stack or queue.
See List and Collection for details on the methods of LinkedList.
In Java 5.0 List is a generic interface and the type variable E represents the type of the objects in the list.
Each element in a List has an index, or position, in the list, and elements can be inserted, queried, and removed by index.
The first element of a List has an index of 0
The last element in a list has index size( )-1
In addition to the methods defined by the superinterface, Collection, List defines a number of methods for working with its indexed elements.
Versions of add( ) and addAll( ) that take an index argument insert an object or Collection of objects at a specified index.
The versions of add( ) and addAll( ) that do not take an index argument insert an object or collection of objects at the end of the list.
List defines a version of remove( ) that removes the object at a specified index.
The iterator( ) method is just like the iterator( ) method of Collection, except that the Iterator it returns is guaranteed to enumerate the elements of the List in order.
Each method returns the index of the first matching object it finds, or –1 if it does not find a match.
Finally, subList( ) returns a List that contains only a specified contiguous range of list elements.
The returned list is simply a view into the original list, so changes in the original List are visible in the returned List.
This subList( ) method is particularly useful if you want to sort, search, clear( ), or otherwise manipulate only a partial range of a larger list.
An interface cannot specify constructors, but it is conventional that all implementations of List provide at least two standard constructors: one that takes no arguments and creates an empty list, and a copy constructor that accepts an arbitrary Collection object that specifies the initial contents of the new List.
As with Collection, List methods that change the contents of the list are optional, and implementations that do not support them simply throw java.lang.UnsupportedOperationException.
Different implementations of List may have significantly different efficiency characteristics.
For example, the get( ) and set( ) methods of an ArrayList are much more efficient than those of a LinkedList.
On the other hand, the add( ) and remove( ) methods of a LinkedList can be more efficient than those of an ArrayList.
This interface is an extension of Iterator for use with ordered collections, or lists.
It defines methods to iterate forward and backward through a list, to determine the list index of the elements being iterated, and, for mutable lists, to safely insert, delete, and edit elements in the list while the iteration is in progress.
For some lists, notably LinkedList, using an iterator to enumerate the list’s elements may be substantially more efficient than looping through the list by index and calling get( ) repeatedly.
Like the Iterator interface, ListIterator has been made generic in Java 5.0
The type variable E represents the type of the elements on the list.
In addition to these two methods, however, ListIterator also defines hasPrevious( ) and previous( ) that allow you to iterate backward through the list.
If next( ) or previous( ) throw a NoSuchElementException, nextIndex( ) returns the size of the list, and previousIndex( ) returns –1
ListIterator defines three optionally supported methods that provide a safe way to modify the contents of the underlying list while the iteration is in progress.
Calling add( ) does not affect the value that is returned by next( ), however.
If you call previous( ) immediately after calling add( ), the method returns the object you just added.
You can only call remove( ) once per call to next( ) or previous( )
If you have called add( ), you must call next( ) or previous( ) again before calling remove( )
If you have called add( ) or remove( ), you must call next( ) or previous( ) again before calling set( )
Remember that support for the add( ), remove( ), and set( ) methods is optional.
If the underlying list is modified while an iteration is ongoing, the ListIterator may fail to operate correctly or may throw a ConcurrentModificationException.
This abstract class provides a simple way to define a ResourceBundle.
You may find it easier to subclass ListResourceBundle than to subclass ResourceBundle directly.
ListResourceBundle provides implementations for the abstract handleGetObject( ) and getKeys( ) methods defined by ResourceBundle and adds its own abstract getContents( ) method a subclass must override.
Each element of this array must itself be an array with two elements: the first element of each subarray should be a String that specifies the name of a resource, and the corresponding second element should be the value of that resource; this value can be an Object of any desired type.
The Locale class represents a locale: a political, geographical, or cultural region that typically has a distinct language and distinct customs and conventions for such things as formatting dates, times, and numbers.
Locale also defines a static getDefault( ) method that returns the default Locale object, which represents a locale value inherited from the host system.
If none of these methods for obtaining a Locale object are suitable, you can explicitly create your own Locale object.
To do this, you must specify a language code and optionally a country code and variant string.
The Locale class does not implement any internationalization behavior itself; it merely serves as a locale identifier for those classes that can localize their behavior.
Given a Locale object, you can invoke the various getDisplay methods to obtain a description of the locale suitable for display to a user.
These methods may themselves take a Locale argument, so the names of languages and countries can be localized as appropriate.
Returned By java.text.BreakIterator.getAvailableLocales( ), java.text.Collator.getAvailableLocales( ), java.text.DateFormat.getAvailableLocales( ), java.text.MessageFormat.getLocale( ), java.text.NumberFormat.getAvailableLocales( ), Calendar.getAvailableLocales( ), java.util.Formatter.locale( ), ResourceBundle.getLocale( ), Scanner.locale( ), javax.security.auth.callback.LanguageCallback.getLocale( )
This interface represents a collection of mappings, or associations, between key objects and value objects.
The type variable K represents the type of the keys held by the map and the type variable V represents the type of the values associated with those keys.
The set of key objects in a Map must not have any duplicates; the collection of value objects is under no such constraint.
The key objects should usually be immutable objects, or, if they are not, care should be taken that they do not change while in use in a Map.
As of Java 1.2, the Map interface replaces the abstract Dictionary class.
Although a Map is not a Collection, the Map interface is still considered an integral part, along with Set, List, and others, of the Java collections framework.
You can add a key/value association to a Map with the put( ) method.
Use putAll( ) to copy all mappings from one Map to another.
Call get( ) to look up the value object associated with a specified key object.
Use remove( ) to delete the mapping between a specified key and its value, or use clear( ) to delete all mappings from a Map.
For most implementations, containsValue( ) is a much more expensive operation than containsKey( ), however.) keySet( ) returns a Set of all key objects in the Map.
The collections returned by values( ), keySet( ), and entrySet( ) are based on the Map itself, so changes to the Map are reflected in the collections.
An interface cannot specify constructors, but it is conventional that all implementations of Map provide at least two standard constructors: one that takes no arguments and creates an empty map, and a copy constructor that accepts a Map object that specifies the initial contents of the new Map.
Implementations are required to support all methods that query the contents of a Map, but support for methods that modify the contents of a Map is optional.
If an implementation does not support a particular method, the implementation of that method simply throws a java.lang.UnsupportedOperationException.
This interface represents a single mapping, or association, between a key object and a value object in a Map.
Like Map itself, Map.Entry has been made generic in Java 5.0 and defines the same type variables that Map does.
The entrySet( ) method of a Map returns a Set of Map.Entry objects that represent the set of mappings in the map.
Use the iterator( ) method of that Set to enumerate these Map.Entry objects.
Use getKey( ) and getValue( ) to obtain the key and value objects for the entry.
Use the optionally supported setValue( ) method to change the value of an entry.
This method throws a java.lang.UnsupportedOperationException if it is not supported by the implementation.
An IllegalFormatException of this type is thrown by a Formatter when a format( ) or printf( ) method does not have enough arguments to match the number conversion specifiers in the format string.
An IllegalFormatException of this type is thrown by a Formatter when a format conversion requires a field width, but the width is omitted.
Signals that no ResourceBundle can be located for the desired locale or that a named resource cannot be found within a given ResourceBundle.
Signals that there are no elements in an object (such as a Vector) or that there are no more elements in an object (such as an Enumeration)
This class is the superclass for classes that want to provide notifications of state changes to interested Observer objects.
Register an Observer to be notified by passing it to the addObserver( ) method of an Observable, and de-register it by passing it to the deleteObserver( ) method.
You can delete all observers registered for an Observable with deleteObservers( ), and can find out how many observers have been added with countObservers( )
Note that there is not a method to enumerate the particular Observer objects that have been added.
An Observable subclass should call the protected method setChanged( ) when its state has changed in some way.
After an operation or series of operations that may have caused the state to change, the Observable subclass should call notifyObservers( ), optionally passing an arbitrary Object argument.
If the state changed flag is set, this notifyObservers( ) calls the update( ) method of each registered Observer (in some arbitrary order), passing the Observable object, and the optional argument, if any.
Once the update( ) method of each Observable has been called, notifyObservers( ) calls clearChanged( ) to clear the state changed flag.
If notifyObservers( ) is called when the state changed flag is not set, it does not do anything.
You can use hasChanged( ) to query the current state of the changed flag.
The Observable class and Observer interface are not commonly used.
Most applications prefer the event-based notification model defined by the JavaBeans component framework and by the EventObject class and EventListener interface of this package.
This interface defines the update( ) method required for an object to observe subclasses of Observable.
An Observer registers interest in an Observable object by calling the addObserver( ) method of Observable.
Observer objects that have been registered in this way have their update( ) methods invoked by the Observable when that object has changed.
This interface is conceptually similar to, but less commonly used than, the EventListener interface and its various event-specific subinterfaces.
This class is a Queue implementation that orders its elements according to a specified Comparator or orders Comparable elements according to their compareTo( ) methods.
The head of the queue (the element removed by remove( ) and poll( )) is the smallest element on the queue according to this ordering.
The Iterator return by the iterator( ) method is not guaranteed to iterate the elements in their sorted order.
This class is an extension of Hashtable that allows key/value pairs to be read from and written to a stream.
The Properties class implements the system properties list, which supports user customization by allowing programs to look up the values of named resources.
Because the load( ) and store( ) methods provide an easy way to read and write properties from and to a text stream, this class provides a convenient way to implement an application configuration file.
When you create a Properties object, you may specify another Properties object that contains default values.
Keys (property names) and values are associated in a Properties object with find the key in the current Properties object, it looks in the default Properties object that was passed to the constructor method.
A default value can also be specified, in case the key is not found at all.
Use setProperty( ) to add a property name/value pair to the Properties object.
This Java 1.2 method is preferred over the inherited put( ) method because it enforces the constraint that property names and values be strings.
The second argument to both store( ) and save( ) is a comment that is written out at the beginning of the property file.
Finally, load( ) reads key/value pairs from a stream and stores them in a Properties object.
It is suitable for reading both properties written with store( ) and hand-edited properties files.
In Java 5.0, storeToXML( ) and loadFromXML( ) are alternatives that write and read properties files using a simple XML grammar.
This class is a java.security.Permission that governs read and write access to system properties with System.getProperty( ) and System.setProperty( )
A PropertyPermission object has a name, or target, and a comma-separated list of actions.
The name of the permission is the name of the property of interest.
PropertyPermission extends java.security.BasicPermission, so the name of the property supports simple wildcards.
If a name ends with “.*”, it represents any property names that share the specified prefix.
Granting access to system properties is not overtly dangerous, but caution is still necessary.
Some properties, such as “user.home”, reveal details about the host system that malicious code can use to mount an attack.
Programmers writing system-level code and system administrators configuring security policies may need to use this class, but applications never need to use it.
It reads a Properties file from a specified InputStream and implements the ResourceBundle API for looking up named resources from the resulting Properties object.
Each such line defines a named property with the specified String value.
Although you can instantiate a PropertyResourceBundle yourself, it is more common to simply define a Properties file and then allow ResourceBundle.getBundle( ) to look up that file and return the necessary PropertyResourceBundle object.
A Queue<E> is an ordered Collection of elements of type E.
Unlike List, the Queue interface does not permit indexed access to its elements: elements may be inserted at the tail of the queue and may be removed from the head of the queue, but the elements in between may not be accessed by their position.
Queues may be manipulated through the methods of the Collection interface, including iteration via the iterator( ) method and the Iterator object it returns.
It is more common to manipulate queues through the more specialized methods defined by the Queue interface, however.
Place an element at the tail of the queue with offer( )
If the queue is already full, offer( ) returns false.
Remove an element from the head of the queue with remove( ) or poll( )
These methods differ only in the case of an empty queue: remove( ) throws an unchecked NoSuchElementException and poll( ) returns null.
Most queue implementations prohibit null elements for this reason, but LinkedList is an exception.) Query the element at the head of a queue without removing it with element( ) or peek( )
If the queue is empty, element( ) throws NoSuchElementException and peek( ) returns null.
Most Queue implementations order their elements in first-in, first-out (FIFO) order.
A queue Iterator is not required to traverse the queue’s elements in order.
A Queue implementation with a fixed size is a bounded queue.
When a bounded queue is full, it is not possible to insert a new element until an element is first removed.
Unlike the List and Set interfaces, the Queue interface does not require implementations to override the equals( ) method, and Queue implementations typically do not override it.
In Java 5.0, the LinkedList class has been retrofitted to implement Queue as well as List.
PriorityQueue is a Queue implementation that orders elements based on the Comparable or Comparator interfaces.
AbstractQueue is an abstract implementation that offers partial support for simple Queue implementations.
The java.util.concurrent package defines a BlockingQueue interface that extends this implementation and includes Queue and BlockingQueue implementations that are useful in multithreaded programming.
This class implements a pseudorandom number generator suitable for games and similar applications.
If you need a cryptographic-strength source of pseudorandomness, see java.security.SecureRandom.
As of Java 1.2, if you pass an argument to nextInt( ), it returns a value between zero (inclusive) and the specified number (exclusive)
You can use the setSeed( ) method or the optional constructor argument to initialize the pseudorandom number generator with some variable seed value other than the current time (the default) or with a constant to ensure a repeatable sequence of pseudorandomness.
This marker interface is implemented by List implementations to advertise that they provide efficient (usually constant time) random access to all list elements.
ArrayList and Vector implement this interface, but LinkedList does not.
Classes that manipulate generic List objects may want to test for this interface with instanceof and use different algorithms for lists that provide efficient random access than they use for lists that are most efficiently accessed sequentially.
This abstract class allows subclasses to define sets of localized resources that can then be dynamically loaded as needed by internationalized programs.
Such resources may include user-visible text and images that appear in an application, as well as more complex things such as Menu objects.
Use getBundle( ) to load a ResourceBundle subclass that is appropriate for the default or specified locale.
Use getObject( ), getString( ), and getStringArray( ) to look up a named resource in a bundle.
To define a bundle, provide implementations of handleGetObject( ) and getKeys( )
It is often easier, however, to subclass ListResourceBundle or provide a Properties file that is used by PropertyResourceBundle.
The name of any localized ResourceBundle class you define should include the locale language code, and, optionally, the locale country code.
It can read input from any Readable object, and convenience constructors can read text from a specified string, file, byte stream, or byte channel.
The constructors for files, byte streams, and byte channels optionally allow you to specify the name of the charset to use for byte-to-character conversions.
These configuration methods may be called at any time and are not required to be called before scanning begins.
Scanner implements the Iterable<String> interface, and you can use the hasNext( ) and next( ) methods of this interface to break the input into a series of String tokens separated by whitespace or by the delimiter specified with useDelimiter( )
In addition to these Iterable methods, however, Scanner defines a number of nextX and hasNextX methods for various numeric types X.
Two variants of the next( ) method accept a regular expression as an argument and return the next chunk of text matching a specified regular expression.
The corresponding hasNext( ) methods accept a regular expression and return true if the input matches it.
The skip( ) method ignores delimiters and skips text matching the specified regular expression.
If a match is found, the Scanner advances past that text and returns it.
The next( ) methods and its nextX variants throw a NoSuchElementException if there is no more input text.
They throw an InputMismatchException (a subclass of NoSuchElementException) if the next token cannot be parsed as the specified type or does not match the specified pattern.
The Readable object that the Scanner reads text from may throw a java.io.IOException, but, for ease of use, the Scanner never propagates this exception.
If an IOException occurs, the Scanner assumes that no more input is available from the Readable.
Call ioException( ) to obtain the most recent IOException, if any, thrown by the Readable.
The close( ) method checks whether the Readable object implements the Closeable interface and, if so, calls the close( ) method on that object.
Once close( ) has been called, any attempt to read tokens from the Scanner results in an IllegalStateException.
This interface represents an unordered Collection of objects that contains no duplicate elements.
The Set interface defines the same methods as its superinterface, Collection.
It constrains the add( ) and addAll( ) methods from adding duplicate elements to the Set.
In Java 5.0 Set is a generic interface and the type variable E represents the type of the objects in the set.
An interface cannot specify constructors, but it is conventional that all implementations of Set provide at least two standard constructors: one that takes no arguments and creates an empty set, and a copy constructor that accepts a Collection object that specifies the initial contents of the new Set.
This copy constructor must ensure that duplicate elements are not added to the Set, of course.
As with Collection, the Set methods that modify the contents of the set are optional, and implementations that do not support the methods throw java.lang.UnsupportedOperationException.
This concrete subclass of TimeZone is a simple implementation of that abstract class that is suitable for use in locales that use the Gregorian calendar.
Programs do not normally need to instantiate this class directly; instead, they use one of the static factory methods of TimeZone to obtain a suitable TimeZone subclass.
The only reason to instantiate this class directly is if you need to support a time zone with nonstandard daylightsavings-time rules.
In that case, you can call setStartRule( ) and setEndRule( ) to specify the starting and ending dates of daylight-savings time for the time zone.
This interface represents a Map object that keeps its set of key objects in sorted order.
As with Map, it is conventional that all implementations of this interface define a noargument constructor to create an empty map and a copy constructor that accepts a Map object that specifies the initial contents of the SortedMap.
Furthermore, when creating a SortedMap, there should be a way to specify a Comparator object to sort the key objects of the map.
If no Comparator is specified, all key objects must implement the java.lang.Comparable interface so they can be sorted in their natural order.
The inherited keySet( ), values( ), and entrySet( ) methods return collections that can be iterated in the sorted order.
This interface is a Set that sorts its elements and guarantees that its iterator( ) method returns an Iterator that enumerates the elements of the set in sorted order.
As with the Set interface, it is conventional for all implementations of SortedSet to provide a noargument constructor that creates an empty set and a copy constructor that expects.
Furthermore, when creating a SortedSet, there should be a way to specify a Comparator object that compares and sorts the elements of the set.
If no Comparator is specified, the elements of the set must all implement java.lang.Comparable so they can be sorted in their natural order.
SortedSet defines a few methods in addition to those it inherits from the Set interface.
Note that all three methods return a SortedSet that is implemented as a view onto the original SortedSet.
Changes in the original set are visible through the returned set and vice versa.
In Java 1.2, you can instead use a LinkedList as a stack.
When a StringTokenizer is instantiated with a String, it breaks the string up into tokens separated by any of the characters in the specified string of delimiters.
For example, words separated by space and tab characters are tokens.) The hasMoreTokens( ) and nextToken( ) methods obtain the tokens in order.
StringTokenizer implements the Enumeration interface, so you may also access the tokens with the familiar hasMoreElements( ) and nextElement( ) methods.
When you create a StringTokenizer, you can specify a string of delimiter characters to use for the entire string, or you can rely on the default whitespace delimiters.
You can also specify whether the delimiters themselves should be returned as tokens.
Finally, you can optionally specify a new string of delimiter characters when you call nextToken( )
This class implements a timer: its methods allow you to schedule one or more runnable TimerTask objects to be executed (once or repetitively) by a background thread at a specified time in the future.
You can create a timer with the Timer( ) constructor.
The no-argument version of this constructor creates a regular non-daemon background thread, which means that the Java VM will not terminate while the timer thread is running.
Pass true to the constructor if you want the background thread to be a daemon thread.
In Java 5.0 you can also specify the name of the background thread when creating a Timer.
Once you have created a Timer, you can schedule TimerTask objects to be run in the future with the various schedule( ) and scheduleAtFixedRate( ) methods.
To schedule a task for a single execution, use one of the two-argument schedule( ) methods and specify the desired execution time either as a number of milliseconds in the future or as an absolute Date.
If the number of milliseconds is 0, or if the Date object represents a time already passed, the task is scheduled for immediate execution.
To schedule a repeating task, use one of the three-argument versions of schedule( ) or scheduleAtFixedRate( )
These methods are passed an argument that specifies the time (either as a number of milliseconds or as a Date object) of the first execution of the task and another argument, period, that specifies the number of milliseconds between repeated executions of the task.
The schedule( ) methods schedule the task for fixedinterval execution.
That is, each execution is scheduled for period milliseconds after the previous execution ends.
Use schedule( ) for tasks such as animation, where it is important to have a relatively constant interval between executions.
The scheduleAtFixedRate( ) methods, on the other hand, schedule tasks for fixed-rate execution.
That is, each repetition of the task is scheduled for period milliseconds after the previous execution begins.
Use scheduleAtFixedRate( ) for tasks, such as updating a clock display, that must occur at specific absolute times rather than at fixed intervals.
A single Timer object can comfortably schedule many TimerTask objects.
Note, however, that all tasks scheduled by a single Timer share a single thread.
If you are scheduling many rapidly repeating tasks, or if some tasks take a long time to execute, other tasks may have their scheduled executions delayed.
When you are done with a Timer, call cancel( ) to stop its associated thread from running.
This is particularly important when you are using a timer whose associated thread is not a daemon thread, because otherwise the timer thread can prevent the Java VM from exiting.
To cancel the execution of a particular task, use the cancel( ) method of TimerTask.
This abstract Runnable class represents a task that is scheduled with a Timer object for one-time or repeated execution in the future.
You can define a task by subclassing TimerTask and implementing the abstract run( ) method.
Schedule the task for future execution by passing an instance of your subclass to one of the schedule( ) or scheduleAtFixedRate( ) methods of Timer.
The Timer object will then invoke the run( ) method at the scheduled time or times.
Call cancel( ) to cancel the one-time or repeated execution of a TimerTask( )
This method returns true if a pending execution was actually canceled.
It returns false if the task has already been canceled, was never scheduled, or was scheduled for one-time execution and has already been executed.
Some tasks may choose to do nothing if they are not invoked on time.
The run( ) method can compare the return values of scheduledExecutionTime( ) and System.currentTimeMillis( ) to determine whether the current invocation is sufficiently timely.
The TimeZone class represents a time zone; it is used with the Calendar and DateFormat classes.
Instead, you should call the static getDefault( ) method to obtain a TimeZone object that represents the time zone inherited from the host operating system.
Or you can call the static getTimeZone( ) method with the name of the desired zone.
You can obtain a list of the supported time-zone names by calling the static getAvailableIDs( ) method.
Once you have a TimeZone object, you can call inDaylightTime( ) to determine whether, for a given Date, daylight-savings time is in effect for that time zone.
Call getID( ) to obtain the name of the time zone.
Call getOffset( ) for a given date to determine the number of milliseconds to add to GMT to convert to the time zone.
Returned By java.text.DateFormat.getTimeZone( ), Calendar.getTimeZone( ), GregorianCalendar.getTimeZone( ), javax.xml.datatype.XMLGregorianCalendar.getTimeZone( )
Signals that an AWT component, JavaBeans component, or Swing component can have only one EventListener object registered for some specific type of event.
That is, it signals that a particular event is a unicast event rather than a multicast event.
This exception type serves a formal purpose in the Java event model; its presence in the throws clause of an EventListener registration method (even if the method never actually throws the exception) signals that an event is a unicast event.
This class implements the SortedMap interface using an internal Red-Black tree data structure and guarantees that the keys and values of the mapping can be enumerated in ascending order of keys.
The objects used as keys in a TreeMap must all be mutually Comparable, or an appropriate Comparator must be provided when the TreeMap is created.
Because TreeMap is based on a binary tree data structure, the get( ), put( ), remove( ), and containsKey( ) methods operate in relatively efficient logarithmic time.
If you do not need the sorting capability of TreeMap, however, use HashMap instead, as it is even more efficient.
See Map and SortedMap for details on the methods of TreeMap.
In order for a TreeMap to work correctly, the comparison method from the Comparable or Comparator interface must be consistent with the equals( ) method.
That is, the equals( ) method must compare two objects as equal if and only if the comparison method also indicates those two objects are equal.
If you are working in a multithreaded environment, you must explicitly synchronize all code that modifies the TreeMap, or obtain a synchronized wrapper with Collections.synchronizedMap( )
This class implements SortedSet, provides support for all optional methods, and guarantees that the elements of the set can be enumerated in ascending order.
In order to be sorted, the elements of the set must all be mutually Comparable objects, or they must all be compatible with a Comparator object that is specified when the TreeSet is created.
TreeSet is implemented on top of a TreeMap, so its add( ), remove( ), and contains( ) methods all operate in relatively efficient logarithmic time.
If you do not need the sorting capability of TreeSet, however, use HashSet instead, as it is significantly more efficient.
In order for a TreeSet to operate correctly, the Comparable or Comparator comparison method must be consistent with the equals( ) method.
If you are working in a multithreaded environment, you must explicitly synchronize code that modifies the contents of the set, or obtain a synchronized wrapper with Collections.synchronizedSet( )
An IllegalFormatException of this type is thrown by a Formatter when an unknown conversion specifier is included in a format string.
An IllegalFormatException of this type is thrown by a Formatter when unknown flags are specified in a format string.
This class is an immutable representation of 128-bit Universal Unique Identifier, or UUID, which serves as an identifier that is (with very high probability) globally unique.
Create a UUID based on random bits with the randomUUID( ) factory method.
Create a UUID based on the MD5 hash code of an array of bytes with the nameUUIDFromBytes( ) factory method.
Or create a UUID by parsing a string with the fromString( ) factory method.
The toString( ) method converts a UUID object to a string using this standard format.
You can also create a UUID object by explicitly passing the 128 bits in the form of two long values to the UUID( ) constructor, but this option should be used only if you are intimately familiar with the relevant UUID standards.
The toString( ) and equals( ) methods define the most common operations on a UUID.
The UUID class implements the Comparable interface and defines an ordering for UUID objects.
Note, however, that the ordering does not represent any meaningful property, such as generation order, of the underlying bits.
Various accessor methods provide details about the bits of a UUID, but these details are rarely useful.
Note that the UUID class does not provide a factory method for creating a time-based UUID.
In Java 1.2, Vector has been modified to implement the List interface.
Unless the synchronized methods of the Vector class are actually needed, ArrayList is preferred in Java 1.2 and later.
The type variable E represents the type of the elements of the vector.
Vector is useful when you need to keep track of a number of objects, but do not know in advance how many there will be.
Use setElementAt( ) to set the object at a given index of a Vector.
Use elementAt( ) to retrieve the object stored at a specified index.
Call add( ) to append an object to the end of the Vector or to insert an object at any specified position.
Use removeElementAt( ) to delete the element at a specified index or removeElement( ) to remove a specified object from the vector.
Vector automatically resizes its internal storage for you, but if you know in advance how many objects a Vector will contain, you can increase its efficiency by pre-allocating this many elements with ensureCapacity( )
It is similar in features and performance to HashMap, except that it uses the capabilities of the java.lang.ref package, so that the key-to-value mappings it maintains do not prevent the key objects from being reclaimed by the garbage collector.
When there are no more references to a key object except for the weak reference maintained by the WeakHashMap, the garbage collector reclaims the object, and the WeakHashMap deletes the mapping between the reclaimed key and its associated value.
If there are no references to the value object except for the one maintained by the WeakHashMap, the value object also becomes available for garbage collection.
Thus, you can use a WeakHashMap to associate an auxiliary value with an object without preventing either the object (the key) or the auxiliary value from being reclaimed.
See HashMap for a discussion of the implementation features of this class.
See Map for a description of the methods it defines.
It is less useful with key objects of type String, for example, because there can be multiple String objects that are equal to one another and, even if the original key value has been reclaimed by the garbage collector, it is always possible to pass a String with the same value to the get( ) method.
This package includes a number of powerful utilities for multithreaded programming.
These classes achieve threadsafety without relying exclusively on synchronized methods, greatly increasing the number of threads that can safely use them concurrently.
In addition to these Map, List, Set, and Queue implementations, this package also defines the BlockingQueue interface.
Blocking queues are important in many concurrent algorithms, and this package provides a variety of useful implementations: ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, PriorityBlockingQueue, and SynchronousQueue.
Asynchronous Execution with Thread Pools java.util.concurrent provides a robust framework for asynchronous execution of tasks defined by the existing java.lang.Runnable interface or the new Callable interface.
The Executor, ExecutorService, and ScheduledExecutorService interfaces define methods for executing (or scheduling for future execution) Runnable and Callable tasks.
The Future interface represents the future result of the asynchronous execution of a task.
ThreadPoolExecutor and ScheduledThreadPoolExecutor are executor implementations based on highly configurable thread pools.
The Executors class provides convenient factory methods for obtaining instances of these thread pool implementations.
Synchronizers A number of classes in this package are useful for synchronizing two or more concurrent threads.
This abstract class implements the submit( ), invokeAll( ), and invokeAny( ) methods of the ExecutorService interface.
It does not implement the ExecutorService shutdown methods or the crucial execute( ) method for asynchronous execution of Runnable tasks.
The methods implemented by AbstractExecutorService wrap the submitted Callable or Runnable task in a FutureTask object.
FutureTask implements Runnable and Future, which are first passed to the abstract execute( ) method to be run asynchronously and then returned to the caller.
See ThreadPoolExecutor for a concrete implementation, and see Executors for convenient ExecutorService factory methods.
This BlockingQueue implementation uses an array to store queue elements.
The internal array has a fixed size that is specified when the queue is created, which means that this is a bounded queue and the put( ) method blocks when the queue has no more room.
ArrayBlockingQueue orders its elements on a first-in, first-out (FIFO) basis.
If you pass true as the second argument to the ArrayBlockingQueue constructor, the queue enforces a fairness policy for blocked threads: threads blocked in put( ) or take( ) are themselves queued in FIFO order, and the thread that has been waiting the longest is served first.
This prevents thread starvation but may decrease overall throughput for the ArrayBlockingQueue.
This interface extends the java.util.Queue interface of the Java Collections Framework and adds blocking put( ) and take( ) methods.
Blocking queues are useful in many concurrent algorithms in which a producer thread puts objects onto a queue and a consumer thread removes them for some kind of processing.
The producer thread must block if a bounded queue fills up, and the consumer thread must block if no objects are available on the queue.
In addition to put( ) and take( ) methods that block indefinitely, BlockingQueue also defines timed versions of the Queue methods offer( ) and poll( ) that wait up to the specified time.
The timeout is specified as both a long and a TimeUnit constant.
A variant on this method puts an upper bound on the number of elements removed from the queue.
For bounded queues, this method provides a hint as to whether a call to put( ) will block.
The BlockingQueue interface refines the Collection.add( ) and Queue.offer( ) contracts to indicate that these methods throw NullPointerException if passed a null value.
An exception of this type is thrown when a thread calls CyclicBarrier.await( ) on a broken barrier, or when the barrier is broken while a thread is waiting.
A CyclicBarrier enters a broken state when one of the waiting threads is interrupted or times out.
This interface is a generalized form of the java.lang.Runnable interface.
Unlike the run( ) method of Runnable, the call( ) method of Callable can return a value and throw an Exception.
Callable is a generic type, and the type variable V represents the return type of the call( ) method.
An ExecutorService accepts Callable objects for asynchronous execution and returns a Future object representing the future result of the call( ) method.
An exception of this type is thrown to indicate that the result of a computation cannot be retrieved because the computation was canceled.
The get( ) method of the Future interface may throw a CancellationException, for example.
This interface combines the features of an ExecutorService with the features of a BlockingQueue.
A producer thread may submit Callable or Runnable tasks for asynchronous execution.
As each submitted task completes, its result, in the form of a Future object, becomes available to be removed from the queue by a consumer thread that calls poll( ) or take( )
This generic type declares a type variable V, which represents the result type of all tasks on the queue.
This class is a threadsafe implementation of the java.util.Map interface, and of the atomic operations added by the ConcurrentMap interface.
This class is intended as a drop-in replacement for java.util.Hashtable.
It is more efficient than that class, however, because it provides threadsafety without using synchronized methods that lock the entire data structure.
ConcurrentHashMap allows any number of concurrent read operations without locking.
Locking is required for updates to a ConcurrentHashMap, but the internal data structure is segmented so that only the segment being updated is locked, and reads and writes can proceed concurrently in other segments.
You can specify the number of internal segments with the concurrencyLevel argument to the constructor.
Set this to the approximate number of updater threads you expect to access the data structure.
Like Hashtable, ConcurrentHashMap does not allow null keys or values.
This class is a threadsafe implementation of the java.util.Queue interface (but not of the BlockingQueue interface)
It provides threadsafety without using synchronized methods that would lock the entire data structure.
ConcurrentLinkedQueue is unbounded and orders its elements on a first-in, first-out (FIFO) basis.
Note that the size( ) method must traverse the internal data structure and is therefore a relatively expensive operation for this class.
This interface extends the java.util.Map interface to add four important atomic methods.
As with the Map interface, the type variables K and V represent the types of the mapped keys and values.
There are two versions of the atomic replace( ) method.
The first checks whether the specified value is already mapped to a value.
If so, it replaces the existing mapping with the specified value and returns true.
The three-argument version of replace( ) maps the specified key to the specified new value, but only if the key is currently mapped to the specified old value.
It returns true if the replacement was made and false otherwise.
This class is a threadsafe java.util.List implementation based on an array.
The Iterator of a CopyOnWriteArrayList operates on the copy of the array that was current when the iterator( ) method was called: it does not see any updates that occur after the call to iterator( ) and is guaranteed never to throw ConcurrentModificationException.
Update methods of the Iterator and ListIterator interfaces are not supported and throw UnsupportedOperationException.
CopyOnWriteArrayList defines a few useful methods beyond those specified by the List interface.
Two new indexOf( ) and lastIndexOf( ) methods are defined that specify a starting index for the search.
These provide a convenient alternative to using a subList( ) view when searching for repeated matches in a list.
This class is a threadsafe java.util.Set implementation based on the CopyOnWriteArrayList class.
Because the data structure uses copyon-write, the class is best suited to cases where read operations and traversals greatly outnumber update operations.
Iteration over the members of the set is efficient, and the Iterator returned by iterator( ) never throws ConcurrentModificationException.
All threads that call await( ) block until the countDown( ) method is invoked a specified number of times.
The required number of calls is specified when the CountDownLatch is created.
Once countDown( ) has been called the required number of times, all threads blocked in await( ) are allowed to resume, and any subsequent calls to await( ) do not block.
Note that there is no way to reset the count.
Once a CountDownLatch has “latched,” it remains in that state forever.
Create a new CountDownLatch if you need to synchronize another group of threads.
This class synchronizes a group of n threads, where n is specified to the CyclicBarrier( ) constructor.
Threads call the await( ) method, which blocks until n threads are waiting.
In the simple case, all n threads are then allowed to proceed, and the CyclicBarrier resets itself until it has another n threads blocked in await( )
More complex behavior is possible if you pass a Runnable object to the CyclicBarrier constructor.
This Runnable is typically used to perform some sort of coordinating action on the blocked threads.
When the run( ) method returns, the CyclicBarrier allows all blocked threads to resume.
When threads resume from await( ), the return value of await( ) is an integer that represents the order in which they called await( )
This is useful if you want to be able to distinguish between otherwise identical worker threads.
For example, you might have the thread that arrived first perform some special action while the remaining threads resume.
If any thread times out or is interrupted while blocked in await( ), the CyclicBarrier is said to be “broken,” and all waiting threads (and any threads that subsequently call await( )) wake up with a BrokenBarrierException.
Waiting threads also receive a BrokenBarrierException if the CyclicBarrier is reset( )
The reset( ) method is the only way to restore a broken barrier to its initial state.
This is difficult to coordinate properly, however, unless one controller thread is coded differently from the other threads at the barrier.
An object that implements this interface has an associated delay.
Typically, it is some kind of task, such as a Callable, that has been scheduled to execute at some future time.
If no time remains, getDelay( ) should return zero or a negative value.
This BlockingQueue implementation restricts its elements to instances of some class E that implements the Delay interface.
Elements on the queue are ordered by the amount of delay remaining.
The element whose getDelay( ) method returns the smallest value is the first to be removed from the queue.
No element may be removed, however, until its getDelay( ) method returns zero or a negative number.
This class allows two threads to rendezvous and exchange data.
This is a generic type, and the type variable V represents the type of data to be exchanged.
Each thread should call exchange( ) and pass the value of type V that it wants to exchange.
The first thread to call exchange( ) blocks until the second thread calls it.
Both threads receive as their return value the object of type V passed by the other thread.
Note that this class also defines a timed version of exchange( ) that throws a TimeoutException if no exchange occurs within the specified timeout interval.
Unlike a CountDownLatch, which is a one-shot latch, and CyclicBarrier which can be “broken,” an Exchanger may be reused for any number of exchanges.
An exception of this type is like a checked wrapper around an arbitrary exception thrown while executing a task.
The get( ) method of a Future object, for example, throws an ExecutionException if the call( ) method of a Callable throws an exception.
Use the Throwable.getCause( ) method to obtain the exception object that the ExecutionException wraps.
A variety of implementations are possible for the execute( ) method.
An implementation might simply synchronously invoke the run( ) method of the specified Runnable.
Another implementation might create and start a new thread for each Runnable object it is passed.
Another might select an existing thread from a thread pool to run the Runnable or queue the Runnable for future execution when a thread becomes available.
ExecutorService extends this interface with methods to execute Callable tasks and methods for canceling tasks.
ThreadPoolExecutor is an ExecutorService implementation that creates a configurable thread pool.
Finally, the Executors class defines a number of factory methods for easily obtaining ExecutorService instances.
This class implements the CompletionService interface, which uses an Executor object passed to its constructor for executing the tasks passed to its submit( ) method.
As these tasks complete, their result (or exception) is placed, in the form of a Future object, on an internal queue and becomes available for removal with the blocking take( ) method or the nonblocking or timed poll( ) methods.
This class is useful when you want to execute a number of tasks concurrently and want to process their results in whatever order they complete.
See Executors for a source of Executor objects to use with this class.
This utility class defines static factory methods for creating ExecutorService and ScheduledExecutorService objects.
Each of the factory methods has a variant that allows you to explicitly specify a ThreadFactory.
ExecutorService that uses a thread pool with the specified number of threads and an unbounded queue.
When a task terminates, its thread is cached for reuse.
Cached threads are allowed to terminate if they remain unused for 60 seconds.
The factory methods of this class typically return instances of ThreadPoolExecutor and ScheduledThreadPoolExecutor.
If the returned objects are cast to these implementing types, they can be configured (to change the thread pool size, for example)
If you want to prevent this from happening, use the unconfigurableExecutorService( ) and unconfigurableScheduledExecutorService( ) methods to obtain wrapper objects that implement only the ExecutorService and ScheduledExecutorService methods and do not permit configuration.
Other methods of this class include callable( ), which returns a Callable object wrapped around a Runnable and an optional result, and defaultThreadFactory( ), which returns a basic ThreadFactory object.
Executors also define methods related to access control and the Java security system.
A variant of the callable( ) method wraps a Callable around a java.security.PrivilegedAction.
When passed a Callable in this way, it returns a new Callable that can be used later to invoke the original callable in a privileged access control context, granting it permissions that it would not otherwise have.
This interface extends Executor to add methods to obtain a Future result of the asynchronous execution of a Callable task.
It also adds methods for graceful termination or shutdown of an ExecutorService.
ThreadPoolExecutor is a useful and highly configurable implementation of this interface.
An easy way to obtain instances of this class is through the factory methods of the Executors utility class.
Note that ExecutorService is not a generic type; it does not declare any type variables.
It does have a number of generic methods, however, that use the type variable T to represent the result type of Callable and Future objects.
The submit( ) method allows you to submit a Callable<T> object to an ExecutorService for execution.
Typical ExecutorService implementations invoke the call( ) method of the Callable on another thread, and the return value (of type T) of the method is therefore not available when the call to submit( ) returns.
Two variants on the submit( ) method accept a java.lang.Runnable task instead of a Callable task.
The run( ) method of a Runnable has no return value, so the two-argument version of submit( ) accepts a dummy return value of type T and returns a Future<T> that makes this dummy value available when the Runnable has completed running.
The other Runnable variant of the submit( ) method takes no return value and returns a Future<?> value.
The get( ) method of this Future object returns null when the Runnable is done.
It executes them and blocks until all have completed, or until an optionally specified timeout has elapsed.
Note that a Callable<T> task can complete either by returning a result of type T or by throwing an exception.
It blocks until any one of these Callable tasks has returned a value of type T and returns that value.
If all tasks throw an exception, invokeAny( ) throws an ExecutionException.
Before invokeAny( ) returns, it cancels the execution of any still-running Callable tasks.
Like invokeAll( ), invokeAny( ) has a variant with a timeout value.
ExecutorService defines several methods for gracefully shutting down the service.
Once this has occurred, the isTerminated( ) method returns true.
The shutdownNow( ) method shuts down an ExecutorService more abruptly: it attempts to abort all currently executing tasks (typically via Thread.interrupt( )) and returns a List of the tasks that have not yet started executing.
This interface represents the result of a computation that may not be available until some time in the future.
Future is a generic type, with a type variable V.
The key method of the Future interface is get( )
It returns the result (of type V) of the computation, blocking, if necessary, until that result is ready.
If the computation throws an exception of its own (as the Callable.call( ) method can), get( ) throws an ExecutionException wrapped around that exception.
Additionally, the timed version of the get( ) method throws a TimeoutException if the timeout elapses before the computation completes.
As noted above, the computation represented by a Future object can be canceled by calling its cancel( ) method.
This method returns true if the computation was canceled successfully, and false otherwise.
If you pass false to cancel( ), any computation that has started running is allowed to complete.
In this case, only computations that have not yet started can be canceled.
If you pass true to the cancel( ) method, running computations are interrupted with Thread.interrupt( )
Note, however, that interrupting a thread does not guarantee that it will stop running.
This may be because it returned a value, threw an exception, or was canceled.
If isDone( ) returns true, the get( ) method does not block.
This class is a Runnable wrapper around a Callable object (or around another Runnable)
FutureTask is a generic type and the type variable V represents the return type of the wrapped Callable object.
AbstractExecutorService uses FutureTask to convert Callable objects passed to the submit( ) method into Runnable objects it can pass to the execute( ) method.
FutureTask also implements the Future interface, which means that the get( ) method waits for the run( ) method to complete and provides access to the result (or exception) of the Callable’s execution.
The protected methods set( ) and setException( ) are invoked when the Callable returns a value or throws an exception.
Subclasses can override any of these methods to insert hooks for notification, logging, and so on.
This threadsafe class implements the BlockingQueue interface based on a linked-list data structure.
You may specify a maximum queue capacity, creating a bounded queue.
It is an unbounded queue that orders its elements according to a Comparator, or, for Comparable elements, according to their compareTo( ) method.
The head of the queue (the next element to be removed) is always the smallest element.
Note that the Iterator returned by the iterator( ) method is not guaranteed to return elements in this order.
An exception of this type is thrown by an Executor when it cannot accept a task for execution.
When a ThreadPoolExecutor cannot accept a task, it attempts to invoke a RejectedExecutionHandler.
ThreadPoolExecutor defines several nested implementations of that handler interface that can handle the rejected task without throwing an exception of this type.
This interface defines an API for a handler method invoked by a ThreadPoolExecutor when its execute( ) method cannot accept any more Runnable objects.
This can occur when both the thread pool and the queue of waiting tasks is full, or when the ThreadPoolExecutor has been shut down.
Register an instance of this class with the setRejectedExecutionHandler( ) method of ThreadPoolExecutor.
ThreadPoolExecutor includes several predefined implementations of this interface as static member classes.
If the rejectedExecution( ) method cannot arrange for the Runnable to be run and does not wish to simply discard that task, it should throw a RejectedExecutionException which propagates up to the caller that submitted the task for execution.
This interface extends Executor and ExecutorService to add methods for scheduling Callable or Runnable tasks for future execution on a one-time basis or a repeating basis.
The schedule( ) methods schedule a Callable or a Runnable task for one-time execution after a specified delay.
The delay is specified by a long plus a TimeUnit.
This is like a Future<V> object but also implements the Delay interface so you can call getDelay( ) to find out how much time remains before execution begins.
If you schedule( ) a Runnable object, the result is a ScheduledFuture<?>
Since a Runnable has no return value, the get( ) method of this ScheduledFuture returns null, but the cancel( ), getDelay( ), and isDone( ) methods remain useful.
ScheduledExecutorService provides two alternatives for scheduling Runnable tasks for repeated execution.
See also java.util.Timer, which has similar methods.) scheduleAtFixedRate( ) begins the first execution of the Runnable after initialDelay time units, and begins subsequent executions at multiples of period time units after that.
This means that the Runnable runs at a fixed rate, regardless of how long each execution takes.
But it waits for this first execution (and all subsequent executions) to complete before scheduling the next execution for delay time units in the future.
Both methods return a ScheduledFuture object that you can use to cancel( ) the repeated execution of tasks.
If the task is not canceled, the ScheduledExecutorService runs it repeatedly until the service is shut down (see ExecutorService) or the Runnable throws an exception.
This interface extends Future and Delayed and adds no methods of its own.
A ScheduledFuture represents a computation and the future result of that computation just as Future does, but it adds a getDelay( ) method that returns the amount of time until the computation begins.
This class extends ThreadPoolExecutor to implement the methods of the ScheduledExecutorService interface to allow tasks to be submitted for execution once or repeatedly at some scheduled time in the future.
Instances of this class are usually obtained through the static factory methods of the Executors utility class.
You can also explicitly create one with the ScheduledThreadPoolExecutors( ) constructor.
ScheduledThreadPoolExecutor always creates its own unbounded work queue, which means that you cannot pass a queue to the constructor.
Also, there is no need to specify a maximumPoolSize since this configuration parameter is irrelevant with unbounded queues.
Note that tasks submitted to a ScheduledThreadPoolExecutor are not guaranteed to run at the scheduled time.
That is the time at which they first become eligible to run.
If all threads are busy with other tasks, however, eligible tasks may get queued up to run later.
This class provides functionality similar to java.util.Timer but adds multithreaded capability and the ability to work with Callable and Future objects.
This class implements semaphores, a classic thread synchronization primitive that can be used to implement mutual exclusion and wait/notify-style thread synchronization.
A Semaphore maintains some fixed number (specified when the Semaphore( ) constructor is called) of permits.
The acquire( ) method blocks until a permit is available, then decrements the number of available permits and returns.
The release( ) method does the reverse: it increments the number of permits, possibly unblocking a thread waiting in acquire( )
If you pass true as the second argument to the Semaphore( ) constructor, the semaphore treats waiting threads fairly by placing them on a FIFO queue in the order they called acquire( ) and granting permits to the threads in this order.
This BlockingQueue implementation is the degenerate case of a bounded queue with a capacity of zero.
Every call to put( ) blocks until a corresponding call to take( ), and vice versa.
You can think of this as an Exchanger that does only a one-way exchange.
The size( ) and remainingCapacity( ) methods always return 0
The iterator( ) method returns an Iterator for which the hasNext( ) method returns false.
An instance of this interface is an object that creates Thread objects to run Runnable objects.
You might define a ThreadFactory if you want to set the priority, name, or ThreadGroup of the threads used by a ThreadPoolExecutor, for example.
A number of the factory methods of the Executors utility class rely on ThreadPoolExecutor and accept a ThreadFactory argument.
This class implements the ExecutorService interface to execute tasks using a highly configurable thread pool.
The easiest way to instantiate this class is through the static factory methods of the Executors class.
If you want a more highly configured thread pool, you can instantiate it directly.
Four configuration parameters must be passed to every ThreadPoolExecutor( ) constructor; two others are optional.
Many of these parameters may also be queried and adjusted after the executor has been created through various ThreadPoolExecutor accessor methods.
The most important configuration parameters specify the size of the thread pool, and the queue that the executor uses to hold tasks that it cannot currently run.
As tasks are submitted to the ThreadPoolExecutor, a new thread is created for each task until the total number of threads reaches this size.
If corePoolSize threads have already been created, newly submitted tasks are placed on the work queue.
As these core threads finish the tasks they are executing, they take( ) a new task from the work queue.
You must specify the workQueue when you call the ThreadPoolExecutor( ) constructor.
It may be any BlockingQueue object and the behavior of the thread pool depends strongly on the behavior of the queue you specify.
Options include an unbounded LinkedBlockingQueue, a bounded ArrayBlockingQueue with a capacity of your choosing, or even a SynchronousQueue which has a capacity of zero and cannot actually accept a task unless a thread is already waiting to execute it.
If the work queue becomes empty, it is inefficient to leave all the core threads sitting idly waiting for work.
You specify this time with the keepAliveTime parameter and a TimeUnit constant.
If the work queue fills up, the maximumPoolSize parameter comes into play.
ThreadPoolExecutor prefers to maintain corePoolSize threads but allows this number to grow up to maximumPoolSize.
A new thread is created only when the workQueue is full.
If you specify an unbounded work queue, maximumPoolSize is irrelevant because the queue never fills up.
If on the other hand you specify a SynchronousQueue (which is always full), if none of the existing threads are waiting for a new task, a new thread is always created (up to the maximumPoolSize limit)
If a ThreadPoolExecutor has already created the maximum number of threads and its work queue is full, it must reject any newly submitted tasks.
You can alter this behavior by specifying a RejectedExecutionHandler object to the ThreadPoolExecutor( ) constructor or with the setRejectedExecutionHandler( ) method.
The four inner classes of this class are implementations of four handlers that address this case.
The final way that you can customize a ThreadPoolExecutor is to pass ThreadFactory to the constructor or to the setThreadFactory( ) method.
If you do not specify a factory, the ThreadPoolExecutor obtains one with Executors.defaultThreadFactory( )
This RejectedExecutionHandler implementation runs the rejected Runnable object directly in the calling thread, causing that thread to block until the Runnable completes.
If the ThreadPoolExecutor has been shut down, the Runnable is simply discarded instead of being run.
This RejectedExecutionHandler implementation discards the rejected Runnable if the ThreadPoolExecutor has been shut down.
Otherwise, it discards the oldest pending task that has not run and tries again to execute( ) the rejected task.
An exception of this type is thrown by timed methods to indicate that the specified timeout has elapsed.
Other timed methods are able to indicate their timeout status in a boolean or other return value.
The constants defined by this enumerated type represent granularities of time.
Timeout and delay specifications throughout the java.util.concurrent package are specified by a long value and TimeUnit constant that specifies the interpretation of that value.
TimeUnit defines conversion methods that convert values expressed in one unit to values in another unit.
More interestingly, it defines convenient alternatives to Thread.sleep( ), Thread.join( ), and Object.wait( )
This package includes classes that provide atomic operations on boolean, integer, and reference values.
Instances of the classes defined here have the properties of volatile fields but also add atomic operations like the canonical compareAndSet( ), which verifies that the field holds an expected value, and, if it does, sets it to a new value.
The classes also define a weakCompareAndSet( ) method that may be more efficient than compareAndSet( ) but may also fail to set the value even when the field holds the expected value.
The “Array” classes provide atomic access to arrays of values and provide volatile access semantics for array elements, which is not possible with the volatile modifier itself.
The “FieldUpdater” classes use reflection to provide atomic operations on a named volatile field of an existing class.
The AtomicMarkableReference class and AtomicStampedReference class maintain a reference value and an associated boolean or int value and allow the two values to be atomically manipulated together.
These classes can be useful in concurrent algorithms that detect concurrent updates with version numbering, for example.
Most implementations of this package rely on low-level atomic instructions in the underlying CPU and perform atomic operations without the overhead of locking.
In addition to the get( ) and set( ) iterators, it provides atomic compareAndSet( ), weakCompareAndSet( ), and getAndSet( ) operations.
It extends java.lang.Number, but unlike the Integer class, it is mutable.
Access the int value with the get( ) method and the various methods inherited from Number.
You can set the value with the set( ) method or through various atomic methods.
In addition to the basic compareAndSet( ) and weakCompareAndSet( ) methods, this class defines methods for atomic pre-increment, post-increment, pre-decrement and post-decrement operations as well as generalized addAndGet( ) and getAndAdd( ) methods.
It provides threadsafe access to the array elements, treating each as if it was a volatile field, and defines atomic operations on them.
The methods of this class are like those of AtomicInteger, except that each has an additional parameter that specifies the array index.
This class uses java.lang.reflect to provide atomic operations for named volatile int fields within existing types.
Obtain an instance of this class with the newUpdater( ) factory method.
Pass the name of the field (which must have been declared volatile int) to be updated and the class that it is defined within to this factory method.
This is a generic type, and the type variable T represents the type whose volatile int field is being updated.
This threadsafe class holds a mutable long value and defines atomic operations on that value.
It behaves just like AtomicInteger, with the substitution of long for int.
This threadsafe class provides atomic operations for an array of long values.
See AtomicIntegerArray, which offers the equivalent operations for int arrays.
This class uses java.lang.reflect to define atomic operations for named volatile long fields of a specified class.
This threadsafe class holds a mutable reference to an object of type V and also holds a mutable boolean value or “mark.” It defines atomic operations and volatile access semantics for the reference and the mark.
The set( ) method unconditionally sets the reference and mark value.
The get( ) method queries both, returning the reference as its return value, and storing the current value of the mark in element 0 of the specified boolean array.
The reference and mark can also be queried individually (and nonatomically) with getReference( ) and isMarked( )
The atomic compareAndSet( ) and weakCompareAndSet( ) methods take expected and new values for both the reference and the mark, and neither is set to its new value unless both match their expected values.
Like weakCompareAndSet( ), this method may fail spuriously, even if the reference does equal the expected value.
Repeated invocation eventually succeeds, however, as long as the expected value is correct, and other threads are not continuously changing the reference value.
This threadsafe class holds a mutable reference to an object of type V, provides volatile access semantics, and defines atomic operations for manipulating that value.
This threadsafe class holds an array of elements of type E.
It provides volatile access semantics for these array elements and defines atomic operations for manipulating them.
Its methods are like those of AtomicReference with the addition of a parameter that specifies the array index of the desired element.
This threadsafe class uses java.lang.reflect to provide atomic operations for a named volatile field of type V within an object of type T.
Its instance methods are like those of AtomicReference and the static newUpdater( ) factory method is like that of AtomicIntegerFieldUpdater.
This threadsafe class holds a mutable reference to an object of type V and also holds a mutable int value or “stamp.” It defines atomic operations and volatile access semantics for the reference and the stamp.
This package defines Lock and associated Condition interfaces as well as concrete implementations (such as ReentrantLock) that provide an alternative to locking with synchronized blocks and methods and to waiting with the wait( ), notify( ), and notifyAll( ) methods of Object.
Although Lock and Condition are somewhat more complex to use than the built-in locking, waiting, and notification mechanisms of Object, they are also more flexible.
A thread waiting to acquire a Lock can time out or be interrupted, which is not possible with synchronized locking.
Also, more than one Condition can be associated with a given Lock, which is simply not possible with Object-based locking and waiting.
The ReadWriteLock interface and its ReentrantReadWriteLock implementation allow multiple concurrent readers but only a single writer thread to hold the lock.
A concrete subclass can be used as a helper class for implementing the Lock interface or for implementing synchronizer utilities like the CountDownLatch class of java.util.concurrent.
Subclasses must define tryAcquire( ), tryRelease( ), tryAcquireShared( ), tryReleaseShared( ), and isHeldExclusively.
This class implements the Condition interface and is suitable for use with an AbstractQueuedSynchronizer.
This interface defines an alternative to the wait( ), notify( ), and notifyAll( ) methods of java.lang.Object.
Obtain a Condition with the newCondition( ) method of Lock.
The no-argument version of await( ) is the simplest: it blocks until the thread is signaled or interrupted.
The other three waiting methods are timed waits: they all wait until signaled, interrupted, or until the specified time elapses.
It returns zero or a negative number if the timeout elapses.
If it wakes up because of a signal (or because of a spurious wakeup), it returns an estimate of the time remaining in the timeout.
If it turns out that the thread needs to continue waiting, this return value can be used as the new timeout value.
The signal( ) and signalAll( ) methods are just like the notify( ) and notifyAll( ) methods of Object.
Locking considerations apply to the use of a Condition object just as they apply to the use of the wait( ) and notify( ) methods of Object.
Before a thread can call any of the waiting or signaling methods of a Condition, it must hold the Lock associated with the condition.
When the thread begins waiting, it automatically relinquishes the Lock, and when it awakes because of a signal, timeout, or interrupt, it must reacquire the lock before it can proceed.
A thread is guaranteed to hold the lock when it returns from one of the waiting methods.
Threads waiting on a Condition may wake up spuriously, just as they may when waiting on an Object.
Therefore, calls to wait on a Condition are typically written in the form of a loop so that the desired condition is retested when the thread wakes up.
This interface represents a flexible API for preventing thread concurrency with locking.
The simplest method is lock( ) which blocks indefinitely and uninterruptibly until the lock is acquired.
The no-argument version of tryLock( ) acquires the lock and returns true if the lock is currently available or returns false without blocking if the lock is unavailable.
The two-argument version of tryLock( ) is a timed method: it blocks until it acquires the lock (in which case it returns true), or until the specified timeout elapses (in which case it returns false), or until the thread is interrupted (in which case it throws InterruptedException)
Once a Lock has been acquired, no other thread can acquire it until it is released with the unlock( ) method.
In order to ensure that locks are always released, even in the presence of unanticipated exceptions, it is typical to begin a try block immediately after acquiring the lock and to call unlock( ) from the associated finally clause.
Obtain a Condition object associated with a Lock by calling newCondition( )
See ReentrantLock for a concrete implementation of the Lock interface.
This class provides a low-level alternative to the deprecated methods Thread.suspend( ) and Thread.resume( )
The park( ), parkNanos( ), and parkUntil( ) methods suspend, or park, the thread until it is unparked by another thread with unpark( ), or until it is interrupted by another thread, or until the specified time elapses.
Any call to these parking methods may return spuriously, so it is important to call park( ) in a loop that can repark the thread if it should not have resumed.
Note that while the parking methods affect the current thread, the unpark( ) method affects the thread you specify.
If the specified thread is not parked, the next time that thread calls one of the park( ) methods, it returns immediately instead of blocking.
This interface represents a pair of Lock objects with special locking behavior that is useful for concurrent algorithms in which reader threads frequently access a data structure and writer threads only infrequently modify the structure.
The Lock returned by readLock( ) may be locked by multiple threads at the same time as long as no thread has the writeLock( ) locked.
See ReentrantReadWriteLock for a concrete implementation with implementation-specific locking details.
This class implements the Lock interface and adds instrumentation methods to determine what thread currently holds the lock, to return the number of threads waiting to acquire the lock or waiting on an associated Condition, and to test whether a specified thread is waiting to acquire the lock.
The name of this class includes the term “reentrant” because the thread that holds the lock can call any of the locking methods again, and they return immediately without blocking.
A “fair” lock may be created by passing true to the ReentrantLock( ) constructor.
If you do this, the lock will always be granted to the thread that has been waiting for it the longest.
The locks returned by the readLock( ) and writeLock( ) methods are instances of the inner classes ReadLock and WriteLock.
Any number of threads can acquire the read lock as long as no thread holds or is attempting to acquire the write lock.
When a thread attempts to acquire the write lock, no new read locks are granted.
When all existing readers have relinquished the lock, the writer acquires the lock, and no reads are allowed until the writer has relinquished it.
A thread that holds the write lock may downgrade to a read lock by acquiring the read lock and then relinquishing the write lock.
Because the read lock is not exclusive, it cannot have a Condition associated with it.
Any number of threads can acquire the lock as long as the corresponding WriteLock is not held.
This lock can be acquired only when all holders of the corresponding ReadLock have relinquished the locks.
While this lock is held, no other thread may acquire either this lock or the corresponding ReadLock.
The java.util.jar package contains classes for reading and writing Java archive, or JAR, files.
A JAR file is nothing more than a ZIP file whose first entry is a specially named manifest file that contains attributes and digital signatures for the ZIP file entries that follow it.
Many of the classes in this package are relatively simple extensions of classes from the java.util.zip package.
The easiest way to read a JAR file is with the random-access JarFile class.
This class allows you to obtain the JarEntry that describes any named file within the JAR archive.
It also allows you to obtain an enumeration of all entries in the archive and an InputStream for reading the bytes of a specific JarEntry.
Each JarEntry describes a single entry in the archive and allows access to the Attributes and the digital signatures associated with the entry.
The JarFile also provides access to the Manifest object for the JAR archive; this object contains Attributes for all entries in the JAR file.
Attributes is a mapping of attribute name/value pairs, of course, and the inner class Attributes.Name defines constants for various standard attribute names.
This class requires to you read each entry of the file sequentially, however.
JarOutputStream allows you to write out a JAR file sequentially.
Finally, you can also read an entry within a JAR file and manifest attributes for that entry with a java.net.JarURLConnection object.
This class is a java.util.Map that maps the attribute names of a JAR file manifest to arbitrary string values.
Thus, this class uses Attributes.Name as the type of attribute names, in addition to the more general String class.
Although you can create your own Attributes objects, you more commonly obtain Attributes objects from a Manifest.
This class represents the name of an attribute in an Attributes object.
It defines constants for the various standard attribute names used in JAR file manifests.
Attribute names can contain only ASCII letters, digits, and the hyphen and underscore characters.
This class extends java.util.zip.ZipEntry; it represents a single file in a JAR archive and the manifest attributes and digital signatures associated with that file.
JarEntry objects can be read from a JAR file with JarFile or JarInputStream, and they can be written to a JAR file with JarOutputStream.
Use getAttributes( ) to obtain the Attributes for the entry.
Use getCertificates( ) to obtain a java.security.cert.Certificate array that contains the certificate chains for all digital signatures associated with the file.
In Java 5.0, this digital signature information may be more conveniently retrieved as an array of CodeSigner objects.
Signals an error while reading or writing a JAR file.
This class represents a JAR file and allows the manifest, file list, and individual files to be read from the JAR file.
It extends java.util.zip.ZipFile, and its use is similar to that of its superclass.
Create a JarFile by specifying a filename or File object.
If you do not want JarFile to attempt to verify any digital signatures contained in the JarFile, pass an optional boolean argument of false to the JarFile( ) constructor.
As of Java 1.3, temporary JAR files can be automatically deleted when they are closed.
To take advantage of this feature, pass ZipFile.OPEN_READ|ZipFile.OPEN_DELETE as the mode argument to the JarFile( ) constructor.
Once you have created a JarFile object, obtain the JAR Manifest with getManifest( )
Obtain an enumeration of the java.util.zip.ZipEntry objects in the file with entries( )
Get the JarEntry for a specified file in the JAR file with getJarEntry( )
To read the contents of a specific entry in the JAR file, obtain the JarEntry or ZipEntry object that represents that entry, pass it to getInputStream( ), and then read until the end of that stream.
JarFile does not support the creation of new JAR files or the modification of existing files.
This class allows a JAR file to be read from an input stream.
It extends java.util.ZipInputStream and is used much like that class is used.
To create a JarInputStream, simply specify the InputStream from which to read.
If you do not want the JarInputStream to attempt to verify any digital signatures contained in the JAR file, pass false as the second argument to the JarInputStream( ) constructor.
The JarInputStream( ) constructor first reads the JAR manifest entry, if one exists.
The manifest must be the first entry in the JAR file.
Once you have created a JarInputStream, call getNextJarEntry( ) or getNextEntry( ) to obtain the JarEntry or java.util.zip.ZipEntry object that describes the next entry in the JAR file.
Then, call a read( ) method (including the inherited versions) to read the contents of that entry.
When the stream reaches the end of file, call getNextJarEntry( ) again to start reading the next entry in the file.
When all entries have been read from the JAR file, getNextJarEntry( ) and getNextEntry( ) return null.
This class can write a JAR file to an arbitrary OutputStream.
JarOutputStream extends java.util.zip.ZipOutputStream and is used much like that class is used.
Create a JarOutputStream by specifying the stream to write to and, optionally, the Manifest object for the JAR file.
The JarOutputStream( ) constructor starts by writing the contents of the Manifest object into an appropriate JAR file entry.
It is the programmer’s responsibility to ensure that the contents of the JAR entries written subsequently match those specified in the Manifest object.
This class provides no explicit support for attaching digital signatures to entries in the JAR file.
After creating a JarOutputStream, call putNextEntry( ) to specify the JarEntry or java.util.zip.ZipEntry to be written to the stream.
Then, call any of the inherited write( ) methods to write the contents of the entry to the stream.
When that entry is finished, call putNextEntry( ) again to begin writing the next entry.
When you have written all JAR file entries in this way, call close( )
Before writing any entry, you may call the inherited setMethod( ) and setLevel( ) methods to specify how the entry should be compressed.
This class represents the manifest entry of a JAR file.
You can edit the contents of the Manifest by adding, deleting, or editing entries in the Map.
Obtain a Packer object with the Pack200.newPacker( ) factory method.
Configure the packer before using it by setting properties in the Map returned by the properties( ) method.
The constants defined by this class represent the names (and in some cases values) of properties that can be set.
Pack a JAR file by passing JarFile or JarInputStream to a pack( ) method along with the byte output stream to which the packed representation should be written.
You can monitor the progress of the packer engine by querying the PROGRESS property in the properties( ) map.
Before using an unpacker, you may configure it by setting properties in the Map returned by the properties( ) method.
Unpack a JAR file with the unpack( ) method, specifying a File or stream of packed bytes.
Monitor the progress of the unpacker by querying the PROGRESS key in the Map returned by properties( )
If you want to be notified of changes to the PROGRESS property, register a java.beans.PropertyChangeListener with addPropertyChangeListener( )
Public Instance Methods void pack(JarInputStream in, java.io.OutputStream out) throws java.io.IOException; void pack(JarFile in, java.io.OutputStream out) throws java.io.IOException;
Public Instance Methods void unpack(java.io.InputStream in, JarOutputStream out) throws java.io.IOException; void unpack(java.io.File in, JarOutputStream out) throws java.io.IOException;
The java.util.logging package defines a sophisticated and highly-configurable logging facility that Java applications can use to emit, filter, format, and output warning, diagnostic, tracing and debugging messages.
An application generates log messages by calling various methods of a Logger object.
The content of a log message (with other pertinant details such as the time and sequence number) is encapsulated in a LogRecord object generated by the Logger.
Concrete subclasses of Handler support destinations such as files and sockets.
Most Handler objects have an associated Formatter that converts a LogRecord object into the actual text that is logged.
The subclasses SimpleFormatter and XMLFormatter produce simple plain-text log messages and detailed XML logs respectively.
The Level class defines a type-safe enumeration of defined levels.
Logger and Handler objects both have an associated Level, and discard any log messages whose severity is less than that specified level.
In addition to this level-based filtering, Logger and Handler objects may also have an associated Filter object which may be implemented to filter log messages based on any desired criteria.
Applications that desire complete control over the logs they generate can create a Logger object, along with Handler, Formatter and Filter objects that control the destination, content, and appearance of the log.
Simpler applications need only to create a Logger for themselves, and can leave the rest to the LogManager class.
LogManager reads a systemwide configuration file (or a configuration class) and automatically directs log messages to a standard destination (or destinations) for the system.
In Java 5.0, LoggingMXBean defines an interface for monitoring and management of the logging facility through the javax.management packages (which are beyond the scope of this book)
This Handler subclass formats LogRecord objects and outputs the resulting string to the System.err output stream.
When a ConsoleHandler is created, the various properties inherited from Handler are initialized using system-wide defaults obtained by querying named values with LogManager.getProperty( )
The table below lists these properties, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
An important feature of the Logging API is that the logging methods called by applications never throw exceptions: it is not reasonable to expect programmers to nest all their logging calls within try/catch blocks, and even if they did, there is no useful way for an application to recover from an exception in the logging subsystem.
Since handler classes such as FileHandler are inherently subject to I/O exceptions, the ErrorManager provides a way for a handler to report an exception instead of simply discarding it.
All Handler objects have an instance of ErrorManager associated with them.
If an exception occurs in the handler, it passes the exception, along with a message and one of the error code constants defined by ErrorManager to the error( ) method.
You can of course define subclasses of ErrorManager that override error( ) to provide some other reporting mechanism.
If you do this, register an instance of your custom ErrorManager by calling the setErrorManager( ) method of your Handler.
This Handler subclass formats LogRecord objects and outputs the resulting strings to a file or to a rotating set of files.
Arguments passed to the FileHandler( ) constructor specify which file or files are used, and how they are used.
The arguments are optional, and if they are not specified, defaults are obtained through LogManager.getProperty( ) as described below.
The substitutions performed to convert this pattern to a filename are described below.
If count is set to greater than one, then when a log file reaches this maximum, FileHandler closes it, renames it, and then starts a new log with the original filename.
The pattern argument is the most important of these: it specifies which file or files the FileHandler will write to.
FileHandler performs the following substitutions on the specified pattern to convert it to a filename:
This means that you can always use a forward slash in your patterns, even on Windows filesystems that use backward slashes.
Older files are similarly renamed, with their generation number being incremented.
When the number of log files reaches the number specifed by count, then the oldest file is deleted to make room for the new one.
When a FileHandler is created, the LogManager.getProperty( ) method is used to obtain defaults for any unspecified constructor arguments, and also to obtian initial values for the various properties inherited from Handler.
The table below lists these arguments and properties, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
This interface defines the method that a class must implement if it wants to filter log messages for a Logger or Handler class.
It should return false if the LogRecord should be filtered out not appear in any destination log.
Note that both Logger and Handler provide built-in filtering based on the severity level of the LogRecord.
This Filter interface exists to provide a customized filtering capability.
A Formatter object is used by a Handler to convert a LogRecord to a String prior to logging it.
Most applications can simply use one one of the pre-defined concrete subclasses: SimpleFormatter or XMLFormatter.
Applications requiring custom formatting of log messages will need to subclass this class and define the format( ) method to perform the desired conversion.
Such subclasses may find the formatMessage( ) method useful: it performs localization using java.util.ResourceBundle and formatting using the facilities of the java.text XML tags) for a log file.
A Handler takes LogRecord objects from a Logger and, if their severity level is high enough, formats and publishes them to some destination (a file or socket, for example)
The subclasses of this abstract class support various destinations, and implement destination-specific publish( ), flush( ) and close( ) methods.
In addition to the destination-specific abstract methods, this class also defines concrete methods used by most Handler subclasses.
These are property getter and setter methods to specify the severity Level of logging messages to be handled, an optional Filter, a Formatter to convert log messages from LogRecord objects to text, a text encoding for the output text, and an ErrorManager to handle any exceptions that arise during log output.
Subclass-specific defaults for each of these properties are typically defined as properties of LogManager and are read from a system-wide logging configuration file.
In this case there is no need for the application to ever instantiate or use a Handler directly.
Applications that want custom control over the destination of their logs create and configure an instance of a Handler subclass, but never need to call its publish( ), flush( ) or close( ) methods directly: that is done by the Logger.
This class defines constants that represent the seven standard severity levels for log messages plus constants that turn logging off and enable logging at any level.
When logging is enabled at one severity level, it is also enabled at all higher levels.
The seven level constants, in order from most severe to least severe are: SEVERE, WARNING, INFO, CONFIG, FINE, FINER, and FINEST.
The constant ALL enables logging of any message, regardless of its level.
Note that these constants are all Level objects, rather than integers.
Application code should rarely, if ever, need to use any of the methods of this class: instead they can simply use the constants it defines.
Logger does not have a public constructor, but there are several ways to obtain a Logger object to use in your code:
Typically, applications call the static getLogger( ) method to create or lookup a named Logger within a hierarchy of named loggers.
Loggers have dot-separated hierarchical names, which should be based on the name of the class or package that uses them.
Loggers obtained in this way inherit their logging level, resource bundle (for localization), and Handler objects from their ancestors in the hierarchy and, ultimately, from the root Logger defined by the global LogManager.
Applets that require a Logger with no security restrictions should use the static getAnonymousLogger( ) method to create an unnamed Logger that is not part of the hierarchy of named Logger objects managed by the LogManager.
A Logger created by this method has the LogManager root logger as its parent, and inherits the logging level and handlers of that root logger.
Finally, the static Logger.global field refers to a pre-defined Logger named “global”; programmers may find this pre-defined Logger convenient during the early stages of application development, but it should not be used in production code.
Once a suitable Logger has been obtained, there are a variety of methods that can be used to create a log message:
The log( ) methods log a specified message at the specified level, with optional parameters that can be used in message localization.
These methods examine the call stack and make an attempt to determine the class and method name from which the method is emitted.
Because of code optimization and just-in-time compilation techniques, however, they may not always be able to determine this information.
The logrb( ) methods are like the logp( ) methods, but additionally take the name of a resource bundle to use for localizing the message.
Note that there are variants of entering( ) and exiting( ) that allow specification of method arguments and return values.
Finally, Logger defines a set of easy-to-use convenience methods for logging a simple message at a specific logging level.
These methods have the same names as the logging levels: severe( ), warning( ), info( ), config( ), fine( ), finer( ), finest( )
A Logger has an associated logging Level, and discards any log messages with a severity lower than this.
The severity level is initialized from the system configuration file, which is usually the desired behavior.
You might want to do this if you created the Logger with getAnonymousLogger( ) and have read the desired logging level from a configuration file of your own.
If level-based filtering of log messages is not sufficient, you can associate a Filter with your Logger by calling setFilter.
If you do this, any log messages rejected by the Filter will be discarded.
A Logger sends its log messages to any Handler objects that have been registered with addHandler( )
Call getHandlers( ) to obtain an array of all registered handlers, and call removeHandler( ) to de-register a handler.
By default, all log messages are also sent to the handlers of the parent logger and any other ancestor loggers.
Since all named and anonymous loggers have the LogManager root logger as a parent or ancestor, all loggers by default send their log messages to the handlers defined in the system logging configuration file.
If you do not want a Logger to use the handlers of its ancestors, pass false to setUseParentHandlers( )
If a resource bundle is specified for the Logger or for a specific log message, then the message argument to the various logging methods is treated not as a literal message but instead as a localization key for which a localized version is to be looked up in the resource bundle.
As part of the localization, any parameters, such as those specified by the param1 and params arguments to the log( ) method are substituted into the localized message string as per java.text.MessageFormat.
Note, however that this localization and formatting is not performed by the Logger itself: instead, it simply stores the ResourceBundle and parameters in the LogRecord.
It is the Formatter associated with the output Handler object that actually performs the localization.)
All the methods of this class are threadsafe and do not require external synchronization.
The methods of this class allow the monitoring of all registered loggers and their logging level and allow management to change the logging level of any named logger.
This class is a java.security.Permission that governs the use of security-sensitive logging methods.
The single defined name (or target) for LoggingPermission is “control” which represents permission to invoke various logging control methods such as Logger.setLevel( ) and LogManager.readConfiguration( )
The methods in this package that throw SecurityException all require a LoggingPermission named “control” in order to run.
System adminstrators configuring security policies may need to be familiar with it.
As its name implies, this class is the manager for the java.util.logging API.
This class handles the important behind-the-scenes details that makes the Logging API work.
Typical applications can make use of logging without ever having to use this class explicitly.
Although its API is not commonly used by application programmers, it is still useful to understand the LogManager class, so it is described in detail here.
There is a single global instance of LogManager, which is obtained with the static getLogManager( ) method.
By default, this global log manager object is an instance of the LogManager class itself.
You may instead instantiate an instance of a subclass of LogManager by specifing the full class name of the subclass as the value of the system property java.util.logging.manager.
One of the primary purposes of the LogManager class is to read a java.util.Properties file that specifies the default logging configuration for the system.
By default, this file is named logging.properties and is stored in the jre/lib directory of the Java installation.
If you want to run a Java application using a different logging configuration, you can edit the default configuration file, but it is typically easier to create a new configuation file and tell the JVM about it by setting the system property java.util.logging.config.file to the name of your customized configuration file.
The most important purpose of the configuration file is to specify a set of Handler objects to which all log messages are sent.
This is done by setting the handlers property in the file to a space-separated list of Handler class names.
The LogManager will load the specified classes, and instantiate each one (using the default no-arg constructor), and then register those Handler objects on the root Logger, where they are inherited by all other loggers.
We’ll see more about the root logger below.) Each of these Handler.
The configuration file may also contain property name that are formed by appending “.level” to the name of a logger.
The value of any such property is taken as the name of a logging Level for the named Logger.
When the named logger is created and registered with the LogManager (described below) its logging level is automatically set to the specified level.
An application or any custom Handler or Formatter subclass or Filter implementation can read its own properties from the logging configuration file with the getProperty( ) method of LogManager.
This is a useful way to provide customizability for logging-related classes.
In addition to managing the configuration file properties, a second purpose of LogManager is to maintain a tree of Logger objects organized into a hierarchy based on their dot-separated hierarchical names.
The addLogger( ) method registers a new Logger object with the LogManager and inserts it into the tree.
This method is called automatically by the Logger.getLogger( ) factory method, however, so you never need to call it yourself.
The getLogger( ) method of LogManager finds and returns a named Logger object within the tree.
Use getLoggerNames( ) to obtain an Enumeration of the names of all registered loggers.
At the root of the tree is a root logger, created by the LogManager, and initialized with default Handler objects specified in the logging configuration file as described above.
This root logger has no name, and you can obtain a reference to it by passing the empty string to the getLogger( ) method.
Except for this root logger and anonymous loggers (see Logger.getAnonymousLogger( )), all loggers have names, and they are typically named after the package or class for which they provide logging.
When the LogManager determines the position of a logger within the tree of loggers, it calls the setParent( ) method of the newly-registered Logger to tell it who its parent is.
This is important because, by default, loggers inherit their logging level and handlers from their parent.
Although the Logger.setParent( ) method is public, it is intended for use only by the LogManager class.
Anonymous loggers created with Logger.getAnonymousLogger( ) do not have names, and are not part of the logger tree.
When they are created, however, their parent is set to the root logger of the LogManager.
For this reason, anonymous loggers inherit the default handlers specified in the logging configuration file.
The readConfiguration( ) methods are used to force the LogManager to re-read the system configuration file, or to read a new configuration file from the specified stream.
Both versions of the method generate a java.beans.PropertyChangeEvent and use it to notify any listeners that have been registered with addPropertyChangeListener.
Both methods also first invoke the reset( ) method which discards the properties of the current configuration file, removes and closes all handlers for all loggers, and sets the logging level of all loggers to null, except for the root logger’s logging level, which it sets to Level.INFO.
It is unlikely that you would ever want to invoke reset( ) yourself.
A number of LogManager methods throw a SecurityException if the caller does not have appropriate permissions.
You can use checkAccess( ) to test whether the current calling context has the required LoggingPermission named “control”
All LogManager methods can be safely used by multiple threads.
Instances of this class are used to represent log messages as they are passed between Logger, Handler, Filter and Formatter objects.
LogRecord defines a number of JavaBeans-type property getter and setter methods.
The values of the various properties encapsulate all details of the log message.
The LogRecord( ) constructor takes arguments for the two most constructor also initializes the millis property to the current time, the sequenceNumber property to a unique (within the VM) value that can be used to compare the order of two log messages, and the threadID property to a unique identifier for the current thread.
All other properties of the LogRecord are left uninitialized with their default null values.
A MemoryHandler stores LogRecord objects in a fixed-sized buffer in memory.
When the buffer fills up, it discards the oldest record one each time a new record arrives.
It maintains a reference to another Handler object, and whenever the push( ) method is called, or whenver a LogRecord arrives with a level at or higher than the pushLevel threshold, it “pushes” all of buffered LogRecord objects to that other Handler object, which typically formats and outputs them to some appropriate destination.
Because MemoryHandler never outputs log records itself, it does not use the formatter or encoding properties inherited from its superclass.
When you create a MemoryHandler, you can specify the target Handler object, the size of the in-memory buffer, and the value of the pushLevel property, or you can omit these constructor arguments and rely on system-wide defaults obtained with LogManager.getProperty( )
MemoryHandler also uses LogManager.getProperty( ) to obtain initial values for the level and filter properties inherited from Handler.
The table below lists these properties, as well as the target, size, and pushLevel constructor arguments, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
This Formatter subclass converts a LogRecord object to a human-readable log message that is typically one or two lines long.
This Handler subclass formats LogRecord objects and outputs the resulting strings to a network socket.
When you create a SocketHandler, you can pass the hostname and port of the socket to the constructor or you can rely on system-wide defaults obtained with LogManager.getProperty( )
SocketHandler also uses LogManager.getProperty( ) to obtain initial values for the properties inherited from Handler.
The table below lists these properties, as well as the host and port arguments, the value passed to getProperty( ), and the default value used if getProperty( ) returns null.
This Handler subclass sends log messages to an arbitrary java.io.OutputStream.
It exists primarily to serve as the common superclass of ConsoleHandler, FileHandler, and SocketHandler.
This Formatter subclass converts a LogRecord to an XML-formatted string.
Note however, that if an application terminates abnormally, the logging facility may be unable to terminate the log file with the closing <log> tag.
Protected Instance Methods protected void setOutputStream(java.io.OutputStream out) throws SecurityException;  synchronized.
The java.util.prefs package contains classes and interfaces for managing persistant user and system-wide preferences for Java applications and classes.
Some will also use the event objects and listener interfaces defined by this package, and some may need to explicitly catch the types of exceptions defined by this package.
Application programmers never need to use the PreferencesFactory interface or the AbstractPreferences class, which are intended for Preferences implementors only.
To use the Preferences class, first use a static method to obtain an appropriate Preferences object or objects, and then use a get( ) method to query a preference value or a put( ) method to set a preference value.
Note that we always pass a default value // Look up a user preference using a system preference as the default sysprefs.get("dictionary",
This class implements all the abstract methods of Preferences on top of a smaller set of abstract methods.
Signals that a Preferences method could not complete because of an implementationspecific problem with the preferences database.
The most commonly used methods of the Preferences class do not throw this exception, and are guaranteed to succeed even if the implementation’s preferences data is not available.
Note that although this class inherits the Serializable interface, implementations are not actually required to be serializable.
Note that although this class inherits the Serializable interface, implementations are not actually required to be serializable.
Protected Instance Fields protected final Object lock; protected boolean newNode;
A NodeChangeEvent object is passed to the methods of any NodeChangeListener objects registered on a Preferences object when a child Preferences node is added or removed.
This parent Preferences object is the one on which the NodeChangeListener was registered.
Although this class inherits the Serializable interface, it is not actually serializable.
This interface defines the methods that an object must implement if it wants to be notified when a child preferences node is added to or removed from a Preferences object.
When such an addition or removal occurs, the parent Preferences object passes a NodeChangeEvent object to the appropriate method of any NodeChangeListener objects that have been registered through the Preferences.addNodeChangeListener( ) method.
A PreferenceChangeEvent object is passed to the preferenceChange( ) method of any PreferenceChangeListener objects registered on a Preferences object whenever a preferences value is added to, removed from, or modified in that Preferences node.
If the preference value was added or modified, getNewValue( ) returns that value.
Although this class inherits the Serializable interface, it is not actually serializable.
This interface defines the method that an object must implement if it wants to be notified when a preference key/value pair is added to, removed from, or changed in a Preferences object.
After any such change, the Preferences object passes a PreferenceChangeEvent object describing the change to the preferenceChange( ) method of any PreferenceChangeListener objects that have been registered through the Preferences.addPreferenceChangeListener( ) method.
A Preferences object represents a mapping between preference names, which are casesensitive strings, and corresponding preference values.
The remove( ) method allows you to delete a named preference altogether, and clear( ) deletes all preference values stored in a Preferences object.
The keys( ) method returns an array of strings that specify the names of all preferences in the Preferences object.
Note that all the get( ) methods of this class require a default value to be specified.
They return this default if no value has been stored for the named preference, or if the backing store is unavailable for any reason.
The Preferences class is completely independent of the underlying implementation, except that it enforces an.
To obtain a Preferences object for use in your application, you must must use one of the static methods described below.
Each Preferences object is a node in a hierarchy of Preferences nodes.
There are two distinct hierarchies: one stores user-specific preferences, and one stores system-wide preferences.
All Preferences nodes (in either hierarchy) have a unique name and use the same naming convention that Unix filesystems use.
For example, the preferences node used by java.lang.System would be “/java/lang”
Preferences defines static methods that you can use to obtain the Preferences objects your application requires.
Pass a Class object to systemNodeForPackage( ) and userNodeForPackage( ) to obtain the system and user Preferences objects that are specific to the package of that class.
If you want a Preferences node specific to a single class rather than to the package, you can pass the class name to the node( ) method of the package-specific node returned by systemNodeForPackage( ) or userNodeForPackage( )
If you want to navigate the entire tree of preferences nodes (which most applications never need to do) call systemRoot( ) and userRoot( ) to obtain the root node of the two hierarchies, and then use the node( ) method to look up child nodes of those roots.
Various Preferences methods allow you to traverse the preferences hierarchies.
If the specified node name begins with a slash, it is an absolute name and is interpreted relative to the root of the hierarchy.
Otherwise, it is a relative name and is interpreted relative to the Preferences object on which node( ) was called.
Finally, isUserNode( ) allows you to determine whether a Preferences object is part of the user or system hierarchies.
Many applications will simply read their preference values once at startup.
Long-lived applications or applications that want to respond dynamically to modifications to preferences (such as applications that are tightly integrated with a graphical desktop) may use addPreferenceChangeListener( ) to register a PreferenceChangeListener to recieve notifications of preference changes (in the form of PreferenceChangeEvent objects)
Applications that are interested in changes to the Preferences hierarchy itself can register a NodeChangeListener.
Call flush( ) to force any preference changes to this Preferences node (and any of its descendants in the hierarchy) to be stored persistantly.
Note that it is not necessary to call flush( ) before an application terminates: all preferences will eventually be made persistant.) More than one application (within more than one Java virtual machine) may set preference values in the same Preferences node at the same time.
Call sync( ) to ensure that future calls to get( ) and its related convenience methods retrieve current preference values set by this or other virtual machines.
Note that the flush( ) and sync( ) operations are typically much more expensive than get( ) and put( ) operations, and applications do not often need to use them.
Preferences implementations ensure that all the methods of this class are thread safe.
If multiple threads or multiple VMs write store the same preferences concurrently, their values may overwrite one another, but the preference data will not be corrupted.
Note that, for simplicity, Preferences does not define any way to set multiple preferences in a single atomic transaction.
If you need to ensure atomicity for multiple preference values, define a data format that allows you to store all the requisite values in a single string, and set and query those values with a single call to put( ) or get( )
The contents of a Preferences node, or of a node and all of its descendants may be exported as an XML file with exportNode( ) and exportSubtree( )
The static importPreferences( ) method reads an exported XML file back into the preferences hierarchy.
These methods allow backups to be made of preference data, and allow preferences to be transferred between systems or between users.
Prior to Java 1.4, application preferences were sometimes managed with the java.util.Properties object.
The PreferencesFactory interface defines the factory methods used by the static methods of the Preferences class to obtain the root Preferences nodes for user-specific and system-wide preferences hierarchies.
An implementation of the preferences API for a specific back-end data store must include an implementation of this interface that works with that data store.
Sun’s implementation of Java includes a default filesystem-based implementation, which you can override by specifying the name of a PreferencesFactory implementation as the value of the “java.util.prefs.PreferencesFactory” system property.
This small package provides a facility for textual pattern matching with regular expressions.
Pattern objects represent regular expressions, which are specified using a syntax very close to the one used by the Perl programming language.
The Matcher class encapsulates a Pattern and a java.lang.CharSequence of text, and defines various methods for matching the pattern to the text.
In Java 5.0, the MatchResult interface represents the result of a match.
In addition to the pattern matching methods defined in this package, the java.lang.String class has been augmented in Java 1.4 with a number of convenience methods for matching strings against regular expressions that are specified in their text form as strings, rather than in their compiled form as Pattern objects.
Applications with simple pattern matching needs can use these convenience methods and may never have to directly use the Pattern or Matcher classes.
A Matcher objects encapsulate a regular expression and a string of text (a Pattern and a java.lang.CharSequence) and defines methods for matching the pattern to the text in several different ways, for obtaining details about pattern matches, and for doing search-andreplace operations on the text.
Obtain a Matcher by passing the character sequence to be matched to the matcher( ) method of the desired Pattern object.
You can also reuse an existing Matcher object with a new character sequence (but the same Pattern) by passing a new CharSequence to the matcher’s reset( ) method.
In Java 5.0, you can use a new Pattern object on the current character sequence with the usePattern( ) method.
Once you have created or reset a Matcher, there are three types of comparisons you can perform between the regular expression and the character sequence.
All three comparisons operate on the current region of the character sequence.
In Java 5.0, however, you can set the bound of the region with region( )
The simplest type of comparison is the matches( ) method.
It returns true if the pattern matches the complete region of the character sequence, and returns false otherwise.
The lookingAt( ) method is similar: it returns true if the pattern matches the complete region, or if it matches some subsequence at the beginning of the region.
If the pattern does not match the start of the region, lookingAt( ) returns false.
The find( ) method, on the other hand, has neither of these requirements: it returns true if the pattern matches any part of the region.
As will be described below, find( ) has some special behavior that allows it to be used in a loop to find all matches in the text.
If matches( ), lookingAt( ), or find( ) return true, then several other Matcher methods can be used to obtain details about the matched text.
The MatchResult interface defines the start( ), end( ) and group( ) methods that return the starting position, the ending position and the text of the match, and of any matching subexpressions within the Pattern.
Calling MatchResult methods on a Matcher returns results from the most recent match.
If you want to store these results, call toMatchResult( ) to obtain an indepedent, immutable MatchResult object whose methods can be queried later.
The no-argument version of find( ) has special behavior that makes it suitable for use in a loop to find all matches of a pattern within a region.
The first time find( ) is called after a Matcher is created or after the reset( ) method is called, it starts it search at the beginning of the string.
If it finds a match, it stores the start and end position of the matched text.
If reset( ) is not called in the meantime, then the next call to find( ) searches again but starts the search at the first character after the match: at the position returned by end( )
If the previous call to find( ) matched the empty string, then the next call begins at end( )+1 instead.) In this way, it is possible to find all matches of a pattern within a string simply by calling find( ) repeatedly until it returns false indicating that no match was found.
After each repeated call to find( ) you can use the MatchResult methods to obtain more information about the text that matched the pattern and any of its subpatterns.
It then returns a string that is the character sequence with the matched text replaced with the specified replacement string.
The replacement string passed to replaceFirst( ) and replaceAll( ) is not always replaced literally.
If the replacement contains a dollar sign followed by an integer that is a valid group number, then the dollar sign and the number are replaced by the text that matched the numbered group.
If you want to include a literal dollar sign in the replacement string, preceed it with a backslash.
In Java 5.0, you can use the static quoteReplacement( ) method to properly quote any special characters in a replacement string so that the string will be interpreted literally.
However, Matcher also defines lower-level methods that you can use build up a modified string in a StringBuffer.
The appendReplacement( ) method is designed to be used after a successful call to find( )
It copies all the text between the append position and the character before the start( ) position for the last match into the specified string buffer.
Then it appends the specified replacement text to that string buffer (performing the same substitutions that replaceAll( ) does)
Finally, it sets the append position to the end( ) of the last match, so that a subsequent call to appendReplacement( ) starts at a new character.
When find( ) cannot find another match and returns false, you should complete the replacement operation by calling appendTail( ): this method copies all text between the end( ) position of the last match and the end of the character sequence into the specified StringBuffer.
It erases any saved information about the last match, and restores the Matcher to its initial state so that subsequent calls to find( ) and appendReplacement( ) start at the begining of the character sequence.
The oneargument version of reset( ) also allows you to specify an entirely new character sequence to match against.
It is important to understand that several other Matcher methods call reset( ) themselves before they perform their operation.
They are: matches( ), lookingAt( ), the one-argument version of find( ), replaceAll( ), and replaceFirst( )
Prior to Java 5.0, the region of the input text that a Matcher operates on is the entire character sequence.
In Java 5.0, you can define a different region with the region( ) method, which specifies the position of the first character in the region and the position of the first character after the end of the region.
See Pattern for regular expression grammar details.) Call useAnchoringBounds( ) to turn anchoring bounds on or off in Java 5.0
In Java 5.0, you can make the bounds transparent with useTransparentBounds(true)
Matcher is not threadsafe, and should not be used by more than one thread concurrently.
This interface represents the results of a regular expression matching operation performed by a Matcher.
Matcher implements this interface directly, and you can use the methods defined here to obtain the results of the most recent match performed by a Matcher.
You can also save those most recent match results in a separate immutable MatchResult object by calling the toMatchResult( ) method of the Matcher.
The no-argument versions of the start( ) and end( ) method return the index of the first character that matched the pattern and the index of the last character that matched plus one (the index of the first character following the matched text), respectively.
If this occurs, end( ) returns the same value as start( )
The no-argument version of group( ) returns the text that matched the pattern.
If the matched Pattern includes capturing subexpressions within parentheses, the other methods of this interface provide details about the text that matched each of those subexpressions.
Pass a group number to start( ), end( ), or group( ) to obtain the start, end, or text that matched the specified group.
When there are nested groups, their ordering is based on the position of the opening left parenthesis that begins the group.
It has no public constructor: obtain a Pattern by calling one of the static compile( ) methods, passing the string representation of the regular expression, and an optional bitmask of flags that modify the behavior of the regex.
If you want to perform only a single match operation with a regular expression, and don’t need to use any of the flags, you don’t have to create a Pattern object: simply pass the string representation of the pattern and the CharSequence to be matched to the static matches( ) method: the method returns true if the specified pattern matches the complete specified text, or returns false otherwise.
Pattern represents a regular expression, but does not actually define any primitive methods for matching regular expressions to text.
To do that, you must create a Matcher object that encapsulates a pattern and the text it is to be compared with.
Do this by calling the matcher( ) method and specifying the CharSequence you want to match against.
See Matcher for a description of what you can do with it.
The split( ) methods are the exception to the rule that you must obtain a Matcher in order to be able to do anything with a Pattern (although they create and use a Matcher internally)
The two-argument version of split( ) takes an integer argument that specifies the maximum number of substrings to break the input into.
Pattern defines the following flags that control various aspects of how regular expression matching is performed.
CANON_EQ The Unicode standard sometimes allows more than one way to specify the same character.
If this flag is set, characters are compared by comparing their full canonical decompositions, so that characters will match even if expressed in different ways.
Unlike all the other flags, there is no way to temporarily enable this flag within a pattern.
By default this flag only affects the comparisons of ASCII letters.
Also set the UNICODE_CASE flag if you want to ignore the case of all Unicode characters.
You can enable this flag within a pattern with (?i)
Comments are all characters between a # and end of line.
You can enable this flag within a pattern with (?x)
If it is not set, then it does not match line terminator characters.
Within a pattern you can enable this flag with (?m)
You can enable both flags within a pattern with (?iu)
You can turn this flag on within a pattern with (?d)
Although the API for the Pattern class is quite simple, the syntax for the text representation of regular expressions is fairly complex.
The table below, is a quick-reference for regular expression syntax.
It is very similar to the syntax used in Perl.
Because Java strings also use the backslash character as an escape, you must double the backslashes when expressing a regular expression as a string literal: “\\d”
In Java 5.0, the static quote( ) method quotes all special characters in a string so that you can match arbitrary text literally without worrying that punctuation in that text will be interpreted specially.
For complete details on regular expressions see a book like Programming Perl by Larry Wall et.
Characters may be specified literally, and the syntax also allows the specification of character ranges, with intersection, union, and subtraction operators.
If the DOTALL flag is set, then it matches any character including line terminators.
Many of the group names are from POSIX, which is why p is used for this character class.
Category names are one or two letter codes defined by the Unicode standard.
One letter codes include L for letter, N for number, S for symbol, Z for separator, and P for punctuation.
Two letter codes represent subcategories, such as Lu for uppercase letter, Nd for decimal digit, Sc for currency symbol, Sm for math symbol, and Zs for space separator.
See java.lang.Character for a set of constants that correspond to these subcategories; however, note that the full set of one- and two-letter codes is not documented in this book.
In Java regular expressions, block names begin with “In”, followed by mixed-case capitalization of the Unicode block name, without spaces or underscores.
Also “capture” the characters that match this group for use later.
Group subexpression as with ( ), but do not capture the text that matched.
Be careful when n is followed by another digit: the largest number that is a valid group number will be used.
The beginning of the input string, or if the MULTILINE flag is specified, the beginning of the string or of any new line.
The end of the input string, or if the MULTILINE flag is specified, the end of the string or of line within the string.
Like ^, but never matches the beginning of a new line, regardless of what flags are set.
Require that the following characters do not match the pattern x.
Require that the characters immediately before the position do not match x.
A group of this form does not capture the matched text.
Don t match anything, but turn on the flags specified by onflags, and turn off the flags specified by offflags.
Flag settings specified in this way take effect at the point that they appear in the expression and persist until the end of the expression, or until the end of the parenthesized group of which they are a part, or until overridden by another flag setting expression.
Match x, applying the specified flags to this subexpression only.
This is a noncapturing group, like (?:...), with the addition of flags.
All characters within such a quoted section are interpreted as literal characters to match, and none (except \E) have special meanings.
Signals a syntax error in the text representation of a regular expression.
An exception of this type may be thrown by the Pattern.compile( ) and Pattern.matches( ) methods, and also by the String matches( ), replaceFirst( ), replaceAll( ) and split( ) methods which call those Pattern methods.
The inherited getMessage( ) method combines the information provided by these other three methods into a single multiline message.
The java.util.zip package contains classes for data compression and decompression.
The Deflater and Inflater classes perform data compression and decompression.
DeflaterOutputStream and InflaterInputStream apply that functionality to byte streams; the subclasses of these streams implement both the GZIP and ZIP compression formats.
This class implements the Checksum interface and computes a checksum on a stream of data using the Adler-32 algorithm.
This algorithm is significantly faster than the CRC32 algorithm and is almost as reliable.
The CheckedInputStream and CheckedOutputStream classes provide a higher-level interface to computing checksums on streams of data.
This class is a subclass of java.io.FilterInputStream; it allows a stream to be read and a checksum computed on its contents at the same time.
This is useful when you want to check the integrity of a stream of data against a published checksum value.
To create a CheckedInputStream, you must specify both the stream it should read and a Checksum object, such as CRC32, that implements the particular checksum algorithm you desire.
The read( ) and skip( ) methods are the same as those of other input streams.
As bytes are read, they are incorporated into the checksum that is being computed.
The getChecksum( ) method does not return the checksum value itself, but rather the Checksum object.
You must call the getValue( ) method of this object to obtain the checksum value.
This class is a subclass of java.io.FilterOutputStream that allows data to be written to a stream and a checksum computed on that data at the same time.
To create a CheckedOutputStream, you must specify both the output stream to write its data to and a Checksum object, such as an instance of Adler32, that implements the particular checksum algorithm you desire.
The write( ) methods are similar to those of other OutputStream classes.
You must call getValue( ) on this object in order to obtain the actual checksum value.
This interface defines the methods required to compute a checksum on a stream of data.
The checksum is computed based on the bytes of data supplied by the update( ) methods; the current value of the checksum can be obtained at any time with the getValue( ) method.
The checksum value computed by a Checksum object and returned through the getValue( ) method must fit into a long value.
Therefore, this interface is not suitable for the cryptographic checksum algorithms used in cryptography and security.
The classes CheckedInputStream and CheckedOutputStream provide a higher-level API for computing a checksum on a stream of data.
This class implements the Checksum interface and computes a checksum on a stream of data using the CRC-32 algorithm.
The CheckedInputStream and CheckedOutputStream classes provide a higher-level interface to computing checksums on streams of data.
Signals that invalid or corrupt data has been encountered while uncompressing data.
This class implements the general ZLIB data-compression algorithm used by the gzip and PKZip compression programs.
The constants defined by this class are used to specify the compression strategy and the compression speed/strength tradeoff level to be used.
If you set the nowrap argument to the constructor to true, the ZLIB header and checksum data are omitted from the compressed output, which is the format both gzip and PKZip use.
The important methods of this class are setInput( ), which specifies input data to be compressed, and deflate( ), which compresses the data and returns the compressed output.
The remaining methods exist so that Deflater can be used for stream-based compression, as it is in higher-level classes, such as GZIPOutputStream and ZipOutputStream.
The Inflater class uncompresses data compressed with a Deflater object.
This class is a subclass of java.io.FilterOutputStream; it filters a stream of data by compressing (deflating) it and then writing the compressed data to another output stream.
To create a DeflaterOutputStream, you must specify both the stream it is to write to and a Deflater object to perform the compression.
You can set various options on the Deflater object to specify just what type of compression is to be performed.
Once a DeflaterOutputStream is created, its write( ) and close( ) methods are the same as those of other output streams.
The InflaterInputStream class can read data written with a DeflaterOutputStream.
A DeflaterOutputStream writes raw compressed data; applications often prefer one of its subclasses, GZIPOutputStream or ZipOutputStream, that wraps the raw compressed data within a standard file format.
This class is a subclass of InflaterInputStream that reads and uncompresses data compressed in gzip format.
To create a GZIPInputStream, simply specify the InputStream to read compressed data from and, optionally, a buffer size for the internal decompression buffer.
Once a GZIPInputStream is created, you can use the read( ) and close( ) methods as you would with any input stream.
This class is a subclass of DeflaterOutputStream that compresses and writes data using the gzip file format.
To create a GZIPOutputStream, specify the OutputStream to write to and, optionally, a size for the internal compression buffer.
Once the GZIPOutputStream is created, you can use the write( ) and close( ) methods as you would any output stream.
This class implements the general ZLIB data-decompression algorithm used by gzip, PKZip, and other data-compression applications.
It decompresses or inflates data compressed through the Deflater class.
The important methods of this class are setInput( ), which specifies input data to be decompressed, and inflate( ), which decompresses the input data into an output buffer.
A number of other methods exist so that this class can be used for stream-based decompression, as it is in the higher-level classes, such as GZIPInputStream and ZipInputStream.
This class is a subclass of java.io.FilterInputStream; it reads a specified stream of compressed input data (typically one that was written with DeflaterOutputStream or a subclass) and filters that data by uncompressing (inflating) it.
To create an InflaterInputStream, specify both the input stream to read from and an Inflater object to perform the decompression.
Once an InflaterInputStream is created, the read( ) and skip( ) methods are the same as those of other input streams.
Applications often prefer one of its subclasses, GZIPInputStream or ZipInputStream, that work with compressed data written in the standard gzip and PKZip file formats.
This class describes a single entry (typically a compressed file) stored within a ZIP file.
The various methods get and set various pieces of information about the entry.
The ZipEntry class is used by ZipFile and ZipInputStream, which read ZIP files, and by ZipOutputStream, which writes ZIP files.
When you are reading a ZIP file, a ZipEntry object returned by ZipFile or ZipInputStream contains the name, size, modification time, and other information about an entry in the file.
When writing a ZIP file, on the other hand, you must create your own ZipEntry objects and initialize them to contain the entry name and other appropriate information before writing the contents of the entry.
Passed To java.util.jar.JarEntry.JarEntry( ), java.util.jar.JarFile.getInputStream( ), java.util.jar.JarOutputStream.putNextEntry( ), ZipFile.getInputStream( ), ZipOutputStream.putNextEntry( )
Signals that an error has occurred in reading or writing a ZIP file.
It uses a random-access file internally so that the entries of the ZIP file do not have to be read sequentially, as they do with the ZipInputStream class.
A ZipFile object can be created by specifying the ZIP file to be read either as a String filename or as a File object.
To take advantage of this feature, pass ZipFile.OPEN_READ|ZipFile.OPEN_DELETE as the mode argument to the ZipFile( ) constructor.
Once a ZipFile is created, the getEntry( ) method returns a ZipEntry object for a named entry, and the entries( ) method returns an Enumeration object that allows you to loop through all the ZipEntry objects for the file.
To read the contents of a specific ZipEntry within the ZIP can read the entry’s contents.
This class is a subclass of InflaterInputStream that reads the entries of a ZIP file in sequential order.
Create a ZipInputStream by specifying the InputStream from which it is to read the contents of the ZIP file.
Once the ZipInputStream is created, you can use getNextEntry( ) to begin reading data from the next entry in the ZIP file.
This method must be called before read( ) is called to begin reading the first entry.
The read( ) methods of ZipInputStream read until the end of the current entry and then return –1, indicating that there is no more data to read.
To continue with the next entry in the ZIP file, you must call getNextEntry( ) again.
Similarly, the skip( ) method only skips bytes within the current entry.
Protected Methods Overriding Object 1.3 protected void finalize( ) throws java.io.IOException;
This class is a subclass of DeflaterOutputStream that writes data in ZIP file format to an output stream.
Before writing any data to the ZipOutputStream, you must begin an entry within the ZIP file with putNextEntry( )
The ZipEntry object passed to this method should specify at least a name for the entry.
Once you have begun an entry with putNextEntry( ), you can write the contents of that entry with the write( ) methods.
When you reach the end of an entry, you can begin a new one by calling putNextEntry( ) again, you can close the current entry with closeEntry( ), or you can close the stream itself with close( )
Before beginning an entry with putNextEntry( ), you can set the compression method and level with setMethod( ) and setLevel( )
The constants DEFLATED and STORED are the two legal values for setMethod( )
If you use STORED, the entry is stored in the ZIP file without any compression.
If you are storing an entry without compression, the ZIP file format requires that you specify, in advance, the entry size and CRC-32 checksum in the ZipEntry object for the entry.
An exception is thrown if these values are not specified or specified incorrectly.
Public Methods Overriding InflaterInputStream 1.2 public int available( ) throws java.io.IOException;
This chapter documents the cryptographic features (including encryption and decryption) of the javax.crypto package and its subpackages.
All of the commonly-used cryptography classes are in the javax.crypto package itself.
The javax.crypto.interfaces subpackage defines algorithm-specific interfaces for certain type of cryptographic keys.
The javax.crypto.spec subpackage defines classes that provide a transparent, portable, and provider-independent representation of cryptographic keys and related objects.
The javax.crypto package defines classes and interfaces for various cryptographic operations.
The central class is Cipher, which is used to encrypt and decrypt data.
CipherInputStream and CipherOutputStream are utility classes that use a Cipher object to encrypt or decrypt streaming data.
SealedObject is another important utility class that uses a Cipher object to encrypt an arbitrary serializable Java object.
The KeyGenerator class creates the SecretKey objects used by Cipher for encryption and decryption.
The KeyAgreement class enables two or more parties to agree on a SecretKey in such a way that an eavesdropper cannot determine the key.
The Mac class computes a message authentication code (MAC) that can ensure the integrity of a transmission between two parties who share a SecretKey.
A MAC is akin to a digital signature, except that it is based on a secret key instead of a public/private key pair.
Like the java.security package, the javax.crypto package is provider-based, so that arbitrary cryptographic implementations may be plugged into any Java installation.
Various classes in this package have names that end in Spi.
These classes define a service-provider interface and must be implemented by each cryptographic provider that wishes to provide an implementation of a particular cryptographic service or algorithm.
This package was originally shipped as part of the Java Cryptography Extension (JCE), but it has been added to the core platform in Java 1.4
This package is distributed with a cryptographic provider named “SunJCE” that includes a robust set of implementations for Cipher, KeyAgreement, Mac, and other classes.
This provider is installed by the default java.security properties in Java 1.4 distributions.
A full tutorial on cryptography is beyond the scope of this chapter and of this book.
In order to use this package, you need to have a basic understanding of cryptographic algorithms such as DES.
In order to take full advantage of this package, you also need to have a detailed understanding of things like feedback modes, padding schemes, the Diffie-Hellman key-agreement protocol, and so on.
For a good introduction to modern cryptography in Java, see Java Cryptography by Jonathan Knudsen (O’Reilly)
For more in-depth coverage, not specific to Java, see Applied Cryptography by Bruce Schneier (Wiley)
Signals that input data to a Cipher is not padded correctly.
Cipher is provider-based, so to obtain a Cipher object, you must call the static getInstance( ) factory method.
The and, optionally, the name of the provider whose implementation should be used.
To specify the desired type of encryption, you can simply specify the name of an encryption algorithm, such as “DES”
Advanced users may specify a three-part algorithm name that includes the encryption algorithm, the algorithm operating mode, and the padding scheme.
These three parts are separated by slash characters, as in “DES/CBC/PKCS5Padding”
Finally, if you are requesting a block cipher algorithm in a stream mode, you can specify the number of bits to be processed at a time by following the name of the feedback mode with a number of bits.
Details of supported operating modes and padding schemes are beyond the scope of this book.
In Java 5.0, you can obtain details about the services available through the SunJCE (or any other) provider through the java.security.Provider.Services class.
Once you have obtained a Cipher object for the desired cryptographic algorithm, mode, and padding scheme, you must initialize it by calling one of the init( ) methods.
The second argument is a java.security.Key object that performs the encryption or decryption.
If you use one of the symmetric (i.e., nonpublic key) encryption algorithms supported by the “SunJCE” provider, this Key object is a SecretKey implementation.
Note that some cryptographic providers restrict the maximum allowed key length based on a jurisdiction policy file.
In Java 5.0 you can query the maximum allowed key length for a named encryption algorithm with getMaxAllowedKeyLength( )
You can optionally pass a java.security.SecureRandom object to init( ) to provide a source of randomness.
If you do not, the Cipher implementation provides its own pseudorandom number generator.
Some cryptographic algorithms require additional initialization parameters; these can be passed to init( ) as a java.security.AlgorithmParameters object or as a java.security.spec.AlgorithmParameterSpec object.
When encrypting, you can omit these parameters, and the Cipher implementation uses default values or generates appropriate random parameters for you.
In this case, you should call getParameters( ) after performing encryption to obtain the AlgorithmParameters used to encrypt.
These parameters are required in order to decrypt, and must therefore be saved or transferred along with the encrypted data.
You can represent an initialization vector with a javax.crypto.spec.IvParameterSpec object and obtain the raw bytes of the initialization vector used by a Cipher with the getIV( ) method.
The “PBEWithMD5AndDES” algorithm requires a salt and iteration count as parameters.
Once you have obtained and initialized a Cipher object, you are ready to use it for encryption or decryption.
If you have only a single array of bytes to encrypt or decrypt, pass that input array to one of the doFinal( ) methods.
Some versions of this method return the encrypted or decrypted bytes as the return value of the function.
Other versions store the encrypted or decrypted bytes to another byte array you specify.
If you choose to use one of these latter methods, you should first call getOutputSize( ) to determine the required size of the output array.
If you want to encrypt or decrypt data from a streaming source or have more than one array of data, pass the data to one of the update( ) methods, calling it as many times as necessary.
Then pass the last array of data to one of the doFinal( ) methods.
If you are working with streaming data, consider using the CipherInputStream and CipherOutputStream classes instead.
Java 5.0 adds versions of the update( ) and doFinal( ) that work with ByteBuffer objects, which facilitates the use of encryption and decryption with the New I/O API of java.nio.
This class is an input stream that uses a Cipher object to encrypt or decrypt the bytes it reads from another stream.
You must initialize the Cipher object before passing it to the CipherInputStream( ) constructor.
This class is an output stream that uses a Cipher object to encrypt or decrypt bytes before passing them to another output stream.
You must initialize the Cipher object before passing it to the CipherOutputStream( ) constructor.
If you are using a Cipher with any kind of padding, you must not call flush( ) until you are done writing all data to the stream; otherwise decryption fails.
A cryptographic provider must implement a concrete subclass of this class for each encryption algorithm it supports.
A provider can implement a separate class for each combination of algorithm, mode, and padding scheme it supports or implement more general classes and leave the mode and/or padding scheme to be specified in calls to engineSetMode( ) and engineSetPadding( )
Pass a Cipher object to getKeySpec( ) to decrypt the key.
Protected Instance Methods 5.0 protected int engineDoFinal(java.nio.ByteBuffer input, java.nio.ByteBuffer output)
Some countries place legal restrictions on the use of cryptographic algorithms.
This class defines a very general API to such mechanism.
This class is rarely used, and is not supported in the default implementation provided by Sun.
Using this class successfully is quite complex, and is beyond the scope of this reference.
Security providers may implement this interface, but applications never need to use it.
Note that the default “SunJCE” provider does not provide an implementation.
Signals that the length of data provided to a block cipher (as implemented, for example, by Cipher and SealedObject) does not match the block size for the cipher.
This class provides an API to a key-agreement protocol that allows two or more parties to agree on a secret key without exchanging any secrets and in such a way that an eavesdropper listening in on the communication between those parties cannot determine the secret key.
The KeyAgreement class is algorithm-independent and providerbased, so you must obtain a KeyAgreement object by calling one of the static getInstance( ) factory methods and specifying the name of the desired key agreement algorithm and, optionally, the name of the desired provider of that algorithm.
To use a KeyAgreement object, each party first calls the init( ) method and supplies a Key object of its own.
Then, each party obtains a Key object from one of the other parties to the agreement and calls doPhase( )
Each party obtains an intermediate Key object as the return value of doPhase( ), and these keys are again exchanged and passed to doPhase( )
This process typically repeats n–1 times, where n is the number of parties, but the actual number of repetitions is algorithm-dependent.
When doPhase( ) is called the last time, the second argument must be true to indicate that it is the last phase of the agreement.
After all calls to doPhase( ) have been made, each party calls generateSecret( ) to obtain an array of bytes or a SecretKey object for a named algorithm type.
All parties obtain the same bytes or SecretKey from this method.
The KeyAgreement class is not responsible for the transfer of Key objects between parties or for mutual authentication among the parties.
The most common type of key agreement is “DiffieHellman” key agreement between two parties.
First, both parties obtain a java.security.KeyPairGenerator for the “DiffieHellman” algorithm and use it to generate a java.security.KeyPair of DiffieHellman public and private keys.
Each party passes its private key to the init( ) method of its KeyAgreement object.
The init( ) method can be passed a java.security.spec.AlgorithmParameterSpec object, but the Diffie-Hellman protocol does not require any additional parameters.) Next, the two parties exchange public keys, typically through some kind of networking mechanism (the KeyAgreement class is not responsible for the actual exchange of keys)
Each party passes the public key of the other party to the doPhase( ) method of its KeyAgreement object.
There are only two parties to this agreement, so only one phase is required, and the second argument to doPhase( ) is true.
At this point, both parties call generateSecret( ) to obtain the shared secret key.
A three-party Diffie-Hellman key agreement requires two phases and is slightly more complicated.
Each generates a key pair and uses its private key to initialize its KeyAgreement object, as before.
Then Alice passes her public key to Bob, Bob passes his to Carol, and Carol passes hers to Alice.
Since this is not the final doPhase( ), the second argument is false, and doPhase( ) returns an intermediate Key object.
The three parties exchange these intermediate keys again in the same way: Alice to Bob, Bob to.
Now each party passes the intermediate key it has received to doPhase( ) a second time, passing true to indicate that this is the final phase.
Finally, all three can call generateSecret( ) to obtain a shared key to encrypt future communication.
A cryptographic provider must implement a concrete subclass of this class for each encryption algorithm it supports.
This class provides an API for generating secret keys for symmetric cryptography.
It is similar to java.security.KeyPairGenerator, which generates public/private key pairs for asymmetric or public-key cryptography.
KeyGenerator is algorithm-independent and providerbased, so you must obtain a KeyGenerator instance by calling one of the static getInstance( ) factory methods and specifying the name of the cryptographic algorithm for which a key is desired and, optionally, the name of the security provider whose key-generation implementation is to be used.
Once you have obtained a KeyGenerator, you initialize it with the init( ) method.
You can provide a java.security.spec.AlgorithmParameterSpec object to provide algorithm-specific initialization parameters or simply specify the desired size (in bits) of the key to be generated.
In either case, you can also specify a source of randomness in the form of a SecureRandom object.
If you do not specify a SecureRandom, the KeyGenerator instantiates one of its own.
None of the algorithms supported by the “SunJCE” provider require algorithm-specific parameters.
After calling getInstance( ) to obtain a KeyGenerator and init( ) to initialize it, simply call generateKey( ) to create a new SecretKey.
Take precautions when storing or transmitting the key, so that it does not fall into the wrong hands.
You may want to use a java.security.KeyStore object to store the key in a password-protected form.
A cryptographic provider must implement a concrete subclass of this class for each keygeneration algorithm it supports.
This class defines an API for computing a message authentication code (MAC) that can check the integrity of information transmitted between two parties that share a secret key.
A MAC is similar to a digital signature, except that it is generated with a secret key rather than with a public/private key pair.
Obtain a Mac object by calling one of the static getInstance( ) factory methods and specifying the name of the desired MAC algorithm and, optionally, the name of the provider of the desired implementation.
After obtaining a Mac object, initialize it by calling the init( ) method and specifying a SecretKey and, optionally, a java.security.spec.AlgorithmParameterSpec object.
After obtaining and initializing a Mac object, specify the data for which the MAC is to be computed.
If the data is contained in a single byte array, simply pass it to doFinal( )
If the data is streaming or is stored in various locations, you can supply the data in multiple calls to update( )
In Java 5.0, you can pass a ByteBuffer to update( ) which facilities use with the java.nio New I/O API.
End the series of update( ) calls with a single call to doFinal( )
Note that some versions of doFinal( ) return the MAC data as the function return value.
If you use this version of doFinal( ), be sure to call getMacLength( ) to instantiate an array of the correct length.
A call to doFinal( ) resets the internal state of a Mac object.
If you want to compute a MAC for part of your data and then proceed to compute the MAC for the full data, you should clone( ) the Mac object before calling doFinal( )
Note, however, that Mac implementations are not required to implement Cloneable.
A cryptographic provider must implement a concrete subclass of this class for each MAC algorithm it supports.
Signals that no implementation of the requested padding scheme can be found.
This trivial subclass of Cipher implements an identity cipher that does not transform plain text in any way.
Unlike Cipher objects returned by Cipher.getInstance( ), a NullCipher must be created with the NullCipher( ) constructor.
It serializes the object and encrypts the resulting data stream, thereby protecting the confidentiality of the object.
Create a SealedObject by specifying the object to be sealed and a Cipher object to perform the encryption.
Retrieve the sealed object by calling getObject( ) and specifying the Cipher or java.security.Key to use for decryption.
The SealedObject keeps track of the encryption algorithm and parameters so that a Key object alone can decrypt the object.
This interface represents a secret key used for symmetric cryptographic algorithms that depend on both the sender and receiver knowing the same secret.
SecretKey extends the java.security.Key interface, but does not add any new methods.
The interface exists in order to keep secret keys distinct from the public and private keys used in public-key, or asymmetric, cryptography.
A secret key is nothing more than arrays of bytes and does not require a specialized encoding format.
Therefore, an implementation of this interface should return the format name “RAW” from getFormat( ) and should return the bytes of the key from getEncoded( )
These two methods are defined by the java.security.Key interface that SecretKey extends.)
This class defines an API for translating a secret key between its opaque SecretKey representation and its transparent javax.crypto.SecretKeySpec representation.
SecretKeyFactory is algorithm-independent and provider-based, so you must obtain a SecretKeyFactory object by calling one of the static getInstance( ) factory methods and specifying the name of the desired secret-key algorithm and, optionally, the name of the provider whose implementation is desired.
Once you have obtained a SecretKeyFactory, use generateSecret( ) to create a SecretKey from a java.security.spec.KeySpec (or its subclass, javax.crypto.spec.SecretKeySpec)
Or call getKeySpec( ) to obtain a KeySpec for a Key object.
Because there can be more than one suitable type of KeySpec, getKeySpec( ) requires a Class object to specify the type of the KeySpec to be created.
See also DESKeySpec, DESedeKeySpec, and PBEKeySpec in the javax.crypto.spec package.
A cryptographic provider must implement a concrete subclass of this class for each type of secret key it supports.
Signals that an output buffer is too short to hold the results of an operation.
The interfaces in the javax.crypto.interfaces package define the public methods that must be supported by various types of encryption keys.
The “DH” interfaces respresent DiffieHellman public/private key pairs used in the Diffie-Hellman key-agreement protocol.
These interfaces are typically of interest only to programmers who are implementing a cryptographic provider or who want to implement cryptographic algorithms themselves.
Use of this package requires basic familiarity with the encryption algorithms and the mathematics that underlie them.
Note that the javax.crypto.spec package contains classes that provide algorithmspecific details about encryption keys.
The javax.crypto.spec.DHParameterSpec returned by getParams( ) specifies the parameters that generate the key; they define a key family.
See the subinterfaces DHPublicKey and DHPrivateKey for the actual key values.
If you are working with a PrivateKey you know is a Diffie-Hellman key, you can cast your PrivateKey to a DHPrivateKey.
If you are working with a PublicKey you know is a Diffie-Hellman key, you can cast your PublicKey to a DHPublicKey.
If you are working with a SecretKey that you know is a password-based key, you can cast it to a PBEKey.
The javax.crypto.spec package contains classes that define transparent java.security.spec.KeySpec and java.security.spec.AlgorithmParameterSpec representations of secret keys, Diffie-Hellman The classes in this package are used in conjunction with java.security.KeyFactory, javax.crypto.SecretKeyFactory and java.security.AlgorithmParameters for converting opaque Key, and AlgorithmParameters objects to and from transparent representations.
In order to make good use of this package, you must be familiar with the specifications of the various cryptographic algorithms it supports and the basic mathematics that underlie those algorithms.
This class is a transparent representation of a DESede (triple-DES) key.
This class is a transparent representation of a DES key.
This class is a transparent representation of the values needed to generate a set of Diffie-Hellman parameters (see DHParameterSpec)
An instance of this class can be passed to the init( ) method of a java.security.AlgorithmParameterGenerator that computes Diffie-Hellman parameters.
This class is a transparent representation of the set of parameters required by the Diffie-Hellman key-agreement algorithm.
All parties to the key agreement must share these parameters and use them to generate a Diffie-Hellman public/private key pair.
This java.security.spec.KeySpec is a transparent representation of a Diffie-Hellman private key.
This java.security.spec.KeySpec is a transparent representation of a Diffie-Hellman public key.
This java.security.spec.AlgorithmParameterSpec is a transparent representation of an initialization vector or IV.
An IV is required for block ciphers used in feedback mode, such as DES in CBC mode.
This class specifies parameters for OAEP padding, defined by the PKCS #1 standard.
This class is a transparent representation of a password used in password-based encryption (PBE)
The password is stored as a char array rather than as a String, so that the characters of the password can be overwritten when they are no longer needed (for increased security)
This class is a transparent representation of the parameters used with the passwordbased encryption algorithm defined by PKCS#5
This class is a transparent representation of the parameters used by the RC2 encryption algorithm.
An object of this class initializes a Cipher object that implements RC2
This class is a transparent representation of the parameters used by the RC5 encryption algorithm.
An object of this class initializes a Cipher object that implements RC5
This class is a transparent and algorithm-independent representation of a secret key.
This class is useful only for encryption algorithms (such as DES and DESede) whose secret keys can be represented as arbitrary byte arrays and do not require auxiliary parameters.
Note that SecretKeySpec implements the javax.crypto.SecretKey interface directly, so no algorithm-specific javax.crypto.SecretKeyFactory object is required.
This chapter documents the javax.net package and, more importantly, its subpackage javax.net.ssl.
This small package defines factory classes for creating sockets and server sockets.
These factory classes can be used to create regular java.net.Socket and java.net.ServerSocket objects.
More importantly, however, these factory classes can be subclassed to serve as factories for other types of sockets such as the SSL-enabled sockets of the javax.net.ssl package.
This abstract class defines a factory API for creating server socket objects.
Use the static getDefault( ) method to obtain a default ServerSocketFactory object that is suitable for creating regular java.net.ServerSocket sockets.
Once you have a ServerSocketFactory object, call one of the createServerSocket( ) methods to create a new socket and optionally bind it to a local port and specify the allowed backlog of queued connections.
See javax.net.ssl.SSLServerSocketFactory for a socket factory that can create secure javax.net.ssl.SSLServerSocket objects.
This abstract class defines a factory API for creating socket objects.
Use the static getDefault( ) method to obtain a default SocketFactory object that is suitable for creating regular java.net.Socket sockets.
This default SocketFactory is the one used by the Socket( ) constructor, which usually provides an easier way to create normal sockets.) Once you have a SocketFactory object, call one of the createSocket( ) methods to create a new socket and optionally connect it to a remote host and optionally bind it to a local address and port.
See javax.net.ssl.SSLSocketFactory for a socket factory that can create secure javax.net.ssl.SSLSocket objects.
This package defines an API for secure network sockets using the SSL (Secure Sockets Layer) protocol, or the closely related TLS (Transport Layer Security) protocol.
It defines the SSLSocket and SSLServerSocket subclasses of the java.net socket and server socket.
And it defines SSLSocketFactory and SSLServerSocketFactory subclasses of the javax.net factory classes to create those SSL-enabled sockets and server sockets.
Clients that want to perform simple SSL-enabled networking can create an SSLSocket with code like the following:
Once an SSLSocket has been created, it can be used just like a normal java.net.Socket.
Once a connection is established over an SSLSocket, you can use the getSession( ) method to obtain an SSLSession object that provides information about the connection.
Note that despite the name of this package and of its key classes, it supports the TLS protocol in addition to the SSL.
The SSLSocket class allows you to do arbitrary networking with an SSL-enabled peer.
The most common use of SSL today is with the https: protocol on the web.
The addition of this package to the core Java platform enables support for https: URLs in the java.net.URL class, which allows you to securely transfer data over the web without having to directly use this package at all.
When you call openConnection( ) on a https: URL, the URLConnection object that is returned can be cast to an HttpsURLConnection object, which defines some SSL-specific methods.
See java.net.URL and java.net.URLConnection for more information about networking with URLs.
Although the code shown above to create a SSLSocket is quite simple, this package is much more complex because it exposes a lot of SSL infrastructure so that applications with advanced networking needs can configure it as needed.
Also, like all securityrelated packages, this one is provider-based and algorithm-independent, which adds a layer of complexity.
If you want to explore this package beyond the two socket classes, the two factory classes, and the HttpsURLConnection class, start with SSLContext.
This class is a factory for socket factories, and as such is the central class of the API.
To customize the way SSL networking is done, you create an SSLContext optionally specifing the desired provider of the implementation.
Next, you initialize the SSLContext by providing a custom KeyManager as a source of authentication information to be supplied to the remote host if required, a custom TrustManager as a verifier for the authentication information (if any) presented by the remote host, and a custom java.security.SecureRandom object as a source of randomness.
Once the SSLContext is initialized in this way, you can use it to create SSLSocketFactory and SSLServerSocketFactory objects that use the KeyManager and TrustManager objects you supplied.
In Java 5.0, the SSLContext can also be used to create an SSLEngine object, which performs transport-independent SSL encryption of outbound packets and SSL decryption of inbound packets.
This enables the use of SSL with the nonblocking networking facilities of the java.nio.channels package, for example.
This class implements the ManagerFactoryParameters interface and wraps a java.security.cert.CertPathParameters object used to initialize a TrustManager based on a certificate path.
An instance of this class is passed to the handshakeCompleted( ) method of any registered HandshakeCompletedListener objects by an SSLSocket when that socket completes the handshake phase of establishing a connection.
The various methods of a HandshakeCompletedEvent return information (such as the name of the cipher suite in use and the certificate chain of the remote host) that was determined during that handshake.
Note that the getPeerCertificateChain( ) method returns an object from the javax.security.cert for backward compatibility with earlier versions of the JSSE API, and should be considered deprecated.
This interface is implemented by any class that wants to receive notifications (in the form of a call to handshakeCompleted( ) method) when an SSLSocket completes the SSL handshake.
Register a HandshakeCompletedListener for an SSLSocket by passing it to the addHandshakeCompletedListener( ) method of the socket.
When the socket completes the handshake phase of connection, it will call the handshakeCompleted( ) method of all registered listeners, passing in a HandshakeCompletedEvent object.
An object that implements this interface may be used with an HttpsURLConnection object to handle the case in which the hostname that appears in the URL does not match the hostname obtained during the SSL handshake with the server.
This occurs, for example, when a website uses the secure certificate of its parent web hosting company, for example.
In this situation, the verify( ) method of the HostnameVerifier is called to determine whether the connection should proceed or not.
The hostname argument to verify( ) specifies the hostname that appeared in the URL.
The session argument specifies the SSLSession object that was established during the handshake.
Call getPeerHost( ) on this object to determine the hostname reported during server authentication.
If no HostnameVerifier is registered with a HttpsURLConnection object, and no default verifier is registered with the HttpsURLConnection class, then hostname mismatches will always cause the connection to fail.
In user-driven applications such as web browsers, a HostnameVerifier can be used to ask the user whether to proceed or not.
This class is a java.net.URLConnection for a URL that uses the https: protocol.
It extends java.net.HttpURLConnection and, in addition to inheriting the methods of its superclasses, it defines methods for specifying the SSLSocketFactory and HostnameVerifier to use when establishing the connection.
Static versions of these methods allow you to specify a default factory and verifier objects for use with all HttpsURLConnection objects.
After the connection has been established, several other methods exist to obtain information (such as the cipher suite and the server certificates) about the connection itself.
Obtain a HttpsURLConnection object by calling the openConnection( ) method of a URL that uses the https:// protocol specifier, and casting the returned value to this type.
The HttpsURLConnection object is unconnected at this point, and you can call setHostnameVerifier( ) and setSSLSocketFactory( ) to customize the way the connection is made.
If you do not specify a HostnameVerifier for the instance, or a default one for the class, then hostname mismatches will always cause the connection to fail.
If you do not specify an SSLSocketFactory for the instance or class, then a default one will be used.) To connect, call the inherited connect( ) method, and then call the inherited getContent( ) to retrieve the content of the URL as an object, or use the inherited getInputStream( ) to obtain a java.io.InputStream with which you can read the content of the URL.
This is a marker interface to identify key manager objects.
A key manager is responsible for obtaining and managing authentication credentials (such as a certificate chain and an associated private key) that the local host can use to authenticate itself to the remote host.
It is usually used on the server-side of an SSL connection, but can be used on the client-side as well.
KeyManager objects returned by a KeyManagerFactory can always be cast to a subinterface specific to a particular type of authentication credentials.
A KeyManagerFactory is responsible for creating KeyManager objects for a specific key management algorithm.
Obtain a KeyManagerFactory object by calling one of the getInstance( ) methods and specifying the desired algorithm and, optionally, the desired provider.
After calling getInstance( ), you initialize the factory object with init( )
Once a KeyManagerFactory has been created and initialized, use it to create a KeyManager by calling getKeyManagers( )
This method returns an array of KeyManager objects because some key management algorithms may handle more than one type of key.
This returned array is typically passed to the init( ) method of an SSLContext object.
If a KeyStore and password are not passed to the init( ) method of the KeyManagerFactory for the “SunX509” algorithm, then the factory uses attempts to read a KeyStore from the file specified by the javax.net.ssl.keyStore system property using the password specified by the javax.net.ssl.keyStorePassword.
Security providers must implement this interface, but applications never need to use it.
This class implements the ManagerFactoryParameters interface and encapsulates a java.util.List of java.security.KeyStore.Builder object for use by an X509KeyManager.
This marker interface identifies objects that provide algorithm-specific or providerspecific initialization parameters for KeyManagerFactory and TrustManagerFactory objects.
Factories of these types need to be initialized with a KeyStore object but do not require any specialized ManagerFactoryParameters object.
Therefore, the javax.net.ssl package does not define any subinterfaces of this interface, and it is never used with the default provider.
This class is a factory for socket and server socket factories.
Although most applications do not need to use this class directly, it is the central class of the javax.net.ssl returned by the static getDefault( ) methods of those classes.
Applications that want to perform SSL networking using a security provider other than the default provider, or that want to customize key management or trust management for the SSL connection should use custom socket factories created from a custom SSLContext.
In Java 5.0, this class also includes createSSLEngine( ) factory methods for creating SSLEngine objects.
Create an SSLContext by passing the name of the desired secure socket protocol and, optionally, the desired provider to getInstance( )
Once you have created an SSLContext object, call its init( ) method to supply the KeyManager, TrustManager, and SecureRandom objects it requires.
If any of the init( ) arguments is null, a default value will be used.
Finally, obtain a SSLSocketFactory and SSLServerSocketFactory by calling getSocketFactory( ) and getServerSocketFactory( )
Security providers must implement this interface, but applications never need to use it.
This class performs SSL handshaking, encryption and decryption, but does not send or receive messages over the network.
This leaves the network transport mechanism up to the user of this class, and enables SSL communication using the nonblocking I/O mechanisms of the java.nio package.
The price of this flexibility is that your code must follow a relatively complex protocol to use an SSLEngine correctly.
Next, configure it with the various setter methods to specify authentication requirements, encryption algorithms, etc.
After creating and configuring an engine, you use it to encrypt outbound data from one ByteBuffer to another with wrap( ) and to decrypt inbound data from one byte buffer to another with unwrap( )
Note that the wrap( ) and unwrap( ) methods also come in gathering and scattering variants.) Both methods return an SSLEngineResult.
The initial call or calls to wrap( ) produce outbound handshaking data without consuming any of the source bytes in the buffer you provide.
Initial calls to unwrap( ) may consume inbound handshaking data without producing any result bytes.
Monitor the SSLEngineResult.HandshakeStatus value to ensure that handshaking is proceeding as needed.
When handshaking is complete, you can call getSession( ) to obtain the SSLSession object that describes session details negotiated during handshaking.
Remember that either peer of an SSL connection may request a new handshake at any time; this means that you must monitor the HandshakeStatus after every wrap( ) or unwrap( ) call in case a new handshake has been requested.
You can request a new handshake yourself with beginHandshake( )
As part of the handshaking protocol, the SSLEngine typically needs to use the KeyManager or TrustManager of the originating SSLContext object.
Rather than blocking a wrap( ) or unwrap( ) method while these operations are performed, it instead returns an SSLResult.HandshakeStatus, indicating that a task needs to be performed.
When this happens, you must call getDelegatedTask( ) repeatedly, calling the run( ) methods of the Runnable objects it returns until it returns null to indicate that all necessary tasks have been completed.
If it returns more than one Runnable, it is safe to run them in parallel (with a java.util.concurrent.ExecutorCompletionService, for example)
Once all such tasks have been run, the original call to wrap( ) or unwrap( ) should be repeated.
When you are done sending outbound data, call closeOutbound( ), and then call wrap( ) one or more times to flush any remaining data from the engine.
Call wrap( ) until the returned SSLEngineResult.Status indicates that the connection has closed.
Similarly, if you are done reading inbound data, call closeInbound( ) and final calls to unwrap( ) until the connection is closed.
It is safe for one thread to call wrap( ) while another thread is calling unwrap( )
It is not safe, however, for either method to be called by two threads at once.
An object of this type is returned by the wrap( ) and unwrap( ) methods of an SSLEngine.
Use the methods of this object to determine how much data was consumed and produced and to obtain the Status of the operation and the HandshakeStatus of the connection.
Correct operation of an SSLEngine requires that your code respond correctly to the Status and HandshakeStatus results.
The constants defined by this enumerated type specify the handshake status of the SSLEngine and often specify the action your code must take next in order to ensure correct operation.
NEED_WRAP The SSLEngine needs to send more handshake data, so a call to wrap( ) is necessary.
NEED_UNWRAP The SSLEngine needs to receive more handshake data, so a call to unwrap( ) is necessary.
NEED_TASK The SSLEngine needs to perform an authentication or related task, so you must repeatedly call getDelegatedTask( ) and run( ) any Runnable objects it returns.
The constants of this enumerated type indicate the status of a wrap( ) or unwrap( ) operation:
Or, that connection is already closed, and so the wrap( ) or unwrap( ) call could not proceed.
BUFFER_OVERFLOW There were not enough bytes in the destination buffer to hold the results.
BUFFER_UNDERFLOW There were not enough incoming bytes in the source buffer to produce a complete output packet.
Fill the buffer with more bytes from the network and call unwrap( ) again.
This class serves as the common superclass of more specific SSL exception subclasses.
Signals that the SSL handshake failed for some reason other than failed authentication (see SSLPeerUnverifiedException)
For example, it may be thrown because the client and server count not agree on a mutually-acceptable cipher suite.
When this exception is thrown, the SSLSocket object is no longer usable.
Signals a problem with the public key certificate and private key used by a server (or client) for authentication.
Signals that authentication of the remote host was not successfully completed.
This Permission class controls access to sensitive methods in the javax.net.ssl package.
The first is required in order to call HttpURLConnection.setHostnameVerifier( ) and HttpURLConnection.setDefaultHostnameVerifier( )
The second permission target is required in order to call SSLSession.getSessionContext( )
An exception of this type usually indicates that there is a bug in the SSL implementation being used locally or on the remote host.
This class is an SSL-enabled subclass of java.net.ServerSocket that is used to listen for and accept connections from clients and to create SSLSocket objects for communicating with those clients.
Create an SSLServerSocket and bind it to a local port by calling one of the inherited getServerSocket( ) methods of an SSLServerSocketFactory.
Once a SSLServerSocket is created, use it as you would a regular ServerSocket: call the inherited accept( ) method to wait for and accept a connection from a client, returning a Socket object.
With SSLServerSocket, the Socket returned by accept( ) can always be cast to an instance of SSLSocket.
SSLServerSocket defines methods for setting the enabled protocols and cipher suites, and for querying the full set of supported protocols and suites.
See SSLSocket, which has methods with the same names, for details.
If your server desires or requires authentication by its clients, call setWantClientAuth( ) or setNeedClientAuth( )
These methods cause the SSLSocket objects returned by accept( ) to be configured to request or require client authentication.
In typical SSL networking scenarios, the client requires the server to provide authentication information.
When you create an SSLServerSocket using the default SSLServerSocketFactory, the authentication information required is an X.509 public key certificate and the corresponding private key.
The default SSLServerSocketFactory uses an X509KeyManager to obtain this information.
The default X509KeyManager attempts to read this information from the java.security.KeyStore file specified by the system property javax.net.ssl.keyStore.
It uses the value of the the javax.net.ssl.keyStorePassword as the keystore password, and uses the value of the javax.net.ssl.keyStoreType system property to specify the keystore type.
The key store should only contain valid keys and certificate chains that identify the server; the X509KeyManager automatically chooses a key and certificat chain that are appropriate for the client.
Most applications use the default SSLServerSocketFactory returned by the static getDefault( ) method.
Once this SSLServerSocketFactory has been obtained, they use one of the inherited createServerSocket( ) methods to create and optionally bind a new SSLServerSocket.
The return value of the createServerSocket( ) methods is a java.net.ServerSocket object, but you can safely cast this object to a SSLServerSocket if you need to.
Applications that need to customize the SSL configuration and cannot use the default server socket factory may obtain a custom SSLServerSocketFactory from an SSLContext, which is essentially a factory for socket factories.
A SSLSession object contains information about the SSL connection established through an SSLSocket.
Use the the getSession( ) method of a SSLSocket to obtain the SSLSession object for that socket.
Many of the SSLSession methods return information that was obtained during the handshake phase of the connection.
In Java 5.0 and later the peer’s identity can also be queried with getPeerPrincipal( )
It does not affect any current connections, but all future connections and any re-negotiations of existing connections will need to establish a new SSLSession.
Multiple SSL connections between two hosts may share the same SSLSession as long as they are using the same protocol version and cipher suite.
There is no way to enumerate the SSLSocket objects that share a session, but these sockets can exchange information by using putValue( ) to bind a shared object to some well-known name that can be looked up by other sockets with getValue( )
Objects bound and unbound with putValue( ) and removeValue( ) may implement SSLSessionBindingListener to be notified when they are bound and unbound.
Note that the getPeerCertificateChain( ) method returns an object from the javax.security.cert.
An object of this type is passed to the valueBound( ) and valueUnbound( ) methods of and object that implements SSLSessionBindingListener when that object is bound or unbound in a SSLSession with the putValue( ) or removeValue( ) methods of SSLSession.
This interface is implemented by an object that want to be notified when it is bound or unbound in an SSLSession object.
If the object passed to the putValue( ) method of a SSLSession implements this interface, then its valueBound( ) method will be called by putValue( ), and its valueUnbound( ) method will be called when that object is removed from the SSLSession with removeValue( ) or when it is replaced with a new object by putValue( )
The argument to both methods of this interface is a SSLSessionBindingEvent, which specifies both the name to which the object was bound or unbound, and the SSLSession within which it was bound or unbound.
It is a low-level interface and is not commonly used in application code.
An SSLSessionContext can serve as a cache for SSLSession objects, facilitating reuse of those objects for multiple connections between the same two hosts.
Those that do return an implementing object from the getSessionContext( ) method of an SSLSession object, and also return implementing objects from the getClientSessionContext( ) and getServerSessionContext( ) methods of an SSLContext object, providing separate control over client and server SSL connections.
Create a SSLSocket for connecting to a SSL-enabled server by calling one of the createSocket( ) methods of a SSLSocketFactory object.
If you are writing server code, then you will obtain a SSLSocket for communicating with an SSL-enabled client from the inherited accept( ) method of an SSLServerSocket.
SSLSocket inherits all of the standard socket method of its superclass, and can be used for networking just like an ordinary java.net.Socket object.
In addition, however, it also defines methods that control how the secure connection is established.
These methods may be called before the SSL “handshake” occurs.
The handshake does not occur when the socket is first created and connected, so that you can configure various SSL parameters that control how the handshake occurs.
Calling startHandshake( ), getSession( ), or reading or writing data on the socket trigger a handshake, so you must configure the socket before doing any of these things.
If you want to be notified when the handshake occurs, call addHandshakeCompletedListener( ) to register a listener object to receive the notification.
Note that not all supported cipher suites are enabled by default: only suites that provide encryption and require the server to authenticate itself to the client are enabled.
If you want to allow the server to remain anonymous, you can use setEnabledCipherSuites( ) to enable a nonauthenticating suite.
Specific protocols and cipher suites are not described here because using them correctly requires a detailed understanding of cryptography, which is beyond the scope of this reference.
Most applications can simply rely on the default set of enabled protocols and cipher suites.
If you are writing a server and have obtained an SSLSocket by accepting a connection on an SSLServerSocket, then you may call setWantClientAuth( ) to request that the client authenticate itself to you, and you may call setNeedClientAuth( ) to require that the client authenticate itself during the handshake.
Note, however, that it is usually more efficient to request or require client authentication on the server socket than it is to call these methods on each SSLSocket it creates.
The configuration methods described above must be called before the SSL handshake occurs.
Call getSession( ) to obtain an SSLSession object that you can query for for information about the handshake, such as the protocol and cipher suite in use, and the identity of the server.
Note that a call to getSession( ) will cause the handshake to occur if it has not already occurred, so you can call this method at any time.
Most applications use the default SSLSocketFactory returned by the static getDefault( ) method.
Once this SSLSocketFactory has been obtained, they use one of the inherited createSocket( ) methods to create, and optionally connect and bind, a new SSLSocket.
The return value of the createSocket( ) methods is a java.net.Socket object, but you can safely cast this object to a SSLSocket if you need to.
SSLSocketFactory defines one new version of createSocket( ) in addition to the ones it inherits from its superclass.
This version of the method creates an SSLSocket that is layered over an existing Socket object rather than creating a new socket entirely from scratch.
Applications that need to customize the SSL configuration and cannot use the default socket factory may obtain a custom SSLSocketFactory from an SSLContext, which is essentially a factory for socket factories.
This is a marker interface to identify trust manager objects.
A trust manager is responsible for examining the authentication credentials (such as a certificate chain) presented by the remote host and deciding whether to trust those credentials and accept them.
A TrustManager is usually used an SSL client to decide whether the SSL server is authentic, but may also be used by an SSL server when client authentication is also required.
TrustManager objects returned by a TrustManagerFactory can always be cast to a subinterface specific to a specific type of keys.
A TrustManagerFactory is responsible for creating TrustManager objects for a specific trust management algorithm.
Obtain a TrustManagerFactory object by calling one of the getInstance( ) methods and specifying the desired algorithm and, optionally, the desired provider.
After calling getInstance( ), you initialize the factory object with init( )
For the “SunX509” algorithm, you pass a KeyStore object to init( )
This KeyStore should contain the public keys of trusted CAs (certification authorities)
Once a TrustManagerFactory has been created and initialized, use it to create a TrustManager by calling getTrustManagers( )
This method returns an array of TrustManager objects because some trust management algorithms may handle more than one type of key or certificate.
This returned array is typically passed to the init( ) method of an SSLContext object.
If no KeyStore is passed to the init( ) method of the TrustManagerFactory for the “SunX509” algorithm, then the factory uses a KeyStore created from the file named by the system property javax.net.ssl.trustStore if that property is defined.
It also uses the key store type and password specified by the properties javax.net.ssl.trustStoreType and javax.net.ssl.trustStorePassword.) Otherwise, it uses the file jre/lib/security/jssecacerts in the Java distribution, if it exists.
Otherwise it uses the file jre/lib/security/cacerts which is part of Sun’s Java distribution.
Sun ships a default cacerts file that contains certificates for several wellknown and reputable CAs.
You can use the keytool program to edit the cacerts keystore (the default password is “changeit”)
Security providers must implement this interface, but applications never need to use it.
This class implements the X509KeyManager interface and extends it with two methods.
This interface is a KeyManager for working with X.509 certificates.
This is usually done on the server side of the.
Applications do not call the methods of an X509KeyManager themselves.
Instead, they simply supply an appropriate X509KeyManager object to the SSLContext object that is responsible for setting up SSL connections.
When the system needs to authenticate itself during an SSL handshake, it calls various methods of the key manager object to obtain the information in needs.
An X509KeyManager retrieves keys and certificae chains from the KeyStore object that was passed to the init( ) method of the KeyManagerFactory object from which it was created.
The other methods are called to list all aliases in the keystore or to choose one alias from the keystore that matches the specified keytype and certificate authority criteria.
In this way, a X509KeyManager can choose a certificate chain (and it corresponding key) based on the types of keys and the list of certificate authorities recognized by the remote host.
This interface is a TrustManager for working with X.509 certificates.
Trust managers are used during the handshake phase of SSL connection to determine whether the authentication credentials presented by the remote host are trusted.
This is usually done on the client-side of an SSL connection, but may also be done on the server side.
Applications do call the methods of this interface themselves; instead, they simply provide an appropriate X509TrustManager object to the SSLContext object that is responsible for setting up SSL connections.
When the system needs to determine whether the authentication credentials presented by the remote host are trusted, it calls the methods of the trust manager.
This chapter documents the javax.security.auth package and its subpackages, which, together, form the Java Authentication and Authorization Service, or JAAS.
This is the top-level package of the Java Authentication and Authorization Service (JAAS)
The key class is Subject, which represents an authenticated user, and defines static methods that allow Java code be run as (i.e., using the permissions of) a specified Subject.
Applications do not create Subject objects directly, but typically obtain them from a javax.security.auth.login.LoginContext constructed with a javax.security.auth.callback.CallbackHandler.
This java.security.Permission class governs the use of various methods in this package and its subpackages.
The target name of the permission specifies which methods are allowed; AuthPermission objects have no actions list.
System implementors may need to use it, and system administrators who configure security policies may need to be familiar with the following table of target names and the permissions they represent:
If name is  * , it allows a LoginContext of any name to be created.
Classes that encapsulate sensitive information, such as security credentials, may implement this interface to provide an API that allows the sensitive information to be destroyed or erased.
The destroy( ) method erases or clears the sensitive information.
It may throw a DestroyFailedException if the information cannot be erased for any reason.
It may also throw a SecurityException if the caller does not have whatever permissions are required.
Once destroy( ) has been called on an object, the isDestroyed( ) method returns true.
Once an object has been destroyed, any other methods it defines may throw an IllegalStateException.
Signals that the destroy( ) method of a Destroyable object did not succeed.
Thrown By java.security.KeyStore.PasswordProtection.destroy( ), Destroyable.destroy( ), javax.security.auth.kerberos.KerberosKey.destroy( ), javax.security.auth.kerberos.KerberosTicket.destroy( )
Because the JAAS API (this package and its subpackages) were introduced as an extension to the core Java platform, this class was required to augment the java.security.Policy class which, prior to Java 1.4,
In Java 1.4, however, java.security.Policy has been extended to represent security policies based on code origin, code signers, and subjects.
Thus, this class is no longer required and has been deprecated.
This Permission class protects access to private credential objects belonging to a Subject (as specified by a set of one or more Principal objects)
System programmers implementing new private credentials classes may need to use it, and system administrators configuring security policy files should be familiar with it.
The target name for this permission has a complex syntax and specifies the name of the credential class and a list of one or more principals.
Each principal is specified as the name of the Principal class followed by the principal name in quotes.
For example, a security policy file might contain a statement like the following to allow permission to read the private KerberosKey credentials of a KerberosPrincipal named “david”
The target name syntax for PrivateCredentialPermission also allows the use of the “*” wildcard in place of the credential class name or in place of the Principal class name and/or name.
A class implements this interface if its instances that have a limited period of validity (as some security credentials do) and need to be periodically “refreshed” in order to remain valid.
And may also throw a SecurityException if the caller does not have the requisite permissions.)
Signals that the refresh( ) method of a Refreshable object failed.
The Subject class is the key abstraction of the JAAS API.
It represents a person or other entity, and consists of:
Subject defines methods that allow you to retreive each of these three sets, or to retreive a subset of each set that contains only objects of a specified Class.
Unless the Subject is read-only, you can use the methods of java.util.Set to modify each of the three sets.
Once setReadOnly( ) has been called, however, the sets become immutable and their contents may not be modified.
Instead, it obtains a Subject that represents the authenticated user of the application by calling the login( ) and getSubject( ) methods of a javax.security.auth.login.LoginContext object.
Once an authenticated Subject has been obtained from a LoginContext, an application can call the doAs( ) method to run code using the permissions granted to that Subject combined with the permissions granted to the code itself.
Note that many of the methods of this class throw a SecurityException if the caller has not been granted the requisite AuthPermission.
Passed To java.security.AuthProvider.login( ), javax.security.auth.Policy.getPermissions( ), SubjectDomainCombiner.SubjectDomainCombiner( ), javax.security.auth.login.LoginContext.LoginContext( ), javax.security.auth.spi.LoginModule.initialize( )
It is used to merge permissions based on code source and code signers with permissions granted to the specified Subject.
A SubjectDomainCombiner is created by the Subject.doAs( ) and Subject.doAsPrivileged( ) methods for use in by the AccessControlContext.
This package defines a mechanism that allows the low-level code of a javax.security.auth.spi.LoginModule to interact with the end-user of an application to obtain a username, password, or other authentication-related information.
The LoginModule sends messages and requests for information in the form of objects that implement the Callback interface.
An application that wants to authenticate a user provides (via a javax.security.auth.login.LoginContext) a CallbackHandler object to convert these Callback objects into text or GUI-based interactions with the user.
An application that want to provide a customized login interface must implement its own CallbackHandler.
The CallbackHandler API consists of only a single method, but the implementation of that method can require a substantial amount of code.
See the various Callback classes for directions on how a CallbackHandler should handle them.
Although these classes are not guaranteed to exist in all distributions, text-based applications may use the TextCallbackHandler, and GUIbased applications may use the DialogCallbackHandler.
Programmers wanting to write a custom CallbackHandler may also find it useful to study the source code of these two existing handlers.
All of the classes in this package, with the exception of UnsupportedCallbackException implement this interface.
A CallbackHandler is responsible for communication between the end-user of an application and the javax.security.auth.spi.LoginModule that is performing authentication of that user on behalf of the javax.security.auth.login.LoginContext instantiated by the application.
When an application needs to authenticate a user, it creates a LoginContext and specifies a CallbackHandler object for that context.
The underlying LoginModule uses the CallbackHandler to communicate with the end user--for example prompting them to enter a name and password.
The LoginModule passes an array of objects that implement the Callback interface to the handle( ) method of CallbackHandler.
The handle( ) method must determine the type of Callback object, and display the information and/or prompt for the input it represents.
Different Callback classes have different purposes and must be handled differently.
NameCallback and PasswordCallback are two of the most commonly used: they represent requests for the user’s name and password.
See the descriptions of the individual Callback classes for information on how a CallbackHandler should handle them.
CallbackHandler implementations are not required to support every type of Callback and my throw an UnsupportedCallbackException if passed a Callback object of a type they do not recognize or do not support.
The handle( ) method is passed an array of Callback objects.
A CallbackHandler (such as a typical console-based handler) may choose to handle the Callback objects one at a time, prompting for and returning the user’s input before moving on to the next.
LoginModule implementations may, of course, call the handle( ) method more than once.
Note, finally, that if a CallbackHandler implementation has knowledge of the user from some other source, it is allowed to handle certain callbacks automatically, such as automatically providing the user’s name for a NameCallback.
Java installations may have a default CallbackHandler registered by setting the auth.login.defaultCallbackHandler security property to the name of the implementing class.
No such default is defined by the default security policy that ships with Sun’s distribution.
Sun’s Java 1.4 SDK does include CallbackHandler implementations to perform text-based and GUI-based communication in the classes TextCallbackHandler and DialogCallbackHandler in the com.sun.security.auth.callback package.
Note that these are part of Sun’s implementation, and are not part of the specification; they are not guaranteed to exist in all releases.
A Callback of this type represents a request to display set of text choices and allow the user to select one or more of them.
A CallbackHandler, should display the prompt returned by getPrompt( ) and also the strings returned by getChoices( )
If allowMultipleSelections( ) is true, then it should allow the user to select zero or more; otherwise, it should only allow the user to select a single one.
In either case, the CallbackHandler should also call getDefaultChoice( ) and make the choice at the returned index the default choice.
When the user has made her selection, the CallbackHandler should pass the index of a single selection to setSelectedIndex( ), or the indexes of multiple selections to setSelectedIndexes( )
A Callback of this type represents a request to ask the user a yes/no or multiple-choice question.
A CallbackHandler should first call getPrompt( ) to obtain the text of the question.
It should also call getMessageType( ) to determine the message type (INFORMATION, WARNING, or ERROR) and present the question to the user in a suitable manner based on that type.
Next, the CallbackHandler must determine the appropriate set of responses to the question.
UNSPECIFIED_OPTION The CallbackHandler should call getOptions( ) and use present all strings it returns as possible responses.
In each of these cases, the CallbackHandler should also call getDefaultOption( ) to determine which response should be presented as the default response.
If getOptionType( ) returned UNSPECIFIED_TYPE, then getDefaultOption( ) returns an index into the array of options returned by getOptions( )
Otherwise getDefaultOption( ) returns one of the constants YES, NO, OK, or CANCEL.
When the user has selected a response to the callback, the CallbackHandler should pass that response to setSelectedIndex( )
The response value should be one of the constants YES, NO, OK, or CANCEL, or an index into the array of options returned by getOptions( )
This Callback class represents a request for the user’s preferred language (as represented by a Locale object), which a LoginModule can use to localize things such as prompts and error messages in subsequent Callback objects.
If a CallbackHandler already has knowledge of the user’s preferred langauge, it is not required to prompt the user for this information and can simply pass an appropriate Locale object to setLocale( )
This Callback class represents a request for the username or other text that identifies the user to be authenticated.
An interactive CallbackHandler should call getPrompt( ) and getDefaultName( ) and should display the returned prompt and optionally, the returned default name to the user.
When the user has entered a name (or accepted the default name) the handler should pass the user’s input to setName( )
A CallbackHandler should handle it by displaying the prompt returned by getPrompt( ) and then allowing the user the enter a password.
When the user has entered the password, it should pass the entered text to setPassword( )
If isEchoOn( ) returns true, then the Handler should display the password as the user types it.
A Callback of this type is a request to prompt the user for text input; it is essentially a generic version of NameCallback.
A CallbackHandler should call getPrompt( ) and should display the returned prompt text to the user.
It should then allow the user to enter text, and provide the option of selecting the default text returned by getDefaultText( )
When the user has entered text (or selected the default text) it should pass the user’s input to setText( )
A Callback of this type represents a request to display text to the user.
A callback handler should call getMessage( ) and display the returned string to the user.
It should also call getMessageType( ) and use the returned value (which is one of the constants defined by the class) to indicate the type or severity of the information.
CallbackHandler implementations may throw exceptions of this type from their handle( ) method if a Callback object passed to that method is of an unrecognized or unsupported type.
Note that the offending Callback object must be passed to the constructor method.
This package defines classes for use with Kerberos: a secure network authentication protocol.
They are primarily of interest to system-level programmers writing Kerberosbased javax.security.auth.spi.LoginModule implementations.
A full description of Kerberos is beyond the scope of this book; so it is assumed that the reader is familar with Kerberos authentication.
This java.security.Permission class governs the delegation of Kerberos tickets from a Kerberos principal to a Kerberos service for use on behalf of the original principal.
The target name of a DelegationPermission consists of the principal names of two Kerberos services.
The first specifies the service that is being delegated to, and the second specifies the service that is to be used by the first on behalf of the original Kerberos principal.
This class is a javax.crypto.SecretKey implementation that represents the secret key of a Kerberos principal.
A Kerberos-based javax.security.auth.spi.LoginModule implementation instantiates a KerberosKey object and stores it in the private credential set of the authenticated Subject it creates.
This class represents a Kerberos principal, specified as a principal name with an optional realm.
This class represents a Kerberos ticket: a credential used to authenticate a Kerberos principal to some Kerberos-enabled network service.
A Kerberos-based javax.security.auth.spi.LoginModule implementation will instantiate a KerberosTicket object and store it in the private credential set of the authenticated Subject it creates.
This java.security.Permission class protects access to the Kerberos tickets used to access a specified service.
The target name of of a ServicePermission is the Kerberos principal name of the service.
This package defines the LoginContext class which is one of the primary JAAS classes used by application programmers.
To authenticate a user, an application creates a LoginContext object, specifying the application name (used to lookup the type of authentication required for that application in the Configuration) and usually specifying a javax.security.auth.callback.CallbackHandler for communication between the user and the underlying login modules.
Next, the application calls the login( ) method of the LoginContext to perform the actual login.
If this method returns without throwing a LoginException, then the user was sucessfully authenticated, and the getSubject( ) method of LoginContext returns a javax.security.auth.Subject representing the user.
Get a default GUI-based CallbackHandler // Try to create a LoginContext for use with this application LoginContext context; // Now use that context to authenticate the user // If we get here, authentication was successful, so get the Subject that // represents the authenticated user.
In order to make this kind of authentication work correctly, a fair bit of configuration is required in various files in the jre/lib/security directory of the Java installation and possibly elsewhere.
In particular, a login configuration file is required to specify which login modules are required to authenticate users for a particular application (some applications may require more than one)
A description of how to do this is beyond the scope of this reference.
See the Configuration class for a run-time representation of the login configuration information, however.
A LoginException exception of this type signals a problem logging in to the specified account.
Signals that login failed because the user’s account has expired.
Prior to Java 5.0, this exception was a direct subclass of LoginException.
An exception of this type indicates that the account for which login was attempted has been “locked” or otherwise made unavailable.
An exception of this type indicates that the account specified in a login attempt does not exist.
An instance of this class represents a login module to be used for user authentication for a particular application.
The constants defined by this class specify whether a login module is required or optional, and have the following meanings:
However, even if authentication fails for this module, the LoginContext continues to attempt authentication with any other modules in the list.
This can server to disguise the source of the authentication failure from an attacker)
If authentication fails for this module, the LoginContext does not try any further login modules.
However, if authentication by this module does succeed, the LoginContext does not try any further login modules, but instead returns immediately.
Whether or not it succeeds, the LoginContext continues to with any other modules on the list.
This abstract class is a representation of the system and user login configuration files.
The static getConfiguration( ) method returns the global Configuration object, and the static setConfiguration( ) allows that global object to be replaced with some other implementation.
The instance method refresh( ) causes a Configuration to re-read the underlying configuration files.
LoginContext uses this class to determine which login modules to use to authenticate a user of the named application.
Application programmers do not typically need to use this class themselves.
See the documentation for your Java implementation for the syntax of the underlying login configuration files.
An exception of this type indicates a problem with the credential (e.g., the password) presented during the login attempt.
Signals that a login failed because a credential (such as a password) has expired and is no longer valid.
Prior to Java 5.0, this is a direct subclass of LoginException.
An exception of this type indicates that a credential (such as a Kerberos ticket) necessary for login could not be found.
This is not the same as presenting an invalid credential, which results in a FailedLoginException.
Typically this is because an incorrect username, password, or other information was presented.
Login modules that throw this exception may provide human-readable details through the getMessage( ) method.
This is one of the most important classes in the JAAS API for application programmers: it defines the login( ) method (and the corresponding logout( ) method) that allows an application to authenticate a user.
Create a LoginContext object using one of the javax.security.auth.callback.CallbackHandler that is to be used for communication between the underlying login module (or modules) and the user.
If no Subject is specified, then the LoginContext will instantiate a new one to represent the authenticated user.
If a Subject is supplied, then the LoginContext adds new entries to its sets of principals and credentials.
If no CallbackHandler is specified, then the LoginContext attempts to instantiate one using the class name specified by the auth.login.defaultCallbackHandler property in the system’s security properties file.
Once a LoginContext is successfully created, you can authenticate a user simply by calling the login( ) method, and then calling getSubject( ) to obtain the Subject object that represents the authenticated user.
When this Subject is no longer required, you can log them out by calling the logout( ) method.
Signals that something went wrong while creating a LoginContext or during the login or logout process.
The subclasses of this class represent more specific exception types.
Developers of login modules to be used with the JAAS authentication API must implement this interface.
Because this interface is not typically used by application developers, its methods are not documented here.
This package defines classes for use with authentication schemes for on X.500 principals.
This class implements the java.security.Principal interface for entities represented by X.500 constructor methods can accept the distinguished name in string form or in binary encoded form.
The no-argument version of getName( ) (the one defined by the Principal interface) returns the distinguished name formatted as specified by RFC 2253
Finally, getEncoded( ) returns a binary-encoded form of the name.
This class associates a java.security.cert.X509Certificate with a java.security.PrivateKey for that certificate, and, optionally, the keystore alias used to retrieve the certificate and key from a java.security.KeyStore.
The class defines methods to retreive the certificate, key, and alias, and also implements the methods of the javax.security.cert.Destroyable interface.
It defines Source and Result interfaces to represent a source document and a result document.
This package has many important subpackages but defines only a single class XMLConstants, which, as its name implies, provides symbolic names for constants defined by various XML specifications.
This class is a repository for constants defined by various XML standards.
This package defines Java data types that correspond to certain time, date, and duration data types required by the W3C XML Schema, XQuery, and XPath standards.
This package is of primary interest to those implementing schema validators and XPath evaluators and should not be required by applications that use schemas or XPath expressions.
An exception of this type is thrown by DatatypeFactory.newInstance( ) to indicate a factory configuration error.
Most of the constants are int values, but some are qualified names and some are instances of the DatatypeConstants.Field type.
This class defines a typesafe enumeration for some of the constants in DatatypeConstants.
Note that it is a class, not a Java 5.0 enum type.
This class defines factory methods for creating Duration and XMLGregorianCalendar objects.
An instance of this class represents a length of time.
This small package defines types for working with XML namespaces.
NamespaceContext represents a mapping between namespace URIs and namespace prefixes.
QName represents a qualified name consisting of a local part and a namespace.
This interface represents a mapping between namespace URIs and the local prefixes that are bound to them.
Use getNamepaceURI( ) to obtain the URI that a prefix is bound to.
More than one prefix can be bound to the same URI, and the getPrefixes( ) method returns an Iterator that you can use to loop through all prefixes that have been associated with a given URI.
Note that a QName does not always have a prefix and that the prefix, if it exists, is ignored for the purposes of the equals( ), hashCode( ), and toString( ) methods.
The static valueOf( ) method parses a QName from a string in the format of toString( ):
Passed To javax.xml.xpath.XPath.evaluate( ), javax.xml.xpath.XPathExpression.evaluate( ), javax.xml.xpath.XPathFunctionResolver.resolveFunction( ), javax.xml.xpath.XPathVariableResolver.resolveVariable( )
This package defines classes that represent XML parsers and factory classes for obtaining instances of those parser classes.
DocumentBuilder is a DOM-based XML parser created from a DocumentBuilderFactory.
SAXParser is a SAX-based XML parser created from a SAXParserFactory.
Instead, it is an implementationindependent layer that supports “pluggable” XML parsers.
Furthermore, this package does not define a DOM or SAX API for working with XML documents.
The DOM API is defined in org.w3c.dom, and the SAX API is defined in org.xml.sax and its subpackages.
This class defines a high-level API to an underlying DOM parser implementation.
After obtaining a DocumentBuilder, you can provide org.xml.sax.ErrorHandler and org.xml.sax.EntityResolver objects, if desired.
These classes are defined by the SAX API but are useful for DOM parsers as well.) You may also want to call isNamespaceAware( ), isXIncludeAware( ) and isValidating( ) to ensure that the parser is configured with the features your application requires.
Finally, use one of the parse( ) methods to read an XML document from a stream, file, URL, or org.xml.sax.InputSource object, parse that document, and convert it into a org.w3c.dom.Document tree.
In Java 5.0, you can call reset( ) to restore the parser to its original state for reuse.
Another Java 5.0 method, getSchema( ) returns the Schema object, if any, registered with the DocumentBuilderFactory that created this parser.
If you want to obtain an empty Document object (so that you can build the document tree from scratch, for example) call newDocument( )
Or use getDOMImplementation( ) to obtain a the org.w3c.dom.DOMImplementation object of the underlying DOM implementation from which you can also create an empty Document.
See the org.w3c.dom package for information on what you can do with a Document object once you have used a DocumentBuilder to create it.
A DocumentBuilderFactory is a factory class for creating DocumentBuilder objects.
You can obtain a DocumentBuilderFactory by instantiating an implementation-specific subclass provided by a parser vendor, but it is much more common to simply call newInstance( ) to obtain an instance of the factory that has been configured as the default for the system.
Once you have obtained a factory object, you can use the various set methods to configure the properties of the DocumentBuilder objects it will create.
These methods allow you to specify whether the parsers created by the factory will:
In Java 5.0, you can use setSchema( ) to specify the javax.xml.vaidation.Schema object against which parsers should validate their documents.
And you can use setXIncludeAware( ) to indicate that parsers should process XInclude markup.
In addition to the various implementation-independent set methods, you can also use setAttribute( ) pass an implementation-dependent named attribute to the underlying parser implementation.
Once you have configured the factory object as desired, simply call newDocumentBuilder( ) to create a DocumentBuilder object with the all of the attributes you have specified.
If the javax.xml.parsers.DocumentBuilderFactory system property is defined, then the class specified by that property is used.
Otherwise, if the jre/lib/jaxp.properties file exists in the Java distribution and contains a definition for the javax.xml.parsers.DocumentBuilderFactory property, then the class specified by that property is used.
Otherwise, if any of the JAR files on the classpath includes a file named METAINF/services/javax.xml.parsers.DocumentBuilderFactory, then the class named in that file will be used.
Otherwise, a default implementation provided by the Java implementation will be used.
This usually means that a pluggable parser implementation has been incorrectly plugged in and the getInstance( ) method cannot locate the specified factory implementation class.
Signals a parser configuration problem that prevents a parser factory object from creating a parser object.
The SAXParser class is a wrapper around an org.xml.sax.XMLReader class and is used to parse XML documents using the SAX version 2 API.
Call setProperty( ) if desired to set a property on the underlying parser.
See www.saxproject.org for a description of standard SAX properties and their values.
Finally, call one of the parse( ) methods to parse an XML document from a stream, file, URL, or org.xml.sax.InputSource.
A SAX parser does not build a document tree to describe an XML document like a DOM parser does.
Instead, it describes the XML document to your application by invoking methods on an object the application provides.
This is the purpose of the org.xml.sax.helpers.DefaultHandler object that is passed to the parse( ) method: you subclass this class to implement the methods you care about, and the parser will invoke those methods at appropriate times.
For example, when the parser encounters an XML tag in a document, it parses the tag, and calls the startElement( ) method to tell you about it.
And when it finds a run of plain text, it passes that text to the characters( ) method.
In Java 5.0, the reset( ) method restores a SAXParser to its original state so that it can be reused.
Instead of using one of the parse( ) methods of this class, you can also call getXMLReader( ) to obtain the underlying XMLReader object and work with it directly to parse the desired document.
Note that the getParser( ) method as well as the parse( ) methods that take an org.xml.sax.HandlerBase object are based on the SAX version 1 API, and should be avoided.
Once you have a SAXParserFactory object, you can use setValidating( ) and setNamespaceAware( ) to specify whether the parsers it creates will be validating parsers or not and whether they will know how to handle XML namespaces.
You may also call setFeature( ) to set a feature of the underlying parser implementation.
See http://www.saxproject.org for the names of standard parser features that can be enabled and disabled with this method.
In Java 5.0, call setXIncludeAware( ) to specify that created parsers will recognize XInclude markup.
Use setSchema( ) to specify a W3C XML Schema against which parsers should validate the document.
Once you have created and configured your factory object, simply call newSAXParser( ) to create a SAXParser object.
This pluggability is provided by the getInstance( ) method, which follows the following steps to determine which SAXBuilderFactory subclass to use:
If the javax.xml.parsers.SAXParserFactory system property is defined, then the class specified by that property is used.
Otherwise, if the jre/lib/jaxp.properties file exists in the Java distribution and contains a definition for the javax.xml.parsers.SAXParserFactory property, then the class specified by that property is used.
Otherwise, if any of the JAR files on the classpath includes a file named METAINF/services/javax.xml.parsers.SAXParserFactory, then the class named in that file will be used.
Otherwise, a default implementation provided by the Java platform will be used.
This package defines an high-level implementation-independent API for using an XSLT engine or other document transformation system for transforming XML document content, and also for transforming XML documents from one form (such as a stream of text in a file) to anther form (such as a tree of DOM nodes)
The Source interface is a very generic description of a document source.
Three concrete implementations that represent documents in text form, as DOM trees, and as sequences of SAX parser events are defined in the three subpackages of this package.
The Result interface is a similarly high-level description of what form the source document should be transformed into.
The three subpackages define three Result implementations that represent XML documents as streams or files, as DOM trees, and as sequnces of SAX parser events.
The implementation provides a default factory that represents an XSLT engine.
A TransformerFactory can be used to produce Templates objects that represent compiled XSL stylesheets (or other implementation-dependent forms of transformation instructions)
Documents are actually transfomed from Soruce to Result with a Transformer object, which is obtained from a Templates object, or directly from a TransformerFactory.
This interface defines methods that Transformer and TransformerFactory use for reporting warnings, errors, and fatal errors to an application.
To use an ErrorListener, an application must implement this interface and pass an implementing object to the setErrorListener( ) method of Transformer or TransformerFactory.
The argument to each method of this interface is a TransformerException object, and the implementation of these methods can throw that exception if it chooses, or it can simply log the warning or error in some way and return.
A Transformer or TransformerFactory is not required to continue processing after reporting a nonrecoverable error with an invocation of the fatalError( ) method.
If you are familiar with the SAX API for parsing XML documents, you’ll recognize that this interface is very similar to org.xml.sax.ErrorHandler.
This class defines string constants that hold the names of the attributes of an object returned by Templates.getOutputProperties( ) and passed to Transformer.setOutputProperties( )
This interface represents, in a very general way, the result of an XML transformation.
All other methods related to the result are the responsibility of the concrete implementation of this interface.
See the DOMResult, SAXResult and StreamResult implementations in the three subpackages of this package.
This interface represents, in a very general way, the source of an XML document.
This is useful for resolving relative URLs and for error reporting even when the document is not read directly from a URL.
All other methods related to the document source are the responsibility of the concrete implementation of this interface.
See the DOMSource, SAXSource and StreamSource implementations in the three subpackages of this package.
This interface defines methods that return the system and public identifiers of an XML document, and return a line number and column number within that document.
SourceLocator objects are used with TransformerException and TransformerConfigurationException objects to specify the location in an XML file at which the exception occurred.
Note, however that system and public identifiers are not always available for a document, and so getSystemId( ) and getPublicId( ) may return null.
Also, a Tranformer is not required to track line and column numbers precisely, or at all, so.
If they return a value other than -1, it should be considered an approximation to the actual value.
If you are familiar with the SAX API for parsing XML, you’ll recognize this interface as a renamed version of org.xml.sax.Locator.
This interface represents a set of transformation instructions for transforming a Source document into a Result document.
The javax.xml.transform package is nominally independent of type of transformation, but in practice, an object of this type always represents the compiled form of an XSLT stylesheet.
Obtain a Templates object from a TransformerFactory object, or with a javax.xml.transform.sax.TemplatesHandler.
Once you have a Templates object, you can use the newTransformer( ) method to create a Transformer object for applying the templates to a Source to produce a Result document.
These properties are specified in an XSLT stylesheet with the <xsl:output> element.
The constants defined by the OutputKeys are legal output property names.
The returned Properties object contains explicitly properties directly, and contains default values in a parent Properties object.
This means that if you query a property value with getProperty( ), you’ll get an explicitly specified value of a default value.
On the other hand, if you query a property with the get( ) method (inherited by Properties from its superclass) you’ll get a property value if it was explictly specified in the stylesheet, or null if it was not specified.
The returned Properties object is a clone of the internal value, so you can modify it (before passing it to the setOutputProperties( ) method of a Transformer object, for example) without affecting the Templates object.
A Templates object can be used to create any number of Transformer objects.
Objects of this type are used to transform a Source document into a Result document.
Obtain a Transformer object from a TransformerFactory object, from a Templates object created by a TransformerFactory, or from a TransformerHandler object created by a SAXTransformerFactory (these last two types are from the javax.xml.transform.sax package)
Once you have a Transformer object, you may need to configure it before using it to transform documents.
OutputKeys defines constants that represent the set of standard output property names.
The output properties you specify with these methods override any output properties specified (with an <xsl:output> tag) in the Templates object.
Use setParameter( ) to supply values for any top-level parameters defined (with <xsl:param> tags) in the stylesheet.
Note that if the name of any such parameter is a qualified name, then it appears in the stylesheet with a namespace prefix.
You can’t use the prefix with the setParameter( ) method, however, and you must instead specify the parameter name using the URI of the namespace within curly braces followed by the local name.
If no namespace is involved, then you can just use the simple name of the parameter with no curly braces or URIs.
Once you have created and configured a Transformer object, use the transform( ) method to perform a document transformation.
This method transforms the specified Source document and creates the transformed document specified by the Result object.
In Java 5.0, you can reset( ) a Transformer to restore it to its original state and prepare it for reuse.
You can reuse a Transformer object and call transform( ) any number of times (just not concurrently)
The output properties and parameters you specify are not changed by calling the transform( ) method, and can be reused.
This may occur, for exmaple, if there is a syntax error in the XSL stylesheet that contains the transformation instructions.
Use the inherited getLocator( ) method to obtain a SourceLocator that describes the document location at which the exception occurred.
Call getLocator( ) to obtain a SourceLocator object that describes the document location at which the exception occured.
A TransformerFactory is used to create Transformer objects that perform document transformations, and can also be used to process transformation instructions (such as XSLT stylesheets) into compiled Templates objects.
Obtain a TransformerFactory instance by calling the static newInstance( ) method.
The default TransformerFactory implementation provided with the Java distribution transforms XML documents using XSL stylesheets.
You can configure a TransformerFactory instance by calling setErrorListener( ) and setURIResolver( ) to specify an ErrorListener object and a URIResolver object to be used by the factory when reading and parsing XSL stylesheets.
The setAttribute( ) and getAttribute( ) methods can be used to set and query implementation-dependent attributes of the transformation engine.
The default engine supplied by Sun does not define any attributes.
The getFeature( ) method is used to test whether the factory supports a given feature.
For uniqueness, feature names are expressed as URIs, and each of the Source and Result implementations defined in the three subpackages of this package define a FEATURE constant that specifies a URL that you can use to test whether a TransformerFactory supports that particular Source or Result type.
Once you have obtained and configured your TransformerFactory object, you can use it in several ways.
If you call the newTransformer( ) method that takes no arguments, you’ll obtain a Transformer object that transforms the format or representation of an XML document without transforming its content.
For example, you could use a Transformer created in this way to transform a DOM tree (represented by a javax.xml.transform.dom.DOMSource object) to a stream of XML text stored in a file named by a javax.xml.transform.stream.StreamResult.
Another way to use a TransformerFactory is to call the newTemplates( ) method, passing in a Source object that represents an XSL stylesheet.
This produces a Templates object, which you can use to obtain a Transformer object that applies the stylesheet to transform document content.
Alternatively, if you do not plan to create more than one Transformer object from the Templates object, you can combine the two steps and simply pass the Source object representing the stylesheet to the one-argument version of newTransformer( )
The getAssociatedStylesheet( ) method reads the XML document represented by a Source object and returns a new Source object that represents the stylesheet (or the concatenation of all the stylesheets) contained in that document that match the media, title, and charset constraints defined by the other three parameters (which may be null)
If you want to process an XML document using the stylesheet that it defines itself, use this method to obtain a Source object that you can pass to newTransformer( ) to create the Transformer object that you can use to transform the document.
This error class signals a fatal problem while creating a TransformerFactory.
It usually signals a configuration problem, such as the system property javax.xml.transform.TransformerFactory has a value that is not a valid classname, or that the class path does not contain the specified factory implementation class.
This interface allows an application to tell a Transformer how to resolve the URIs that appear in an XSLT stylesheet.
If you pass a URIResolver to the setURIResolver( ) method of a Transformer or TransformerFactory then when the Transformer or TransformerFactory encounters a.
URI, it first passes that URI, along with the base URI to the resolve( ) method of the URIResolver.
If resolve( ) returns a Source object, then the Transformer will use that Source.
If a Transformer or TransformerFactory has no URIResolver registered, or if the resolve( ) method returns null, then the tranformer or factory will attempt to resolve the URI itself.
This package contains Source and Result implementations that work with DOM document trees and subtrees.
This class extends SourceLocator to define a method for retrieving a DOM Node object, which is typically used to indicate the source of an error in the transformation process.
This class is a Result implementation that writes XML content by generating a DOM tree to represent that content.
If you pass an org.w3c.dom.Node to the constructor or to setNode( ), the DOMResult will create the result tree as a child of the specified node (which should typically be a Document or Element node)
If you do not specify a node, the DOMResult will create a new Document node when it creates the result tree.
In Java 5.0, you can also pass two Node objects to the constructor: these specify the parent node of the result tree and the child of that parent before which the result tree should be inserted.
This class is a Source implementation that reads an XML document from a DOM document tree or subtree.
Pass the org.w3c.dom.Node object that represents the root of the tree or subtree to the constructor or to setNode( )
When possible, it is also useful to provide a system id (a filename or URL) for use in error messages and for resolving relative URLs contained in the document.
This package defines Source and Result implementations that work with SAX events.
In addition, it includes an extension to the TransformerFactory class that has additional methods for returning TemplatesHandler and TransformerHandler objects.
These objects implement SAX handler interfaces and are able to work with a SAX parser object to turn a series of SAX parse events into a Templates object or into a Result document.
SAXSource and SAXResult adapt the org.xml.sax framework for use in the javax.xml.transform framework.
This class is a Result implementation that describes the content of a transformed document by triggering the methods of the specified ContentHandler.
That is, a SAXResult acts like a org.xml.sax.SAXReader object, invoking the methods of the specified org.xml.sax.ContentHandler object as it parses the transformed document.
You may also provide a org.xml.sax.ext.LexicalHandler object whose methods will be invoked by the SAXResult by calling setLexicalHandler, or by suppling a ContentHandler object that also implements the LexicalHandler interface.
This class is a Source implementation that describes a document represented as a series of SAX event method calls.
A SAXSource requires an org.xml.sax.InputSource object that describes the stream to parse, and may optionally specify the org.xml.sax.XMLReader or org.xml.sax.XMLFilter that generates the SAX events.
If no XMLReader or XMLFilter is specified, then the Transformer object will a default XMLReader.) Note that since an InputSource is required, a SAXSource does not behave significantly differently than a StreamSource unless an XMLFilter is used.
SAXSource also has one static method, sourceToInputSource( ) which returns a SAX InputSource method derived from the specified Source object, or null if the specified Source cannot be converted to an InputSource.
This class extends TransformerFactory to define additional factory methods that are useful when working with documents that are represented as sequences of SAX events.
Pass the FEATURE constant to the getFeature( ) method of your TransformerFactory object to determine whether the newTemplatesHandler( ) and newTransformerHandler( ) methods are supported and whether it is safe to cast your TransformerFactory object to a SAXTransformerFactory.
Use the FEATURE_XMLFILTER constant with getFeature( ) to determine if the newXMLFilter( ) methods are also supported.
The newTransformerHandler( ) methods are similar: they return a TransformerHandler object that can receive SAX events and representing a source document and transform them into a Result document.
The no-argument version of newTransformerHandler( ) creates a TransformerHandler that simply modifies the form of the document without applying a stylesheet to its content.
The other two versions of newTransformerHandler( ) use a stylesheet specified either as a Source or Templates object.
The newXMLFilter( ) methods, if supported, return an org.xml.sax.XMLFilter object that can acts as both a sink and a source of SAX events and filters those events by applying the transformation instructions specified by the Templates or Source objects.
This interface extends org.xml.sax.ContentHandler and adds a getTemplates( ) method.
An object that implements this interface can be used to receive method calls from some source of SAX events and process those events (as a XSL stylesheet) into a Templates object.
Register it with the setContentHandler( ) method of an org.xml.sax.XMLReader and invoke the parse( ) method of the reader.
When parse( ) returns, call the getTemplates( ) method to obtain the Templates object.
This interface extends org.xml.sax.ContentHandler and related interfaces so that it can consume SAX events generated by a org.xml.sax.SAXReader or org.xml.sax.SAXFilter.
Create a TransformerHandler by calling one of the newTransformerHandler( ) methods of a SAXTransformerFactory.
Next, call the setResult( ) method to specify a Result object that describes the result document you’d like the transformation to produce.
You may also call getTransformer( ) to get the Transformer object associated with this TransformerHandler if you need to set output properties or parameter values for the transformation.
Now, register the TransformerHandler with the SAXReader or SAXFilter object by calling setContentHandler( ), setDTDHandler( ), and setProperty( )
Finally, invoke one of the parse( ) methods on your XMLReader or XMLFilter object.
This will cause the reader or filter to start parsing the source document and translating it into method calls on the TransformerHandler.
The TransformerHandler will transform those calls as specified in the Templates or Source object (if any) that was passed to the original call to newTransformerHandler( ) and generate a result document as directed by the Result object that was passed to setResult( )
This package contains Source and Result implementations that work with files and streams.
This class is a Result implementation that writes a textual representation of a transformed document to stream or file.
Because XML documents define their own encoding, it is usually preferable to construct a StreamResult using a File or OutputStream instead of a character-based Writer which may use a different encoding than that specified within the document.
This class is a Source implementation that reads the textual format of an XML document from a file, byte stream, or character stream.
Because XML documents declare their own encoding, it is preferable to create a StreamSource object from an InputStream instead of from a Reader, so that the XML processor can correctly handle the declared encoding.
The system id is required if the XML file to be processed includes relative URLs to be resolved.
This package contains classes for validating XML documents against W3C XML Schema definitions.
Implementations may also support additional schema types, such as RELAX NG.
Typical usage begins with the SchemaFactory class, which parses schema specifications into immutable Schema objects.
Next, the Schema object is used to create a Validator with which a document may be validated.
A Schema is an immutable opaque parsed representation of a schema.
Schema objects don’t perform validation themselves; instead, they are factories for Validator and ValidatorHandler objects that can be used to validate individual documents.
Returned By javax.xml.parsers.DocumentBuilder.getSchema( ), javax.xml.parsers.DocumentBuilderFactory.getSchema( ), javax.xml.parsers.SAXParser.getSchema( ), javax.xml.parsers.SAXParserFactory.getSchema( ), SchemaFactory.newSchema( )
A SchemaFactory parses the textual representation of a schema into a Schema object.
Obtain a SchemaFactory with the newInstance( ) method, passing a string that identifies the type of schema you want to parse.
Other schema types may also be supported, such as RELAX NG schemas, identified by XMLConstants.RELAXNG_NS_URI.
To parse a schema, call the newSchema( ) method, passing the File or javax.xml.transform.Source object that identifies the schema contents.
For schemas in the W3C XML Schema language, you may also specify an array of Source objects that contain the schema definition.
If you call newSchema( ) with no arguments, a special Schema object is returned that expects the document to specify the location of its own W3C XML Schema.
You can configure a SchemaFactory before calling newSchema( ) with setErrorHandler( ), setResourceResolver( ), setProperty( ), and setFeature( )
This class is used by implementations of the validation API to produce a SchemaFactory object for a specified schema type.
Applications that use the javax.xml.validation package do not need to use this class.
A TypeInfoProvider provides information about the type of the element or attribute currently being processed by a ValidatorHandler.
This type information is obtained by validating document content against a schema and may be useful to the ContentHandler to which the ValidatorHandler dispatches its method calls.
A Validator object validates an XML document against the Schema from which the Validator was created.
Specify the document to be validated with a DOMSource or SAXSource object (from the javax.xml.transform.dom or javax.xml.transform.sax packages)
The validate( ) method accepts any javax.xml.transform.Source object as an argument, but SAXSource and DOMSource are the only two supported implementations.
The document validation process can also be used to augment the source document by adding the default values of unspecified attributes.
If you want to capture this augmented form of the document, pass a Result object to the two-argument version of validate( )
If the source is a SAXSource, the result must be a SAXResult, and if the source is a DOMSource, the result must be a DOMResult object.
If the document is valid, the validate( ) method returns normally.
If the document is not valid, validate( ) throws an org.xml.sax.SAXException.
You can alter this somewhat by passing a custom org.xml.sax.ErrorHandler to setErrorHandler( )
Validation exceptions are first passed to the error handler methods, which may throw the exception or handle them in some other way, such as printing a message.
If the error handler does not throw an exception, the validate( ) method attempts to continue validation.
The default error handler ignores exceptions passed to its warn( ) method but throws exceptions passed to its error( ) and fatalError( ) methods.
Before calling validate( ), a Validator may also be configured with setResourceResolver( ), setFeature( ), and setProperty( )
A ValidatorHandler is an org.xml.sax.ContentHandler that uses the streaming SAX API to validate an XML document against the Schema from which the ValidatorHandler was derived.
The Validator class can be used to validate a SAXSource, but ValidatorHandler provides lower-level access to the SAX API.
If the document is not valid, one of the ContentHandler methods throws a SAXException that propagates up to your code.
As with the Validator class, you can alter this by specifying a custom org.xml.sax.ErrorHandler class.
ValidatorHandler can be used as a filter for SAX parsing events.
If you pass a ContentHandler to setContentHandler( ), the ValidatorHandler augments the source document with attribute defaults from the schema and invokes the appropriate callback methods on the ContentHandler you supply.
If you are interested in attribute and element type information provided by the schema, your ContentHandler can use the TypeInfoProvider obtained from the ValidatorHandler getTypeInfoProvider( )
This package defines types for the evaluation of XPath expressions in the context of an XML document.
XPath is a language for describing a “path” to a node or set of nodes within an XML document.
Details of the XPath grammar are beyond the scope of this reference.
A typical use of this package begins with the XPathFactory, an instance of which is used to create an XPath object.
After configuring the XPath object as desired, you can use it to evaluate XPath expressions directly or to compile XPath expressions into XPathExpression objects for later use.
An XPath object is used to compile or evaluate an XPath expression.
Configuration methods of XPath allow you to specify an XPathVariableResolver and an XPathFunctionResolver to resolve variable and function references in XPath expressions.
You may also specify the javax.xml.namespace.NamespaceContext with which the XPath can resolve qualified names.
After creating and configuring an XPath object, you can use the compile( ) method to compile an XPath expression for later evaluation, or you can use one of the evaluate( ) methods to compile and evaluate an expression directly.
All expect a String containing an XPath expression as their first argument.
The second argument is the document or portion of a document to evaluate the expression against.
Two versions of evaluate( ) expect an org.xml.sax.InputSource for this second argument.
These versions of the method first parse the document and build a DOM (or other object model) tree.
The other two versions of evaluate( ) expect an Object as the second argument.
The object passed should be a DOM (or other object model) object representing the document or some portion of it.
For the org.w3c.dom object model, this might be a Document, DocumentFragment, Node, or NodeList object.
The final difference between evaluate( ) methods is the presence or absence of a third argument.
The two-argument versions of evaluate( ) return the result of the expression.
The three-argument versions expect a third argument that specifies the desired return type and return an Object of an appropriate type.
The valid types are the QName objects defined in the XPathConstants class, such as XPathConstants.NODE and XPathConstants.NODESET.
This class defines javax.xml.namespace.QName constants that represent the possible return types of the evaluate( ) methods of XPath and XPathExpression.
This is the common superclass of all XPath-related exception types.
XPathExpression compile(String expression) throws XPathExpressionException; String evaluate(String expression, Object item) throws XPathExpressionException; String evaluate(String expression, org.xml.sax.InputSource source) throws XPathExpressionException; Object evaluate(String expression, org.xml.sax.InputSource source, javax.xml.namespace.QName returnType)
If an XPath expression is to be evaluated more than once, it is not efficient to call the XPath.evaluate( ) method repeatedly.
Instead, compile the expression to an XPathExpression using the XPath.compile( ) method and then evaluate it using one of the evaluate( ) methods of XPathExpression.
The evaluate( ) methods of XPathExpression behave just like the corresponding methods of XPath.
Exceptions of this type indicate an error while compiling or evaluating an XPath expression.
See the compile( ) and evaluate( ) methods of XPath and XPathExpression.
String evaluate(org.xml.sax.InputSource source) throws XPathExpressionException; String evaluate(Object item) throws XPathExpressionException; Object evaluate(Object item, javax.xml.namespace.QName returnType) throws XPathExpressionException; Object evaluate(org.xml.sax.InputSource source, javax.xml.namespace.QName returnType)
The XPathFactory class is a factory for creating XPath expression evaluators.
Call the noargument version of newInstance( ) to obtain an XPathFactory object that creates XPath object to work with DOM documents.
The javax.xml.xpath package is nominally object-model independent, however, and you can specify the name of a different object model by calling the one-argument version of newInstance( )
Once you have created an XPathFactory object, you can set default function and variable resolvers with setXPathFunctionResolver( ) and setXPathVariableResolver( )
You can configure implementation-dependent features of an XPathFactory with setFeature( )
When this feature is set to true, external functions are not allowed in XPath expressions, and the XPathFunctionResolver is not used.
After creating and configuring an XPathFactory object, use the newXPath( ) method to create one or more XPath objects for actually evaluating XPath expressions.
This exception is thrown by methods of XPathFactory to indicate that a specified object model or feature is not supported.
This interface defines the invocation API for user-defined XPath functions.
Arguments are passed to the evaluate( ) method as a java.util.List and the return value should be an Object.
Exceptions of this type may be thrown by user-defined XPathFunction implementations.
This interface defines a single method to return the XPathFunction with the specified qualified name and specified arity (number of arguments)
Objects that implement this interface may be passed to the setXPathFunctionResolver( ) methods of XPath or XPathFactory.
Note that the function resolvers are invoked only for functions defined in an external namespace, so they cannot be used to override the meaning of XPath’s built-in functions or to add new core functions to the XPath language.
Also, if the XMLConstants.FEATURE_SECURE_PROCESSING feature has been enabled on an XPathFactory, userdefined functions are not allowed in XPath expressions, and the XPathFunctionResolver is never called.
This interface defines a single method to return the Object value of a variable identified by a qualified name.
The value of a named variable is allowed to change between XPath evaluations, but implementations of this interface must ensure that no variable changes during the evaluation of an expression.
Objects that implement this interface may be passed to the setXPathVariableResolver( ) methods of XPath or XPathFactory.
This package defines the Java binding to the core and XML modules of the DOM API defined by the World Wide Web Consortium (W3C)
This package includes methods that allow document trees to be traversed, examined, modified, and built from scratch.
All nodes in a document tree implement this interface, and it defines the basic methods for traversing and modifying the tree of nodes.
Most of the other interfaces in the package are extensions of Node that represent specific types of XML content.
The most important and commonly used of these subinterfaces are Document, Element, and Text.
A Document object serves as the root of the document tree and defines methods for searching the tree for elements with a specified tag name or ID attribute.
The Element interface represents an XML element or tag and has methods for manipulating the element’s attributes.
The Text interface represents a run of plain text within an Element and has methods for querying or altering that text.
NodeList and DOMImplementation do not extend Node but are also important interfaces.
This package is an endorsed standard, which means that it is defined outside of Sun Microsystems and the Java Community Process but has been adopted as part of the Java platform.
Note that Java 5.0 also adopts the bootstrap, events, and ls (load/save) subpackages.
Those subpackages are not documented in this book because they are only tangentially used by the rest of the Java platform.
An Attr object represents an attribute of an Element node.
Attr objects are associated with Element nodes, but are not directly part of the document tree: the getParentNode( ) method of an Attr object always returns null.
Use getOwnerElement( ) to deterine which Element an Attr is part of.
You can obtain an Attr object by calling the getAttributeNode( ) method of Element, or you can obtain a NamedNodeMap of all Attr objects for an element with the getAttributes( ) method of Node.
The getValue( ) method returns the attribute value as a single string.
If you want to know the precise composition of the attribute however, you can examine the children of the Attr node: they may consist of Text and/or EntityReference nodes.
In most cases the easiest way to work with attributes is with the getAttribute( ) and setAttribute( ) methods of the Element interface.
This interface represents a CDATA section in an XML document.
CDATASection is a subinterface of Text and does not define any methods of its own.
The content of the CDATA section is available through the getNodeValue( ) method inherited from Node, or through the getData( ) method inherited from CharacterData.
Although CDATASection nodes can often be treated in the same way as Text nodes, note that the Node.normalize( ) method does not merge adjacent CDATA sections.
This interface is a generic one that is extended by Text, CDATASection (which extends Text) and Comment.
Any node in a document tree that implements CharacterData also implements one of these more specific types.
This interface exists simply to group the string manipulation methods that these text-related node types all share.
The appendData( ), deleteData( ), insertData( ), and replaceData( ) methods mutate the data by appending a string to the end, deleting region, inserting a string at the specified location, and replacing a region with a specified string.
A Comment node represents a comment in an XML document.
This content may be manipulated using the various methods inherited from CharacterData.
This interface represents a DOM document, and an object that implements this interface serves as the root of a DOM document tree.
Note that there are two versions of the methods for creating attributes and elements.
The methods with “NS” in their name are namespace-aware and require the attribute or element name to be specified as a combination of a namespace URI and a local name.
You’ll notice that throughout the DOM API, methods with “NS” in their names are namespace-aware.
The Element interface defines methods by the same names that search only within the subtree defined by an Element.
This is useful when you use an ID attribute to uniquely identify certain tags within an XML document.
It searches for attributes whose XML type (as declared in the document’s DTD) is ID.
Such attributes are often named “id”, but this is not required.
Note, however that this does not mean that a Document node has only one child.
It must have exactly one child that is an Element, but it can also have other children such as Comment and ProcessingInstruction nodes.
The getDoctype( ) method returns the DocumentType object (or null if there isn’t one) that represents the document’s DTD.
More specifically, it represents one or more adjacent document nodes, and all of the descendants of each.
DocumentFragment nodes are never part of a document tree, and getParentNode( ) always returns null.
Although a DocumentFragment does not have a parent, it can have children, and you can use the inherited Node methods to add child nodes (or delete or replace them) to a DocumentFragment.
DocumentFragment nodes exhibit a special behavior that makes them quite useful: when a request is made to insert a DocumentFragment into a document tree, it is not the DocumentFragment node itself that is inserted, but each of the children of the DocumentFragment instead.
This makes DocumentFragment useful as a temporary placeholder for a sequence of nodes that you wish to insert, all at once, into a document.
You can create a new, empty, DocumentFragment to work with by calling the createDocumentFragment( ) method of the desired Document.
Because the DTD is not part of the document itself, a DocumentType object is not part of DOM document tree, even though it extends the Node interface.
If a Document has a DTD, then you may obtain the DocumentType object that represents it by calling the getDoctype( ) method of the Document object.
You can use this NamedNodeMap to lookup an Entity object by name.
Similarly, getNotations( ) returns a read-only NamedNodeMap that allows you to look up a Notation object declared in the DTD by name.
DocumentType does not provide access to the bulk of a DTD, which usually consists of element and attribute delcarations.
Future versions of the DOM API may provide more details.
This Level 3 interface defines methods for querying and setting the values of named parameters.
The DOMConfiguration object obtained with the Document.getDomConfig( ) method allows you to specify parameters that affect the behavior of the Document.normalizeDocument( ) method.
You can also obtain a DOMConfiguration object from the LSParser and LSSerializer interfaces of the org.w3c.dom.ls package.
Those configuration objects affect the way documents are loaded and saved, but the package is beyond the scope of this book.
See the DOM specification for details on the available parameters.
This Level 3 interface describes an error that occurs while processing a document (such as when loading, saving, validating or normalizing it)
An object that implements this interface is passed to the registered DOMErrorHandler, if any.
The constants defined by this interface represent error severity levels.
Note that this interface is unrelated to DOMException class or to the java.lang.Error and java.lang.Exception classes.
This Level 3 interface defines a handler for DOMError objects that represent errors while processing an XML document.
Register an object that implements this interface by setting it as the value of the “error-handler” property through the DOMConfiguration interface.
An instance of this class is thrown whenever an exception is raised by the DOM API.
Unlike many Java APIs, the DOM API does not define specialized subclasses to define different categories of exceptions.
Object getParameter(String name) throws DOMException; void setParameter(String name, Object value) throws DOMException;
The value of this field will be one of the constants defined by this class, which have the following meanings:
INDEX_SIZE_ERR Indicates an out-of-bounds error for an array or string index.
DOMSTRING_SIZE_ERR Indicates that a requested text is too big to fit into a String object.
Exceptions of this type are intended for DOM implementations for other languages and should not occur in Java.
HIERARCHY_REQUEST_ERR Indicates that an attempt was made to place a node somewhere illegal in the document tree hierarchy.
WRONG_DOCUMENT_ERR Indicates an attempt to use a node with a document that is different than the document that created the node.
INVALID_CHARACTER_ERR Indicates that an illegal character is used (in an element name, for example)
NO_MODIFICATION_ALLOWED_ERR Indicates that an attempt was made to modify a node that is read-only and does not allow modifications.
Entity, EntityReference, and Notation nodes, and all of their descendants are read-only.
NOT_FOUND_ERR Indicates that a node was not found where it was expected.
NOT_SUPPORTED_ERR Indicates that a method or property is not supported in the current DOM implementation.
INUSE_ATTRIBUTE_ERR Indicates that an attempt was made to associate an Attr with an Element when that Attr node was already associated with a different Element node.
INVALID_STATE_ERR Indicates an attempt to use an object that is not yet, or is no longer, in a state that allows such use.
SYNTAX_ERR Indicates that a specified string contains a syntax error.
Exceptions of this type are not raised by the core module of the DOM API described here.
INVALID_MODIFICATION_ERR Exceptions of this type are not raised by the core module of the DOM API described here.
INVALID_ACCESS_ERR Indicates an attempt to access an object in a way that is not supported by the implementation.
This interface defines methods that are global to an implementation of the DOM rather than specific to a particular Document object.
Obtain a reference to the DOMImplementation object that represents your implementation by calling the getImplementation( ) method of any Document object.
The DOM standard includes a number of optional modules, but the Java platform has not adopted the subpackages of this package that define the API for those optional modules, and therefore the DOM implementation bundled with a Java implementation is not likely to support those modules.
The javax.xml.parsers.DocumentBuilder class provides another way to obtain the DOMImplementation object by calling its getDOMImplementation( ) method.
It also defines a shortcut newDocument( ) method for creating empty Document objects to populate.
This Level 3 interface represents a fixed-size, read-only list (or array) of DOMImplementation objects.
This Level 3 interface is designed for use by DOM implementors.
It is also used in the org.w3c.dom.bootstrap package, which is beyond the scope of this book.
This Level 3 interface represents the location at which a DOMError occurred.
The methods return the location of the error as measured by various metrics (byte offset, line and column number, etc.) and return -1 or null if location information is not available.
This Level 3 interface represents a fixed-size, read-only list of strings.
An object of this type is returned by DOMConfiguration.getParameterNames( )
This interface represents an element (or tag) in an XML document.
When working with namespaces, you will probably prefer to use the namespace-aware methods defined by the Node interface.
Use getNamespaceURI( ) to get the namespace URI of the element, and use getLocalName( ) to the local name of the element within that namespace.
You can also use getPrefix( ) to query the namespace prefix, or setPrefix( ) to change the namespace prefix (this does not change the namespace URI)
Element defines a getElementsByTagName( ) method and a corresponding namespace-aware getElementsByTagNameNS( ) method, which behave just like the methods of the same names on the Document object, except that they search for named elements only within the subtree rooted at this Element.
The remaining methods of the Element interface are for querying and setting attribute values, testing the existence of an attribute, and removing an attribute from the Element.
There are a confusing number of methods to perform these four basic attribute operations.
If an attribute-related method has “NS” in its name, then it is namespace-aware.
If it has “Node” in its name, then it works with Attr objects rather than with the simpler string representation of the attribute value.
If your document may include entity references in attribute values, then you may need to use the Attr interface because the expansion of such an entity reference can result in a subtree of nodes beneath the Attr object.
Whenver possible, however, it is much easier to work with the methods that treat attribute values as plain strings.
Note also that in addition to the attribute methods defined by the Element interface you can also obtain a NamedNodeMap of Attr objects with the getAttributes( ) method of the Node interface.
Finally, note also that getAttribute( ) and related methods and hasAttribute( ) and related methods return the value of or test for the existance of both explicitly specified attributes, and also attributes for which a default value is specified in the document DTD.
If you need to determine whether an attribute was explicitly specified in the document, obtain its Attr object, and use its getSpecified( ) method.
This interface represents an entity defined in an XML DTD.
The name of the entity is specified by the getNodeName( ) method inherited from the Node interface.
The entity content is represented by the child nodes of the Entity node.
The methods defined by this interface return the public identifier and system identifier for external entities, and the notation name for unparsed entities.
Note that Entity nodes and their children are not part of the document tree (and the getParentNode( ) method of an Entity always returns null)
Instead a document may contain one or more references to an entity: see the EntityReference interface.
The DocumentType interface has a getEntities( ) method that returns a NamedNodeMap mapping entity names to Entity nodes.
This is the only way to obtain an Entity object: because they are part of the DTD, Entity nodes never appear within the document tree itself.
Entity nodes and all descendants of an Entity node are read-only and cannot be edited or modified in any way.
This interface represents a reference from an XML document to an entity defined in the document’s DTD.
Character entities and predefined entities such as &lt; are always expanded in XML documents and do not create EntityReference nodes.
Note also that some XML parsers expand all entity references.
Documents created by such parsers do not contain EntityReference nodes.
The getNodeName( ) method of the Node interface provides the name of the referenced entity.
The getEntities( ) method of the DocumentType interface provides a way to look up the Entity object associated with that name.
Note however, that the DocumentType may not contain an Entity with the specified name (because, for example, nonvalidating XML parsers are not required to parse the external subset of the DTD.) In this case, the EntityReference is a reference to a named entity whose content is not known, and it has no children.
On the other hand, if the DocumentType does contain an Entity node with the specified name, then the child nodes of the EntityReference are a copy of the child nodes of the Entity, and represent the expansion of the entity.
The children of an EntityReference may not be an exact copy of the children of an Entity if the entity’s expansion includes namespace prefixes that are not bound to namespace URIs.)
Like Entity nodes, EntityReference nodes and their descendants are read-only and cannot be edited or modified.
The NamedNodeMap interface defines a collection of nodes that may be looked up by name or by namespace URI and local name.
Use getNamedItem( ) to look for and return a node whose getNodeName( ) method returns the specified value.
Use getNamedItemNS( ) to look for and return a node whose getNamespaceURI( ) and getLocalName( ) methods return the specified values.
A NamedNodeMap is a mapping from names to nodes, and does not order the nodes in any particular way.
Nevertheless, it does impose an arbitrary ordering on the nodes and allow them to be looked up by index.
Use getLength( ) to find out how many nodes are contained in the NamedNodeMap, and use item( ) to obtain the Node object at a specified index.
If a NamedNodeMap is not read-only, you can use removeNamedItem( ) and removeNamedItemNS( ) to remove a named node from the map, and you can use setNamedItem( ) and setNamedItemNS( ) to add a node to the map, mapping to it from its name or its namespace URI and local name.
NamedNodeMap objects are “live,” which means that they immediately reflect any changes to the document tree.
For example, if you obtain a NamedNodeMap that represents the.
NamedNodeMap is returned only by relatively obscure methods of the DOM API.
The most notable use is as the return value of the getAttributes( ) method of Node.
It is usually easier to work with attributes through the methods of the Element interface, however.
This Level 3 interface represnts a fixed-size, read-only list of element or attribute names and their namespace URI.
All objects in a DOM document tree (including the Document object itself) implement the Node interface, which provides basic methods for traversing and manipulating the tree.
You can enumerate the children of a given node by looping through the elements of the NodeList returned by getChildNodes( ), or by using getFirstChild( ) and getNextSibling( ) (or getLastChild( ) and getPreviousSibling( ) to loop backwards)
It is sometimes useful to call hasChildNodes( ) to determine whether a node has children or not.
It provides a quick way to jump to the root of the document tree.
Several methods allow you to add children to a tree or alter the list of children.
For all of these methods, if the node to be appended or inserted is already part of the document tree, it is first removed from its current parent.
Use cloneNode( ) to produce a copy of this node.
Pass true if you want all descendants of this node to be cloned as well.
Every object in a document tree implements the Node interface, but also implements a more specialized subinterface, such as Element or Text.
The getNodeType( ) method provides an easy way to determine which subinterface a node implements: the return value is one of the _NODE constants defined by this class.
You might use the return value of getNodeType( ) in a switch statement, for exmaple, to determine how to process a node of unknown type.
Note that subinterfaces typically define specialized methods (such as the getTagName( ) method of Element and the getData( ) method of Text) for obtaining this same information.
Note also that unless a node is read-only, you can use setNodeValue( ) to alter the value associated with the node.
In documents that use namespaces, the getNodeName( ) method of a Element or Attr node returns the qualified node name, which may include a namespace prefix.
In documents that use namespaces, you may prefer to use the namespace-aware methods getNamespaceURI( ), getLocalName( ) and getPrefix( )
Element nodes may have a list of attributes, and the Element interface defines a number of methods for working with these attributes.
In addition, however, Node defines the hasAttributes( ) method to determine if a node has any attributes.
If it does, they can be retrieved with getAttributes( )
Text content in an XML document is represented by Text nodes, which have methods for manipulating that textual content.
The Node interface defines a normalize( ) method which has the specialized purpose of normalizing all descendants of a node by deleting empty Text nodes and coalescing adjacent Text nodes into a single combined node.
Document trees usually start off in this normalized form, but modifications to the tree may result in non-normalized documents.
Most of the other interfaces in this package extend Node.
This interface represents a read-only ordered collection of nodes that can be interated through.
The elements of a NodeList are always valid Node objects: a NodeList never contains null elements.
Note that NodeList objects are “live"—they are not static but immediately reflect changes to the document tree.
For example, if you have a NodeList that represents the children of a specific node, and you then delete one of those children, the child will be removed from your NodeList.
Be careful when looping through the elements of a NodeList if the body of your loop makes changes to the document tree (such as deleting nodes) that may affect the contents of the NodeList!
This interface represents a notation declared in the DTD of an XML document.
In XML notations are used to specify the format of an unparsed entity or to formally declare a processing instruction target.
The getNodeName( ) method of the Node interface returns the name of the notation.
The getNotations( ) method of the DocumentType interface returns a NamedNodeMap of Notation objects declared in the DTD and provides a way to look up Notation objects by notation name.
Because notations appear in the DTD and not the document itself, Notation nodes are never part of the document tree, and the getParentNode( ) method always returns null.
Similarly, since XML notation declarations never have any content, a Notation node never has children and getChildNodes( ) always returns null.
Notation objects are read-only and cannot be modified in any way.
Node removeChild(Node oldChild) throws DOMException; Node replaceChild(Node newChild, Node oldChild) throws DOMException; void setNodeValue(String nodeValue) throws DOMException; void setPrefix(String prefix) throws DOMException;
This interface represents an XML processing instruction (or PI) which specifies an arbitrary string of data to a named target processor.
The getTarget( ) and getData( ) methods return the target and data portions of a PI, and these values can also be obtained using the getNodeName( ) and getNodeValue( ) methods of the Node interface.
You can alter the data portion of a PI with setData( ) or with the setNodeValue( ) method of Node.
A Text node represents a run of plain text that does not contain any XML markup.
Plain text appears within XML elements and attributes, and Text nodes typically appear as children of Element and Attr nodes.
Text nodes inherit from CharacterData, and the textual content of a Text node is available through the getData( ) method inherited from CharacterData or through the getNodeValue( ) method inherited from Node.
Text nodes may be manipulated using any of the methods inherited from CharacterData.
The Text interface defines one method of its own: splitText( ) splits a Text node at the specified character position.
The method changes the original node so that it contains only the text up to the specified position.
Then it creates a new Text node that contains the text from the specified position on and inserts that new node into the document tree immediately after the original one.
The Node.normalize( ) method reverses this process by deleting emty Text nodes and merging adjacent Text nodes into a single node.
This Level 3 interface represents information about the type of an Element or Attr node.
Obtain a TypeInfo object by calling the getSchemaTypeInfo( ) method of an Element or Attr.
Note that TypeInfo information is only available if the document has been validated against a W3C XML Schema.
The methods of TypeInfo return the name and namespace of the element or attribute type.
The constants defined by the interface specify different derivation techniques for types.
This Level 3 interface defines a handler that is invoked when a node on which userspecified data has been registered is adopted, cloned, deleted, imported or renamed.
Register an object that implements this interface in the call to Node.setUserData( )
The org.xml.sax.ext package defines optional extensions to the SAX API, and the org.xml.sax.helpers package defines helper classes that are often useful with SAX.
This is the core package for SAX (Simple API for XML) parsing of XML documents.
These “events” are actually method calls made on one or more handler objects that the application has registered with the parser.
The XMLReader interface defines the API that must be implemented by a SAX parser.
ContentHandler, ErrorHandler, EntityResolver, and DTDHandler are interfaces that define handler objects.
An application registers objects that implement one or more of these interfaces with the XMLReader.
The AttributesList, DocumentHandler and Parser interfaces, as well as the HandlerBase class are part of the SAX1 API and are now deprecated in favor of Attributes, ContentHandler, XMLReader, and org.xml.sax.helpers.DefaultHandler.
This interface represents a list of attributes of an XML element and includes information about the attribute names, types, and values.
If the SAX parser has read a DTD or schema for the document, this list of attributes will include attributes that are not explicitly specified in the document but which have a default value specified in the DTD or schema.
The most commonly used method is getValue( ) which returns the value of a named attribute (there is also a version of this method that returns the value of a numbered attribute; it is discussed later)
If the SAX parser is not processing namespaces, you can use the one-argument version of getValue( )
The getType( ) methods are similar, except that they return the type of the named attribute, rather than its value.
In XML documents the attributes of a tag can appear in any order.
Attributes objects make no attempt to preserve the document source order of the tags.
Nevertheless, it does impose an ordering on the attributes so that you can loop through them.
There are versions of getValue( ) and getType( ) that return the value and type of the attribute at a specified position in the list.
You can also query the name of the attribute at a specified position, although the way you do this depends on whether the parser handles namespaces or not.
If it does not process namespaces, use getQName( ) to get the name at a specified position.
Otherwise, use getURI( ) and getLocalName( ) to obtain the URI and local name pair for the numbered attribute.
Note that getQName( ) may return the empty string when namespace processing is on, and getLocalName( ) may return the empty string if namespace processing is off.
This interface is the key one for XML parsing with the SAX API.
An XMLReader tells your application about the content of the XML document it is parsing by invoking the various methods of the ContentHandler interface.
In order to parse documents with SAX, you must implement this interface to define methods that take whatever actions are necessary when they are invoked by the parser.
Because this interface is so critical to the SAX API, the methods are explained individually below:
Locator defines methods that return the current line and column number of the document being parsed, and if the parser supplies a Locator object, it guarantees that its methods will return valid values during any other ContentHandler invocations that follow.
A ContentHandler can call the methods of this object when printing error messages, for example.
Both are passed three arguments describing the name of the tag: if the parser is doing namespace processing, then the first two arguments of both methods return the URI that uniquely identifies the namespace, and the local name of the tag within that namespace.
If the parser is not doing namespace parsing, then the third argument provides the full name of the tag.
In addition to these tag name arguments, startElement( ) is also passed an Attributes object that describes the attributes of the tag.
The text is contained within the specified character array, at the specified start position, and continuing for the specified number of characters.
An application can implement this interface to receive notification of DTD-related events from the parser.
Similarly, the org.xml.sax.ext package defines two “extension” interfaces that can be used (if the parser supports these extensions) to obtain even more information about the document (such as comments and CDATA sections) and about the DTD (including the full set of element, attribute and entity declarations)
It implements ContentHandler and three other interfaces that are commonly used with the XMLReader class and provides empty implementations of all their methods.
Applications can subclass DefaultHandler only need to override the methods they care about.
This is usually more convenient that implementing the interfaces directly.
Returned By javax.xml.transform.sax.SAXResult.getHandler( ), javax.xml.validation.ValidatorHandler.getContentHandler( ), XMLReader.getContentHandler( ), org.xml.sax.helpers.ParserAdapter.getContentHandler( ), org.xml.sax.helpers.XMLFilterImpl.getContentHandler( )
This interface defines methods that an application can implement in order to receive notification from a XMLReader about notation and unparsed entity declarations in the DTD of an XML document.
Notations and unparsed entities are two of the most obscure features of XML, and they (and this interface) are not frequently used.
To use a DTDHandler, define a class that implements the interface, (or simply subclass the helper class org.xml.sax.helpers.DefaultHandler) and pass an instance of that class to the setDTDHandler( ) method of an XMLReader.
Then, if the parser encounters any notation or unparsed entity declarations in the DTD of the document, it will invoke the notationDecl( ) or unparsedEntityDecl( ) method that you have supplied.
Unparsed entities can appear later in a document as the value of an attribute, so if your application cares about them, it should somehow make a note of the entity name and system id for use later.
Passed To Parser.setDTDHandler( ), XMLReader.setDTDHandler( ), org.xml.sax.helpers.ParserAdapter.setDTDHandler( ), org.xml.sax.helpers.XMLFilterImpl.setDTDHandler( ), org.xml.sax.helpers.XMLReaderAdapter.setDTDHandler( )
An application can implement this interface to help the parser resolve external entities, if required.
If you pass an EntityResolver instance to the setEntityResolver( ) method of an XMLReader, then the parser will call the resolveEntity( ) method whenever it needs to read an external entity.
This method should use the public identifier or system identifier to return an InputSource that the parser can use to read the content of the external entity.
If the external entity includes a valid system identifier, then the parser can read it directly without the need for an EntityResolver, but this interface is still useful for mapping network URLs to locally cached copies, or for mapping public identifiers to local files, for example.
The helper class org.xml.sax.helpers.DefaultHandler includes a stub implementation of this interface, so if you subclass DefaultHandler you can override its resolveEntity( ) method.
Passed To javax.xml.parsers.DocumentBuilder.setEntityResolver( ), Parser.setEntityResolver( ), XMLReader.setEntityResolver( ), org.xml.sax.helpers.ParserAdapter.setEntityResolver( ), org.xml.sax.helpers.XMLFilterImpl.setEntityResolver( ), org.xml.sax.helpers.XMLReaderAdapter.setEntityResolver( )
Before parsing an XML document, an application should provide an implementation of this interface to the XMLReader by calling the setErrorHandler( ) method of the XMLReader.
If the reader needs to issue a warning or report an error or fatal error, it will call the appropriate method of the ErrorHandler object you supplied.
The error( ) method is used to report recoverable errors, such as document validity problems.
The fatalError( ) method is used to report nonrecoverable errors, such as well-formedness problems.
An ErrorHandler object may respond to warnings, errors, and fatal errors however it likes, and may throw exceptions from these methods.
Instead of implementing this interface directly, you may also subclass the helper class org.xml.sax.helpers.DefaultHandler and override the error reporting methods it provides.
The warning( ) and error( ) methods of a DefaultHandler do nothing, and the fatalError( ) method throws the SAXParseException object that was passed to it.
Passed To javax.xml.parsers.DocumentBuilder.setErrorHandler( ), javax.xml.validation.SchemaFactory.setErrorHandler( ), javax.xml.validation.Validator.setErrorHandler( ), javax.xml.validation.ValidatorHandler.setErrorHandler( ), Parser.setErrorHandler( ), XMLReader.setErrorHandler( ), org.xml.sax.helpers.ParserAdapter.setErrorHandler( ), org.xml.sax.helpers.XMLFilterImpl.setErrorHandler( ), org.xml.sax.helpers.XMLReaderAdapter.setErrorHandler( )
Returned By javax.xml.validation.SchemaFactory.getErrorHandler( ), javax.xml.validation.Validator.getErrorHandler( ), javax.xml.validation.ValidatorHandler.getErrorHandler( ), XMLReader.getErrorHandler( ), org.xml.sax.helpers.ParserAdapter.getErrorHandler( ), org.xml.sax.helpers.XMLFilterImpl.getErrorHandler( )
This simple class describes a source of input for an XMLReader.
An InputSource object can be passed to the parse( ) method of XMLReader, and is also the return value of the EntityResolver.resolveEntity( ) method.
Create an InputSource( ) with one of the constructor methods, specifying the system identifier (a URL) of the file to be parsed, or specifying a byte or character stream that the parser should read the document from.
In addition to calling the constructor, you may also want to call setSystemId( ) to specify and/or setPublicId( ) to provide identifiers for the document being parsed.
Having a filename or URL is useful if an error arises, and your ErrorHandler object needs to print an error message, for example.
If you specify the document to parse as a URL or as a byte stream, you can also call setEncoding( ) to specify the character encoding of the document.
The parser will use this encoding value if you supply it, but XML documents are supposed to describe their own encoding in the document even if you do not call setEncoding( )
This class allows you to specify more than one input source.
The XMLReader will first call getCharacterStream( ) and use the returned Reader if there is one.
If that method returns false, then it calls getByteStream( ) and uses the InputStream it returns.
Finally, if no character or byte stream is found, then the parser will call getSystemId( ) and will attempt to read an XML document from the returned URL.
An XMLReader will never use any of the set( ) methods to modify the state of an InputSource object.
A XMLReader may pass an object that implements this interface to the application by calling the setDocumentLocator( ) method of the application’s ContentHandler object before it invokes any other methods of that ContentHandler.
The ContentHandler can use methods of this Locator object from within any of the other methods called by the parser in order to determine what document the parser is parsing and what line number and column number it is parsing at.
This information is particularly useful when displaying error or warning messages, for example.
The parser is allowed to return an approximate value from these methods, or to return -1 if it does not track line and column numbers.
Passed To org.xml.sax.ContentHandler.setDocumentLocator( ), DocumentHandler.setDocumentLocator( ), HandlerBase.setDocumentLocator( ), SAXParseException.SAXParseException( ), org.xml.sax.ext.Locator2Impl.Locator2Impl( ), org.xml.sax.helpers.DefaultHandler.setDocumentLocator( ), org.xml.sax.helpers.LocatorImpl.LocatorImpl( ), org.xml.sax.helpers.ParserAdapter.setDocumentLocator( ), org.xml.sax.helpers.XMLFilterImpl.setDocumentLocator( ), org.xml.sax.helpers.XMLReaderAdapter.setDocumentLocator( )
This class serves as the general superclass for more specific types of SAX exceptions.
The parse( ) method of an XMLReader can throw an exception of this type.
The application can also throw a SAXException from any of the handler methods (of ContentHandler and ErrorHandler for example) invoked by the parser.
Signals that the parser does not recognize a feature or property name.
See the setFeature( ) and setProperty( ) methods of XMLReader.
Signals that the parser does recognizes, but does not support a named feature or property.
The property or feature may be entirely unsupported, or it may be read-only, in which case this exception will be thrown by the setFeature( ) or setProperty( ) method, but not by the corresponding getFeature( ) or getProperty( ) method of XMLReader.
An exception of this type signals an XML parsing error or warning.
SAXParseException includes methods to return the system and public identifiers of the document in which the error or warning occurred, as well as methods to return the approximate line number and column number at which it occurred.
A parser is not required to obtain or track all of this information, and the methods may return null or -1 if the information is not available.
Exceptions of this type are usually thrown by the application from the methods of the ErrorHandler interface.
The parser never throws a SAXParseException itself, but does pass an appropriately initialized instance of this class to each of the ErrorHandler methods.
It is up to the application’s ErrorHandler object to decide whether to actually throw the exception, however.
An XMLFilter extends XMLReader and behaves like an XMLReader except that instead of parsing a document itself, it filters the SAX events provided by a “parent” XMLReader object.
Use the setParent( ) method to link an XMLFilter object to the XMLReader that it is to serve as a filter for.
An XMLFilter serves as both a source of SAX events, and also as a receipient of those events, so an implementation must implement ContentHandler and related interfaces so that it can obtain events from the parent object, filter them, and then pass the filtered events on to the ContentHandler object that was registered on the filter.
See the helper class org.xml.sax.helpers.XMLFilterImpl for a bare-bones implementation of an XMLFilter that implements the XMLReader interface and the ContentHandler and related handler interfaces.
XMLFilterImpl does no filtering—it simply passes passes all of its method invocations through.
You can subclass it and override only the methods that need filtering.
This interface defines the methods that must be implemented by a SAX2 XML parser.
Since it is an interface, XMLReader cannot define a constructor for creating an XMLReader.
To obtain an XMLReader, object, you can instantiate some implementation-specific class that implements this interface.
Alternatively, you can keep your code independent of any specific parser implementation by using the SAXParserFactory and SAXParser classes of the javax.xml.parsers package.
Note that the XMLReader interface has no relationship to the java.io.Reader class or any other character stream classes.
Once you have obtained an XMLReader instance, you must register handler objects on it, so that it can invoke methods on those handlers to notify your application of the results of its parsing.
All applications should register a ContentHandler and an ErrorHandler with setContentHandler( ) and setErrorHandler( )
Some applications may also want to register an EntityResolver and/or a DTDHandler.
Applications can also register DeclHandler and LexicalHandler objects from the org.xml.sax.ext package, if the parser implementation supports these extension handler interfaces.
DeclHandler and LexicalHandler objects are registered with setProperty( ), as explained below.
In addition to registering handler objects for an XMLReader, you may also want to configure the behavior of the parser using setFeature( ) and setProperty( )
For uniqueness, the names of features and properties are expressed as URLs (the URLs usually do not have any web content associated with them: they are merely unique identifiers)
Features have boolean values, and properties have arbitrary object values.
Features and properties are an extension mechanism, allowing an application to specify implementation-specific details about how the parser should behave.
If a parser does not recognize the name of a feature or property, the setFeature( ) and setProperty( ) methods (as well as the corresponding getFeature( ) and getProperty( ) query methods) throw a SAXNotRecognizedException.
If the parser recognizes the name of a feature or property, but does not support the feature or property, the methods instead throw a SAXNotSupportedException.
This exception is also thrown by the set methods when the parser allows the feature or property to be queried but not set.
Their names are all URLs that begin with the prefix “http://www.xml.org/sax/features/”
Note that only two of these features must be supported by all parsers.
The others may or may not be supported in any given implementation:
Support for this feature is required in all parser implementations.
A qName consists of a namespace prefix, a colon, and the local name.
The default value of this feature is false, and support for the feature is required in all parser implementations.
This is always true if the validation feature is true.
This is always true if the validation feature is true.
Like the features, their names are all URLs that begin with the prefix (omitted below) “http://www.xml.org/sax/properties/”
Note that support for all of these properties is optional.
The value of this property is a String that contains the document content that triggered the current handler invocation.
Finally, after you have obtained an XMLReader object, have queried and configured its features and properties, and have set a ContentHandler, ErrorHandler, and any other required handler objects, you are ready to parse an XML document.
Do this by calling one of the parse( ) methods, specifying the document to parse either as a system identifier (a URL) or as an InputSource object (which allows the use of streams as well)
Returned By javax.xml.parsers.SAXParser.getXMLReader( ), javax.xml.transform.sax.SAXSource.getXMLReader( ), XMLFilter.getParent( ), org.xml.sax.helpers.XMLFilterImpl.getParent( ), org.xml.sax.helpers.XMLReaderFactory.createXMLReader( )
Neither SAX parsers nor SAX applications are required to support these extensions, but when they do, the interfaces defined here provide a standard way for the parser to provide additional information about an XML document to the application.
DeclHandler defines methods for reporting the content of a DTD, and LexicalHandler defines methods for reporting the lexical structure of an XML document.
This interface extends org.xml.sax.Attributes and adds methods for determining if an attribute was declared in the DTD and whether an attribute value was explicitly specified in the document or whether a default value from the DTD was used.
If the SAX implementation supports this interface, the Attributes object passed to the startElement( ) method of the ContentHandler implements this interface.
You can also test for support by querying the feature named “http://xml.org/sax/features/use-attributes2” with XMLReader.getFeature( )
This extension helper class extends the org.xml.sax.helpers.AttributesImpl class to make it implement the Attributes2 interface.
This extension interface defines methods that a SAX parser can call to notify an application about element, attribute, and entity declarations in a DTD.
Because this is an extension handler, SAX parsers are not required to support it, and may throw a SAXNotRecognizedException or a SAXNotSupportedException when you attempt to register a DeclHandler.
This class extends org.xml.sax.helpers.DefaultHandler to add no-op methods that implement the LexicalHandler, DeclHandler, and EntityResolver2 methods.
It overrides the two-argument version of resolveEntity from the core EntityResolver interface to invoke the four-argument version from the EntityResolver2 interface.
If you register an entity resolver that implements this interface, if the SAX implementation supports this interface, and you set the feature “http://xml.org/sax/features/use-entity-resolver2” to true, then the implementation will use the methods defined by this interface instead of the method defined by the super-interface.
This extension interface defines methods that a SAX parser can call to notify an application about the lexical structure of an XML document.
Because this is an extension handler, SAX parsers are not required to support it, and may throw a SAXNotRecognizedException or a SAXNotSupportedException when you attempt to register a DeclHandler.
If a LexicalHandler is successfully registered on an XMLReader, then the parser will call startDTD( ) and endDTD( ) to report the beginning and end of the document’s DTD.
It will call startCDATA( ) and endCDATA( ) to report the start and end of a CDATA section.
When the parser expands an entity, it first calls startEntity( ) to specify the name of the entity it is about to expand, and then calls endEntity( ) when the entity expansion is complete.
Finally, whenever the parser encounters an XML comment, it calls the comment( ) method.
This interface defines an extension to the core Locator interface.
If the implementation supports it, then the Locator object passed to ContentHandler.setDocumentLocator( ) will implement this interface.
You can also test for support by querying the feature named “http://xml.org/sax/features/use-locator2”
This class extends the org.xml.sax.helpers.LocatorImpl class to make it implement the Locator2 interface.
This package contains utility classes that are useful for programmers working with SAX parsers.
DefaultHandler is the most commonly used: it is a default implementation of the four standard handler interfaces, suitable for easy subclassing by an application.
XMLReaderFactory provides a layer implementation-independence, allowing an application to use an XMLReader implementation specified in a system property.
XMLFilterImpl is a no-op implementation of the XMLFilter interface that also implements the various handler interfaces necessary to connect the filter to its “parent” XMLReader.
It does no filtering of its own, but is easy to subclass to add filtering.
This deprecated class is an implementation of the deprecated SAX1 org.xml.sax.AttributeList interface.
They have been deprecated in favor of the AttributesImpl implementation of the SAX2 org.xml.sax.Attributes interface.
This utility class is a general-purpose implementation of the Attributes interface.
In addition to implementing all the methods of Attributes, it also defines various set methods for setting attribute names, values, and types, an addAttribute( ) method for adding a new attribute to the end of the list, a removeAttribute( ) method for removing an attribute from the list, and a clear( ) method for removing all attributes.
Also, there is an AttributesImpl( ) constructor that initializes the new AttributesImpl object with a copy of a specified Attributes object.
This class is useful for XMLFilter implementations that want to filter the attributes of an element, or for ContentHandler implementations that need to make and save a copy of an Attributes object for later use.
This helper class implements the four commonly-used SAX handler interfaces from the org.xml.sax package and defines stub implementations for all of their methods.
It is usually easier to subclass DefaultHandler and override the desired methods than it is to implement all of the interfaces (and all of their methods) from scratch.
DefaultHandler implements ContentHandler, ErrorHandler, EntityResolver and DTDHandler, so you can pass an instance of this class, (or of a subclass you define) to the setContentHandler( ), setErrorHandler( ), setEntityResolver( ), and setDTDHandler( ) methods of an XMLReader.
You can also pass an instance of a DefaultHandler subclass directly to one of the parse( ) methods of a javax.xml.parsers.SAXParser.
The SAXParser will take care of calling the four relevant methods of its internal XMLReader.
All but two of the methods of DefaultHandler have empty bodies and do nothing.
The exceptions are resolveEntity( ) which simply returns null to tell the parser to resolve the entity itself, and fatalError( ) which throws the SAXParseException object that is passed to it.
This helper class is a very simple implementation of the Locator interface.
It defines a copy constructor that create a new LocatorImpl object that copies the state of a specified Locator object.
This constructor is useful because it allows applications to copy the state of a Locator and save it for later use.
This utility class exists to help SAX parser implementors handle XML namespaces.
In order to make this work, it implements the deprecated SAX1 DocumentHandler interface so that it can receive events from the Parser.
ParserAdapter provides its own layer of namespace processing to convert a namespace-unaware Parser into a namespace-aware XMLReader.
This class is useful when working you are working with a legacy API that supplies a SAX1 Parser object, but want to work with that parser using the SAX2 XMLReader API: to use it, simply pass the Parser object to the ParserAdapter( ) constructor and use the resulting object as you would use any other XMLReader object.
In particular, a ParserAdapter will never call the skippedEntity( ) handler method because the SAX1 Parser API does not provide notification of skipped entities.
Also, it does not attempt to determine whether two namespaceprefixed attributes of an element actually resolve to the same attribute.
This class is implements an XMLFilter that does no filtering.
You can subclass it to override whatever methods are required to perform the type of filtering you desire.
XMLFilterImpl implements ContentHandler, ErrorHandler, EntityResolver, and DTDHandler so that it can receive SAX events from the “parent” XMLReader object.
But it also implements the XMLFilter interface, which is an extension of XMLReader, so that it acts as an XMLReader itself, and can send SAX events to the handler objects that are registered on it.
Each of the handler methods of this class simply invoke the corresponding method of the corresponding handler that was registered on the filter.
The XMLReader methods for getting and setting features and properties simply invoke the corresponding method of the parent XMLReader object.
The parse( ) methods do the same thing: they pass their argument to the corresponding parse( ) method of the parent reader to start the parsing process.
It is useful when working with a legacy API that requires a deprecated Parser object.
Create an XMLReaderAdapter by passing an XMLReader to the XMLReaderAdapter( ) constructor.
Then use the resulting object exactly as you would use any other SAX1 Parser object.
This class implements ContentHandler so that it can receive SAX events from the XMLReader.
But it also implements the Parser interface so that it can have a SAX1 DocumentHandler registered on it.
The methods of ContentHandler are implemented to invoke the corresponding methods of the registered DocumentHandler.
This factory class defines two static factory methods for creating XMLReader objects.
One method takes the name of a class as its argument.
It dynamically loads and instantiates the class, then casts it to an XMLReader object.
The second factory method takes no arguments; it reads the system property named “org.xml.sax.driver” and uses the value of that property as the name of the class XMLReader implementation class to load and instantiate.
An application that instantiates its SAX parser using the no-argument method of XMLReaderFactory gains a layer of independence from the underlying parser implementation.
The end user or system administrator of the system on which the application is deployed can change the parser implementation simply by setting a system property.
Note that the javax.xml.parsers package provides a similar, but somewhat more useful SAXParserFactory.
We’d like to hear your suggestions for improving our indexes.
David Flanagan is a computer programmer who spends most of his time writing about Java and JavaScript.
David has a degree in computer science and engineering from the Massachusetts Institute of Technology.
Our look is the result of reader comments, our own experimentation, and feedback from distribution channels.
Distinctive covers complement our distinctive approach to technical topics, breathing personality and life into potentially dry subjects.
The animal on the cover of Java in a Nutshell, Fifth Edition is a Javan tiger, a subspecies unique to the island of Java.
Although this tiger once offered unrivaled research opportunities due to its genetic isolation, these opportunities have been permanently lost due to human encroachment on the Javan tiger’s habitat: in a worst-case scenario for the tiger, Java developed into the most densely populated island on earth, and awareness of the subspecies’ precarious position came too late to secure the animals’ survival even in captivity.
The last known sighting of the tiger was in 1972, and it is now presumed extinct.
Jamie Peppard was the production editor and proofreader for Java in a Nutshell, Fifth Edition.
The cover image is a 19th-century engraving from the Dover Pictorial Archive.
An Example Program Compiling and Running the Program Analyzing the Program Comments Defining a class Defining a method Declaring a variable and parsing input Computing the result Displaying output The end of a method Blank lines Another method Checking for valid input An important variable Looping and computing the factorial Returning the result.
Nested Types Static Member Types Features of static member types Restrictions on static member types Syntax for static member types.
Nonstatic Member Classes Features of member classes Restrictions on member classes Syntax for member classes Scope versus inheritance.
Local Classes Features of local classes Restrictions on local classes Syntax for local classes Scope of a local class Local variables, lexical scoping, and closures.
Anonymous Classes Features of anonymous classes Restrictions on anonymous classes Syntax for anonymous classes When to use an anonymous class Anonymous class indentation and formatting.
Advanced Enum Syntax The class body of an enumerated type Implementing an interface Value-specific class bodies Restrictions on enum types.
