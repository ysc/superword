No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the information presented.
However, the information contained in this book is sold without warranty, either express or implied.
Neither the author, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals.
However, Packt Publishing cannot guarantee the accuracy of this information.
Griebel Jr’s first introduction to computers was in elementary school through LOGO on an Apple and The Oregon Trail on a VAX.
Pursuing his interest in computers, he graduated from Bucknell University with a degree in Computer Engineering.
At his first job, he quickly realized he didn’t know everything that there was to know about computer programming.
Currently working on enterprise development in Java EE, he feels that any day spent writing a code is a good day.
I would like to thank my wife and three children who are used to letting me sleep late after long nights at the computer.
Jacek Laskowski is a professional software specialist using a variety of commercial and open source solutions to meet customer’s demands.
He develops applications, writes articles, guides less-experienced engineers, records screen casts, delivers courses, and has been a technical reviewer for many IT books.
He’s recently been appointed to the IBM Academy of Technology.
Without you, I wouldn’t have achieved so much! Love you all immensely.
Abraham Tehrani, over a decade, has software development experience as a developer and QA engineer.
Get in touch with us at service@ packtpub.com for more details.
Do you need instant solutions to your IT questions? PacktLib is Packt’s online digital book library.
Here, you can access, read and search across Packt’s entire library of books.
Why Subscribe? f Fully searchable across every book published by Packt f Copy and paste, print and bookmark content f On demand and accessible via web browser.
Preface When you work with a computer, you can do several things at once.
You can hear music while you edit a document in a word processor and read your e-mail.
This can be done because your operating system allows the concurrency of tasks.
Concurrent programming is about the elements and mechanisms a platform offers to have multiple tasks or programs running at once and communicate with each other to exchange data or to synchronize with each other.
Java is a concurrent platform and offers a lot of classes to execute concurrent tasks inside a Java program.
With each version, Java increases the functionalities offered to programmers to facilitate the development of concurrent programs.
This book covers the most important and useful mechanisms included in Version 7 of the Java concurrency API, so you will be able to use them directly in your applications, which are as follows:
What this book covers Chapter 1, Thread Management will teach the readers how to make basic operations with threads.
Creation, execution, and status management of the threads are explained through basic examples.
Chapter 2, Basic Thread Synchronization will teach the readers to use the low-level Java mechanisms to synchronize a code.
Chapter 3, Thread Synchronization Utilities will teach the readers to use the high-level utilities of Java to manage the synchronization between the threads in Java.
It includes an explanation of how to use the new Java 7 Phaser class to synchronize tasks divided into phases.
Chapter 4, Thread Executors will teach the readers to delegate the thread management to executors.
They allow running, managing, and getting the results of concurrent tasks.
It’s a special kind of executor oriented to execute tasks that will be divided into smaller ones using the divide and conquer technique.
Chapter 6, Concurrent Collections will teach the readers to how to use some concurrent data structures provided by the Java language.
These data structures must be used in concurrent programs to avoid the use of synchronized blocks of code in their implementation.
Chapter 7, Customizing Concurrency Classes will teach the readers how to adapt some of the most useful classes of the Java concurrency API to their needs.
The readers will also learn how to use some free tools to debug concurrent applications, such as the Eclipse, NetBeans IDE, or FindBugs applications to detect possible bugs on their applications.
This chapter will teach the readers the notions of synchronization, the Executor, and Fork/Join frameworks, concurrent data structures, and monitoring of concurrent objects that was not included in the respective chapters.
This appendix will teach the readers some tips that every programmer should consider when he or she is going to develop a concurrent application.
What you need for this book To follow this book, you need a basic knowledge of the Java programming language.
You should know how to use an IDE, such as Eclipse or NetBeans, but this is not a necessary prerequisite.
You should already be comfortable with general Java development practices and a basic grasp of threads would be an advantage.
Conventions In this book, you will find a number of styles of text that distinguish between different kinds of information.
Here are some examples of these styles, and an explanation of their meaning.
Warnings or important notes appear in a box like this.
Let us know what you think about this book—what you liked or may have disliked.
Reader feedback is important for us to develop titles that you really get the most out of.
Customer support Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.PacktPub.com.
If you purchased this book elsewhere, you can visit http://www.PacktPub.com/support and register to have the files e-mailed directly to you.
Errata Although we have taken every care to ensure the accuracy of our content, mistakes do happen.
By doing so, you can save other readers from frustration and help us improve subsequent versions of this book.
If you find any errata, please report them by visiting http://www.packtpub.com/support, selecting your book, clicking on the errata submission form link, and entering the details of your errata.
Once your errata are verified, your submission will be accepted and the errata will be uploaded on our website, or added to any list of existing errata, under the Errata section of that title.
Any existing errata can be viewed by selecting your title from http://www.packtpub.com/support.
Piracy Piracy of copyright material on the Internet is an ongoing problem across all media.
At Packt, we take the protection of our copyright and licenses very seriously.
If you come across any illegal copies of our works, in any form, on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy.
We appreciate your help in protecting our authors, and our ability to bring you valuable content.
Introduction In the computer world, when we talk about concurrency, we talk about a series of tasks that run simultaneously in a computer.
This simultaneity can be real if the computer has more than one processor or a multi-core processor, or apparent if the computer has only one core processor.
All modern operating systems allow the execution of concurrent tasks.
You can read your e-mails while you listen to music and read the news in a web page.
We can say that this kind of concurrency is a process-level concurrency.
But inside a process, we can also have various simultaneous tasks.
The concurrent tasks that run inside a process are called threads.
There are different definitions and relations with the concurrency concept.
Some authors talk about concurrency when you execute your application with multiple threads in a single-core processor, so simultaneously you can see when your program execution is apparent.
Also, you can talk about parallelism when you execute your application with multiple threads in a multi-core processor or in a computer with more than one processor.
Other authors talk about concurrency when the threads of the application are executed without a predefined order, and talk about parallelism when you use various threads to simplify the solution of a problem, where all these threads are executed in an ordered way.
This chapter presents a number of recipes that show how to perform basic operations with threads using the Java 7 API.
You will see how to create and run threads in a Java program, how to control their execution, and how to group some threads to manipulate them as a unit.
Creating and running a thread In this recipe, we will learn how to create and run a thread in a Java application.
As with every element in the Java language, threads are objects.
We have two ways of creating a thread in Java:
In this recipe, we will use the second approach to create a simple program that creates and runs 10 threads.
Each thread calculates and prints the multiplication table of a number between one and 10
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Run the program and see how the different threads work in parallel.
The following screenshot shows part of the output of the program.
We can see that all the threads we have created, run in parallel to do their job, as shown in the following screenshot:
When you run the program, the JVM runs this execution thread that calls the main() method of the program.
When we call the start() method of a Thread object, we are creating another execution thread.
Our program will have as many execution threads as calls to the start() method are made.
A Java program ends when all its threads finish (more specifically, when all its non-daemon threads finish)
If the initial thread (the one that executes the main() method) ends, the rest of the threads will continue with their execution until they finish.
If one of the threads use the System.exit() instruction to end the execution of the program, all the threads end their execution.
Creating an object of the Thread class doesn't create a new execution thread.
Also, calling the run() method of a class that implements the Runnable interface doesn't create a new execution thread.
Only calling the start() method creates a new execution thread.
As we mentioned in the introduction of this recipe, there is another way of creating a new execution thread.
You can implement a class that extends the Thread class and overrides the run() method of this class.
Then, you can create an object of this class and call the start() method to have a new execution thread.
See also f The Creating threads through a factory recipe in Chapter 1, Thread Management.
Getting and setting thread information The Thread class saves some information attributes that can help us to identify a thread, know its status, or control its priority.
It's not recommended to change the priority of the threads, but it's a possibility that you can use if you want.
In Java, Thread can be in one of these six states: new, runnable, blocked, waiting, time waiting, or terminated.
In this recipe, we will develop a program that establishes the name and priority for 10 threads and then shows information about their status until they finish.
The threads will calculate the multiplication table of a number.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Until the 10 threads end, we are going to check their status.
If we detect a change in the status of a thread, we write them on the file.
Run the example and open the log.txt file to see the evolution of the 10 threads.
The following screenshot shows some lines of the log.txt file in an execution of this program.
In this file, we can see that the threads with the highest priority end before the ones with the lowest priority.
We also can see the evolution of the status of every thread.
The program shown in the console is the multiplication tables calculated by the threads and the evolution of the status of the different threads in the file log.txt.
By this way, you can better see the evolution of the threads.
The class Thread has attributes to store all the information of a thread.
The JVM uses the priority of the threads to select the one that uses the CPU at each moment and actualizes the status of every thread according to its situation.
If you don't specify a name for a thread, the JVM automatically assigns it one with the format, Thread-XX where XX is a number.
You can't modify the ID or status of a thread.
The Thread class doesn't implement the setId() and setStatus() methods to allow their modification.
There's more… In this recipe, you learned how to access the information attributes using a Thread object.
But you can also access these attributes from an implementation of the Runnable interface.
You can use the static method currentThread() of the Thread class to access the Thread object that is running the Runnable object.
Interrupting a thread A Java program with more than one execution thread only finishes when the execution of all of its threads end (more specifically, when all its non-daemon threads end its execution or when one of the threads use the System.exit() method)
Sometimes, you will need to finish a thread, because you want to terminate a program, or when a user of the program wants to cancel the tasks that a Thread object is doing.
Java provides the interruption mechanism to indicate to a thread that we want to finish it.
One peculiarity of this mechanism is that Thread has to check if it has been interrupted or not, and it can decide if it responds to the finalization request or not.
In this recipe, we will develop a program that creates Thread and, after 5 seconds, will force its finalization using the interruption mechanism.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
The following screenshot shows the result of execution of the previous example.
We can see how the PrimeGenerator thread writes the message and ends its execution when it detects that it has been interrupted.
The Thread class has an attribute that stores a boolean value indicating whether the thread has been interrupted or not.
When you call the interrupt() method of a thread, you set that attribute to true.
The isInterrupted() method only returns the value of that attribute.
The Thread class has another method to check whether Thread has been interrupted or not.
It's the static method, interrupted(), that checks whether the current executing thread has been interrupted or not.
There is an important difference between the isInterrupted() and the interrupted() methods.
The first one doesn't change the value of the interrupted attribute, but the second one sets it to false.
As the interrupted() method is a static method, the utilization of the isInterrupted() method is recommended.
As I mentioned earlier, Thread can ignore its interruption, but this is not the expected behaviour.
Controlling the interruption of a thread In the previous recipe, you learned how you can interrupt the execution of a thread and what you have to do to control this interruption in the Thread object.
The mechanism shown in the previous example can be used if the thread that can be interrupted is simple.
But if the thread implements a complex algorithm divided into some methods, or it has methods with recursive calls, we can use a better mechanism to control the interruption of the thread.
You can throw this exception when you detect the interruption of the thread and catch it in the run() method.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
The following screenshot shows the result of an execution of this example.
You can see how the FileSearch object ends its execution when it detects that it has been interrupted.
In this example, we use Java exceptions to control the interruption of Thread.
When you run the example, the program starts going through folders by checking if they have the file or not.
For example, if you enter in the folder \b\c\d, the program will have three recursive calls to the processDirectory() method.
Sleeping and resuming a thread Sometimes, you'll be interested in interrupting the execution of Thread during a determined period of time.
For example, a thread in a program checks a sensor state once per minute.
During this time, the thread doesn't use any resources of the computer.
After this time, the thread will be ready to continue with its execution when the JVM chooses it to be executed.
You can use the sleep() method of the Thread class for this purpose.
This method receives an integer as the parameter indicates the number of milliseconds that the thread suspends its execution.
When the sleeping time ends, the thread continues with its execution in the instruction, after the sleep() method calls, when the JVM assigns them CPU time.
Another possibility is to use the sleep() method of an element of the TimeUnit enumeration.
This method uses the sleep() method of the Thread class to put the current thread to sleep, but it receives the parameter in the unit that it represents and converts it to milliseconds.
In this recipe, we will develop a program that uses the sleep() method to write the actual date every second.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
How it works… When you run the example, you can see how the program writes a Date object per second and then, the message indicating that the FileClock thread has been interrupted.
When you call the sleep() method, Thread leaves the CPU and stops its execution for a period of time.
During this time, it's not consuming CPU time, so the CPU can be executing other tasks.
There's more… The Java concurrency API has another method that makes a Thread object leave the CPU.
It's the yield() method, which indicates to the JVM that the Thread object can leave the CPU for other tasks.
The JVM does not guarantee that it will comply with this request.
Waiting for the finalization of a thread In some situations, we will have to wait for the finalization of a thread.
For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution.
We can run the initialization tasks as threads and wait for its finalization before continuing with the rest of the program.
For this purpose, we can use the join() method of the Thread class.
When we call this method using a thread object, it suspends the execution of the calling thread until the object called finishes its execution.
In this recipe, we will learn the use of this method with the initialization example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
It will be equal to the run() method of the DataSourcesLoader class, but this will sleep for 6 seconds.
How it works… When you run this program, you can see how both Thread objects start their execution.
There's more… Java provides two additional forms of the join() method:
In the first version of the join() method, instead of waiting indefinitely for the finalization of the thread called, the calling thread waits for the milliseconds specified as a parameter of the method.
When one of these two conditions is true, the join() method returns.
The second version of the join() method is similar to the first one, but receives the number of milliseconds and the number of nanoseconds as parameters.
Creating and running a daemon thread Java has a special kind of thread called daemon thread.
These kind of threads have very low priority and normally only executes when no other thread of the same program is running.
When daemon threads are the only threads running in a program, the JVM ends the program finishing these threads.
With these characteristics, the daemon threads are normally used as service providers for normal (also called user) threads running in the same program.
They usually have an infinite loop that waits for the service request or performs the tasks of the thread.
They can't do important jobs because we don't know when they are going to have CPU time and they can finish any time if there aren't any other threads running.
A typical example of these kind of threads is the Java garbage collector.
In this recipe, we will learn how to create a daemon thread developing an example with two threads; one user thread that writes events on a queue and a daemon one that cleans that queue, removing the events which were generated more than 10 seconds ago.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
This class only stores information about the events our program will work with.
Each Thread writes an event and sleeps for one second.
You can play with the time until the WriterTask threads are sleeping.
If you use a smaller value, you will see that CleanerTask has less CPU time and the size of the queue will increase because CleanerTask doesn't delete any event.
There's more… You only can call the setDaemon() method before you call the start() method.
Once the thread is running, you can't modify its daemon status.
You can use the isDaemon() method to check if a thread is a daemon thread (the method returns true) or a user thread (the method returns false)
When a checked exception is thrown inside the run() method of a Thread object, we have to catch and treat them, because the run() method doesn't accept a throws clause.
When an unchecked exception is thrown inside the run() method of a Thread object, the default behaviour is to write the stack trace in the console and exit the program.
Fortunately, Java provides us with a mechanism to catch and treat the unchecked exceptions thrown in a Thread object to avoid the program ending.
In this recipe, we will learn this mechanism using an example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
How it works… In the following screenshot, you can see the results of the execution of the example.
The exception is thrown and captured by the handler that writes the information in console about Exception and Thread that threw it.
When an exception is thrown in a thread and is not caught (it has to be an unchecked exception), the JVM checks if the thread has an uncaught exception handler set by the corresponding method.
If it has, the JVM invokes this method with the Thread object and Exception as arguments.
If the thread has not got an uncaught exception handler, the JVM prints the stack trace in the console and exits the program.
There's more… The Thread class has another method related to the process of uncaught exceptions.
When an uncaught exception is thrown in Thread, the JVM looks for three possible handlers for this exception.
First, it looks for the uncaught exception handler of the Thread objects as we learned in this recipe.
If this handler doesn't exist, then the JVM looks for the uncaught exception handler for ThreadGroup of the Thread objects as was explained in the Processing uncontrolled exceptions in a group of threads recipe.
If this method doesn't exist, the JVM looks for the default uncaught exception handler as we learned in this recipe.
If none of the handlers exits, the JVM writes the stack trace of the exception in the console and exits the program.
See also f The Processing uncontrolled exceptions in a group of threads recipe in Chapter 1,
Using local thread variables One of the most critical aspects of a concurrent application is shared data.
This has special importance in those objects that extend the Thread class or implement the Runnable interface.
If you create an object of a class that implements the Runnable interface and then start various Thread objects using the same Runnable object, all the threads share the same attributes.
This means that, if you change an attribute in a thread, all the threads will be affected by this change.
Sometimes, you will be interested in having an attribute that won't be shared between all the threads that run the same object.
The Java Concurrency API provides a clean mechanism called thread-local variables with a very good performance.
In this recipe, we will develop a program that has the problem exposed in the first paragraph and another program that solves this problem using the thread-local variables mechanism.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Thread has a different start time but, when they finish, all have the same value in its startDate attribute.
As mentioned earlier, we are going to use the thread-local variables mechanism to solve this problem.
The main class of this example is the same as the unsafe example, changing the name of the Runnable class.
How it works… In the following screenshot, you can see the results of the execution of the safe sample.
Now, the three Thread objects have their own value of the startDate attribute.
Thread-local variables store a value of an attribute for each Thread that uses one of these variables.
You can read the value using the get() method and change the value using the set() method.
The first time you access the value of a thread-local variable, if it has no value for the Thread object that it is calling, the thread-local variable calls the initialValue() method to assign a value for that Thread and returns the initial value.
There's more… The thread-local class also provides the remove() method that deletes the value stored in the thread-local variable for the thread that it's calling.
If a thread A has a value in a threadlocal variable and it creates another thread B, the thread B will have the same value as the thread A in the thread-local variable.
You can override the childValue() method that is called to initialize the value of the child thread in the thread-local variable.
It receives the value of the parent thread in the thread-local variable as a parameter.
Grouping threads into a group An interesting functionality offered by the concurrency API of Java is the ability to group the threads.
This allows us to treat the threads of a group as a single unit and provides access to the Thread objects that belong to a group to do an operation with them.
For example, you have some threads doing the same task and you want to control them, irrespective of how many threads are still running, the status of each one will interrupt all of them with a single call.
Java provides the ThreadGroup class to work with groups of threads.
A ThreadGroup object can be formed by Thread objects and by another ThreadGroup object, generating a tree structure of threads.
In this recipe, we will learn to work with ThreadGroup objects developing a simple example.
We will have 10 threads sleeping during a random period of time (simulating a search, for example) and, when one of them finishes, we are going to interrupt the rest.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
It will store the name of Thread that finishes first.
Declare a private String attribute called name and the methods to read and set the value.
How it works… In the following screenshot, you can see the output of the list() method and the output generated when we write the status of each Thread object, as shown in the following screenshot:
The ThreadGroup class stores the Thread objects and the other ThreadGroup objects associated with it, so it can access all of their information (status, for example) and perform operations over all its members (interrupt, for example)
Check the API documentation to have a complete explanation of all of these methods.
A very important aspect in every programming language is the mechanism that provides management of error situations in your application.
Java language, as almost all modern programming languages, implements an exception-based mechanism to manage error situations.
It provides a lot of classes to represent different errors.
Those exceptions are thrown by the Java classes when an error situation is detected.
You can also use those exceptions, or implement your own exceptions, to manage the errors produced in your classes.
Java also provides a mechanism to capture and process those exceptions.
There are exceptions that must be captured or re-thrown using the throws clause of a method.
There are exceptions that don't have to be specified or caught.
In the recipe, Controlling the interruption of a Thread, you learned how to use a generic method to process all the uncaught exceptions that are thrown in a Thread object.
Another possibility is to establish a method that captures all the uncaught exceptions thrown by any Thread of the ThreadGroup class.
In this recipe, we will learn to set this handler using an example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
How it works… When you run the example, you will see how one of the Thread objects threw the exception and the other one was interrupted.
When an uncaught exception is thrown in Thread, the JVM looks for three possible handlers for this exception.
First, it looks for the uncaught exception handler of the thread, as was explained in the Processing uncontrolled exceptions in a Thread recipe.
If this handler doesn't exist, then the JVM looks for the uncaught exception handler for the ThreadGroup class of the thread, as we learned in this recipe.
If this method doesn't exist, the JVM looks for the default uncaught exception handler, as was explained in the Processing uncontrolled exceptions in a Thread recipe.
If none of the handlers exit, the JVM writes the stack trace of the exception in the console and exits the program.
See also f The Processing uncontrolled exceptions in a thread recipe in Chapter 1,
Creating threads through a factory The factory pattern is one of the most used design patterns in the object-oriented programming world.
It is a creational pattern and its objective is to develop an object whose mission will be creating other objects of one or several classes.
Then, when we want to create an object of one of those classes, we use the factory instead of using the new operator.
With this factory, we centralize the creation of objects with some advantages:
For example, we can only have n objects of a type.
Java provides an interface, the ThreadFactory interface to implement a Thread object factory.
Some advanced utilities of the Java concurrency API use thread factories to create threads.
In this recipe, we will learn how to implement a ThreadFactory interface to create Thread objects with a personalized name while we save statistics of the Thread objects created.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare three attributes: an integer number called counter, which we will use to store the number of the Thread object created, a String called name with the base name of every Thread created, and a List of String objects called stats to save statistical data about the Thread objects created.
We also implement the constructor of the class that initializes these attributes.
How it works… The ThreadFactory interface has only one method called newThread.
It receives a Runnable object as a parameter and returns a Thread object.
When you implement a ThreadFactory interface, you have to implement that interface and override this method.
You can improve this implementation by adding some variants by:
The use of the factory design pattern is a good programming practice but, if you implement a ThreadFactory interface to centralize the creation of threads, you have to review the code to guarantee that all threads are created using that factory.
See also f The Implementing the ThreadFactory interface to generate custom threads recipe in.
Introduction One of the most common situations in concurrent programming occurs when more than one execution thread shares a resource.
In a concurrent application, it is normal that multiple threads read or write the same data or have access to the same file or database connection.
These shared resources can provoke error situations or data inconsistency and we have to implement mechanisms to avoid these errors.
The solution for these problems comes with the concept of critical section.
A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time.
To help programmers to implement critical sections, Java (and almost all programming languages) offers synchronization mechanisms.
When a thread wants access to a critical section, it uses one of those synchronization mechanisms to find out if there is any other thread executing the critical section.
Otherwise, the thread is suspended by the synchronization mechanism until the thread that is executing the critical section ends it.
When more than one thread is waiting for a thread to finish the execution of a critical section, the JVM chooses one of them, and the rest wait for their turn.
This chapter presents a number of recipes that teaches how to use the two basic synchronization mechanisms offered by the Java language:
Synchronizing a method In this recipe, we will learn how to use one of the most basic methods for synchronization in Java, that is, the use of the synchronized keyword to control the concurrent access to a method.
Only one execution thread will access one of the methods of an object declared with the synchronized keyword.
If another thread tries to access any method declared with the synchronized keyword of the same object, it will be suspended until the first thread finishes the execution of the method.
In other words, every method declared with the synchronized keyword is a critical section and Java only allows the execution of one of the critical sections of an object.
Only one execution thread will access one of the static methods declared with the synchronized keyword, but another thread can access other nonstatic methods of an object of that class.
You have to be very careful with this point, because two threads can access two different synchronized methods if one is static and the other one is not.
If both methods change the same data, you can have data inconsistency errors.
To learn this concept, we will implement an example with two threads accessing a common object.
We will have a bank account and two threads; one that transfers money to the account and another one that withdraws money from the account.
Synchronization mechanisms ensures that the final balance of the account will be correct.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the constructor of the class that initializes that Account object.
Implement the constructor of the class that initializes that account object.
Wait for the finalization of the two threads using the join() method and print in the console the final balance of the account.
In this recipe, you have developed an application that increments and decrements the balance of a class that simulates a bank account.
You should expect the final and initial balances to be equal.
You have tried to force an error situation using a variable named tmp to store the value of the account's balance, so you read the account's balance, you increment the value of the temporal variable, and then you establish the value of the account's balance again.
Additionally, you have introduced a little delay using the sleep() method of the Thread class to put the thread that is executing the method to sleep for 10 milliseconds, so if another thread executes that method, it can modify the account's balance provoking an error.
If you want to see the problems of concurrent access to shared data, delete the synchronized keyword of the addAmount() and subtractAmount() methods and run the program.
Without the synchronized keyword, while a thread is sleeping after reading the value of the account's balance, another method will read the account's balance, so both the methods will modify the same balance and one of the operations won't be reflected in the final result.
As you can see in the following screenshot, you can obtain inconsistent results:
If you run the program often, you will obtain different results.
The order of execution of the threads is not guaranteed by the JVM.
So every time you execute them, the threads will read and modify the account's balance in a different order, so the final result will be different.
Now, add the synchronize keyword as you learned before and run the program again.
As you can see in the following screenshot, now you obtain the expected result.
If you run the program often, you will obtain the same result.
Using the synchronized keyword, we guarantee correct access to shared data in concurrent applications.
As we mentioned in the introduction of this recipe, only a thread can access the methods of an object that use the synchronized keyword in their declaration.
If a thread (A) is executing a synchronized method and another thread (B) wants to execute other synchronized methods of the same object, it will be blocked until the thread (A) ends.
But if threadB has access to different objects of the same class, none of them will be blocked.
The synchronized keyword penalizes the performance of the application, so you must only use it on methods that modify shared data in a concurrent environment.
If you have multiple threads calling a synchronized method, only one will execute them at a time while the others will be waiting.
If the operation doesn't use the synchronized keyword, all the threads can execute the operation at the same time, reducing the total execution time.
If you know that a method will not be called by more than one thread, don't use the synchronized keyword.
As the thread has access to the synchronized methods of an object, you can call other synchronized methods of that object, including the method that is executing.
It won't have to get access to the synchronized methods again.
We can use the synchronized keyword to protect the access to a block of code instead of an entire method.
We should use the synchronized keyword in this way to protect the access to the shared data, leaving the rest of operations out of this block, obtaining a better performance of the application.
The objective is to have the critical section (the block of code that can be accessed only by one thread at a time) be as short as possible.
We have used the synchronized keyword to protect the access to the instruction that updates the number of persons in the building, leaving out the long operations of this block that don't use the shared data.
When you use the synchronized keyword in this way, you must pass an object reference as a parameter.
Only one thread can access the synchronized code (blocks or methods) of that object.
Normally, we will use the this keyword to reference the object that is executing the method.
When you use the synchronized keyword to protect a block of code, you must pass an object reference as a parameter.
Normally, you will use the this keyword to reference the object that executes the method, but you can use other object references.
Normally, these objects will be created exclusively with this purpose.
For example, if you have two independent attributes in a class shared by multiple threads, you must synchronize the access to each variable, but there is no problem if there is one thread accessing one of the attributes and another thread accessing the other at the same time.
In this recipe, you will learn how to resolve this situation's programming with an example that simulates a cinema with two screens and two ticket offices.
When a ticket office sells tickets, they are for one of the two cinemas, but not for both, so the numbers of free seats in each cinema are independent attributes.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a Cinema object and implement the constructor of the class that initializes that object.
Declare a Cinema object and implement the constructor of the class that initializes that object.
When you use the synchronized keyword to protect a block of code, you use an object as a parameter.
When you run this example, you can see how the final result is always the expected number of vacancies for each cinema.
In the following screenshot, you can see the results of an execution of the application:
See the See also section for other recipes that explain the use of this keyword.
See also f The Using conditions in synchronized code recipe in Chapter 2, Basic.
Using conditions in synchronized code A classic problem in concurrent programming is the producer-consumer problem.
We have a data buffer, one or more producers of data that save it in the buffer and one or more consumers of data that take it from the buffer.
As the buffer is a shared data structure, we have to control the access to it using a synchronization mechanism such as the synchronized keyword, but we have more limitations.
A producer can't save data in the buffer if it's full and the consumer can't take data from the buffer if it's empty.
For these types of situations, Java provides the wait(), notify(), and notifyAll() methods implemented in the Object class.
A thread can call the wait() method inside a synchronized block of code.
When the thread calls the wait() method, the JVM puts the thread to sleep and releases the object that controls the synchronized block of code that it's executing and allows the other threads to execute other blocks of synchronized code protected by that object.
To wake up the thread, you must call the notify() or notifyAll() method inside a block of code protected by the same object.
In this recipe, you will learn how to implement the producer-consumer problem using the synchronized keyword and the wait(), notify(), and notifyAll() methods.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare an EventStore object and implement the constructor of the class that initializes that object.
Declare an EventStorage object and implement the constructor of the class that initializes that object.
The key to this example is the set() and get() methods of the EventStorage class.
First of all, the set() method checks if there is free space in the storage attribute.
If it's full, it calls the wait() method to wait for free space.
When the other thread calls the notifyAll() method, the thread wakes up and checks the condition again.
The notifyAll() method doesn't guarantee that the thread will wake up.
This process is repeated until there is free space in the storage and it can generate a new event and store it.
First, it checks if there are events on the storage.
If the EventStorage class is empty, it calls the wait() method to wait for events.
Where the other thread calls the notifyAll() method, the thread wakes up and checks the condition again until there are some events in the storage.
You have to keep checking the conditions and calling the wait() method in a while loop.
If you run this example, you will see how producer and consumer are setting and getting the events, but the storage never has more than 10 events.
See the See also section for other recipes that explain the use of this keyword.
See also f The Arranging independent attributes in synchronized classes recipe in Chapter 2,
Synchronizing a block of code with a Lock Java provides another mechanism for the synchronization of blocks of code.
It's a more powerful and flexible mechanism than the synchronized keyword.
It's based on the Lock interface and classes that implement it (as ReentrantLock)
With the synchronized keyword, you have to get and free the control over a synchronized block of code in a structured way.
The Lock interfaces allow you to get more complex structures to implement your critical section.
One of the new functionalities is implemented by the tryLock() method.
This method tries to get the control of the lock and if it can't, because it's used by other thread, it returns the lock.
With the synchronized keyword, when a thread (A) tries to execute a synchronized block of code, if there is another thread (B) executing it, the thread (A) is suspended until the thread (B) finishes the execution of the synchronized block.
This method returns a Boolean value indicating if there is another thread running the code protected by this lock.
In this recipe, you will learn how to use locks to synchronize a block of code and create a critical section using the Lock interface and the ReentrantLock class that implements it, implementing a program that simulates a print queue.
Getting Ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare an object of the PrintQueue class and implement the constructor of the class that initializes that object.
How it works… In the following screenshot, you can see a part of the output of one execution, of this example:
The key to the example is in the printJob() method of the PrintQueue class.
When we want to implement a critical section using locks and guarantee that only one execution thread runs a block of code, we have to create a ReentrantLock object.
At the beginning of the critical section, we have to get the control of the lock using the lock() method.
When a thread (A) calls this method, if no other thread has the control of the lock, the method gives the thread (A) the control of the lock and returns immediately to permit the execution of the critical section to this thread.
Otherwise, if there is another thread (B) executing the critical section controlled by this lock, the lock() method puts the thread (A) to sleep until the thread (B) finishes the execution of the critical section.
At the end of the critical section, we have to use the unlock() method to free the control of the lock and allow the other threads to run this critical section.
If you don't call the unlock() method at the end of the critical section, the other threads that are waiting for that block will be waiting forever, causing a deadlock situation.
If you use try-catch blocks in your critical section, don't forget to put the sentence containing the unlock() method inside the finally section.
There's more… The Lock interface (and the ReentrantLock class) includes another method to get the control of the lock.
The biggest difference with the lock() method is that this method, if the thread that uses it can't get the control of the Lock interface, returns immediately and doesn't put the thread to sleep.
This method returns a boolean value, true if the thread gets the control of the lock, and false if not.
Take into consideration that it is the responsibility of the programmer to take into account the result of this method and act accordingly.
If the method returns the false value, it's expected that your program doesn't execute the critical section.
If it does, you probably will have wrong results in your application.
The ReentrantLock class also allows the use of recursive calls.
When a thread has the control of a lock and makes a recursive call, it continues with the control of the lock, so the calling to the lock() method will return immediately and the thread will continue with the execution of the recursive call.
More Info You have to be very careful with the use of Locks to avoid deadlocks.
This situation occurs when two or more threads are blocked waiting for locks that never will be unlocked.
For example, a thread (A) locks a Lock (X) and a thread (B) locks a Lock (Y)
If now, the thread (A) tries to lock the Lock (Y) and the thread (B) simultaneously tries to lock the Lock (X), both threads will be blocked indefinitely, because they are waiting for locks that will never be liberated.
Note that the problem occurs, because both threads try to get the locks in the opposite order.
The Appendix, Concurrent programming design, explains some good tips to design concurrent applications adequately and avoid these deadlocks problems.
This class has two locks, one for read operations and one for write operations.
There can be more than one thread using read operations simultaneously, but only one thread can be using write operations.
When a thread is doing a write operation, there can't be any thread doing read operations.
In this recipe, you will learn how to use a ReadWriteLock interface implementing a program that uses it to control the access to an object that stores the prices of two products.
Getting Ready… You should read the Synchronizing a block of code with a Lock recipe for a better understanding of this recipe.
How to do it… Follow these steps to implement the example:
Declare a PricesInfo object and implement the constructor of the class that initializes that object.
Declare a PricesInfo object and implement the constructor of the class that initializes that object.
It modifies three times the value of the two prices that are sleeping for two seconds between modifications.
Create five Reader objects and five Threads to execute them.
How it works… In the following screenshot, you can see a part of the output of one execution of this example:
The lock used in read operations is obtained with the readLock() method declared in the ReadWriteLock interface.
This lock is an object that implements the Lock interface, so we can use the lock(), unlock(), and tryLock() methods.
The lock used in write operations is obtained with the writeLock() method declared in the ReadWriteLock interface.
This lock is an object that implements the Lock interface, so we can use the lock(), unlock(), and tryLock() methods.
It is the responsibility of the programmer to ensure the correct use of these locks, using them with the same purposes for which they were designed.When you get the read lock of a Lock interface, you can't modify the value of the variable.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2,
The false value is the default value and it's called the non-fair mode.
Take into account that the behavior explained previously is only used with the lock() and unlock() methods.
As the tryLock() method doesn't put the thread to sleep if the Lock interface is used, the fair attribute doesn't affect its functionality.
In this recipe, we will modify the example implemented in the Synchronizing a block of code with a Lock recipe to use this attribute and see the difference between the fair and non-fair modes.
Getting Ready… We are going to modify the example implemented in the Synchronizing a block of code with a Lock recipe, so read that recipe to implement this example.
How to do it… Follow these steps to implement the example:
Implement the example explained in the Synchronizing a block of code with a Lock recipe.
Modify in the Main class the block of code that starts the threads.
How it works… In the following screenshot you can see a part of the output of one execution of this example:
All threads are created with a difference of 0.1 seconds.
While Thread 0 is running the first block of code protected by the lock, we have nine threads waiting to execute that block of code.
As the fair mode is enabled, the Lock interface will choose Thread 1, so it's the thread that has been waiting for more time for the lock.
Until all the threads have passed the first block protected by the lock, none of them will execute the second block protected by the lock.
Once all the threads have executed the first block of code protected by the lock, it's the turn of Thread 0 again.
Then, it's the turn of Thread 1, and so on.
To see the difference with the non-fair mode, change the parameter passed to the lock constructor and put the false value.
In the following screenshot, you can see the result of one execution of the modified example:
In this case, the threads are executed in the order that have been created but each thread executes the two protected blocks of code.
However, this behavior is not guaranteed because, as explained earlier, the lock could choose any thread to give it access to the protected code.
The JVM does not guarantee, in this case, the order of execution of the threads.
There's more… Read/write locks also have the fair parameter in their constructor.
The behaviour of this parameter in this kind of lock is the same as we explained in the introduction of this recipe.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2,
Using multiple conditions in a Lock A lock may be associated with one or more conditions.
The purpose of these conditions is to allow threads to have control of a lock and check whether a condition is true or not and, if it's false, be suspended until another thread wakes them up.
The Condition interface provides the mechanisms to suspend a thread and to wake up a suspended thread.
A classic problem in concurrent programming is the producer-consumer problem.
We have a data buffer, one or more producers of data that save it in the buffer, and one or more consumers of data that take it from the buffer as explained earlier in this chapter.
In this recipe, you will learn how to implement the producer-consumer problem using locks and conditions.
Getting Ready… You should read the Synchronizing a block of code with a Lock recipe for a better understanding of this recipe.
How to do it… Follow these steps to implement the example:
A LinkedList<String> attribute named buffer that will store the shared data.
An int type named maxSize that stores the length of the buffer.
A ReentrantLock object called lock that controls the access to the blocks of code that modify the buffer.
A boolean type called pendingLines that will indicate if there are lines in the buffer.
Declare a Buffer object and implement the constructor of the class that initializes it.
Create three Consumer objects and three threads to run it.
How it works… All the Condition objects are associated with a lock and are created using the newCondition() method declared in the Lock interface.
Before we can do any operation with a condition, you have to have the control of the lock associated with the condition, so the operations with conditions must be in a block of code that begins with a call to a lock() method of a Lock object and ends with an unlock() method of the same Lock object.
When a thread calls the await() method of a condition, it automatically frees the control of the lock, so that another thread can get it and begin the execution of the same, or another critical section protected by that lock.
When a thread calls the signal() or signallAll() methods of a condition, one or all of the threads that were waiting for that condition are woken up, but this doesn't guarantee that the condition that made them sleep is now true, so you must put the await() calls inside a while loop.
You can't leave that loop until the condition is true.
While the condition is false, you must call await() again.
You must be careful with the use of await() and signal()
If you call the await() method in a condition and never call the signal() method in this condition, the thread will be sleeping forever.
There's more… The Condition interface has other versions of the await() method, which are as follows:
Another thread calls the singal() or signalAll() methods in the condition.
Another thread calls the singal() or signalAll() methods in the condition.
You can use conditions with the ReadLock and WriteLock locks of a read/write lock.
See also f The Synchronizing a block of code with a Lock recipe in Chapter 2, Basic Thread.
Introduction In Chapter 2, Basic thread synchronization, we learned the concepts of synchronization and critical section.
Basically, we talk about synchronization when more than one concurrent task shares a resource, for example, an object or an attribute of an object.
The blocks of code that access this shared resource are called critical sections.
If you don't use the appropriate mechanisms, you can have the wrong results, data inconsistency, or error conditions, so we have to adopt one of the synchronization mechanisms provided by the Java language to avoid all these problems.
Chapter 2, Basic thread synchronization, taught us about the following basic synchronization mechanisms:
In this chapter, we will learn how to use high-level mechanisms to get the synchronization of multiple threads.
This mechanism is one of the basic tools of concurrent programming and is provided by most of the programming languages.
All the threads must finish one phase before they can continue with the next one.
This is a new feature of the Java 7 API.
Semaphores are a generic synchronization mechanism that you can use to protect any critical section in any problem.
The other mechanisms are thought to be used in applications with specific features as it was described previously.
Be sure to select the appropriate mechanism according to the characteristics of your application.
This chapter presents seven recipes that show you how to use the mechanisms described.
Controlling concurrent access to a resource In this recipe, you will learn how to use the semaphore mechanism provided by the Java language.
A semaphore is a counter that protects the access to one or more shared resources.
The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was used for the first time in the THEOS operating system.
When a thread wants to access one of these shared resources, first, it must acquire the semaphore.
If the internal counter of the semaphore is greater than 0, the semaphore decrements the counter and allows access to the shared resource.
A counter bigger than 0 means there are free resources that can be used, so the thread can access and use one of them.
A value of 0 in the counter means all the shared resources are used by other threads, so the thread that wants to use one of them must wait until one is free.
When the thread has finished the use of the shared resource, it must release the semaphore so that the other thread can access the shared resource.
In this recipe, you will learn how to use the Semaphore class to implement special kinds of semaphores called binary semaphores.
To show how to use it, you are going to implement a print queue that can be used by concurrent tasks to print their jobs.
This print queue will be protected by a binary semaphore, so only one thread can print at a time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
The key to this example is in the printJob() method of the PrintQueue class.
This method shows the three steps you must follow when you use a semaphore to implement a critical section, and protect the access to a shared resource:
Then, you do the necessary operations with the shared resource.
Another important point in this example is the constructor of the PrintQueue class and the initialization of the Semaphore object.
You pass the value 1 as the parameter of this constructor, so you are creating a binary semaphore.
The initial value of the internal counter is 1, so you will protect the access to one shared resource, in this case, the print queue.
When you start the 10 threads, the first one acquires the semaphore and gets the access to the critical section.
The rest are blocked by the semaphore until the thread that has acquired it, releases it.
When this occurs, the semaphore selects one of the waiting threads and gives it the access to the critical section.
All the jobs print their documents, but one by one.
The Semaphore class has two additional versions of the acquire() method:
This version of the acquire operation ignores the interruption of the thread and doesn't throw any exceptions.
But if it can't, the method returns the false value instead of being blocked and waits for the release of the semaphore.
It's your responsibility to take the correct action based on the return value.
Fairness in semaphores The concept of fairness is used by the Java language in all classes that can have various threads blocked waiting for the release of a synchronization resource (for example, a semaphore)
In this mode, when the synchronization resource is released, one of the waiting threads is selected to get this resource, but it's selected without any criteria.
The fair mode changes this behavior and forces to select the thread that has been waiting for more time.
As occurs with other classes, the Semaphore class admits a second parameter in its constructor.
If you give it the false value, you are creating a semaphore that will work in non-fair mode.
You will get the same behavior if you don't use this parameter.
If you give it the true value, you are creating a semaphore that will work in fair mode.
In the Controlling concurrent access to a resource recipe, you learned the basis of semaphores.
In that recipe, you implemented an example using binary semaphores.
These kinds of semaphores are used to protect the access to one shared resource, or to a critical section that can only be executed by one thread at a time.
But semaphores can also be used when you need to protect various copies of a resource, or when you have a critical section that can be executed by more than one thread at the same time.
In this recipe, you will learn how to use a semaphore to protect more than one copy of a resource.
You are going to implement an example, which has one print queue that can print documents in three different printers.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Implement the example described in the Controlling concurrent access to a resource recipe in this chapter.
As we mentioned earlier, you are going to modify the print queue example implemented with semaphores.
Open the PrintQueue class and declare a boolean array called freePrinters.
This array stores printers that are free to print a job and printers that are printing a document.
You will use this object to protect the access to the freePrinters array.
First of all, declare an int variable to store the index of the printer.
The key of this example is in the PrintQueue class.
The Semaphore object is created using 3 as the parameter of the constructor.
The first three threads that call the acquire() method will get the access to the critical section of this example, while the rest will be blocked.
When a thread finishes the critical section and releases the semaphore, another thread will acquire it.
In this critical section, the thread gets the index of the printer assigned to print this job.
This part of the example is used to give more realism to the example, but it doesn't use any code related with semaphores.
The following screenshot shows the output of an execution of this example:
This parameter represents the number of permits that the thread that uses them wants to acquire or release, so as to say, the number of units that this thread wants to delete or to add to the internal counter of the semaphore.
See also f The Controlling concurrent access to a resource recipe in Chapter 3, Thread.
Waiting for multiple concurrent events The Java concurrency API provides a class that allows one or more threads to wait until a set of operations are made.
This class is initialized with an integer number, which is the number of operations the threads are going to wait for.
When a thread wants to wait for the execution of these operations, it uses the await() method.
This method puts the thread to sleep until the operations are completed.
When one of these operations finishes, it uses the countDown() method to decrement the internal counter.
When the counter arrives to 0, the class wakes up all the threads that were sleeping in the await() method.
In this recipe, you will learn how to use the CountDownLatch class implementing a videoconference system.
The video-conference system will wait for the arrival of all the participants before it begins.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create 10 Participant objects, a Thread object to run each of them, and start all the threads.
When you create a CountDownLatch object, the object uses the constructor's parameter to initialize an internal counter.
Every time a thread calls the countDown() method, the CountDownLatch object decrements the internal counter in one unit.
When the internal counter arrives to 0, the CountDownLatch object wakes up all the threads that were waiting in the await() method.
There's no way to re-initialize the internal counter of the CountDownLatch object or to modify its value.
Once the counter is initialized, the only method you can use to modify its value is the countDown() method explained earlier.
When the counter arrives to 0, all the calls to the await() method return immediately and all subsequent calls to the countDown() method have no effect.
There are some differences with respect to other synchronization methods, which are as follows:
It is used to synchronize one or more threads with the execution of various tasks.
As we explained earlier, once the counter of CountDownLatch arrives at 0, all the calls to its methods have no effect.
You have to create a new object if you want to do the same synchronization again.
The following screenshot shows the output of an execution of the example:
You can see how the last participants arrive and, once the internal counter arrives to 0, the CountDownLatch object wakes up the Videoconference object that writes the messages indicating that the video conference should start.
The CountDownLatch class has another version of the await() method, which is given as follows:
Synchronizing tasks in a common point The Java concurrency API provides a synchronizing utility that allows the synchronization of two or more threads in a determined point.
This class is similar to the CountDownLatch class explained in the Waiting for multiple concurrent events recipe in this chapter, but presents some differences that make them a more powerful class.
The CyclicBarrier class is initialized with an integer number, which is the number of threads that will be synchronized in a determined point.
When one of those threads arrives to the determined point, it calls the await() method to wait for the other threads.
When the thread calls that method, the CyclicBarrier class blocks the thread that is sleeping until the other threads arrive.
When the last thread calls the await() method of the CyclicBarrier class, it wakes up all the threads that were waiting and continues with its job.
One interesting advantage of the CyclicBarrier class is that you can pass an additional Runnable object as an initialization parameter, and the CyclicBarrier class executes this object as a thread when all the threads have arrived to the common point.
This characteristic makes this class adequate for the parallelization of tasks using the divide and conquer programming technique.
In this recipe, you will learn how to use the CyclicBarrier class to synchronize a set of threads in a determined point.
You will also use a Runnable object that will execute after all the threads have arrived to that point.
In the example, you will look for a number in a matrix of numbers.
The matrix will be divided in subsets (using the divide and conquer technique), so each thread will look for the number in one subset.
Once all the threads have finished their job, a final task will unify the results of them.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
These two attributes will determine the subset of rows where this object will look for.
Declare a private int attribute named number that will store the number we are going to look for.
Declare and initialize five constants to store the parameters of the application.
Create five Searcher objects, five threads to execute them, and start the five threads.
The following screenshot shows the results of an execution of this example:
We have a big matrix of random integer numbers and you want to know the total number of occurrences of a number in this matrix.
To get a better performance, we use the divide and conquer technique.
We divide the matrix in five subsets and use a thread to look for the number in each subset.
We use a CyclicBarrier object to synchronize the completion of the five threads and to execute the Grouper task to process the partial results, and calculate the final one.
As we mentioned earlier, the CyclicBarrier class has an internal counter to control how many threads have to arrive to the synchronization point.
Each time a thread arrives to the synchronization point, it calls the await() method to notify the CyclicBarrier object that has arrived to its synchronization point.
CyclicBarrier puts the thread to sleep until all the threads arrive to their synchronization point.
When all the threads have arrived to their synchronization point, the CyclicBarrier object wakes up all the threads that were waiting in the await() method and, optionally, creates a new thread that executes a Runnable object passed as the parameter in the construction of CyclicBarrier (in our case, a Grouper object) to do additional tasks.
The CyclicBarrier class has another version of the await() method:
This class also provides the getNumberWaiting() method that returns the number of threads that are blocked in the await() method, and the getParties() method that returns the number of tasks that are going to be synchronized with CyclicBarrier.
Resetting a CyclicBarrier object The CyclicBarrier class has some points in common with the CountDownLatch class, but they also have some differences.
One of the most important differences is that a CyclicBarrier object can be reset to its initial state, assigning to its internal counter the value with which it was initialized.
This reset operation can be done using the reset() method of the CyclicBarrier class.
This exception was processed in the example presented in this recipe by printing the stack trace, but in a more complex application, it could perform some other operation, such as restarting their execution or recovering their operation at the point it was interrupted.
Broken CyclicBarrier objects A CyclicBarrier object can be in a special state denoted by broken.
The CyclicBarrier class provides the isBroken() method, then returns true if the object is in the broken state; otherwise it returns false.
See also f The Waiting for multiple concurrent events recipe in Chapter 3, Thread.
Running concurrent phased tasks One of the most complex and powerful functionalities offered by the Java concurrency API is the ability to execute concurrent-phased tasks using the Phaser class.
This mechanism is useful when we have some concurrent tasks divided into steps.
The Phaser class provides us with the mechanism to synchronize the threads at the end of each step, so no thread starts its second step until all the threads have finished the first one.
As with other synchronization utilities, we have to initialize the Phaser class with the number of tasks that participate in the synchronization operation,  but we can dynamically modify this number by increasing or decreasing it.
In this recipe, you will learn how to use the Phaser class to synchronize three concurrent tasks.
The three tasks look for files with the extension .log modified in the last 24 hours in three different folders and their subfolders.
Get a list of the files with the extension .log in the assigned folder and its subfolders.
Filter the list created in the first step by deleting the files modified more than 24 hours ago.
If it hasn't any element, the thread ends its execution and is eliminated from the the phaser class.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE like NetBeans, open it and create a new Java project.
Create a class named FileSearch and specify that it implements the Runnable interface.
This class implements the operation of searching for files with a determined extension modified in the last 24 hours in a folder and its subfolders.
Declare a private String attribute to store the folder in which the search operation will begin.
Declare another private String attribute to store the extension of the files we are going to look for.
Declare a private List attribute to store the full path of the files we will find with the desired characteristics.
Finally, declare a private Phaser attribute to control the synchronization of the different phases of the task.
It receives a File object as parameter and checks if its extension is equal to the one we are looking for.
If they are equal, this method adds the absolute path of the file to the list of results.
Then, compare that date with the actual date and, if the difference is less than one day, add the full path of the file to the new list of results.
The program starts creating a Phaser object that will control the synchronization of the threads at the end of each phase.
The constructor of Phaser receives the number of participants as a parameter.
Once Phaser has been created, we launch three threads that execute three different FileSearch objects.
In this example, we use paths of the Windows operating system.
If you work with another operating system, modify the paths to adapt them to existing paths in your environment.
As we mentioned earlier, the Phaser knows the number of threads that we want to synchronize.
When a thread calls this method, Phaser decreases the number of threads that have to finalize the actual phase and puts this thread to sleep until all the remaining threads finish this phase.
Calling this method at the beginning of the run() method makes none of the FileSearch threads begin their job until all the threads have been created.
At the end of phase one and phase two, we check if the phase has generated results and the list with the results has elements, or otherwise the phase hasn't generated results and the list is empty.
In the second case, if the list is empty, there's no point in the thread continuing with its execution, so it returns.
But you have to notify the phaser that there will be one less participant.
This notifies the phaser that this thread has finished the actual phase, but it won't participate in the future phases, so the phaser won't have to wait for it to continue.
With this call, we guarantee that all the threads finish at the same time.
With this call, we deregister the threads of the phaser as we explained before, so when all the threads finish, the phaser will have zero participants.
Finally, the main() method waits for the completion of the three threads and calls the isTerminated() method of the phaser.
When a phaser has zero participants, it enters the so called termination state and this method returns true.
As we deregister all the threads of the phaser, it will be in the termination state and this call will print true to the console.
In this state, Phaser works as it has been explained in this recipe.
This state is not mentioned in the Java concurrency API.
More in detail, Phaser is in the termination state when the method onAdvance() returns the true value.
If you override that method, you can change the default behavior.
A notable feature of the Phaser class is that you haven't had to control any exception from the methods related with the phaser.
There is only one exception that is explained in the There's more section below.
The following screenshot shows the results of one execution of the example:
You can see how the Apps thread finishes its execution in phase two because its results list is empty.
When you execute the example, you will see how some threads finish a phase before the rest, but they wait until all have finished one phase before continuing with the rest.
The Phaser class provides other methods related to the change of phase.
Be careful with the utilization of this method, because it doesn't synchronize with other threads.
If the parameter and the actual phase of the phaser aren't equal, the method returns immediately.
Registering participants in the Phaser When you create a Phaser object, you indicate how many participants will have that phaser.
But the Phaser class has two methods to increment the number of participants of a phaser.
This new participant will be considered as unarrived to the actual phase.
These new participants will be considered as unarrived to the actual phase.
Forcing the termination of a Phaser When a phaser has zero participants, it enters a state denoted by Termination.
The Phaser class provides forceTermination() to change the status of the phaser and makes it enter in the Termination state independently of the number of participants registered in the phaser.
This mechanism may be useful when one of the participants has an error situation, to force the termination of the phaser.
If you know that your phaser could be terminated, you should verify the return value of those methods to know if the phaser has been terminated.
The Phaser class provides a method that is executed each time the phaser changes the phase.
It receives two parameters: the number of the current phase and the number of registered participants; it returns a Boolean value, false if the phaser continues its execution, or true if the phaser has finished and has to enter into the termination state.
The default implementation of this method returns true if the number of registered participants is zero, and false otherwise.
But you can modify this behavior if you extend the Phaser class and you override this method.
Normally, you will be interested in doing this when you have to execute some actions when you advance from one phase to the next one.
In this recipe, you will learn how to control the phase change in a phaser that is implementing your own version of the Phaser class that overrides the onAdvance() method to execute some actions in every phase change.
You are going to implement a simulation of an exam, where there will be some students who have to do three exercises.
All the students have to finish one exercise before they can proceed with the next one.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
According to the value of the phase attribute, we call a different auxiliary method.
If the phase is equal to zero, you have to call the studentsArrived() method.
Otherwise, we return the true value to indicate that the phaser has terminated.
Implement the same code for second exercise and third execise.
Write a message to show that the phaser is in the termination state using the isTerminated() method.
This exercise simulates the realization of an exam that has three exercises.
All the students have to finish one exercise before they can start the next one.
To implement this synchronization requirement, we use the Phaser class, but you have implemented your own phaser extending the original class to override the onAdvance() method.
This method receives as parameters the number of the actual phase, where 0 is the number of the first phase and the number of registered participants.
If you execute a different operation depending on the actual phase, you have to use an alternative structure (if/else or switch) to select the operation you want to execute.
In the example, we used a switch structure to select a different method for each change of phase.
The onAdvance() method returns a Boolean value that indicates if the phaser has terminated or not.
If the phaser returns a false value, it indicates that it hasn't terminated, so the threads will continue with the execution of other phases.
If the phaser returns a true value, then the phaser still wakes up the pending threads, but moves the phaser to the terminated state, so all the future calls to any method of the phaser will return immediately, and the isTerminated() method returns the true value.
In the Core class, when you created the MyPhaser object, you didn't specify the number of participants in the phaser.
You made a call to the register() method for every Student object created to register a participant in the phaser.
This calling doesn't establish a relation between the Student object or the thread that executes it and the phaser.
Really, the number of participants in a phaser is only a number.
There is no relationship between the phaser and the participants.
The following screenshot shows the results of an execution of this example:
You can see how the students finish the first exercise at different times.
When all have finished that exercise, the phaser calls the onAdvance() method that writes the log messages in the console and then all the students start the second exercise at the same time.
See also f The Running concurrent phased tasks recipe in Chapter 3, Thread.
Changing data between concurrent tasks The Java concurrency API provides a synchronization utility that allows the interchange of data between two concurrent tasks.
In more detail, the Exchanger class allows the definition of a synchronization point between two threads.
When the two threads arrive to this point, they interchange a data structure so the data structure of the first thread goes to the second one and the data structure of the second thread goes to the first one.
This class may be very useful in a situation similar to the producer-consumer problem.
This is a classic concurrent problem where you have a common buffer of data, one or more producers of data, and one or more consumers of data.
As the Exchanger class only synchronizes two threads, you can use it if you have a producer-consumer problem with one producer and one consumer.
In this recipe, you will learn how to use the Exchanger class to solve the producer-consumer problem with one producer and one consumer.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE like NetBeans, open it and create a new Java project.
This will be the data structure that the producer will interchange with the consumer.
This will be the exchanger object that will be used to synchronize producer and consumer.
This will be the data structure that the producer will interchange with the consumer.
This will be the exchanger object that will be used to synchronize producer and consumer.
The consumer begins with an empty buffer and calls Exchanger to synchronize with the producer.
It creates 10 strings, stores it in the buffer, and uses the exchanger to synchronize with the consumer.
At this point, both threads (producer and consumer) are in Exchanger and it changes the data structures, so when the consumer returns from the exchange() method, it will have a buffer with 10 strings.
When the producer returns from the exchange() method, it will have an empty buffer to fill again.
If you execute the example, you will see how producer and consumer do their jobs concurrently and how the two objects interchange their buffers in every step.
As it occurs with other synchronization utilities, the first thread that calls the exchange() method was put to sleep until the other threads arrived.
The Exchanger class has another version of the exchange method: exchange(V data, long time, TimeUnit unit) where V is the type used as a parameter in the declaration of Phaser (List<String> in our case)
The thread will be sleeping until it's interrupted, the other thread arrives, or the specified time passes.
If you have to develop a program that runs a lot of concurrent tasks, this approach has the following disadvantages:
If you have to execute a big number of tasks, this can affect the throughput of the application.
If you create too many threads, you can saturate the system.
Since Java 5, the Java concurrency API provides a mechanism that aims at resolving problems.
This mechanism is called the Executor framework and is around the Executor interface, its subinterface ExecutorService, and the ThreadPoolExecutor class that implements both interfaces.
With an executor, you only have to implement the Runnable objects and send them to the executor.
It is responsible for their execution, instantiation, and running with necessary threads.
But it goes beyond that and improves performance using a pool of threads.
When you send a task to the executor, it tries to use a pooled thread for the execution of this task, to avoid continuous spawning of threads.
Another important advantage of the Executor framework is the Callable interface.
It's similar to the Runnable interface, but offers two improvements, which are as follows:
You can use this object to control the status and the result of the Callable object.
This chapter presents 11 recipes that show you how to work with the Executor framework using the classes mentioned earlier and other variants provided by the Java Concurrency API.
Creating a thread executor The first step to work with the Executor framework is to create an object of the ThreadPoolExecutor class.
You can use the four constructors provided by that class or use a factory class named Executors that creates ThreadPoolExecutor.
Once you have an executor, you can send Runnable or Callable objects to be executed.
In this recipe, you will learn how these two operations implement an example that will simulate a web server processing requests from various clients.
Getting ready You should read the Creating and running a thread recipe in Chapter 1 to learn the basic mechanism of thread creation in Java.
You can compare both mechanisms and select the best one depending on the problem.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a Date attribute named initDate to store the creation date of the task and a String attribute named name to store the name of the task.
In this method, call the shutdown() method of the executor to finish its execution.
Finally, implement the main class of the example by creating a class named Main and implement the main() method.
The first important point is the creation of ThreadPoolExecutor in the constructor of the Server class.
The ThreadPoolExecutor class has four different constructors but, due to their complexity, the Java concurrency API provides the Executors class to construct executors and other related objects.
Although we can create ThreadPoolExecutor directly using one of its constructors, it's recommended to use the Executors class.
This method returns an ExecutorService object, so it's been cast to ThreadPoolExecutor to have access to all its methods.
The cached thread pool you have created creates new threads if needed to execute the new tasks, and reuses the existing ones if they have finished the execution of the task they were running, which are now available.
The reutilization of threads has the advantage that it reduces the time taken for thread creation.
The cached thread pool has, however, a disadvantage of constant lying threads for new tasks, so if you send too many tasks to this executor, you can overload the system.
Once you have created the executor, you can send tasks of the Runnable or Callable type for execution using the execute() method.
In this case, you send objects of the Task class that implements the Runnable interface.
You also have printed some log messages with information about the executor.
One critical aspect of the ThreadPoolExecutor class, and of the executors in general, is that you have to end it explicitly.
If you don't do this, the executor will continue its execution and the program won't end.
If the executor doesn't have tasks to execute, it continues waiting for new tasks and it doesn't end its execution.
A Java application won't end until all its non-daemon threads finish their execution, so, if you don't terminate the executor, your application will never end.
To indicate to the executor that you want to finish it, you can use the shutdown() method of the ThreadPoolExecutor class.
When the executor finishes the execution of all pending tasks, it finishes its execution.
The following screenshot shows part of one execution of this example:
The ThreadPoolExecutor class provides a lot of methods to obtain information about its status.
The ThreadPoolExecutor class also provides other methods related with the finalization of the executor.
The tasks that are running when you call this method continue with their execution, but the method doesn't wait for their finalization.
If you want to wait for the completion of the tasks, regardless of their duration, use a big timeout, for example, DAYS.
See also f The Controlling rejected tasks of an executor recipe in Chapter 4, Thread Executors.
The executor creates a new thread for each task that receives, (if there is no pooled thread free) so, if you send a large number of tasks and they have long duration, you can overload the system and provoke a poor performance of your application.
If you want to avoid this problem, the Executors class provides a method to create a fixed-size thread executor.
If you send more tasks than the number of threads, the executor won't create additional threads and the remaining tasks will be blocked until the executor has a free thread.
With this behavior, you guarantee that the executor won't yield a poor performance of your application.
In this recipe, you are going to learn how to create a fixed-size thread executor modifying the example implemented in the first recipe of this chapter.
Getting ready You should read the Creating a thread executor recipe in this chapter and implement the example explained in it, because you're going to modify this example.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
This method creates an executor with a maximum number of threads.
If you send more tasks than the number of threads, the remaining tasks will be blocked until there is a free thread to process them This method receives the maximum number of threads as a parameter you want to have in your executor.
In your case, you have created an executor with five threads.
The following screenshot shows part of the output of one execution of this example:
To write the output of the program, you have used some methods of the ThreadPoolExecutor class, including:
You can see how the output of these methods is 5, indicating that the executor has five threads.
It does not exceed the established maximum number of threads.
When you send the last task to the executor, it has only 5 active threads.
We used the getTaskCount() method to show how many you have sent to the executor.
This is an extreme case of a fixed-size thread executor.
It creates an executor with only one thread, so it can only execute one task at a time.
One of the advantages of the Executor framework is that you can run concurrent tasks that return a result.
The Java Concurrency API achieves this with the following two interfaces:
In this method, you have to implement the logic of a task.
The Callable interface is a parameterized interface, meaning you have to indicate the type of data the call() method will return.
In this recipe, you will learn how to implement tasks that return a result and run them on an executor.
Getting ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private Integer attribute called number to store the number that this task will use for its calculations.
First, create and initialize the internal variables used in the method.
In this recipe, you have learned how to use the Callable interface to launch concurrent tasks that return a result.
The other critical point of this example is in the Main class.
You send a Callable object to be executed in an executor using the submit() method.
This method receives a Callable object as a parameter and returns a Future object that you can use with two main objectives:
For this purpose, you have used the isDone() method to check if the tasks had finished.
This method waits until the Callable object has finished the execution of the call() method and has returned its result.
If the call() method throws an exception, this method throws an ExecutionException exception.
When you call the get() method of a Future object and the task controlled by this object hasn't finished yet, the method blocks until the task finishes.
The Future interface provides another version of the get() method.
If the specified period of time passes and the result isn't yet available, the method returns a null value.
A common problem in concurrent programming is when you have various concurrent tasks that solve a problem, and you are only interested in the first result of those tasks.
You can launch all of them and get the result of the first one that sorts these, that is, the fastest sorting algorithm for a given array.
In this recipe, you will learn how to implement this scenario using the ThreadPoolExecutor class.
You are going to implement an example where a user can be validated by two mechanisms.
The user will be validated if one of those mechanisms validates it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private String attribute named name that will store the name of a user validation system.
Create two String objects named user and password and initialize them with the test value.
The key of the example is in the Main class.
The invokeAny() method of the ThreadPoolExecutor class receives a list of tasks, launches them, and returns the result of the first task that finishes without throwing an exception.
This method returns the same data type that the call() method of the tasks you launch returns.
The following screenshot shows the output of an execution of the example when one task validates the user:
The example has two UserValidator objects that return a random boolean value.
Each UserValidator object is used by a Callable object, implemented by the TaskValidator class.
If the validate() method of the UserValidator class returns a false value, the TaskValidator class throws Exception.
So, we have two tasks that can return the true value or throw an Exception exception.
The result of the invokeAny() method is the name of the task that finishes in the first place.
The result of the invokeAny() method is the name of the first task.
The result of the invokeAny() method is the name of the second task.
In that class, the invokeAny() method throws an ExecutionException exception.
If you run the examples several times, you get the four possible solutions you can get.
The following screenshot shows the output of the application when both tasks throw an exception:
There's more… The ThreadPoolExecutor class provides another version of the invokeAny() method:
See also f The Running multiple tasks and processing all the results recipe in Chapter 4,
The Executor framework allows you to execute concurrent tasks without worrying about thread creation and execution.
It provides you the Future class that you can use to control the status and get the results of any task executed in an executor.
When you want to wait for the finalization of a task, you can use the following two methods:
With the first one, you can only control the completion of a task, and with the second one, you have to shutdown the executor to wait for a thread, otherwise the method's call returns immediately.
The ThreadPoolExecutor class provides a method that allows you to send to the executor a list of tasks and wait for the finalization of all the tasks in the list.
In this recipe, you will learn how to use this feature by implementing an example with three tasks executed and their results printed out when they finish.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
One String attribute named name and one int attribute named value.
In this recipe, you have learned how to send a list of tasks to an executor and wait for the finalization of all of them using the invokeAll() method.
This method receives a list of the Callable objects and returns a list of the Future objects.
This list will have a Future object per task in the list.
The first object in the list of the Future objects will be the object that controls the first task in the list of the Callable objects, and so on.
The first point to take into consideration is that the type of data used for the parameterization of the Future interface in the declaration of the list that stores the result objects must be compatible with the one used to parameterized the Callable objects.
In this case, you have used the same type of data: the Result class.
Another important point about the invokeAll() method is that you will use the Future objects only to get the results of the tasks.
As the method finishes when all the tasks have finished, if you call the isDone() method of the Future objects that is returned, all the calls will return the true value.
The ExecutorService class provides another version of the invokeAll() method:
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Running a task in an executor after a delay The Executor framework provides the ThreadPoolExecutor class to execute Callable and Runnable tasks with a pool of threads, which avoid you all the thread creation operations.
When you send a task to the executor, it's executed as soon as possible, according to the configuration of the executor.
There are used cases when you are not interested in executing a task as soon as possible.
You may want to execute a task after a period of time or to execute a task periodically.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private String attribute named name that will store the name of the task.
You have passed the number 1 as a parameter to this method.
This parameter is the number of threads you want to have in the pool.
To execute a task in this scheduled executor after a period of time, you have to use the schedule() method.
If you want to execute a task at a given time, calculate the difference between that date and the current date and use that difference as the delay of the task.
The following screenshot shows the output of an execution of this example:
You can see how the tasks start their execution one per second.
All the tasks are sent to the executor at the same time, but each one with a delay of 1 second later than the previous task.
The default behavior is that those tasks will be executed despite the finalization of the executor.
With false, at the time of shutdown(), pending tasks won't get executed.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Running a task in an executor periodically The Executor framework provides the ThreadPoolExecutor class to execute concurrent tasks using a pool of threads that avoids you all the thread creation operations.
When you send a task to the executor, according to its configuration, it executes the task as soon as possible.
When it ends, the task is deleted from the executor and, if you want to execute them again, you have to send it again to the executor.
In this recipe, you will learn how to use this functionality of that class to schedule a periodic task.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private String attribute named name that will store the name of the task.
Write a message to the console with the actual date to verify that the task is executed within the specified period.
Use as parameters the task created earlier, the number one, the number two, and the constant TimeUnit.SECONDS.
This method returns a ScheduledFuture object that you can use to control the status of the task.
To create it (as with every executor), Java recommends the use of the Executors class.
That method receives as a parameter the number of threads of the pool.
As you have only one task in this example, you have passed the value 1 as a parameter.
Once you have the executor needed to execute a periodic task, you send the task to the executor.
This method accepts four parameters: the task you want to execute periodically, the delay of time until the first execution of the task, the period between two executions, and the time unit of the second and third parameters.
An important point to consider is that the period between two executions is the period of time between these two executions that begins.
In this example, as your task is a Runnable object that is not parameterized, you have to parameterize them with the ? symbol as a parameter.
The getDelay() method returns the time until the next execution of the task.
This method receives a TimeUnit constant with the time unit in which you want to receive the results.
The following screenshot shows the output of an execution of the example:
That's how long the main thread has been put to sleep.
When you shut down the executor, the scheduled task ends its execution and you don't see more messages in the console.
The default behavior is that the scheduled tasks finish when you call that method.
The periodic tasks won't finish upon calling the shutdown() method.
Canceling a task in an executor When you work with an executor, you don't have to manage threads.
You only implement the Runnable or Callable tasks and send them to the executor.
It's the executor that's responsible for creating threads, managing them in a thread pool, and finishing them if they are not needed.
Sometimes, you may want to cancel a task that you sent to the executor.
In that case, you can use the cancel() method of Future that allows you to make that cancellation operation.
In this recipe, you will learn how to use this method to cancel the tasks that you have sent to an executor.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Create a class named Task and specify that it implements the Callable interface parameterized with the String class.
Write a message to the console and put it to sleep for 100 milliseconds inside an infinite loop.
Finish the executor with the shutdown() method and write a message indicating the finalization of the program.
You use the cancel() method of the Future interface when you want to cancel a task that you have sent to an executor.
Depending on the parameter of the cancel() method and the status of the task, the behavior of this method is different:
If the task is already running, it depends on the parameter of the method.
The cancel() method receives a Boolean value as a parameter.
If the value of that parameter is true and the task is running, it will be canceled.
If the value of the parameter is false and the task is running, it won't be canceled.
The following screenshot shows the output of an execution of this example:
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Controlling a task finishing in an executor The FutureTask class provides a method called done() that allows you to execute some code after the finalization of a task executed in an executor.
It can be used to make some post-process operations, generating a report, sending results by e-mail, or releasing some resources.
This method is called internally by the FutureTask class when the execution of the task that this FutureTask object is controlling finishes.
The method is called after the result of the task is set and its status is changed to the isDone status, regardless of whether the task has been canceled or finished normally.
You can override the FutureTask class and implement this method to change this behavior.
In this recipe, you will learn how to override this method to execute code after the finalization of the tasks.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project..
The done()method is called by the FutureTask class when the task that is being controlled finishes its execution.
In this example, you have implemented a Callable object, the ExecutableTask class, and then, a subclass of the FutureTask class that controls the execution of the ExecutableTask objects.
The done() method is called internally by the FutureTask class after establishing the return value and changing the status of the task to the isDone status.
You can't change the result value of the task or change its status, but you can close resources used by the task, write log messages, or send notifications.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Separating the launching of tasks and the processing of their results in an executor.
Normally, when you execute concurrent tasks using an executor, you will send Runnable or Callable tasks to the executor and get Future objects to control the method.
You can find situations, where you need to send the tasks to the executor in one object and process the results in another one.
This CompletionService class has a method to send the tasks to an executor and a method to get the Future object for the next task that has finished its execution.
Internally, it uses an Executor object to execute the tasks.
This behavior has the advantage to share a CompletionService object, and sends tasks to the executor so the others can process the results.
The limitation is that the second object can only get the Future objects for those tasks that have finished its execution, so these Future objects can only be used to get the results of the tasks.
In this recipe, you will learn how to use the CompletionService class to separate launching tasks in an executor from processing their results.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare two private String attributes named sender and title that will represent data for the report.
CompletionService interface is a parameterized interface, use the String class as parameter of this CompletionService interface.
While the attribute end is false, call the poll() method of the CompletionService interface to get the Future object of the next task executed by the completion service that has finished.
Then, you have used that object to initialize a CompletionService object because the completion service uses an executor to execute its tasks.
To execute a task using the completion service, you use the submit() method as in the ReportRequest class.
When one of these tasks is executed when the completion service finishes its execution, the completion service stores the Future object used to control its execution in a queue.
The poll() method accesses this queue to see if there is any task that has finished its execution and, if so, returns the first element of that queue which is a Future object for a task that has finished its execution.
When the poll() method returns a Future object, it deletes it from the queue.
In this case, you have passed two attributes to that method to indicate the time you want to wait for the finalization of a task, in case the queue with the results of the finished tasks is empty.
Once the CompletionService object is created, you create two ReportRequest objects that execute three ReportGenerator tasks, each one in CompletionService, and a ReportSender task that will process the results generated by the tasks sent by the two ReportRequest objects.
In this example, you have used Callable, but you could also send Runnable objects.
Since Runnable objects don't produce a result, the philosophy of the CompletionService class doesn't apply in such cases.
This class also provides two other methods to obtain the Future objects of the finished tasks.
Otherwise, it returns its first element and removes it from the queue.
If it is empty, it blocks the thread until the queue has an element.
When the queue has elements, it returns and deletes its first element from the queue.
See also f The Executing tasks in an executor that returns a result recipe in Chapter 4,
Controlling rejected tasks of an executor When you want to finish the execution of an executor, you use the shutdown() method to indicate that it should finish.
The executor waits for the completion of the tasks that are running or waiting for their execution, and then finishes its execution.
If you send a task to an executor between the shutdown() method and the end of its execution, the task is rejected, because the executor no longer accepts new tasks.
The ThreadPoolExecutor class provides a mechanism, which is called when a task is rejected.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
In the following screenshot, you can see the result of an execution of the example:
This method is called for every task that is rejected by the executor.
There's more… When an executor receives a task to execute, it checks if the shutdown() method has been called.
This is a runtime exception, so you don't need to put a catch clause to control it.
Introduction Normally, when you implement a simple, concurrent Java application, you implement some Runnable objects and then the corresponding Thread objects.
You control the creation, execution, and status of those threads in your program.
Java 5 introduced an improvement with the Executor and ExecutorService interfaces and the classes that implement them (for example, the ThreadPoolExecutor class)
The Executor framework separates the task creation and its execution.
With it, you only have to implement the Runnable objects and use an Executor object.
You send the Runnable tasks to the executor and it creates, manages, and finalizes the necessary threads to execute those tasks.
Java 7 goes a step further and includes an additional implementation of the ExecutorService interface oriented to a specific kind of problem.
This framework is designed to solve problems that can be broken into smaller tasks using the divide and conquer technique.
Inside a task, you check the size of the problem you want to resolve and, if it's bigger than an established size, you divide it in smaller tasks that are executed using the framework.
If the size of the problem is smaller than the established size, you solve the problem directly in the task and then, optionally, it returns a result.
There is no formula to determine the reference size of a problem that determines if a task is subdivided or not, depending on its characteristics.
You can use the number of elements to process in the task and an estimation of the execution time to determine the reference size.
Test different reference sizes to choose the best one to your problem.
You can consider ForkJoinPool as a special kind of Executor.
The main difference between the Fork/Join and the Executor frameworks is the work-stealing algorithm.
Unlike the Executor framework, when a task is waiting for the finalization of the subtasks it has created using the join operation, the thread that is executing that task (called worker thread) looks for other tasks that have not been executed yet and begins its execution.
By this way, the threads take full advantage of their running time, thereby improving the performance of the application.
To achieve this goal, the tasks executed by the Fork/Join framework have the following limitations:
If they use other synchronization mechanisms, the worker threads can't execute other tasks when they are in the synchronization operation.
It has to include the code necessary to process them.
The core of the Fork/Join framework is formed by the following two classes:
It manages the worker threads and offers information about the status of the tasks and their execution.
It provides the mechanisms to execute the fork() and join() operations inside a task and the methods to control the status of the tasks.
Usually, to implement your Fork/Join tasks, you will implement a subclass of two subclasses of this class: RecursiveAction for tasks with no return result and RecursiveTask for tasks that return one.
This chapter presents five recipes that show you how to work efficiently with the Fork/Join framework.
Creating a Fork/Join pool In this recipe, you will learn how to use the basic elements of the Fork/Join framework.
The main characteristics of the Fork/Join framework you're going to use in this example are as follows:
When a task executes two or more subtasks, it waits for their finalizations.
By this way, the thread that was executing that task (called worker-thread) will look for other tasks to execute, taking full advantage of their execution time.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
In this recipe, you are going to implement a task to update the price of a list of products.
The initial task will be responsible for updating all the elements in a list.
Declare a private String attribute named name and a private double attribute named price.
This element is necessary, because the parent class of the RecursiveAction class, the ForkJoinTask class, implements the Serializable interface.
These attributes will determine the block of products this task has to process.
Declare a private double attribute named increment to store the increment of the price of the products.
Implement a block of code that shows information about the evolution of the pool every five milliseconds writing to the console the value of some parameters of the pool until the task finishes its execution.
In this example, you have created a ForkJoinPool object and a subclass of the ForkJoinTask class that you execute in the pool.
To create the ForkJoinPool object, you have used the constructor without arguments, so it will be executed with its default configuration.
It creates a pool with a number of threads equal to the number of processors of the computer.
When the ForkJoinPool object is created, those threads are created and they wait in the pool until some tasks arrive for their execution.
Since the Task class doesn't return a result, it extends the RecursiveAction class.
In the recipe, you have used the recommended structure for the implementation of the task.
If the task has to update more than 10 products, it divides those set of elements into two blocks, creates two tasks, and assigns a block to each task.
You have used the first and last attributes in the Task class to know the range of positions that this task has to update in the list of products.
You have used the first and last attributes to use only one copy of the products list and not create different lists for each task.
To execute the subtasks that a task creates, it calls the invokeAll() method.
This is a synchronous call, and the task waits for the finalization of the subtasks before continuing (potentially finishing) its execution.
While the task is waiting for its subtasks, the worker thread that was executing it takes another task that was waiting for execution and executes it.
With this behavior, the Fork/Join framework offers a more efficient task management than the Runnable and Callable objects themselves.
The invokeAll() method of the ForkJoinTask class is one of the main differences between the Executor and the Fork/Join framework.
In the Executor framework, all the tasks have to be sent to the executor, while in this case, the tasks include methods to execute and control the tasks inside the pool.
You have used the invokeAll() method in the Task class, that extends the RecursiveAction class that extends the ForkJoinTask class.
You have sent a unique task to the pool to update all the list of products using the execute() method.
In this case, it's an asynchronous call, and the main thread continues its execution.
You have used some methods of the ForkJoinPool class to check the status and the evolution of the tasks that are running.
The class includes more methods that can be useful for this purpose.
See the Monitoring a Fork/Join pool recipe for a complete list of those methods.
Finally, like with the Executor framework, you should finish ForkJoinPool using the shutdown() method.
The following screenshot shows part of an execution of this example:
You can see the tasks finishing their work and the price of the products updates.
The ForkJoinPool class provides other methods to execute a task in.
In this case, you send a Runnable task to the ForkJoinPool class.
Note that the ForkJoinPool class doesn't use the work-stealing algorithm with Runnable objects.
This call doesn't return until the task passed as a parameter finishes its execution.
The ForkJoinPool class doesn't use the work-stealing algorithm with the Callable objects, so you'd be better off executing them using an executor.
The ForkJoinTask class also includes other versions of the invokeAll() method used in the example.
You can pass to it as parameters as many ForkJoinTask objects as you want.
This generic type T must be the ForkJoinTask class or a subclass of it.
Although the ForkJoinPool class is designed to execute an object of ForkJoinTask, you can also execute Runnable and Callable objects directly.
You may also use the adapt() method of the ForkJoinTask class that accepts a Callable object or a Runnable object and returns a ForkJoinTask object to execute that task.
See also f The Monitoring a Fork/Join pool recipe in Chapter 8, Testing concurrent applications.
Joining the results of the tasks The Fork/Join framework provides the ability of executing tasks that return a result.
These kinds of tasks are implemented by the RecursiveTask class.
This class extends the ForkJoinTask class and implements the Future interface provided by the Executor framework.
Inside the task, you have to use the structure recommended by the Java API documentation:
If the task has to resolve a problem bigger than a predefined size, you divide the problem in more subtasks and execute those subtasks using the Fork/Join framework.
When they finish their execution, the initiating task obtains the results generated by all the subtasks, groups them, and returns the final result.
Ultimately, when the initiating task executed in the pool finishes its execution, you obtain its result that is effectively the final result of the entire problem.
In this recipe, you will learn how to use this kind of problem solving with Fork/Join framework developing an application that looks for a word in a document.
All the tasks are going to return the number of appearances of the word in the part of the document or line they process.
Declare a private String matrix named document and two private int attributes named start and end.
This element is necessary because the parent class of the RecursiveTask class, the ForkJoinTask class, implements the Serializable interface.
Declare a private String array attribute named line and two private int attributes named start and end.
Implement a block of code that shows information about the progress of the pool writing every second to the console the value of some parameters of the pool until the task finishes its execution.
Write the number of the appearances of the word in the document.
Check that this number is the same as the number written by the DocumentMock class.
If this set of lines has a size smaller that 10, it creates LineTask per line, and when they finish their execution, it sums the results of those tasks and returns the result of the sum.
If the set of lines the task has to process has a size of 10 or bigger, it divides the set in two and creates two DocumentTask objects to process those new sets.
When those tasks finish their execution, the tasks sum their results and return that sum as a result.
If this set of words is smaller than 100, the task searches the word directly in that set of words and returns the number of appearances of the word.
Otherwise, it divides the set of words in two and creates two LineTask objects to process those sets.
When those tasks finish their execution, the task sums the results of both tasks and returns that sum as a result.
In the Main class, you have created a ForkJoinPool object using the default constructor and you have executed in it a DocumentTask class that has to process a document of DocumentTask objects and LineTask objects, and when all the tasks finish their execution, you can use the original task to get the total number of appearances of the word in the whole document.
Since the tasks return a result, they extend the RecursiveTask class.
To obtain the result returned by Task, you have used the get() method.
This method is declared in the Future interface implemented by the RecursiveTask class.
When you execute the program, you can compare the first and the last lines written in the console.
The first line is the number of appearances of the word calculated when the document is generated and the last is the same number calculated by the Fork/Join tasks.
There's more… The ForkJoinTask class provides another method to finish execution of a task and returns a result, that is, the complete() method.
This method accepts an object of the type used in the parameterization of the RecursiveTask class and returns that object as a result of the task when the join() method is called.
It's use is recommended to provide results for asynchronous tasks.
Since the RecursiveTask class implements the Future interface, there's another version of the get() method:
If the specified period of time passes and the result isn't yet available, the method returns a null value.
Running tasks asynchronously When you execute ForkJoinTask in ForkJoinPool, you can do it in a synchronous or asynchronous way.
When you do it in a synchronous way, the method that sends the task to the pool doesn't return until the task sent finishes its execution.
When you do it in an asynchronous way, the method that sends the task to the executor returns immediately, so the task can continue with its execution.
You should be aware of a big difference between the two methods.
When you use the synchronized methods, the task that calls one of these methods (for example, the invokeAll() method) is suspended until the tasks it sent to the pool finish their execution.
This allows the ForkJoinPool class to use the work-stealing algorithm to assign a new task to the worker thread that executed the sleeping task.
On the contrary, when you use the asynchronous methods (for example, the fork() method), the task continues with its execution, so the ForkJoinPool class can't use the work-stealing algorithm to increase the performance of the application.
In this case, only when you call the join() or get() methods to wait for the finalization of a task, the ForkJoinPool class can use that algorithm.
In this recipe, you will learn how to use the asynchronous methods provided by the ForkJoinPool and ForkJoinTask classes for the management of tasks.
You are going to implement a program that will search for files with a determined extension inside a folder and its subfolders.
The ForkJoinTask class you're going to implement will process the content of a folder.
For each subfolder inside that folder, it will send a new task to the ForkJoinPool class in an asynchronous way.
For each file inside that folder, the task will check the extension of the file and add it to the result list if it proceeds.
This element is necessary because the parent class of the RecursiveTask class, the ForkJoinTask class, implements the Serializable interface.
This attribute will store the full path of the folder this task is going to process.
This attribute will store the name of the extension of the files this task is going to look for.
Write to the console information about the status of the pool every second until the three tasks have finished their execution.
Write the number of results generated by each task to the console.
The following screenshot shows part of an execution of this example:
The key of this example is in the FolderProcessor class.
As you know, this content has the following two kinds of elements:
If the task finds a folder, it creates another Task object to process that folder and sends it to the pool using the fork() method.
This method sends the task to the pool that will execute it if it has a free worker-thread or it can create a new one.
The method returns immediately, so the task can continue processing the content of the folder.
For every file, a task compares its extension with the one it's looking for and, if they are equal, adds the name of the file to the list of results.
Once the task has processed all the content of the assigned folder, it waits for the finalization of all the tasks it sent to the pool using the join() method.
This method called in a task waits for the finalization of its execution and returns the value returned by the compute() method.
The task groups the results of all the tasks it sent with its own results and returns that list as a return value of the compute() method.
The ForkJoinPool class also allows the execution of tasks in an asynchronous way.
You have used the execute() method to send the three initial tasks to the pool.
In the Main class, you also finished the pool using the shutdown() method and wrote information about the status and the evolution of the tasks that are running in it.
The ForkJoinPool class includes more methods that can be useful for this purpose.
See the Monitoring a Fork/Join pool recipe to see a complete list of those methods.
In this example, you have used the join() method to wait for the finalization of tasks and get their results.
You can also use one of the two versions of the get() method with this purpose:
If the specified period of time passes and the result isn't yet available, the method returns a null value.
There are two main differences between the get() and the join() methods:
Throwing exceptions in the tasks There are two kinds of exceptions in Java:
You can't throw any checked exception in the compute() method of the ForkJoinTask class, because this method doesn't include any throws declaration in its implementation.
You have to include the necessary code to handle exceptions.
On the other hand, you can throw (or it can be thrown by any method or object used inside the method) an unchecked exception.
The behavior of the ForkJoinTask and ForkJoinPool classes is different from what you may expect.
The program doesn't finish execution and you won't see any information about the exception in the console.
You can, however, use some methods of the ForkJoinTask class to know if a task threw an exception and what kind of exception it was.
In this recipe, you will learn how to get that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
It will simulate the array of data you are going to process in this example.
These attributes will determine the elements of the array this task has to process.
The Task class you have implemented in this recipe processes an array of numbers.
It checks if the block of numbers it has to process has 10 or more elements.
In that case, it splits the block in two and creates two new Task objects to process those blocks.
Otherwise, it looks for the element in the fourth position of the array (index number three)
If that element is in the block the task has to process, it throws a RuntimeException exception.
When you execute the program, the exception is thrown, but the program doesn't stop.
This method returns true if that task, or one of its subtasks, has thrown an exception.
You also used the getException() method of the same object to get the Exception object that it has thrown.
When you throw an unchecked exception in a task, it also affects its parent task (the task that sent it to the ForkJoinPool class) and the parent task of its parent task, and so on.
If you revise all the output of the program, you'll see that there aren't output messages for the finalization of some tasks.
These tasks are the ones that threw the exception and its parent tasks.
Take this into account, when you develop a program with the ForkJoinPool and ForkJoinTask objects that can throw exceptions if you don't want this behavior.
The following screenshot shows part of an execution of this example:
Canceling a task When you execute the ForkJoinTask objects in a ForkJoinPool class, you can cancel them before they start their execution.
The ForkJoinTask class provides the cancel() method for this purpose.
There are some points you have to take into account when you want to cancel a task, which are as follows:
In this recipe, you will implement an example of cancelation of ForkJoinTask objects.
You will look for the position of a number in an array.
The first task that finds the number will cancel the remaining tasks.
As that functionality is not provided by the Fork/Join framework, you will implement an auxiliary class to do this cancelation.
Getting ready… The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE NetBeans, open it and create a new Java project.
Declare a list of objects parameterized with the ForkJoinTask class parameterized with the Integer class named List.
These attributes will determine the elements of the array this task has to process.
Declare a private int attribute named number to store the number you are going to look for.
You will use this object to cancel all the tasks.
Declare a private int constant and initialize it to the -1 value.
It will be the returned value by the task when it doesn't find the number.
Wait for the finalization of the tasks and return the result of the first task if it is different, to -1, or the result of the second task.
The ForkJoinTask class provides the cancel() method that allows you to cancel a task if it hasn't been executed yet.
If the task has begun its execution, a call to the cancel() method has no effect.
This name may make you think that, if you pass the true value to the method, the task will be canceled even if it is running.
The Java API documentation specifies that, in the default implementation of the ForkJoinTask class, this attribute has no effect.
The tasks are only canceled if they haven't started their execution.
The cancelation of a task has no effect over the tasks that this task sent to the pool.
A limitation of the Fork/Join framework is that it doesn't allow the cancelation of all the tasks that are in ForkJoinPool.
To overcome that limitation, you have implemented the TaskManager class.
It stores all the tasks that have been sent to the pool.
It has a method that cancels all the tasks it has stored.
If a task can't be canceled because it's running or it has finished, the cancel() method returns the false value, so you can try to cancel all the tasks without being afraid of possible collateral effects.
In the example, you have implemented a task that looks for a number in an array of numbers.
You divide the problem into smaller sub-problems as the Fork/Join framework recommends.
You are only interested in one occurrence of the number so, when you find it, you cancel the other tasks.
The following screenshot shows part of an execution of this example:
Almost every program uses one or more types of data structures to store and manage their data.
Java API provides the Java Collections framework that contains interfaces, classes, and algorithms, which implement a lot of different data structures that you can use in your programs.
When you need to work with data collections in a concurrent program, you must be very careful with the implementation you choose.
Most collection classes are not ready to work with concurrent applications because they don't control the concurrent access to its data.
If some concurrent tasks share a data structure that is not ready to work with concurrent tasks, you can have data inconsistency errors that will affect the correct operation of the program.
One example of this kind of data structures is the ArrayList class.
Java provides data collections that you can use in your concurrent programs without any problems or inconsistency.
Basically, Java provides two kinds of collections to use in concurrent applications:
If the operation can't be made immediately, because the collection is full or empty, the thread that makes the call will be blocked until the operation can be made.
If the operation can't be made immediately, the operation returns a null value or throws an exception, but the thread that makes the call won't be blocked.
Through the recipes of this chapter, you will learn how to use some Java collections that you can use in your concurrent applications.
Using non-blocking thread-safe lists The most basic collection is the list.
A list has an undetermined number of elements and you can add, read, or remove the element of any position.
Concurrent lists allow the various threads to add or remove elements in the list at a time without producing any data inconsistency.
In this recipe, you will learn how to use non-blocking lists in your concurrent programs.
Non-blocking lists provide operations that, if the operation can't be done immediately (for example, you want to get an element of the list and the list is empty), they throw an exception or return a null value, depending on the operation.
We are going to implement an example with the following two different tasks:
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
The following screenshot shows the output of an execution of this example:
First, you have executed 100 AddTask tasks to add elements to the list.
Each one of those tasks inserts 10,000 elements to the list using the add() method.
This method adds the new elements at the end of the list.
When all those tasks have finished, you have written in the console the number of elements of the list.
Then, you have executed 100 PollTask tasks to remove elements from the list.
Each one of those tasks removes 10,000 elements of the list using the pollFirst() and pollLast() methods.
The pollFirst() method returns and removes the first element of the list and the pollLast() method returns and removes the last element of the list.
If the list is empty, these methods return a null value.
When all those tasks have finished, you have written in the console the number of elements of the list.
To write the number of elements of the list, you have used the size() method.
You have to take into account that this method can return a value that is not real, especially if you use it when there are threads adding or deleting data in the list.
The method has to traverse the entire list to count the elements and the contents of the list can change for this operation.
Only if you use them when there aren't any threads modifying the list, you will have the guarantee that the returned result is correct.
If the list is empty, these methods return a null value.
Using blocking thread-safe lists The most basic collection is the list.
A list has an undetermined number of elements and you can add, read, or remove the element from any position.
A concurrent list allows various threads to add or remove elements in the list at a time without producing any data inconsistency.
In this recipe, you will learn how to use blocking lists in your concurrent programs.
The main difference between blocking lists and non-blocking lists is that blocking lists has methods to insert and delete elements on it that, if they can't do the operation immediately, because the list is full or empty, they block the thread that make the call until the operation can be made.
You are going to implement an example with the following two tasks:
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
The Client class uses the put() method to insert strings in the list.
If the list is full (because you have created it with a fixed capacity), the method blocks the execution of its thread until there is an empty space in the list.
The Main class uses the take() method to get strings from the list.
If the list is empty, the method blocks the execution of its thread until there are elements in the list.
If the list is empty, these methods block the thread until there are elements in the list.
If the list is empty, these methods return a null value.
If the list is empty, these methods return a null value.
A typical need when you work with data structures is to have an ordered list.
This interface has a method, compareTo() that receives an object of the same type, so you have two objects to compare: the one that is executing the method and the one that is received as a parameter.
The method must return a number less than zero if the local object is less than the parameter, a number bigger that zero if the local object is greater than the parameter, and the number zero if both objects are equal.
The greater elements will be the tail of the queue.
It has methods that, if they can't do their operation immediately, block the thread until they can do it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private int attribute named thread to store the number of the thread that has created the event.
Declare a private int attribute named priority to store the priority of the event.
Declare a private int attribute named id to store the number that identifies the task.
Create an array of five Thread objects to store the threads that is going to execute five tasks.
Write a message to the console with the final size of the queue.
The elements that have a higher value of priority will be the first elements in the queue.
When you have implemented the compareTo() method, if the event executing the method has a priority higher than the priority of the event passed as parameter, it returns -1 as the result.
In the other case, if the event executing the method has a priority lower than the priority of the event passed as parameter, it returns 1 as the result.
If both objects have the same priority, the compareTo() method returns the 0 value.
We have implemented the Task class to add the Event objects to the priority queue.
The main() method of the Main class creates five Task objects and executes them in the corresponding threads.
When all the threads have finished their execution, you have written all the elements to the console.
To get the elements from the queue, we have used the poll() method.
That method returns and removes the first element from the queue.
The following screenshot shows part of the output of an execution of the program:
You can see how the queue has a size of 5,000 elements and how the first elements have the biggest priority values.
If the queue is empty, the method blocks its thread until the queue has elements.
This method inserts the element passed as a parameter into the queue.
An interesting data structure provided by the Java API, and that you can use in concurrent applications, is implemented in the DelayedQueue class.
In this class, you can store elements with an activation date.
The methods that return or extract elements of the queue will ignore those elements whose data is in the future.
To obtain this behavior, the elements you want to store in the DelayedQueue class have to implement the Delayed interface.
This interface allows you to work with delayed objects, so you will implement the activation date of the objects stored in the DelayedQueue class as the time remaining until the activation date.
This method will return a value less than zero if the object that is executing the method has a delay smaller than the object passed as a parameter, a value greater than zero if the object that is executing the method has a delay bigger than the object passed as a parameter, and the zero value if both objects have the same delay.
In this example, you will learn how to use the DelayedQueue class storing in it some events with different activation dates.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private int attribute named id to store a number that identifies this task.
Declare a private DelayQueue attribute parameterized with the Event class named queue.
Create an array of five Thread objects to store the tasks you're going to execute.
That class has a unique attribute, the activation date of the events, and implements the Delayed interface, so you can store Event objects in the DelayedQueue class.
The getDelay() method returns the number of nanoseconds between the activation date and the actual date.
You have used the getTime() method that returns a date converted to milliseconds and then, you have converted that value to TimeUnit received as a parameter.
The DelayedQueue class works in nanoseconds, but at this point, it's transparent to you.
The compareTo() method returns a value less than zero if the delay of the object executing the method is smaller than the delay of the object passed as a parameter, a value greater than zero if the delay of the object executing the method is bigger than the delay of the object passes as a parameter, and the value 0 if both delays are equal.
When a Task object is executed, it adds a number of seconds equal to the ID of the task to the actual date and that is the activation date of the events stored by this task in the DelayedQueue class.
Each Task object stores 100 events in the queue using the add() method.
Finally, in the main() method of the Main class, you have created five Task objects and executed them in the corresponding threads.
When those threads finish their execution, you have written to the console all the events using the poll() method.
That method retrieves and removes the first element of the queue.
If the queue does not have any active element, the method returns the null value.
You called the poll() method and if it returns an Event class, you increment a counter.
When the poll() method returns the null value, you write the value of the counter in the console and put the thread to sleep during half a second to wait for more active events.
When you have obtained the 500 events stored in the queue, the execution of the program finishes.
The following screenshot shows part of the output of an execution of the program:
You can see how the program only gets 100 events when it is activated.
It returns the total number of elements in the list that includes the active and non-active elements.
There's more… The DelayQueue class has other interesting methods, which are as follows:
This method inserts the element passed as a parameter in the queue.
If there aren't any active elements in the queue, the thread that is executing the method will be blocked until the thread has some active elements.
Internally, it uses a Skip List to store the data.
A Skip List is a data structure based on parallel lists that allows us to get efficiency similar to a binary tree.
With it, you can get a sorted data structure with a better access time to insert, search, or delete elements than a sorted list.
When you insert an element in the map, it uses the key to order them, so all the elements will be ordered.
The class also provides methods to obtain a submap of the map, in addition to the ones that return a concrete element.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private String attribute named id to store the ID of the current task.
Create an array for 25 Thread objects to store all the Task objects that you're going to execute.
In this recipe, we have implemented a Task class to store Contact objects in the navigable map.
We have used a concatenation of those values as the key for the contacts.
Each Task object creates 1,000 contacts that are stored in the navigable map using the put() method.
If you insert an element with a key that exists in the map, the element associated with that key will be replaced by the new element.
The main() method of the Main class creates 25 Task objects, using IDs as the letters between A and Z.
Then, you have used some methods to obtain data from the map.
The firstEntry() method returns a Map.Entry object with the first element of the map.
To obtain the element, you have called the getValue() method.
You can use the getKey() method to obtain the key of that element.
In this case, you have used the pollFirst() method to process the elements of the subMap() method.
That method returns and removes the first Map.Entry object of the submap.
The following screenshot shows the output of an execution of the program:
This method returns a submap of the first elements of the map with the elements that have a key smaller than the one passed as parameter.
This method returns a submap of the last elements of the map with the elements that have a key greater than the one passed as parameter.
Generating concurrent random numbers The Java concurrency API provides a specific class to generate pseudo-random numbers in concurrent applications.
It's the ThreadLocalRandom class and it's new in the Java 7 Version.
Every thread that wants to generate random numbers has a different generator, but all of them are managed from the same class, in a transparent way to the programmer.
With this mechanism, you will get a better performance than using a shared Random object to generate the random numbers of all the threads.
In this recipe, you will learn how to use the ThreadLocalRandom class to generate random numbers in a concurrent application.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
How it works… The key of this example is in the TaskLocalRandom class.
In the constructor of the class, we make a call to the current() method of the ThreadLocalRandom class.
This is a static method that returns the ThreadLocalRandom object associated with the current thread, so you can generate random numbers using that object.
If the thread that makes the call does not have any object associated yet, the class creates a new one.
In this case, you use this method to initialize the random generator associated with this task, so it will be created in the next call to the method.
In the run() method of the TaskLocalRandom class, make a call to the current() method to get the random generator associated with this thread, also you make a call to the nextInt() method passing number 10 as parameter.
This method will return a pseudo random number between zero and 10
The ThreadLocalRandom class also provides methods to generate long, float, and double numbers, and Boolean values.
There are methods that allow you to provide a number as a parameter to generate random numbers between zero and that number.
Other methods allow you to provide two parameters to generate random numbers between those numbers.
See also f The Using local thread variables recipe in Chapter 1, Thread management.
Using atomic variables Atomic variables were introduced in Java Version 5 to provide atomic operations on single variables.
When you work with a normal variable, each operation that you implement in Java is transformed in several instructions that is understandable by the machine when you compile the program.
For example, when you assign a value to a variable, you only use one instruction in Java, but when you compile this program, this instruction is transformed in various instructions in the JVM language.
This fact can provide data inconsistency errors when you work with multiple threads that share a variable.
When a thread is doing an operation with an atomic variable, if other threads want to do an operation with the same variable, the implementation of the class includes a mechanism to check that the operation is done in one step.
Basically, the operation gets the value of the variable, changes the value in a local variable, and then tries to change the old value for the new one.
If the old value is still the same, it does the change.
Atomic variables don't use locks or other synchronization mechanisms to protect the access to their values.
All their operations are based on the Compare and Set operation.
It's guaranteed that several threads can work with an atomic variable at a time without generating data inconsistency errors and its performance is better than using a normal variable protected by a synchronization mechanism.
In this recipe, you will learn how to use atomic variables implementing a bank account and two different tasks, one that adds money to the account and one that subtracts money from it.
You will use the AtomicLong class in the implementation of the example.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you are using Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private AtomicLong attribute named balance to store the balance of the account.
Wait for the finalization of the threads using the join() method and write in the console the final balance of the account.
The key of this example is in the Account class.
In that class, we declared an AtomicLong variable named balance to store the balance of the account and then we implemented the methods to work with that balance using the methods provided by the AtomicLong class.
To implement the getBalance() method that returns the value of the balance attribute, you have used the get() method of the AtomicLong class.
To implement the setBalance() method that establish the value of the balance attribute, you have used the set() method.
To implement the addAmount() method that adds an import to the balance of the account, you have used the getAndAdd() method of the AtomicLong class that returns the value and increments it by the value specified as a parameter.
Finally, to implement the subtractAmount() method that decrements the value of the balance attribute, you have also used the getAndAdd() method.
In the Main class, you have created an Account object with a balance of 1,000
Then, you have executed a bank task and a company task, so the final balance of the account must be the same as the initial one.
When you execute the program, you will see how the final balance is the same as the initial one.
The following screenshot shows the output of an execution of this example:
As we mentioned in the introduction, there are other atomic classes in Java.
AtomicBoolean, AtomicInteger, and AtomicReference are other examples of atomic classes.
See also f The Synchronizing a method recipe in Chapter 2, Basic thread synchronization.
Using atomic arrays When you implement a concurrent application that has one or more objects shared by several threads, you have to protect the access to their attributes using a synchronization mechanism as locks or the synchronized keyword to avoid data inconsistency errors.
This situation blocks the program, so it will never finish.
To provide a better performance to this situation, the compare-and-swap operation was developed.
This operation implements the modification of the value of a variable in the following three steps:
You get the value of the variable, which is the old value of the variable.
You change the value of the variable in a temporal variable, which is the new value of the variable.
You substitute the old value with the new value, if the old value is equal to the actual value of the variable.
The old value may be different from the actual value if another thread has changed the value of the variable.
With this mechanism, you don't need to use any synchronization mechanism, so you avoid deadlocks and you obtain a better performance.
These variables provide the compareAndSet() method that is an implementation of the compare-and-swap operation and other methods based on it.
Java also introduced atomic arrays that provide atomic operations for arrays of integer or long numbers.
In this recipe, you will learn how to use the AtomicIntegerArray class to work with atomic arrays.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private AtomicIntegerArray attribute named vector to store an array of integer numbers.
Declare a private AtomicIntegerArray attribute named vector to store an array of integer numbers.
In this example, you have implemented two different tasks to work with an AtomicIntegerArray object:
At the end of those tasks, if there were no inconsistency errors, all the elements of the array must have the value 0
If you execute the program, you will see how the program only writes to the console the final message because all the elements are zero.
It's the AtomicLongArray class that provides the same methods as the IntegerAtomicArray class.
Introduction Java concurrency API provides a lot of interfaces and classes to implement concurrent applications.
They provide low-level mechanisms, such as the Thread class, the Runnable or Callable interfaces, or the synchronized keyword, and also high-level mechanisms, such as the Executor framework and the Fork/Join framework added in the Java 7 release.
Despite this, you may find yourself developing a program where none of the java classes meet your needs.
In this case, you may need to implement your own custom-concurrent utilities based on the ones provided by Java.
For example, overriding the run() method of the Thread class which, by default, does nothing useful and is supposed to be overridden to offer some functionality.
Through the recipes of this chapter, you will learn how to change the behavior of some Java concurrency API classes without the need to design a concurrency framework from scratch.
You can use these recipes as an initial point to implement your own customizations.
Customizing the ThreadPoolExecutor class The Executor framework is a mechanism that allows you to separate the thread creation from its execution.
It's based on the Executor and ExecutorService interfaces with the ThreadPoolExecutor class that implements both interfaces.
It has an internal pool of threads and provides methods that allow you to send two kinds of tasks for their execution in the pooled threads.
In both cases, you only send the task to the executor.
The executor uses one of its pooled threads or creates a new one to execute those tasks.
The executor also decides the moment in which the task is executed.
In this recipe, you will learn how to override some methods of the ThreadPoolExecutor class to calculate the execution time of the tasks that you execute in the executor and to write in the console statistics about the executor when it completes its execution.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private ConcurrentHashMap attribute parameterized with the String and Date classes named startTimes.
In this recipe, we have implemented our custom executor extending the ThreadPoolExecutor class and overriding four of its methods.
The beforeExecute() and afterExecute() methods were used to calculate the execution time of a task.
The beforeExecute() method is executed before the execution of a task.
In this case, we have used HashMap to store in it the start date of the task.
The afterExecute() method is executed after the execution of a task.
You get startTime of the task that has finished from HashMap and then, calculate the difference between the actual date and that date to get the execution time of the task.
You have also overridden the shutdown() and shutdownNow() methods to write statistics about the tasks executed in the executor to the console:
The pending tasks, using the size() method of the blocking queue where the executor stores the pending tasks.
Execute the program and you will see how the program shows the time span of each task that is running and the statistics of the executor upon calling the shutdown() method.
In the first versions of the Java concurrency API, you had to create and run all the threads of your application.
In Java Version 5, with the appearance of the Executor framework, a new mechanism was introduced for the execution of concurrency tasks.
With the Executor framework, you only have to implement your tasks and send them to the executor.
The executor is responsible for the creation and execution of the threads that execute your tasks.
Internally, an executor uses a blocking queue to store pending tasks.
These are stored in the order of their arrival to the executor.
One possible alternative is the use of a priority queue to store new tasks.
In this way, if a new task with high priority arrives to the executor, it will be executed before other threads that have already been waiting for a thread to execute, but have lower priority.
In this recipe, you will learn how to implement an executor that will use a priority queue to store the tasks you send for execution.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
To convert an executor to a priority-based one is simple.
But with the executor, you should know that all the objects stored in a priority queue have to implement the Comparable interface.
You have implemented the MyPriorityTask class that implements the Runnable interface, to be a task, and the Comparable interface, to be stored in the priority queue.
This class has a Priority attribute that is used to store the priority of the tasks.
If a task has a higher value for this attribute, it will be executed earlier.
The compareTo() method determines the order of the tasks in the priority queue.
In the Main class, you sent eight tasks to the executor with different priorities.
The first tasks you sent to the executor are the first tasks that are executed.
As the executor is idle waiting for tasks to be executed, and as the first tasks arrive to the executor, it executes them immediately.
You have created the executor with two execution threads, so the first two tasks will be the first ones that are executed.
Then, the rest of the tasks are executed based on their priority.
There's more… You can configure Executor to use any implementation of the BlockingQueue interface.
This class is used to store elements with a delayed activation.
The factory pattern is a widely used design pattern in the object-oriented programming world.
It is a creational pattern and its objective is to develop a class whose mission will be creating objects of one or several classes.
Then, when we want to create an object of one of those classes, we use the factory instead of using the new operator.
For example, we can only have N objects of a type that is easily generating statistical data about the creation of objects.
Java provides the ThreadFactory interface to implement a Thread object factory.
Some advanced utilities of the Java concurrency API, as the Executor framework or the Fork/Join framework, use thread factories to create threads.
Another example of the factory pattern in the Java Concurrency API is the Executors class.
It provides a lot of methods to create different kinds of Executor objects.
In this recipe, you will extend the Thread class by adding new functionalities and you will implement a thread factory class to generate threads of that new class.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Declare three private Date attributes named creationDate, startDate, and finishDate.
Store the start date of the thread, call the run() method of the parent class, and store the finish date of the execution.
Implement a method named getExecutionTime() that calculates the execution time of the thread as the difference between the start date and the finish date.
In this recipe, you have implemented a custom MyThread class extending the Thread class.
The class has three attributes to store the creation date, the start date of its execution, and the end date of its execution.
Using the start date and the end date attributes, you have implemented the getExecutionTime() method that returns the time that the thread has been executing its task.
Finally, you have overridden the toString() method to generate information about a thread.
Once you had your own thread class, you have implemented a factory to create objects of that class implementing the ThreadFactory interface.
It's not mandatory to make use of the interface if you're going to use your factory as an independent object, but if you want to use this factory with other classes of the Java concurrency API, you must construct your factory by implementing that interface.
The ThreadFactory interface only has one method, the newThread() method that receives a Runnable object as a parameter and returns a Thread object to execute that Runnable object.
To check these two classes, you have implemented the MyTask class that implements the Runnable object.
This is the task to be executed in threads managed by the MyThread object.
A MyTask instance puts its execution thread to sleep for 2 seconds.
In the main method of the example, you have created a MyThread object using a MyThreadFactory factory to execute a Task object.
Execute the program and you will see a message with the start date and the execution time of the thread executed.
The following screenshot shows the output generated by this example:
The Java Concurrency API provides the Executors class to generate thread executors, usually objects of the ThreadPoolExecutor class.
The factory generated by this method generates basic Thread objects belonging to all of them to the same ThreadGroup object.
You can use the ThreadFactory interface in your program for any purposes, not necessarily related to the Executor framework.
In the previous recipe, Implementing the ThreadFactory interface to generate custom threads, we introduced the factory pattern and provided an example of how to implement a factory of threads implementing the ThreadFactory interface.
The Executor framework is a mechanism that allows you the separation of the thread creation and its execution.
It's based on the Executor and ExecutorService interfaces and in the ThreadPoolExecutor class that implements both interfaces.
It has an internal pool of threads and provides methods that allow you to send two kinds of tasks for their execution in the pooled threads.
Internally, an Executor framework uses a ThreadFactory interface to create the threads that it uses to generate the new threads.
In this recipe, you will learn how to implement your own thread class, a thread factory to create threads of that class, and how to use that factory in an executor, so the executor will execute your threads.
Getting ready… Read the previous recipe, Implementing a ThreadFactory interface to generate custom threads, and implement its example.
The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
Copy into the project the classes MyThread, MyThreadFactory, and MyTask implemented in the recipe Implementing a ThreadFactory interface to generate custom threads, so you are going to use them in this example.
In the How it works… section of the previous recipe, Implementing a ThreadFactory interface to generate custom threads, you can read a detailed explanation of how the MyThread, MyThreadFactory, and MyTask classes works.
You have passed the factory object created earlier as a parameter, so the Executor object created will use that factory to create the threads it needs and it will execute threads of the MyThread class.
Execute the program and you will see a message with information about the thread's start date and its execution time.
The following screenshot shows the output generated by this example:
See also f The Implementing a ThreadFactory interface to generate custom threads recipe in.
The scheduled thread pool is an extension of the basic thread pool of the Executor framework that allows you to schedule the execution of tasks to be executed after a period of time.
Delayed tasks can execute both, the Callable and Runnable objects, but the periodic tasks can only execute Runnable objects.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
All the interfaces and classes mentioned earlier are parameterized classes, with the type of data that will be returned by the tasks.
So, when you implement your own version of scheduled tasks, you have to implement your own version of a scheduled executor.
A resultant object that is going to be returned by that task.
In this case, the task won't return a result, so you used the null value.
An original task is used to execute the Runnable object.
This is the task that the new object is going to replace in the pool; an executor that is going to execute the task.
In this case, you use the this keyword to reference the executor that is creating the task.
You have implemented two methods with all the necessary logic to execute both kinds of tasks.
The getDelay() method is called by the scheduled executor to know if it has to execute a task.
The behavior of this method changes in delayed and periodic tasks.
When we are going to execute a delayed task, the getDelay() method returns the delay of the original task, but in the case of the periodic task, the getDelay() method returns the difference between the startDate attribute and the actual date.
The run() method is the one that executes the task.
One particularity of the periodic tasks is that you have to put the next execution of the task in the queue of the executor as a new task if you want the task to be executed again.
So, if you're executing a periodic task, you establish the startDate attribute value adding to the actual date and the period of execution of the task and store the task again in the queue of the executor.
The startDate attribute stores the date when the next execution of the task will begin.
Then, you execute the task using the runAndReset() method provided by the FutureTask class.
In the case of the delayed tasks, you don't have to put them in the queue of the executor, because they only execute once.
You have also to take into account if the executor has been shutdown.
In that case, you don't have to store again the periodic tasks into the queue of the executor.
We mentioned earlier that, for periodic tasks, you establish the value of the startDate attribute using the period of the task, but you haven't initialized that period yet.
You have to override this method that receives that period as a parameter, to pass it to the MyScheduledTask class so it can use it.
The example is complete with the Task class that implements the Runnable interface and is the task executed in the scheduled executor.
The following screenshot shows part of the execution of this example.
You can check as the two kinds of tasks are executed properly:
See also f The Running a task in an executor after a delay recipe in Chapter 4, Thread Executors.
Implementing the ThreadFactory interface to generate custom threads for the Fork/Join framework.
One of the most interesting features of Java 7 is the Fork/Join framework.
It's an implementation of the Executor and ExecutorService interfaces that allow you the execution of the Callable and Runnable tasks without managing the threads that execute them.
This executor is oriented to execute tasks that can be divided into smaller parts.
When a task is waiting for its subtasks, the thread that was executing it is used to execute another thread.
The main class of the Fork/Join framework is the ForkJoinPool class.
In this recipe, you will learn how to implement a customized worker thread to be used in a ForkJoinPool class and how to use it using a factory.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Threads used by the Fork/Join framework are called worker threads.
Your objective is to implement a counter of tasks in each worker thread so you can know how many tasks a worker thread has executed.
This way, each thread will have its own counter in a transparent way for you, the programmer.
This method is called when the worker thread begins its execution.
You also have overridden the onTermination() method to print the value of the task counter to the console.
This method is called when the worker thread finishes its execution.
You have also implemented a method in the MyWorkerThread class.
The addTask() method increments the task counter of each thread.
The ForkJoinPool class, as all the executors in the Java concurrency API, creates its threads using a factory, so if you want to use the MyWorkerThread threads in a ForkJoinPool class, you have to implement your thread factory.
This class only has one method that creates a new MyWorkerThread object.
Finally, you only have to initialize a ForkJoinPool class with the factory you have created.
You have done this in the Main class, using the constructor of the ForkJoinPool class.
The following screenshot shows part of the output of the program:
You can see how the ForkJoinPool object has executed four worker threads and how many tasks have executed each of them.
If the parameter takes the null value, the worker thread finishes normally, but if the parameter takes a value, the thread throws an exception.
You have to include the necessary code to process that situation.
The Executor framework separates the task creation and its execution.
With it, you only have to implement the Runnable objects and use an Executor object.
You send the Runnable tasks to the executor and it creates, manages, and finalizes the necessary threads to execute those tasks.
Java 7 provides a special kind of executor in the Fork/Join framework.
This framework is designed to solve those problems that can be broken into smaller tasks using the divide and conquer technique.
Inside a task, you have to check the size of the problem you want to resolve and, if it's bigger than an established size, you divide the problem in two or more tasks and execute those tasks using the framework.
If the size of the problem is smaller than the established size, you resolve the problem directly in the task and then, optionally, it returns a result.
The Fork/Join framework implements the work-stealing algorithm that improves the overall performance of these kinds of problems.
The main class of the Fork/Join framework is the ForkJoinPool class.
By default, the tasks executed by a ForkJoinPool class are objects of the ForkJoinTask class.
You also can send to a ForkJoinPool class the Runnable and Callable objects, but they can't take advantage of all the benefits of the Fork/Join framework.
Normally, you will send to the ForkJoinPool objects one of two subclasses of the ForkJoinTask class:
In this recipe, you will learn how to implement your own tasks for the Fork/Join framework implementing a task that extends the ForkJoinTask class.
The task you're going to implement measures and writes in the console its execution time, so you can control its evolution.
You can also implement your own Fork/Join task to write log information, to get resources used in the tasks, or to post-process the results of the tasks.
How to do it… Follow these steps to implement the example:
Declare a private String attribute named name to store the name of the task.
How it works… In this recipe, you have implemented the MyWorkerTask class that extends the ForkJoinTask class.
It's your own base class to implement tasks that can be executed in a ForkJoinPool executor and that can take advantage of all the benefits of that executor, as the work-stealing algorithm.
This class is equivalent to the RecursiveAction and RecursiveTask classes.
When you extend the ForkJoinTask class, you have to implement the following three methods:
As your tasks don't return any results, you leave this method empty.
As your tasks don't return any results, this method returns the null value.
In your case, you have delegated the logic in the abstract method compute() (as the RecursiveAction and RecursiveTask classes) and in the exec() method you measure the execution time of that method, writing it in the console.
Finally, in the main class of the example, you have created an array of 10,000 elements, a ForkJoinPool executor, and a Task object to process the whole array.
Execute the program and you'll see how the different tasks that are executed write their execution time in the console.
Implementing a custom Lock class Locks are one of the basic synchronization mechanisms provided by the Java concurrency API.
It allows the programmers to protect a critical section of code, so only one thread can execute that block of code at a time.
If there is another thread running that critical section, other threads are blocked until they're woken up by the lock to get the access to the critical section.
In the Java Concurrency API, locks are declared in the Lock interface and implemented in some classes, for example, the ReentrantLock class.
In this recipe, you will learn how to implement your own Lock object implementing a class that implements the Lock interface that can be used to protect a critical section.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Java Concurrency API provides a class that can be used to implement synchronization mechanisms with features of locks or semaphores.
It provides operations to control access to a critical section and to manage a queue of threads that are blocked awaiting access to the critical section.
If the thread that calls it can access the critical section, the method returns the true value.
If the thread that calls it can release the access, the method returns the true value.
In these methods, you have to implement the mechanism you use to control the access to the critical section.
You have used the compareAndSet() method provided by the AtomicInteger class that tries to change the value you specify as the first parameter for the value you specify as the second parameter.
To implement the tryAcquire() method, you try to change the value of the atomic variable from zero to one.
Similarly, to implement the tryRelease() method, you try to change the value of the atomic variable from one to zero.
Finally, you have implemented the Task class, that implements the Runnable interface and uses a MyLock object to get the access to a critical section.
That critical section puts the thread to sleep for 2 seconds.
The main class creates a MyLock object and runs 10 Task objects that share that lock.
The main class also tries to get the access to the lock using the tryLock() method.
When you execute the example, you can see how only one thread has access to the critical section and when that thread finishes, another one gets the access to it.
You can use your own Lock to write log messages about its utilization, control the time that is locked, or implement advanced synchronization mechanisms, to control, for example, the access to a resource so that it's only available at certain times.
These methods receive and return an integer value with the state of the lock.
You could have used those methods instead of the AtomicInteger attribute to store the state of the lock.
Java concurrency API provides another class to implement synchronization mechanisms.
See also f The Synchronizing a block of code with locks recipe in Chapter 2,
Java 7 API provides several data structures to work with concurrent applications.
From these, we want to highlight the following two data structures:
In those applications, you have one or more producers of data and one or more consumers of data and a data structure is shared by all of them.
The producers put data in the data structure and the consumers take data from the data structure.
If the data structure is empty, the consumers are blocked until they have data to consume.
If the data structure is full, the producers are blocked until they have space to put their data.
The elements have to implement the Comparable interface with the compareTo() method.
When you insert an element in the structure, it's compared to the elements of the structure until it finds its position.
It may be the case when you want to develop a producer/ consumer program, where data is consumed according to some priority instead of arrival time.
In this recipe, you will learn how to implement a data structure to be used in the producer/ consumer problem, whose elements will be ordered by their priority.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private AtomicInteger attribute named counter to store the number of consumers that are waiting for elements to consume.
Declare a private String attribute named thread to store the name of the thread that creates the event.
Declare a private int attribute named priority to store the priority of the event.
This method compares the actual event with an event received as a parameter.
You will get the list ordered by priority in the descending order.
Events with higher priority will be stored first in the queue.
It's a data structure to be used in the producer/consumer problem, but its elements are ordered by priority, not by their arrival order.
You also have implemented the TransferQueue interface to add the methods related with the producer/consumer.
When a consumer calls the take() operation to take an element from the data structure, the counter is incremented.
When the consumer finishes the execution of the take() operation, the counter is decremented again.
Only one thread can be working with the data structure.
If there is a consumer waiting, the method stores the element in the priority queue to be consumed immediately by the consumer and then returns the true value.
If there isn't a consumer waiting, the method returns the false value.
It there is a consumer waiting, the method stores the element in the priority queue to be consumed immediately by the consumer.
Otherwise, the element is stored in the list for transferred elements and the thread is blocked until the element is consumed.
While the thread is put to sleep, you have to free the lock because if not, you block the queue.
While the thread is put to sleep, you have to free the lock because, if not, you block the queue.
If there are elements in the list of transferred elements, the element to be consumed is taken from that list.
Once you have implemented the data structure, you have implemented the Event class.
It is the class of the elements you have stored in the data structure.
The Event class has two attributes to store the ID of the producer and the priority of the event, and implements the Comparable interface, because it is a requirement of your data structure.
Then, you have implemented the Producer and the Consumer classes.
In the example, you have 10 producers and a consumer and they share the same buffer.
Each producer generates 100 events with incremental priority, so the events with higher priority are the last generated ones.
The following screenshot shows part of the output of an execution of the program:
You can see how the events with higher priority are consumed first, and that a consumer consumes the transferred event.
See also f The Using blocking thread-safe lists ordered by priority recipe in Chapter 6,
Implementing your own atomic object Atomic variables were introduced in Java Version 5 and provide atomic operations on single variables.
When a thread is doing an operation with an atomic variable, the implementation of the class includes a mechanism to check that the operation is done in one step.
Basically, the operation gets the value of the variable, changes the value in a local variable, and then tries to change the old value for the new one.
If the old value is still the same, it does the change.
In this recipe, you will learn how to extend an atomic object and how to implement two operations that follow the mechanisms of the atomic objects to guarantee that all the operations are done in one step.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
How to do it… Follow these steps to implement the example:
Declare a private int attribute named maxNumber to store the maximum number of cars admitted in the parking lot.
The ParkingCounter class extends the AtomicInteger class with two atomic operations, carIn() and carOut()
The example simulates a system that controls the number of cars inside a parking lot.
The parking lot can admit a number of cars, represented by the maxNumber attribute.
The carIn() operation compares the actual number of cars in the parking lot with the maximum value.
If they are equal, the car can't enter the parking lot and the method returns the false value.
Otherwise, it uses the following structure of the atomic operations:
Get the value of the atomic object in a local variable.
Use the compareAndSet() method to try to replace the old value by the new one.
If this method returns the true value, the old value you sent as a parameter was the value of the variable, so it makes the change of values.
The operation was made in an atomic way as the carIn() method returns the true value.
If the compareAndSet() method returns the false value, the old value you sent as a parameter is not the value of the variable (the other thread modified it), so the operation can't be done in an atomic way.
The operation begins again until it can be done in an atomic way.
You have also implemented two Runnable objects that use the carIn() and carOut() methods to simulate the activity of the parking.
When you execute the program, you can see that the parking lot never overcomes the maximum value of cars in the parking lot.
Before the application is ready for end users, you have to demonstrate its correctness.
You use a test process to prove that correctness is achieved and errors are fixed.
The testing phase is a common task in any software development and also quality assurance processes.
You can find a lot of literature about testing processes and the different approaches you can apply to your developments.
There are also a lot of libraries, such as JUnit, and applications, such as Apache JMetter that you can use to test your Java applications in an automated way.
The fact that concurrent applications have two or more threads that share data structures and interact with each other adds more difficulty to the testing phase.
The biggest problem you will face when you test concurrent applications is that the execution of threads is non-deterministic.
You can't guarantee the order of the execution of the threads, so it's difficult to reproduce errors.
Monitoring a Lock interface A Lock interface is one of the basic mechanisms provided by the Java concurrency API to get the synchronization of a block of code.
A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time.
This mechanism is implemented by the Lock interface and the ReentrantLock class.
In this recipe, you will learn what information you can obtain about a Lock object and how to obtain that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
In this recipe, you have implemented the MyLock class that extends the ReentrantLock class to return information that otherwise wouldn't have been available – it's protected data of the ReentrantLock class.
The lock stores the thread that is executing the critical section.
This thread is returned by the protected getOwner() method of the ReentrantLock class.
This method uses the getOwner() method to return the name of that thread.
The protected method getQueuedThreads() of the ReentrantLock class returns the list of threads that are waiting to execute the critical section.
This method returns the result returned by the getQueuedThreads() method.
We have also used other methods that are implemented in the ReentrantLock class:
There's more… There are other methods in the ReentrantLock class that can be used to obtain information about a Lock object:
See also f The Synchronizing a block of code with a lock recipe in Chapter 2, Basic.
Monitoring a Phaser class One of the most complex and powerful functionalities offered by the Java Concurrency API is the ability to execute concurrent phased tasks using the Phaser class.
This mechanism is useful when we have some concurrent tasks divided in steps.
The Phaser class provides us the mechanism to synchronize the threads at the end of each step, so no thread starts its second step until all the threads have finished the first one.
In this recipe, you will learn what information about the status of a Phaser class you can obtain and how to obtain that information.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
In this recipe, we have implemented a phased task in the Task class.
This phased task has three phases and uses a Phaser interface to synchronize with other Task objects.
The main class launches three tasks and while these tasks are executing their phases, it prints information about the status of the phaser object to the console.
We have used the following methods to get the status of the phaser object:
The following screenshot shows part of the output of the program:
See also f The Running concurrent phased tasks recipe in Chapter 3, Thread.
Monitoring an Executor framework The Executor framework provides a mechanism that separates the implementation of tasks from the thread creation and management to execute those tasks.
If you use an executor, you only have to implement the Runnable objects and send them to the executor.
It is the responsibility of an executor to manage threads.
When you send a task to an executor, it tries to use a pooled thread for the execution of this task, to avoid creating new threads.
This mechanism is offered by the Executor interface and its implementing classes as the ThreadPoolExecutor class.
In this recipe, you're going to learn what information you can obtain about the status of a ThreadPoolExecutor executor and how to obtain it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Write information about the size of the pool, the number of tasks, and the status of the executor.
In this recipe, you have implemented a task that blocks its execution thread for a random number of milliseconds.
Then, you have sent 10 tasks to an executor and while you're waiting for their finalization, you have written information about the status of the executor to the console.
You have used the following methods to get the status of the Executor object:
It's the minimum number of threads that will be in the internal thread pool when the executor is not executing any task.
Monitoring a Fork/Join pool The Executor framework provides a mechanism that allows the separation of the task implementation from the creation and management of the threads that execute those tasks.
Java 7 includes an extension of the Executor framework for a specific kind of problem that will improve the performance of other solutions (as using Thread objects directly or the Executor framework)
This framework is designed to solve those problems that can be broken into smaller tasks using the divide and conquer technique using the fork() and join() operations.
The main class that implements this behavior is the ForkJoinPool class.
In this recipe, you're going to learn what information you can obtain about a ForkJoinPool class and how to obtain it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Declare a private int array attribute named array to store the array of elements you want to increment.
Declare two private int attributes named start and end to store the start and end positions of the block of elements this task has to process.
Create an array of integer numbers named array with 10,000 elements.
In this recipe, you have implemented a task that increments elements of an array using a ForkJoinPool class and a Task class that extends the RecursiveAction class; one of the kind of tasks that you can execute in a ForkJoinPool class.
While the tasks are processing the array, you print information about the status of the ForkJoinPool class to the console.
You have used the following methods to get the status of the ForkJoinPool class:
Writing effective log messages A log system is a mechanism that allows you to write information to one or more destinations.
You can write log messages to the console, a file, or a database.
A Logger also has a level used to decide what messages it is going to write.
It only writes the messages that are as important as, or more important, than its level.
You should use the log system with the following two main purposes:
This will help to localize the error and resolve it.
Getting ready The example of this recipe has been implemented using the Eclipse IDE.
If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
Wait for the finalization of the five threads using the join() method.
After the finalization of each thread, write a log message indicating that the thread has finished.
In this recipe, you have used the Logger class provided for the Java logging API to write log messages in a concurrent application.
First of all, you have implemented the MyFormatter class to give a format to the log messages.
This class extends the Formatter class that declares the abstract method format()
This method receives a LogRecord object with all the information of the log message and returns a formatted log message.
In your class, you have used the following methods of the LogRecord class to obtain information about the log message:
The MyLogger class implements the static method getLogger() that creates a Logger object and assigns a Handler object to write log messages of the application to the recipe8.log file using the MyFormatter formatter.
You create the Logger object with the static method getLogger() of that class.
This method returns a different object per name that is passed as a parameter.
You only have created one Handler object, so all the Logger objects will write its log messages in the same file.
You also have configured the logger to write all the log messages, regardless of its level.
Finally, you have implemented a Task object and a main program that writes different log messages in the logfile.
When you work with a log system, you have to take into consideration two important points:
If you write too much information, you will generate too large logfiles that will be unmanageable and make it difficult to get the necessary information.
It will be more difficult to know what happened in an error situation or you will have too much information to know the main cause of the error.
There are other libraries that provide a log system more complete than the java.util.
Analyzing concurrent code with FindBugs The static code analysis tools are a set of tools that analyze the source code of an application looking for potential errors.
These tools, such as Checkstyle, PMD, or FindBugs have a set of predefined rules of good practices and parse the source code looking for violations of those rules.
The objective is to find errors or places causing poor performance early, before it will be executed in production.
Programming languages usually offer such tools and Java is not an exception.
One of these tools to analyze Java code is FindBugs.
It's an open source tool that includes a series of rules to analyze Java-concurrent code.
In this recipe, you will learn how to use this tool to analyze your Java-concurrent applications.
Getting ready Before stating this recipe, you should download FindBugs from the project's web page (http://findbugs.sourceforge.net/)
You can download a standalone application or an Eclipse plugin.
How to do it… Follow these steps to implement the example:
Create a new project with the New Project option of the File menu in the menu bar.
In the Classpath for analysis field add the jar file with the project and in the Source directories field add the directory with the source code of the example.
Click on the Analyze button to create the new project and analyze its code.
The FindBugs application shows the result of the analysis of the code.
Click one of the bugs and you'll see the source code of the bug in the right-hand side panel and the description of the bug in the panel of the bottom of the screen.
The following screenshot shows the result of the analysis by FindBugs:
The analysis has detected the following two potential bugs in the application:
This will probably cause a deadlock situation in the application.
If you make a double-click in one of the two bugs, you will see detailed information about it.
As you have included the source-code reference in the configuration of the project, you also will see the source code where the bug was detected.
Be aware that FindBugs can only detect some problematic situations (related or not with the concurrency code)
For example, if you delete the unlock() call in the run() method of the Task class and repeat the analysis, FindBugs won't alert you that you get the lock in the task but you never free it.
Use the tools for the static code analysis as a help to improve the quality of your code, but do not expect to detect all the bugs in your code.
See also f The Configuring NetBeans for debugging concurrency code recipe in Chapter 8,
Nowadays, almost every programmer, regardless of the programming language in use, create their applications with an IDE.
They provide lots of interesting functionalities integrated in the same application, such as:
One of the most helpful features of an IDE is a debugger.
You can execute your application step-by-step and analyze the values of all the objects and variables of your program.
If you work with the Java programming language, Eclipse is one of the most popular IDEs.
It has an integrated debugger that allows you to test your applications.
By default, when you debug a concurrent application and the debugger finds a breakpoint, it only stops the thread that has that breakpoint while the rest of the threads continue with their execution.
In this recipe, you will learn how to change that configuration to help you to test concurrent applications.
Open it and select a project with a concurrent application implemented in it, for example, one of the recipes implemented in the book.
How to do it… Follow these steps to implement the example:
Thread to Suspend VM (marked in red in the screenshot)
As we mentioned in the introduction of this recipe, by default, when you debug a concurrent Java application in Eclipse and the debug process finds a breakpoint, it only suspends the thread that hit the breakpoint first while the other threads continue with their execution.
You can see that only the worker-21 is suspended (marked in red in the screenshot) while the rest of the threads are running.
However, if you change Default suspend policy for new breakpoints to Suspend VM, all the threads suspend their execution while you're debugging a concurrent application and the debug process hits a breakpoint.
With the change, you can see that all the threads are suspended.
In today's world, software is necessary to develop applications that work properly, that meet the quality standards of the company, and that will be easily modified in the future, in a limited time and with a cost as low as possible.
To achieve this goal, it is essential to use an IDE that integrates under one common interface several tools (compilers and debuggers) that facilitate the development of applications.
If you work with the Java programming language, NetBeans is one of the most popular IDEs.
It has an integrated debugger that allows you to test your application.
In this recipe, you will learn how to change that configuration to help you to test concurrent applications.
How to do it… Follow these steps to implement the example:
While the two tasks haven't finished their execution, write a message in the console every 500 milliseconds.
Use the isAlive() method to check if a thread has finished its execution.
Add a breakpoint in the first call to the println() method of the run() method of the Task1 class.
You will see the Debugging window in the top left-hand side corner of the main NetBeans window.
The next screenshot presents the appearance of that window with the thread that executes the Task1 object slept because they have arrived at the breakpoint and the other threads running:
The following screenshot shows the new appearance of the Debugging window.
While debugging a concurrent application using NetBeans, when the debugger hits a breakpoint, it suspends the thread that hit the breakpoint and shows the Debugging window in the top left-hand side corner with the threads that are currently running.
You can use the window to pause or resume the threads that are currently running using the Pause or Resume options.
You can also see the values of the variables or attributes of the threads using the Variables tab.
When you select the Check for Deadlock option in the Debug menu, NetBeans performs an analysis of the application that you're debugging to determine if there's a deadlock situation.
The second thread gets the locks just in a reverse manner.
The breakpoint inserted provokes the deadlock, but if you use NetBeans deadlock detector, you'll not find anything, so this option should be used with caution.
Change the locks used in both tasks by the synchronized keyword and debug the program again.
The code of the Task1 will be presented as follows:
The code of the Task2 class will be analogous to this, but changes the order of the locks.
If you debug the example again, you will obtain a deadlock again, but in this case, it's detected by the deadlock detector, as you can see in the following screenshot:
Then, select the Miscellaneous option and the Java Debugger tab.
There are two options on that window that control the behavior described earlier:
You can suspend only the thread that has the breakpoint or all the threads of the application.
You can resume only the current thread or all the threads.
Both options have been marked in the screenshot presented earlier.
See also f The Configuring Eclipse for debugging concurrency code recipe in Chapter 8, Testing.
Its main objective is to solve the problem of concurrent applications being non-deterministic.
For this purpose, it includes an internal metronome to control the order of execution of the different threads that form the application.
Those testing threads are implemented as methods of a class.
Getting ready You must also download the MultithreadedTC library from http://code.google.com/p/ multithreadedtc/ and the JUnit library, Version 4.10 from http://www.junit.org/
How to do it… Follow these steps to implement the example:
You can implement a test to any concurrent application or class using this library and its metronome.
In the example, you have implemented the classical producer/ consumer problem with two consumers and a producer.
You want to test that the first String object introduced in the buffer is consumed by the first consumer that arrives at the buffer and the second String object introduced in the buffer is consumed by the second consumer that arrives at the buffer.
The MultithreadedTC library is based on the JUnit library, which is the most often used library to implement unit tests in Java.
It's executed when you start the test, so you can use it to initialize objects that are using the test.
You can use it to close or release resources used during the test or to check the results of the test.
They have to start with the thread keyword followed by a string.
To control the order of execution of threads, you use the waitForTick() method.
This method receives an integer type as a parameter and puts the thread that is executing the method to sleep until all threads that are running in the test are blocked.
When they are blocked, the MultithreadedTC library resumes the threads that are blocked by a call to the waitForTick() method.
The integer you pass as a parameter of the waitForTick() method is used to control the order of execution.
The metronome of the MultithreadedTC library has an internal counter.
When all the threads are blocked, the library increments that counter to the next number specified in the waitForTick() calls that are blocked.
Internally, when the MultithreadedTC library has to execute a test, first it executes the initialize() method.
To execute the test, you have used the runOnce() method of the TestFramework class.
See also f The Analyzing concurrent code with FindBugs recipe in Chapter 8,
About Packt Publishing Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective MySQL Management" in April 2004 and subsequently continued to specialize in publishing highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting and customizing today's systems, applications, and frameworks.
Our solution-based books give you the knowledge and power to customize the software and technologies you're using to get the job done.
Packt books are more specific and less general than the IT books you have seen in the past.
Our unique business model allows us to bring you more focused information, giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, cutting-edge books for communities of developers, administrators, and newbies alike.
This book is part of the Packt Enterprise brand, home to books published on enterprise software – software created by major vendors, including (but not limited to) IBM, Microsoft and Oracle, often for use in other corporations.
Its titles will offer information relevant to a range of users of this software, including administrators, developers, architects, and end users.
Writing for Packt We welcome all inquiries from people who are interested in authoring.
If your book idea is still at an early stage and you would like to discuss it first before writing a formal book proposal, contact us; one of our commissioning editors will get in touch with you.
We're not just looking for published authors; if you have strong technical skills but no writing experience, our experienced editors can help you develop a writing career, or simply get some additional reward for your expertise.
A practical, focused mini book for creating Web Services in Java 7
End-to-end application which makes use of the new clientjar option in JAX-WS wsimport tool.
Over 70 highly focused practical recipes to maximize your output with NetBeans.
Learn how to deploy, debug, and test your software using NetBeans IDE.
Another title in Packt's Cookbook series giving clear, real-world solutions to common practical problems.
Learn about the fundamental building blocks of a JVM, such as code generation and memory management, and utilize this knowledge to develop code you can count on.
Realize the full potential of Java applications by learning how to apply advanced tuning and analysis.
Work with the JRockit Mission Control 3.1/4.0 tools suite to debug or profile your Java applications.
Covers exciting features such as the try-withresources block, the monitoring of directory events, asynchronous IO and new GUI enhancements, and more.
A learn-by-example based approach that focuses on key concepts to provide the foundation to solve real world problems.
Chapter 2: Basic Thread Synchronization Introduction Synchronizing a method Arranging independent attributes in synchronized classes Using conditions in synchronized code Synchronizing a block of code with a Lock Synchronizing data access with read/write locks Modifying Lock fairness Using multiple conditions in a Lock.
Chapter 3: Thread Synchronization Utilities Introduction Controlling concurrent access to a resource Controlling concurrent access to multiple copies of a resource Waiting for multiple concurrent events Synchronizing tasks in a common point Running concurrent phased tasks Controlling phase change in concurrent phased tasks Changing data between concurrent tasks.
Chapter 4: Thread Executors Introduction Creating a thread executor Creating a fixed-size thread executor Executing tasks in an executor that returns a result Running multiple tasks and processing the first result Running multiple tasks and processing all the results Running a task in an executor after a delay Running a task in an executor periodically Canceling a task in an executor Controlling a task finishing in an executor Separating the launching of tasks and the processing of their results in an executor Controlling rejected tasks of an executor.
Chapter 5: Fork/Join Framework Introduction Creating a Fork/Join pool Joining the results of the tasks Running tasks asynchronously Throwing exceptions in the tasks Canceling a task.
Chapter 6: Concurrent Collections Introduction Using non-blocking thread-safe lists Using blocking thread-safe lists Using blocking thread-safe lists ordered by priority Using thread-safe lists with delayed elements Using thread-safe navigable maps Generating concurrent random numbers Using atomic variables Using atomic arrays.
Chapter 7: Customizing Concurrency Classes Introduction Customizing the ThreadPoolExecutor class Implementing a priority-based Executor class Implementing the ThreadFactory interface to generate custom threads Using our ThreadFactory in an Executor object Customizing tasks running in a scheduled thread pool Implementing the ThreadFactory interface to generate custom threads for the Fork/Join framework Customizing tasks running in the Fork/Join framework Implementing a custom Lock class Implementing a transfer Queue based on priorities Implementing your own atomic object.
