Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
The authors and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions.
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which may include electronic versions and/or custom covers and content particular to your business, training goals, marketing focus, and branding interests.
This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise.
To the Reader In late 1995, the Java programming language burst onto the.
The promise of Java technology was that it would become the universal glue that connects users with information wherever it comes from—web servers, databases, information providers, or any other imaginable source.
Indeed, Java is in a unique position to fulfill this promise.
It is an extremely solidly engineered language that has gained acceptance by all major vendors, except for Microsoft.
Its built-in security and safety features are reassuring both to programmers and to the users of Java programs.
Java even has built-in support for advanced programming tasks, such as network programming, database connectivity, and multithreading.
Since 1995, eight major revisions of the Java Development Kit have been released.
As with the previous editions of this book, we still target serious programmers who want to put Java to work on real projects.
Our goal is to enable you to fully understand the Java language and.
In this book you will find lots of sample code demonstrating almost.
We keep the sample programs purposefully simple to focus on the major points, but, for the most part, they aren’t fake and they don’t cut corners.
They should make good starting points for your own code.
We assume you are willing, even eager, to learn about all the advanced features that Java puts at your disposal.
But, of course, we’d prefer to learn about each of them only once.
We have put up a list of frequently asked questions, bugs fixes, and workarounds on a web page at http://horstmann.com/corejava.
Strategically placed at the end of the errata page (to encourage you to read through it first) is a form you can use to report bugs and suggest improvements.
Please don’t be disappointed if we don’t answer every query or don’t get back to you immediately.
We do read all e-mail and appreciate your input to make future editions of this book clearer and more informative.
A Tour of This Book Chapter 1 gives an overview of the capabilities of Java that set it.
We explain what the designers of the language set out to do and to what extent they succeeded.
Then, we give a short history of how Java came into being and how it has evolved.
In Chapter 2, we tell you how to download and install the JDK and the program examples for this book.
In this chapter, we cover the basics: variables, loops, and simple functions.
If you are a C or C++ programmer, this is smooth sailing because the syntax for these language features is essentially the same as in C.
If you come from a non-C background such as Visual Basic, you will want to read this chapter carefully.
Object-oriented programming (OOP) is now in the mainstream of programming practice, and Java is an object-oriented programming language.
In addition to the rules of the Java language, we also give advice on sound OOP design.
Finally, we cover the marvelous javadoc tool that formats your code comments as a set of hyperlinked web pages.
If you are familiar with C++, you can browse through this chapter quickly.
Inheritance lets you take an existing class and modify it according to your needs.
The inheritance mechanism in Java is quite similar to that in C++
Once again, C++ programmers can focus on the differences between the languages.
Chapter 6 shows you how to use Java’s notion of an interface.
Interfaces let you go beyond the simple inheritance model of Chapter Java’s completely object-oriented approach to programming.
We also cover a useful technical feature of Java called inner classes.
Inner classes help make your code cleaner and more concise.
Every Java programmer should know a bit about GUI programming, and this volume contains the basics.
We show how you can make windows, how to paint on them, how to draw with geometric shapes, how to format text in multiple fonts, and how to display images.
Chapter 8 is a detailed discussion of the event model of the AWT, the abstract window toolkit.
You’ll see how to write code that responds to events, such as mouse clicks or key presses.
Along the way you’ll see how to handle basic GUI elements like buttons and panels.
Chapter 9 discusses the Swing GUI toolkit in great detail.
Swing toolkit allows you to build cross-platform graphical user interfaces.
You’ll learn all about the various kinds of buttons, text components, borders, sliders, list boxes, menus, and dialog boxes.
However, some of the more advanced components are discussed in Volume II.
Chapter 10 shows you how to deploy your programs, either as applications or applets.
We describe how to package programs in JAR files, and how to deliver applications over the Internet with the Java Web Start and applet mechanisms.
Finally, we explain how Java programs can store and retrieve configuration information once they have been deployed.
Exceptions give you an efficient way of separating the normal processing code from the error handling.
Of course, even after hardening your program by handling all exceptional conditions, it still might fail to work as expected.
In the second half of this chapter, we give you a large number of useful debugging tips.
Generic programming makes your programs easier to read and safer.
We show you how to use strong typing and remove unsightly and unsafe casts, and how to deal with the complexities that arise from the need to stay compatible with older versions of Java.
The topic of Chapter 13 is the collections framework of the Java platform.
Whenever you want to collect multiple objects and retrieve them later, you should use a collection that is best suited for your circumstances, instead of just tossing the elements into an array.
This chapter shows you how to take advantage of the standard collections that are prebuilt for your use.
Chapter 14 finishes the book with a discussion of multithreading, which enables you to program tasks to be done in parallel.
A thread is a flow of control within a program.) We show you how to set up threads and how to deal with thread synchronization.
The Appendix lists the reserved words of the Java language.
Conventions As is common in many computer books, we use monospace type to.
Note Notes are tagged with “note” icons that look like this.
Tip Tips are tagged with “tip” icons that look like this.
Caution When there is danger ahead, we warn you with a “caution” icon.
You can skip over them if you don’t have a background in C++ or if you consider your experience with that language a bad dream of which you’d rather not be reminded.
Java comes with a large programming library, or Application Programming Interface (API)
When using an API call for the first time, we add a short summary description at the end of the section.
These descriptions are a bit more informal but, we hope, also a little more informative than those in the official online API documentation.
The names of interfaces are in italics, just like in the official documentation.
The number after a class, interface, or method name is the JDK version in which the feature was introduced.
Programs whose source code is on the book’s companion web site are listed as listings, for instance.
Sample Code The web site for this book at http://horstmann.com/corejava.
You can expand the file either with one of the familiar unzipping programs or simply with the jar utility that is part of the Java Development Kit.
See Chapter 2 for more information about installing the Java Development Kit and the sample code.
Writing a book is always a monumental effort, and rewriting it doesn’t seem to be much easier, especially with the continuous change in Java technology.
Making a book a reality takes many dedicated people, and it is my great pleasure to acknowledge the contributions of the entire Core Java team.
A large number of individuals at Prentice Hall provided valuable assistance but managed to stay behind the scenes.
I’d like them all to know how much I appreciate their efforts.
As always, my warm thanks go to my editor, Greg Doench, for steering the book through the writing and production process, and for allowing me to be blissfully unaware of the existence of all those folks behind the scenes.
I am very grateful to Julie Nahil for production support, and to Dmitry Kirsanov and Alina Kirsanova for copyediting and typesetting the manuscript.
My thanks also to my coauthor of earlier editions, Gary Cornell, who has since moved on to other ventures.
Thanks to the many readers of earlier editions who reported embarrassing errors and made lots of thoughtful suggestions for improvement.
I am particularly grateful to the excellent reviewing team that went over the manuscript with an amazing eye for detail and saved me from many more embarrassing errors.
The first release of Java in 1996 generated an incredible amount of excitement, not just in the computer press, but in mainstream media such as The New York Times, The Washington Post, and Business Week.
Java has the distinction of being the first and only programming language that had a tenminute story on National Public Radio.
A $100,000,000 venture capital fund was set up solely for products using a specific computer language.
It is rather amusing to revisit those heady times, and we give you a brief history of Java in this chapter.
In the first edition of this book, we had this to write about Java: “As a computer language, Java’s hype is overdone: Java is certainly a good.
There is no doubt that it is one of the better languages available to serious programmers.
We think it could potentially have been a great programming language, but it is probably too late for that.
Once a language is out in the field, the ugly reality of compatibility with existing code sets in.”
Our editor got a lot of flack for this paragraph from someone very high up at Sun Microsystems who shall remain unnamed.
Java has a lot of nice language features—we examine them in detail later in this chapter.
It has its share of warts, and the newer additions to the language are not as elegant as the original features because of the ugly reality of compatibility.
But, as we already said in the first edition, Java was never just a language.
There are lots of programming languages out there, and few of them make much of a splash.
Java is a whole platform, with a huge library, containing lots of reusable code, and an execution environment that provides services.
As a programmer, you will want a language with a pleasant syntax and comprehensible semantics (i.e., not C++)
Java fits the bill, as do dozens of other fine languages.
Some languages give you portability, garbage collection, and the like, but they don’t have much of a library, forcing you to roll your own if you want fancy graphics or networking or database access.
Well, Java has everything—a good language, a high-quality execution environment, and a vast library.
That combination is what makes Java an irresistible proposition to so many programmers.
The authors of Java have written an influential White Paper that explains.
They also published a shorter summary that is organized along the following 11 buzzwords:
We wanted to build a system that could be programmed easily without a lot of esoteric training and which leveraged today’s standard practice.
Java omits many rarely used, poorly understood, confusing features of C++ that, in our experience, bring more grief than benefit.
The syntax for Java is, indeed, a cleaned-up version of the syntax for C++
There is no need for header files, pointer arithmetic (or even a pointer syntax), structures, unions, operator overloading, virtual base classes, and so on.
For example, the syntax of the switch statement is unchanged in Java.
If you know C++, you will find the transition to the Java syntax easy.
If you are used to a visual programming environment (such as Visual Basic), you will not find Java simple.
There is much strange syntax (though it does not take long to get the hang of it)
More importantly, you must do a lot more programming in Java.
The beauty of Visual Basic is that its visual design environment almost automatically provides a lot of the infrastructure for an application.
The equivalent functionality must be programmed manually, usually with a fair bit of code, in Java.
One of the goals of Java is to enable the construction of software that can run stand-alone in small machines.
Of course, the library has since grown to huge proportions.
There is now a separate Java Micro Edition with a smaller library, suitable for embedded devices.
Simply stated, object-oriented design is a technique for programming that focuses on the data (= objects) and on the interfaces to that object.
The object-oriented facilities of Java are essentially those of C++
Object orientation has proven its worth in the last forty years, and it is inconceivable that a modern programming language would not use it.
Indeed, the object-oriented features of Java are comparable to those of C++
These chapters explain what object-oriented programming is and why it is more useful for programming sophisticated projects than are traditional, procedure-oriented languages like C or Basic.
Java has an extensive library of routines for coping with TCP/IP protocols like HTTP and FTP.
Java applications can open and access objects across the Net via URLs with the same ease as when accessing a local file system.
We have found the networking capabilities of Java to be both strong and easy to use.
Anyone who has tried to do Internet programming using another language will revel in how simple Java makes many onerous tasks, such as opening a socket connection.
We cover networking in Volume II of this book.) The remote method invocation mechanism enables communication between distributed objects (also covered in Volume II)
Java is intended for writing programs that must be reliable in a variety of ways.
Java puts a lot of emphasis on early checking for possible problems, later dynamic (runtime) checking, and eliminating situations that are error-prone.
The single biggest difference between Java and C/C++ is that Java has a pointer model that eliminates the possibility of overwriting memory and corrupting data.
The Java compiler detects many problems that, in other languages, would show up only at runtime.
As for the second point, anyone who has spent hours chasing memory corruption caused by a pointer bug will be very happy with this feature of Java.
If you are coming from a language like Visual Basic that doesn’t explicitly use pointers, you are probably wondering why this is so important.
They need pointers to access strings, arrays, objects, and even files.
In Visual Basic, you do not use pointers for any of these entities, nor do you need to worry about memory allocation for them.
On the other hand, many data structures are difficult to implement in a pointerless language.
You do not need pointers for everyday constructs like strings and arrays.
You have the power of pointers if you need it—for example, for linked lists.
And you always have complete safety because you can never access a bad pointer or make memory allocation errors, and you don’t have to protect against memory leaking away.
Toward that end, a lot of emphasis has been placed on security.
Not long after the first version of the Java Development Kit was shipped, a group of security experts at Princeton University found subtle bugs in the security features of Java 1.0
Sun Microsystems has encouraged research into Java security, making publicly available the specification and implementation of the virtual machine and the security libraries.
In any case, Java makes it extremely difficult to outwit its security mechanisms.
The bugs found so far have been very technical and few in number.
From the beginning, Java was designed to make certain kinds of attacks impossible, among them:
A number of security features have been added to Java over time.
Since version 1.1, Java has the notion of digitally signed classes (see Volume II)
With a signed class, you can be sure of who wrote it.
If you trust the author of the class, the class can be allowed more privileges on your machine.
Note A competing code delivery mechanism from Microsoft based on its ActiveX technology relies on digital signatures alone for security.
Clearly this is not sufficient—as any user of Microsoft’s own products can confirm, programs from well-known vendors do crash and create damage.
Java has a far stronger security model than that of ActiveX because it controls the application as it runs, and stops it from wreaking havoc.
The Java compiler does this by generating bytecode instructions which have nothing to do with a particular computer architecture.
Rather, they are designed to be both easy to interpret on any machine and easily translated into native machine code on the fly.
More than forty years ago, both Niklaus Wirth’s original implementation of Pascal and the UCSD Pascal system used the same technique.
Of course, interpreting bytecodes is necessarily slower than running machine instructions at full speed, so it isn’t clear that this is even a good idea.
However, virtual machines have the option of translating the most frequently executed bytecode sequences into machine code—a process called just-in-time compilation.
This strategy has proven so effective that even Microsoft’s .NET platform relies on a virtual machine.
It increases security because it can check the behavior of instruction sequences.
Some programs even produce bytecodes on the fly, dynamically enhancing the capabilities of a running program.
The sizes of the primitive data types are specified, as is the behavior of arithmetic on them.
For example, an int in Java is always a 32-bit integer.
The only restriction is that the int type must have at least as many bytes as a short int and cannot have more bytes than a long int.
Having a fixed size for number types eliminates a major porting headache.
Binary data is stored and transmitted in a fixed format, eliminating confusion about byte ordering.
The libraries that are a part of the system define portable interfaces.
For example, there is an abstract Window class and implementations of it for UNIX, Windows, and the Macintosh.
As anyone who has ever tried knows, it is an effort of heroic proportions to write a program that looks good on Windows, the Macintosh, and ten flavors of UNIX.
Java 1.0 made the heroic effort, delivering a simple toolkit that provided common user interface elements on a number of platforms.
Unfortunately, the result was a library that, with a lot of work, could give barely acceptable results on different systems.
There are many applications in which portability is more important than user interface slickness, and these applications did benefit from early versions of Java.
By now, the user interface toolkit has been completely rewritten so that it no longer relies on the host user interface.
The result is far more consistent and, we think, more attractive than in the earlier versions of Java.
The Java interpreter can execute Java bytecodes directly on any machine to which the interpreter has been ported.
Since linking is a more incremental and lightweight process, the development process can be much more rapid and exploratory.
Incremental linking has advantages, but its benefit for the development process is clearly overstated.
Today, the bytecodes are translated into machine code by the just-intime compiler.
While the performance of interpreted bytecodes is usually more than adequate, there are situations where higher performance is required.
The bytecodes can be translated on the fly (at runtime) into machine code for the particular CPU the application is running on.
A more sophisticated optimization is the elimination (or “inlining”) of function calls.
It can use inlining when, based upon the currently loaded collection of classes, a particular function is never overridden, and it can undo that optimization later if necessary.
Multithreaded [The] benefits of multithreading are better interactive responsiveness and real-time behavior.
If you have ever tried to do multithreading in another language, you will be pleasantly surprised by how easy it is in Java.
Threads in Java can take advantage of multiprocessor systems if the base operating system does so.
Only the code for calling multithreading remains the same across machines; Java offloads the implementation of multithreading to the underlying operating system or a thread library.
Nonetheless, the ease of multithreading is one of the main reasons why Java is such an appealing language for server-side development.
In a number of ways, Java is a more dynamic language than C or C++
Libraries can freely add new methods and instance variables without any effect on their clients.
This is an important feature in the situations where code needs to be added to a running program.
A prime example is code that is downloaded from the Internet to run in a browser.
In Java 1.0, finding out runtime type information was anything but straightforward, but current versions of Java give the programmer full insight into both the structure and behavior of its objects.
This is extremely useful for systems that need to analyze objects at runtime, such as Java GUI builders, smart debuggers, pluggable components, and object databases.
Note Shortly after the initial success of Java, Microsoft released a product called J++ with a programming language and virtual machine that was almost identical to Java.
The idea here is simple: Users will download Java bytecodes from the.
Java programs that work on web pages are called applets.
To use an applet, you only need a Java-enabled web browser, which will execute the bytecodes for you.
Because Oracle licenses the Java source code and insists that there be no changes in the language and standard library, a Java applet should run on any browser that is advertised as Java-enabled.
You get the latest version of the program whenever you visit the web page containing the applet.
Most importantly, thanks to the security of the virtual machine, you need never worry about attacks from hostile code.
Inserting an applet into a web page works much like embedding an image.
The applet becomes a part of the page, and the text flows around the space used for the applet.
It reacts to user commands, changes its appearance, and exchanges data between the computer presenting the applet and the computer serving it.
Figure 1.1 shows a good example of a dynamic web page that carries out sophisticated calculations.
By using the mouse, you can rotate and zoom each molecule to better understand its structure.
This kind of direct manipulation is not achievable with static web pages, but applets make it possible.
When applets first appeared, they created a huge amount of excitement.
Many people believe that the lure of applets was responsible for the astonishing popularity of Java.
Various versions of Netscape and Internet Explorer ran different versions of Java, some of which were seriously outdated.
This sorry situation made it increasingly difficult to develop applets that took advantage of the most current Java version.
Today, most web pages simply use JavaScript or Flash when dynamic effects are desired in the browser.
Java, on the other hand, has become the most popular language for developing the server-side applications that produce web pages and carry out the backend logic.
Java goes back to 1991, when a group of Sun engineers, led by Patrick.
Naughton and James Gosling (a Sun Fellow and all-around computer wizard), wanted to design a small computer language that could be used for consumer devices like cable TV switchboxes.
Since these devices do not have a lot of power or memory, the language had to be small and generate very tight code.
Also, as different manufacturers may choose different central processing units (CPUs), it was important that the language not be tied to any single architecture.
The requirements for small, tight, and platform-neutral code led the team to resurrect the model that some Pascal implementations tried in the early days of PCs.
Niklaus Wirth, the inventor of Pascal, had pioneered the design of a portable language that generated intermediate code for a hypothetical machine.
Such machines are often called virtual—hence the Java Virtual Machine, or JVM.) This intermediate code could then be used on any machine that had the correct interpreter.
The Green project engineers used a virtual machine as well, which solved their main problem.
The Sun people, however, came from a UNIX background, so they based their language on C++ rather than Pascal.
In particular, they made the language object-oriented rather than procedure-oriented.
The people at Sun later realized that Oak was the name of an existing computer language, so they changed the name to Java.
However, none of the standard consumer electronics companies were interested either.
The group then bid on a project to design a cable TV box that could deal with new cable services such as video-on-demand.
Amusingly, the company that did was led by the same Jim Clark who started Netscape—a company that did much to make Java successful.)
Patrick Naughton, one of the founders of the group and the person who ended up doing most of the marketing, claims to have accumulated.
While all of this was going on at Sun, the World Wide Web part of the.
The key to the World Wide Web was the browser translating the hypertext page to the screen.
Mosaic was partially written by Marc Andreessen as an undergraduate student on a workstudy project, for $6.85 an hour.
He moved on to fame and fortune as one of the cofounders and the chief of technology at Netscape.)
The actual browser was built by Patrick Naughton and Jonathan Payne and evolved into the HotJava browser.
The HotJava browser was written in Java to show off the power of Java.
But the builders also had in mind the power of what we now call applets, so they made the browser capable of executing code inside web pages.
Sun released the first version of Java in early 1996
People quickly realized that Java 1.0 was not going to cut it for serious application development.
Sure, you could use Java 1.0 to make a nervous text applet that moved text randomly around in a canvas.
To be blunt, Java 1.0 was not ready for prime time.
Its successor, version 1.1, filled in the most obvious gaps, greatly improved the reflection capability, and added a new event model for GUI programming.
Besides the Standard Edition, two other editions were introduced: the Micro Edition for embedded devices such as cell phones, and the Enterprise Edition for server-side processing.
Again, there are no language changes but additional performance improvements and library enhancements.
As datacenters increasingly relied on commodity hardware instead of specialized servers, Sun Microsystems fell on hard times and was purchased by Oracle in 2009
Table 1.1 shows the evolution of the Java language and library.
As you can see, the size of the application programming interface (API) has grown tremendously.
We close this chapter with a list of some common misconceptions about.
Java is a programming language; HTML is a way to describe the structure.
They have nothing in common except that there are HTML extensions for placing Java applets on a web page.
Java is a programming language; XML is a way to describe data.
In addition, many important third-party XML tools are implemented in Java.
Also, consider that only four chapters in this book discuss the Java language.
The remaining chapters of both volumes show how to put the language to work, using the Java libraries.
The Java libraries contain thousands of classes and interfaces, and tens of thousands of functions.
Luckily, you do not need to know every one of them, but you do need to.
Java will become a universal programming language for all platforms.
This is possible, in theory, and it is certainly something every vendor but.
However, many applications, already working perfectly well on desktops, would not work well on other devices or inside a browser.
Also, these applications have been written to take advantage of the speed of the processor and the native user interface library and have been ported to all the important platforms anyway.
Among these kinds of applications are word processors, photo editors, and web browsers.
They are typically written in C or C++, and we see no benefit to the end user in rewriting them in Java.
Java is a nice programming language; most programmers prefer it over C,
But there have been hundreds of nice programming languages that never gained widespread popularity, whereas languages with obvious flaws, such as C++ and Visual Basic, have been wildly successful.
Why? The success of a programming language is determined far more by the utility of the support system surrounding it than by the elegance of its syntax.
The fact that Java reduces pointer errors is a bonus, so programmers seem to be more productive with Java—but these factors are not the source of its success.
C# took many good ideas from Java, such as a clean programming.
But for whatever reasons, C# also left some good stuff behind, in particular, security and platform independence.
If you are tied to Windows, C# makes a lot of sense.
But judging by the job ads, Java is still the language of choice for a majority of developers.
When Java was first created, Sun gave free licenses to distributors and end.
Although Sun had ultimate control over Java, they involved many other companies in the development of language revisions and the design of new libraries.
Source code for the virtual machine and the libraries has always been freely available, but only for inspection, not for modification and redistribution.
Everyone is given a patent grant to use and modify Java, subject to the GPL, but only on desktop and server platforms.
If you want to use Java in embedded systems, you need a different license and will likely need to pay royalties.
However, these patents will expire within the next decade, and at that point Java will be entirely free.
Java is interpreted, so it is too slow for serious applications.
In the early days of Java, the language was interpreted.
People have complained for years that Java applications are slow.
However, today’s computers are much faster than they were when these complaints started.
A slow Java program will still run quite a bit better today than those blazingly fast C++ programs did a few years ago.
At this point, these complaints sound like sour grapes, and some detractors have instead started to complain that Java user interfaces are ugly rather than slow.
But most Java programs are standalone applications that run outside of a web browser.
In fact, many Java programs run on web servers and produce the code for web pages.
In the early days of Java, there were some well-publicized reports of.
Most failures were in the implementation of Java in a specific browser.
Researchers viewed it as a challenge to find chinks in the Java armor and to defy the strength and sophistication of the applet security model.
The technical failures that they found have all been quickly corrected, and to our knowledge, no actual systems were ever compromised.
To keep this in perspective, consider the literally millions of virus attacks in Windows executable files and Word macros that cause real grief but surprisingly little criticism of the weaknesses of the attacked.
Also, the ActiveX mechanism in Internet Explorer would be a fertile ground for abuse, but it is so boringly obvious how to circumvent it that few researchers have bothered to publicize their findings.
Some system administrators have even deactivated Java in company browsers, while continuing to permit their users to download executable files and Word documents, which pose a far greater risk.
Even 15 years after its creation, Java is far safer than any other commonly available execution platform.
JavaScript, a scripting language that can be used inside web pages, was.
JavaScript has a syntax that is reminiscent of Java, but otherwise there are no relationships (except for the name, of course)
JavaScript is more tightly integrated with browsers than Java applets are.
In particular, a JavaScript program can modify the document that is being displayed, whereas an applet can only control the appearance of a limited area.
Companies produced prototypes of Java-powered network computers, but users were not ready to give up a powerful and convenient desktop for a limited machine with no local storage.
The current generation of tablet computers does not use Java.
In this chapter, you will learn how to install the Java Development Kit (JDK) and how to compile and run various types of programs: console programs, graphical applications, and applets.
You can run the JDK tools by typing commands in a shell window.
However, many programmers prefer the comfort of an integrated development environment.
We show you how to use a freely available development environment to compile and run Java programs.
Although easier to learn, integrated development environments can be resource-hungry and tedious to use for small programs.
Once you have mastered the techniques in this chapter and picked your development tools, you are ready to move on to Chapter 3, where you will begin exploring the Java programming language.
The most complete and up-to-date versions of the Java Development Kit (JDK) are available from Oracle for Linux, Mac OS.
Versions in various states of development exist for many other platforms, but those versions are licensed and distributed by the vendors of those platforms.
You will still find occasional references to the old term.
There is also a Java Runtime Environment (JRE) that contains the virtual machine but not the compiler.
It is intended for end users who have no need for the compiler.
However, because they had that insight only after the release, they decided to keep the version number 1.2 for the development kit.
The platform, however, was renamed from Java to Java 2
For engineers, all of this was a bit confusing, but that’s why we never made it into marketing.
Finally, when Oracle makes a minor version change to fix urgent issues, it refers to the change as an update.
An update does not need to be installed over a prior version—it contains the most current version of the whole JDK.
Sometimes, Oracle makes available bundles that contain both the Java Development Kit and an integrated development environment.
We do not know what the eager beavers in marketing will call it when you approach the download site.
We suggest that you stay away from all bundles and install only the Java Development Kit at this time.
If you later decide to use Oracle’s integrated development environment, simply download it from http://netbeans.org.
Note The setup procedure offers a default for the installation directory that contains the JDK version number, such as jdk1.7.0
This sounds like a bother, but we have come to appreciate the version number—it makes it easier to install a newer JDK release for testing.
Just take out the Program Files part of the path name.
In this book, we refer to the installation directory as jdk.
After you are done installing the JDK, you need to carry out one additional step: Add the jdk/bin directory to the executable.
In UNIX (including Linux, Mac OS X, and Solaris), the procedure for editing the executable path depends on the shell you are using.
In Windows XP, you immediately get the system properties dialog.
In the system properties dialog, click the Advanced tab, then click on the Environment button.
Scroll through the System Variables window until you find a variable named Path.
Add the jdk\bin directory to the beginning of the path, using a semicolon to separate the new entry, like this:
Setting the Path environment variable in Windows Vista Be careful to replace jdk with the actual path to your Java installation, such as c:\jdk1.7.0_02
Any new console windows that you start will have the correct path.
Here is how you test whether you did it right: Start a shell window.
You should get a display such as this one: javac 1.7.0_02
Note In Windows, follow these instructions to open a shell window.
If you use Windows XP, select the Run option from the Start menu and type cmd.
In Vista and Windows 7, simply type cmd into the Start Search field in the Start menu.
The library source files are delivered in the JDK as a compressed file src.zip, and you must unpack that file to get access.
Make sure the JDK is installed and that the jdk/bin directory is on the executable path.
Tip The src.zip file contains the source code for all public libraries.
To obtain even more source (for the compiler, the virtual machine, the native methods, and the private helper classes), go to http://jdk7.java.net.
The documentation is contained in a compressed file that is separate from the JDK.
Make sure the JDK is installed and that the jdk/bin directory is on the executable path.
Download the documentation zip file and move it into the jdk directory.
You should unzip them into a separate directory—we recommend you call it CoreJavaBook.
Make sure the JDK is installed and the jdk/bin directory is on the execution path.
In your explorations of Java, you will occasionally want to peek inside the Java source files.
The two most useful subdirectories for learning Java are docs and src.
The docs directory contains the Java library documentation in HTML format.
You can view it with any web browser, such as Firefox.
You will be referring to this page a lot as you explore the Java platform.
The src directory contains the source code for the public part of the Java libraries.
As you become more comfortable with Java, you may find yourself in situations for which this book and the online information do not provide what you need to know.
At this point, the source code for Java is a good place to begin digging.
It is reassuring to know that you can always dig into the source to find out what a library function really does.
If your programming experience comes from using Microsoft Visual Studio, you are accustomed to a development.
You do everything by typing in commands in a shell window.
This sounds cumbersome, but it is nevertheless an essential skill.
When you first install Java, you will want to troubleshoot your installation before you install a development environment.
Moreover, by executing the basic steps yourself, you gain a better understanding of what a development environment does behind your back.
However, after you have mastered the basic steps of compiling and running Java programs, you will want to use a professional development environment.
In the last decade, these environments have become so powerful and convenient that it simply doesn’t make much sense to labor on without them.
Two excellent choices are the freely available Eclipse and NetBeans programs.
In this chapter, we show you how to get started with Eclipse since it is still a bit slicker than NetBeans, although NetBeans is catching up fast.
Of course, if you prefer a different development environment, you can certainly use it with this book.
In the past, we recommended the use of a text editor such as Emacs, JEdit, or TextPad for simple programs.
We no longer make this recommendation because the integrated development environments are now so fast and convenient.
In sum, we think that you should know how to use the basic JDK tools, and then you should become comfortable with an integrated development environment.
Let’s get started the hard way: compiling and launching a Java program from the command line.
You should see the output shown in Figure 2.4 in the shell window.
Congratulations! You have just compiled and run your first Java program.
It executes the bytecodes that the compiler placed in the class file.
Note If you got an error message complaining about the line.
In that case, you need to rewrite the loop as follows:
You may enjoy looking inside the program, shown in Listing 2.1 (we explain how it works in the next chapter)
In the age of visual development environments, many programmers are unfamiliar with running programs in a shell window.
Any number of things can go wrong, leading to frustrating results.
If you type in the program by hand, make sure you correctly enter the upper-case and lowercase letters.
In particular, the class name is Welcome and not welcome or WELCOME.
When you run the program, you specify a class name (Welcome) without a .java or .class extension.
Under UNIX, check that you used the correct capitalization for Welcome.java.
Under Windows, use the dir shell command, not the graphical Explorer tool.
Some text editors (in particular Notepad) insist on adding an extension .txt to every file’s name.
If you get a complaint about welcome (with a lowercase w), then you should reissue the java Welcome command with an uppercase W.
If you get a complaint about Welcome/java, it means you accidentally typed java Welcome.java.
If you typed java Welcome and the virtual machine can’t find the Welcome class, check if someone has set the CLASSPATH environment variable on your system.
It is usually not a good idea to set this variable globally, but some poorly written software installers in Windows do just that.) You can temporarily unset the CLASSPATH environment variable in the current shell window by typing.
Tip The excellent tutorial at http://docs.oracle.com/javase/tutorial/getStarted/cupojava goes into much greater detail about the “gotchas” that beginners can run into.
In this section, we show you how to compile a program with Eclipse, an integrated development environment that is freely.
Eclipse is written in Java, but since it uses a nonstandard windowing library, it is not quite as portable as Java itself.
There are other popular IDEs, but currently, Eclipse is the most commonly used.
Don’t worry if your version of Eclipse looks slightly different.
You should now see a window with the program code (see Figure 2.7)
An output window appears at the bottom of the window.
The program output is displayed in the output window (see Figure 2.8)
It was only a few lines of code, after all.) Let us suppose, for the.
Try it out—ruin your file, for example, by changing the capitalization of String as follows:
You will get an error message that complains about an unknown string type (see.
The cursor moves to the matching line in the edit window, where you can correct your error.
Tip Often, an Eclipse error report is accompanied by a lightbulb icon.
Click on the lightbulb to get a list of suggested fixes.
These instructions should give you a taste of working in an integrated environment.
Again, let us first compile and run it from the command line.
A new program window pops up with our ImageViewer application (see Figure 2.10)
Now, select File -> Open and look for an image file to open.
We supplied a couple of sample files in the same directory.) To close the program, click on the Close box in the title bar or select File -> Exit from the menu.
The program is substantially longer than the first program, but it is not too complex if you consider how much code it would take in C or C++ to write a similar application.
In Visual Basic, of course, it is easy to write or, rather, drag and drop, such a program.
The JDK does not have a visual interface builder, so you need to write code for everything, as shown in Listing 2.2
We want to show you how to build and run an applet from the command line.
Then we will load our applet into the applet viewer that comes with the JDK.
Figure 2.11 shows what you see in the applet viewer window.
The first command is the now-familiar command to invoke the Java compiler.
This time, however, you do not run the java program.
This program is a special tool included with the JDK that lets you quickly test an applet.
You need to give this program an HTML file name, rather than the name of a Java class file.
The applet viewer ignores all HTML tags except for the applet tag.
Of course, applets are meant to be viewed in a browser.
Unfortunately, many browsers do not have Java support enabled by default.
The page http://java.com/en/download/help/enable_browser.xml shows how to set up the most common browsers for Java.
Once you have configured your browser, you can try loading the applet inside the browser.
Your browser now loads the applet, including the surrounding text.
You can see that this application is actually alive and willing to interact with the Internet.
The applet directs the browser to display Cay’s web page.
The applet directs the browser to pop up a mail window, with Gary’s e-mail address already filled in.
Notice that neither of these two buttons works in the applet viewer.
The applet viewer has no capabilities to send mail or display a web page, so it ignores your requests.
The applet viewer is good for testing applets in isolation, but you need to put applets inside a browser to see how they interact with the browser and the Internet.
Tip You can also run applets from inside your integrated development environment.
Finally, the code for the applet is shown in Listing 2.4
At this point, do not give it more than a glance.
We will come back to writing applets in Chapter 10
In this chapter, you learned about the mechanics of compiling and running Java programs.
You are now ready to move on to Chapter 3, where you will start learning the Java language.
At this point, we are assuming that you successfully installed the JDK and were able to run the sample programs that we showed you in Chapter 2
This chapter shows you how the basic programming concepts such as data types, branches, and loops are implemented in Java.
Unfortunately, in Java you can’t easily write a program that uses a GUI—you need to learn a fair amount of machinery to put up windows, add text boxes and buttons that respond to them, and so on.
Introducing the techniques needed to write GUI-based Java programs would take us too far away from our goal of covering the basic programming concepts, so the sample programs in this chapter are “toy” programs designed to illustrate a concept.
All these examples simply use a terminal window for input and output.
Programmers coming from another background, such as Visual Basic, will find most of the concepts familiar, but the syntax is very different—you should read this chapter very carefully.
Let’s look more closely at one of the simplest Java programs you can have—one that simply.
It is worth spending all the time you need to become comfortable with the framework of this sample; the pieces will recur in all applications.
If you made any mistakes in capitalization (such as typing Main instead of main), the program will not run.
Now let’s look at this source code line by line.
The keyword public is called an access modifier; these modifiers control the level of access other parts of a program have to this.
We have more to say about access modifiers in Chapter 5
The keyword class reminds you that everything in a Java program lives inside a class.
Although we will spend a lot more time on classes in the next chapter, for now think of a class as a container for the program logic that defines the behavior of an application.
As mentioned in Chapter 1, classes are the building blocks with which all Java applications and applets are built.
Everything in a Java program must be inside a class.
Following the keyword class is the name of the class.
The rules for class names in Java are quite generous.
Names must begin with a letter, and after that, they can have any combination of letters and digits.
You cannot use a Java reserved word (such as public or class) for a class name.
The standard naming convention (which we follow in the name FirstSample) is that class names are nouns that start with an uppercase letter.
If a name consists of multiple words, use an initial uppercase letter in each of the words.
You need to make the file name for the source code the same as the name of the public class, with the extension .java appended.
Thus, you must store this code in a file called FirstSample.java.
If you have named the file correctly and not made any typos in the source code, then when you compile this source code, you end up with a file containing the bytecodes for this class.
The term “method” is Java-speak for a function.) Thus, you must have a main method in the source file for your class for your code to execute.
You can, of course, add your own methods to a class and call them from the main method.
We cover writing your own methods in the next chapter.)
Note According to the Java Language Specification, the main method must be declared public.
The Java Language Specification is the official document that describes the Java language.
You can view or download it from http://docs.oracle.com/javase/specs.) However, several versions of the Java launcher were willing to execute Java programs even when the main method was not public.
To see it, visit http://bugs.sun.com/bugdatabase/index.jsp and enter the bug identification number 4252539
The Java launcher in Java SE 1.4 and beyond enforces that the main method is public.
There are a couple of interesting aspects about this story.
On the one hand, it is frustrating to have quality assurance engineers, who are often overworked and not always experts in the fine points of Java, make questionable decisions about bug reports.
On the other hand, it is remarkable that Sun made the bug reports and their resolutions available for anyone to scrutinize, long before Java was open source.
Bugs with lots of votes have a higher chance of being fixed in the next JDK release.
Brace styles have inspired an inordinate amount of useless controversy.
As whitespace is irrelevant to the Java compiler, you can use whatever brace style you like.
We will have more to say about the use of braces when we talk about the various kinds of loops.
For now, don’t worry about the keywords static void—just think of them as part of what you need to get a Java program to compile.
By the end of Chapter 4, you will understand this incantation completely.
The point to remember for now is that every Java application must have a main method that is declared in the following way:
Java classes are similar to C++ classes, but there are a few differences that can trap you.
For example, in Java all functions are methods of some class.
The standard terminology refers to them as methods, not member functions.) Thus, in Java you must have a shell class for the main method.
You may also be familiar with the idea of static member functions in C++
These are member functions defined inside a class that do not operate on objects.
Finally, as in C/C++, the void keyword indicates that this method does not return a value.
If the main method exits normally, the Java program has the exit code 0, indicating successful completion.
To terminate the program with a different exit code, use the System.exit method.
Braces mark the beginning and end of the body of the method.
As with most programming languages, you can think of Java statements as sentences of the language.
In particular, carriage returns do not mark the end of a statement, so statements can span multiple lines if need be.
The body of the main method contains a statement that outputs a single line of text to the console.
Here, we are using the System.out object and calling its println method.
In this case, we are calling the println method and passing it a string parameter.
It then terminates the output line, so that each call to println displays its output on a new line.
Notice that Java, like C/C++, uses double quotes to delimit strings.
You can find more information about strings later in this chapter.)
Methods in Java, like functions in any programming language, can use zero, one, or more parameters (some programmers call them arguments)
Even if a method takes no parameters, you must still use empty parentheses.
For example, a variant of the println method with no parameters just prints a blank line.
Note System.out also has a print method that doesn’t add a newline character to the output.
Comments in Java, as in most programming languages, do not show up in the executable.
Thus, you can add as many comments as needed without fear of bloating the code.
You use this for a comment that will run from the // to the end of the line.
Finally, a third kind of comment can be used to generate documentation automatically.
You can see this type of comment in Listing Chapter 4
You will see how to use them later in this chapter.
Java provides the four integer types shown in Table 3.1
In most situations, the int type is the most practical.
If you want to represent the number of inhabitants of our planet, you’ll need to resort to a long.
The byte and short types are mainly intended for specialized applications, such as low-level file handling, or for large arrays when storage space is at a premium.
Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code.
This alleviates a major pain for the programmer who wants to move software from one platform to another, or even between operating systems on the same.
In contrast, C and C++ programs use the most efficient integer type for each processor.
Since Java programs must run with the same results on all machines, the ranges for the various types are fixed.
Long integer numbers have a suffix L (for example, 4000000000L)
Naturally, this can be confusing, so we recommend against the use of octal constants.
The name double refers to the fact that these numbers have twice the precision of the float type.
Some people call these double-precision numbers.) Here, the type to choose in most applications is double.
The limited precision of float is simply not sufficient for many situations.
Seven significant (decimal) digits may be enough to precisely express your annual salary in dollars and cents, but it won’t be enough for your company president’s salary.
It only makes sense to use float in the rare situations where the slightly faster processing of singleprecision numbers is important, or when you need to store a large number of them.
Numbers of type float have a suffix F (for example, 3.14F)
Floating-point numbers without an F suffix (such as 3.14) are always considered to be of type double.
You can optionally supply the D suffix (for example, 3.14D)
In hexadecimal notation, you use a p, not an e, to denote the exponent.
An e is a hexadecimal digit.) Note that the mantissa is written in hexadecimal and the exponent in decimal.
In particular, there are three special floating-point values to denote overflows and errors:
For example, the result of dividing a positive number by 0 is positive infinity.
Computing 0/0 or the square root of a negative number yields NaN.
Caution Floating-point numbers are not suitable for financial calculations in which roundoff errors cannot be tolerated.
Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary number system.
If you need precise numerical computations without roundoff errors, use the BigDecimal class, which is introduced later in this chapter.
The \u escape sequence (but none of the other escape sequences) can even be.
To fully understand the char type, you have to know about the Unicode encoding scheme.
Unicode was invented to overcome the limitations of traditional character encoding schemes.
A particular code value corresponds to different letters in the different encoding schemes.
Moreover, the encodings for languages with large character sets have variable length: Some common characters are encoded as single bytes, others require two or more bytes.
Unicode grew beyond 65,536 characters, primarily due to the addition of a very large set of ideographs used for Chinese, Japanese, and Korean.
Now, the 16-bit char type is insufficient to describe all Unicode characters.
We need a bit of terminology to explain how this problem is resolved in Java, beginning with Java SE 5.0
A code point is a code value that is associated with a character in an encoding scheme.
Unicode has code points that are grouped into 17 code planes.
The UTF-16 encoding represents all Unicode code points in a variable-length code.
The characters in the basic multilingual plane are represented as 16-bit values, called code units.
The supplementary characters are encoded as consecutive pairs of code units.
Each of the values in such an encoding pair falls into a range of 2048 unused values of the basic.
This is rather clever, because you can immediately tell whether a code unit encodes a single character or it is the first or second part of a supplementary character.
In Java, the char type describes a code unit in the UTF-16 encoding.
Our strong recommendation is not to use the char type in your programs unless you are.
The value 0 is equivalent to the bool value false, and a non-zero value is equivalent to true.
You declare a variable by placing the type first, followed.
Here are some examples: double salary; int vacationDays; long earthPopulation; boolean done;
The semicolon is necessary because a declaration is a complete Java statement.
Tip If you are really curious as to what Unicode characters are “letters” as far as Java is.
Tip Even though $ is a valid Java letter, you should not use it in your own code.
It is intended for names that are generated by the Java compiler and other tools.
You also cannot use a Java reserved word for a variable name.
You can have multiple declarations on a single line: int i, j; // both are integers.
If you declare each variable separately, your programs are easier to read.
Note As you saw, names are case sensitive, for example, hireday and hireDay are two separate names.
In general, you should not have two names that only differ in their letter case.
However, sometimes it is difficult to come up with a good name for a variable.
Many programmers then give the variable the same name as the type, for example.
Box box; // "Box" is the type and "box" is the variable name Other programmers prefer to use an “a” prefix for the variable:
After you declare a variable, you must explicitly initialize it by means of an assignment.
For example, the Java compiler flags the following sequence of statements as an error:
You assign to a previously declared variable by using the variable name on the left, an equal sign (=), and then some Java expression with an appropriate value on the right.
You can both declare and initialize a variable on the same line.
Finally, in Java you can put declarations anywhere in your code.
In Java, it is considered good style to declare variables as closely as possible to the point where they are first used.
In Java, you use the keyword final to denote a constant.
The keyword final indicates that you can assign to the variable once, and then its value is set once and for all.
It is probably more common in Java to create a constant so it’s available to multiple methods inside a single class.
Set up a class constant with the keywords static final.
Note that the definition of the class constant appears outside the main method.
Thus, the constant can also be used in other methods of the same class.
C++ Note const is a reserved Java keyword, but it is not currently used for anything.
The / operator denotes integer division if both arguments are.
There is a convenient shortcut for using binary arithmetic operators in an assignment.
Note One of the stated goals of the Java programming language is portability.
A computation should yield the same results no matter which virtual machine executes it.
For arithmetic computations with floating-point numbers, it is surprisingly difficult to achieve this portability.
These registers yield added precision in intermediate steps of a computation.
That can yield a more accurate result, and it can avoid exponent overflow.
But the result may be different from a computation that uses 64 bits throughout.
For that reason, the initial specification of the Java virtual machine mandated that all intermediate computations must be truncated.
Not only can the truncated computations cause overflow, they are actually slower than the more precise computations because the truncation operations take time.
For that reason, the Java programming language was updated to recognize the conflicting demands for optimum performance and perfect reproducibility.
By default, virtual machine designers are now permitted to use extended precision for intermediate computations.
However, methods tagged with the strictfp keyword must use strict floating-point operations that yield reproducible results.
Programmers, of course, know that one of the most common operations with a numeric.
Since these operators change the value of a variable, they cannot be applied to numbers themselves.
There are actually two forms of these operators; you’ve just seen the postfix form of the operator that is placed after the operand.
The difference between the two only appears when they are used inside expressions.
The prefix form does the addition first; the postfix form evaluates to the old value of the variable.
We recommend against using ++ inside expressions because this often leads to confusing code and annoying bugs.
Thus, the value for the second expression is not calculated.
Thus, 1 / x is not computed if x is zero, and no divide-by-zero error can occur.
Finally, Java supports the ternary ?: operator that is occasionally useful.
When working with any of the integer types, you have operators that can work directly with.
This means that you can use masking techniques to get at individual bits in a number.
That is, both arguments are evaluated before the result is computed.
These operators are convenient when you need to build up bit patterns to do bit masking:
The Math class contains an assortment of mathematical functions that you may occasionally.
To take the square root of a number, use the sqrt method:
Note There is a subtle difference between the println method and the sqrt method.
The println method operates on an object, System.out, defined in the System class.
But the sqrt method in the Math class does not operate on any object.
You can learn more about static methods in Chapter 4
The Java programming language has no operator for raising a quantity to a power: You must use the pow method in the Math class.
Tip You can avoid the Math prefix for the mathematical methods and constants by adding the following line to the top of your source file:
Note The methods in the Math class use the routines in the computer’s floating-point unit for fastest performance.
If completely predictable results are more important than fast performance, use the StrictMath class instead.
It is often necessary to convert from one numeric type to another.
The six solid arrows in Figure 3.1 denote conversions without information loss.
The three dotted arrows denote conversions that may lose precision.
For example, a large integer such as 123456789 has more digits than the float type can represent.
When the integer is converted to a float, the resulting value has the correct magnitude but it loses some precision.
When two values are combined with a binary operator (such as n + f where n is an integer and f is a floating-point value), both operands are converted to a common type before the operation is carried out.
If either of the operands is of type double, the other one will be converted to a double.
Otherwise, if either of the operands is of type float, the other one will be converted to a float.
Otherwise, if either of the operands is of type long, the other one will be converted to a long.
In the preceding section, you saw that int values are automatically converted to double.
On the other hand, there are obviously times when you want to consider a double as an integer.
Numeric conversions are possible in Java, but of course information may be lost.
Conversions in which loss of information is possible are done by means of casts.
The syntax for casting is to give the target type in parentheses, followed by the variable name.
Now, the variable nx has the value 9 because casting a floating-point value to an integer discards the fractional part.
If you want to round a floating-point number to the nearest integer (which in most cases is the more useful operation), use the Math.round method:
You still need to use the cast (int) when you call round.
The reason is that the return value of the round method is a long, and a long can only be assigned to an int with an explicit cast because there is the possibility of information loss.
Caution If you try to cast a number of one type to another that is out of the range for the target type, the result will be a truncated number that has a different value.
C++ Note You cannot cast between boolean values and any numeric type.
Table 3.4 on the following page shows the precedence of operators.
Operators on the same level are processed from left to right, except for those that are right-associative, as indicated in the table.
That is, the value of b += c (which is the value of b after the addition) is added to a.
However, you can use a comma-separated list of expressions in the first and third slot of a for statement.
Sometimes, a variable should only hold a restricted set of values.
It is too easy for a variable to hold a wrong value (such as 0 or m)
You can define your own enumerated type whenever such a situation arises.
An enumerated type has a finite number of named values.
A variable of type Size can hold only one of the values listed in the type declaration, or the special value null that indicates that the variable is not set to any value at all.
We discuss enumerated types in greater detail in Chapter 5
You can extract a substring from a larger string with the substring method of the String.
The second parameter of substring is the first position that you do not want to copy.
There is one advantage to the way substring works: Computing the length of the substring is easy.
The string s.substring(a, b) always has length b - a.
Java, like most programming languages, allows you to use + to join (concatenate) two strings.
The preceding code sets the variable message to the string "Expletivedeleted"
Note the lack of a space between the words: The + operator joins two strings in the order received, exactly as they are given.)
When you concatenate a string with a value that is not a string, the latter is converted to a string.
As you will see in Chapter 5, every Java object can be converted to a string.) For example,
The String class gives no methods that let you change a character in an existing string.
If you are a C programmer, this will make you feel pretty helpless.
How are we going to modify the string? In Java, it is quite easy: Concatenate the substring that you want to keep with the characters that you want to replace.
Since you cannot change the individual characters in a Java string, the documentation refers.
Isn’t that a lot less efficient? It would seem simpler to change the code units than to build up a whole new string from scratch.
Indeed, it isn’t efficient to generate a new string that holds the concatenation of "Hel" and "p!"
But immutable strings have one great advantage: The compiler can arrange that strings are shared.
To understand how this works, think of the various strings as sitting in a common pool.
If you copy a string variable, both the original and the copy share the same characters.
Overall, the designers of Java decided that the efficiency of sharing outweighs the inefficiency of string editing by extracting substrings and concatenating.
Look at your own programs; we suspect that most of the time, you don’t change strings—you just compare them.
C++ Note C programmers are generally bewildered when they see Java strings for the first time because they think of strings as arrays of characters:
And even the most hardened C programmer must admit that the Java syntax is more pleasant than a sequence of strncpy calls.
If a block of memory is no longer needed, it will eventually be recycled.
The memory management is performed explicitly by constructors, assignment operators, and destructors.
To test whether two strings are equal, use the equals method.
To test whether two strings are identical except for the upper/lowercase letter distinction, use the equalsIgnoreCase method.
Sure, if strings are in the same location, they must be equal.
But it is entirely possible to store multiple copies of identical strings in different places.
If the virtual machine always arranges for equal strings to be shared, then you could use the == operator for testing equality.
But only string constants are shared, not strings that are the result of operations like + or substring.
The Java method compareTo is the exact analog to strcmp.
The empty string "" is a string of length 0
However, a String variable can also hold a special value, called null, that indicates that no object is currently associated with the variable.
See Chapter 4 for more information about null.) To test whether a string is null, use the condition.
As you will see in Chapter 4, it is an error to.
The most commonly used Unicode characters can be represented with a single code unit.
The length method yields the number of code units required for a given string in the UTF16 encoding.
Why are we making a fuss about code units? Consider the sentence is the set of integers.
The character  requires two code units in the UTF-16 encoding.
To avoid this problem, you should not use the char type.
If your code traverses a string, and you want to look at each code point in turn, use these statements:
The String class in Java contains more than 50 methods.
The following API note summarizes the ones we found most useful.
Note These API notes, found throughout the book, will help you understand the Java Application Programming Interface (API)
The class name is followed by the names, explanations, and parameter descriptions of one or more methods.
We typically do not list all methods of a particular class but select those that are most commonly used and describe them in a concise form.
We also list the version number in which a particular class was introduced.
If a method has been added later, it has a separate version number.
You probably don’t want to call this method unless you are interested in low-level code units.
You can supply String or StringBuilder objects for the CharSequence parameters.
String toLowerCase() returns a new string containing all characters in the original string, with uppercase characters converted to lowercase.
String toUpperCase() returns a new string containing all characters in the original string, with lowercase characters converted to uppercase.
String trim() returns a new string by eliminating all leading and trailing spaces in the original string.
As you just saw, the String class has lots of methods.
It is plainly impossible to remember all useful classes and methods.
Therefore, it is essential that you become familiar with the online API documentation that lets you look up all classes and methods in the standard library.
A small frame on the top left shows all available packages.
Click on any class name, and the API documentation for the class is displayed in the large frame to the right (see Figure 3.3)
For example, to get more information on the methods of the String class, scroll the second frame until you see the String link, then click on it.
Class description for the String class Then scroll the frame on the right until you reach a summary of all methods, sorted in.
Click on any method name for a detailed description of that method (see Figure 3.5)
Occasionally, you need to build up strings from shorter strings, such as keystrokes or words.
It would be inefficient to use string concatenation for this purpose.
Every time you concatenate strings, a new String object is constructed.
Follow these steps if you need to build a string from many small pieces.
When you are done building the string, call the toString method.
You will get a String object with the character sequence contained in the builder.
Its predecessor, StringBuffer, is slightly less efficient, but it allows multiple threads to add or remove characters.
If all string editing happens in a single thread (which is usually the case), you should use StringBuilder instead.
The following API notes contain the most important methods for the StringBuilder class.
StringBuilder append(char c) appends a code unit and returns this.
StringBuilder insert(int offset, String str) inserts a string at position offset and returns this.
StringBuilder insert(int offset, char c) inserts a code unit at position offset and returns this.
StringBuilder delete(int startIndex, int endIndex) deletes the code units with offsets startIndex to endIndex - 1 and returns this.
String toString() returns a string with the same data as the builder or buffer contents.
To make our example programs more interesting, we want to accept input and properly.
Of course, modern programs use a GUI for collecting user input.
However, programming such an interface requires more tools and techniques than we have at our disposal at this time.
Because the first order of business is to become more familiar with the Java programming language, we make do with the humble console for input and output for now.
To read console input, you first construct a Scanner that is attached to System.in:
Here, we use the nextLine method because the input might contain spaces.
The program in Listing 3.2 asks for the user’s name and age and then prints a message like.
Whenever you use a class that is not defined in the basic java.lang package, you need to use an import directive.
We look at packages and import directives in more detail in Chapter 4
Note The Scanner class is not suitable for reading a password from a console since the input is plainly visible to anyone.
Java SE 6 introduces a Console class specifically for this purpose.
For security reasons, the password is returned in an array of characters rather than a string.
After you are done processing the password, you should immediately overwrite the array elements with a filler value.
Array processing is discussed later in this chapter.) Input processing with a Console object is not as convenient as with a Scanner.
You can only read a line of input at a time.
There are no methods for reading individual words or numbers.
String next() reads the next word of input (delimited by whitespace)
A Console object is available for any program that is launched in a console window.
The args parameters can be used to supply formatting arguments, as described in the next section.
That is a problem if you want to display, for example, dollars and cents.
In early versions of Java, formatting numbers was a bit of a hassle.
That is, the printout contains a leading space and the seven characters.
The conversion character that ends a format specifier indicates the type of the value to be formatted: f is a floating-point number, s a string, and d a decimal integer.
In addition, you can specify flags that control the appearance of the formatted output.
You can use multiple flags, for example "%,(.2f" to use group separators and enclose negative numbers in parentheses.
Note You can use the s conversion to format arbitrary objects.
If an arbitrary object implements the Formattable interface, the object’s formatTo method is invoked.
Otherwise, the toString method is invoked to turn the object into a string.
You can use the static String.format method to create a formatted string without printing it:
Use a two-letter format, starting with t and ending in one of the letters of Table 3.7; for example,
It would be a bit silly if you had to supply the date multiple times to format each part.
For that reason, a format string can indicate the index of the argument to be formatted.
You have now seen all features of the printf method.
For example, in Germany, the group separator is a period, not a comma, and Monday is formatted as Montag.
You will see in Chapter 5 of Volume II how to control the international behavior of your applications.
To read from a file, construct a Scanner object like this:
Now you can read from the file, using any of the Scanner methods that we already.
You can use the print, println, and printf commands as you did when printing to System.out.
Caution You can construct a Scanner with a string parameter, but the scanner interprets the string as data, not a file name.
If you launched your program from a command shell, by executing.
However, if you use an integrated development environment, the starting directory is controlled by the IDE.
As you just saw, you can access files just as easily as you can use System.in and System.out.
There is just one catch: If you construct a Scanner with a file that does not exist or a PrintWriter with a file name that cannot be created, an exception occurs.
In Chapter 11, you will learn various ways of handing exceptions.
You do this by tagging the main method with a throws clause, like this:
You have now seen how to read and write files that contain textual data.
For more advanced topics, such as dealing with different character encodings, processing binary data, reading directories, and writing zip files, please turn to Chapter 1 of Volume II.
Note When you launch a program from a command shell, you can use the redirection syntax of your shell and attach any file to System.in and System.out:
Scanner(String data) constructs a Scanner that reads data from the given string.
Java, like any programming language, supports both conditional statements and loops to.
We will start with the conditional statements, then move on to loops, to end with the somewhat cumbersome switch statement that you can use to test for many values of a single expression.
There is no goto, but there is a “labeled” version of break that you can use to break out of a nested loop (where, in C, you perhaps would have used a goto)
Finally, there is a variant of the for loop that has no analog in C or C++
Before we get into the actual control structures, you need to know more about blocks.
A block or compound statement is any number of simple Java statements surrounded by a.
Here is a block that is nested inside the block of the main method.
However, you may not declare identically named variables in two nested blocks.
For example, the following is an error and will not compile:
This can be a source of programming errors; hence, Java does not allow it.
The conditional statement in Java has the form if (condition) statement.
In Java, as in most programming languages, you will often want to execute multiple.
In this case, use a block statement that takes the form.
In this code all the statements surrounded by the braces will be executed when yourSales is greater than or equal to target (see Figure 3.7)
A block (sometimes called a compound statement) allows you to have more than one (simple) statement in any Java programming structure that otherwise allows for a single (simple) statement.
Of course, it is a good idea to use braces to clarify this code:
The while loop executes a statement (which may be a block statement) while a condition is true.
The  loop will never execute if the condition is  at the outset (see Figure 3.10)
Flowchart for the while statement The program in Listing 3.3 determines how long it will take to save a specific amount of.
In the example, we are incrementing a counter and updating the amount currently accumulated in the body of the loop until the total exceeds the targeted amount.
Don’t rely on this program to plan for your retirement.
We left out a few niceties such as inflation and your life expectancy.)
Therefore, the code in the block may never be executed.
If it’s true, it repeats the statement and retests the condition, and so on.
The code in Listing 3.4 computes the new balance in your retirement account and then asks if you are ready to retire:
As long as the user answers "N", the loop is repeated (see Figure 3.11)
This program is a good example of a loop that needs to be entered at least once, because the user needs to see the balance before deciding whether it is sufficient for retirement.
The for loop is a general construct to support iteration controlled by a counter or similar.
Flowchart for the for statement The first slot of the for statement usually holds the counter initialization.
Although Java, like C++, allows almost any expression in the various slots of a for loop, it is an unwritten rule of good taste that the three slots should only initialize, test, and update the same counter variable.
One can write very obscure loops by disregarding this rule.
Even within the bounds of good taste, much is possible.
Caution Be careful about testing for equality of floating-point numbers in loops.
Because of roundoff errors, the final value may not be reached exactly.
When you declare a variable in the first slot of the for statement, the scope of that variable extends until the end of the body of the for loop.
In particular, if you define a variable inside a for statement, you cannot use its value outside the loop.
Therefore, if you wish to use the final value of a loop counter outside the for loop, be sure to declare it outside the loop header!
Listing 3.5 shows a typical example of a for loop.
In general, if you pick k numbers out of n, there are.
The if/else construct can be cumbersome when you have to deal with multiple selections.
Java has a switch statement that is exactly like the switch statement in C and C++, warts and all.
For example, if you set up a menuing system with four alternatives like that in Figure 3.13, you could use code that looks like this:
Flowchart for the switch statement Execution starts at the case label that matches the value on which the selection is.
If none of the case labels match, then the default clause is executed, if it is present.
Caution It is possible for multiple alternatives to be triggered.
If you forget to add a break at the end of an alternative, then execution falls through to the next alternative! This behavior is plainly dangerous and a common cause for errors.
For that reason, we never use the switch statement in our programs.
If you like the switch statement better than we do, consider compiling your code with the -Xlint:fallthrough option, like this:
An annotation is a mechanism for supplying information to the compiler or a tool that processes Java source or class files.
We will discuss annotations in detail in Chapter 13 of Volume II.)
When you use the switch statement with enumerated constants, you need not supply the name of the enumeration in each label—it is deduced from the switch value.
Although the designers of Java kept goto as a reserved word, they decided not to include it.
They argue that unrestricted use of goto is error-prone but that an occasional jump out of a loop is beneficial.
The Java designers agreed and even added a new statement, the labeled break, to support this programming style.
Of course, you could have computed the same value for years without a break, like this:
But note that the test balance < goal is repeated twice in this version.
To avoid this repeated test, some programmers prefer the break statement.
Unlike C++, Java also offers a labeled break statement that lets you break out of multiple nested loops.
In that case, you may want to break completely out of all the nested loops.
It is inconvenient to program that simply by adding extra conditions to the various loop tests.
Here’s an example that shows the break statement at work.
Notice that the label must precede the outermost loop out of which you want to break.
If there was a bad input, the labeled break moves past the end of the labeled block.
As with any use of the break statement, you then need to test whether the loop exited normally or as a result of a break.
Note Curiously, you can apply a label to any statement, even an if statement or a block statement, like this:
Thus, if you are lusting after a goto and if you can place a block that ends just before the place to which you want to jump, you can use a break statement! Naturally, we don’t recommend this approach.
Note, however, that you can only jump out of a block, never into a block.
Finally, there is a continue statement that, like the break statement, breaks the regular flow of control.
The continue statement transfers control to the header of the innermost enclosing loop.
If the continue statement is used in a for loop, it jumps to the “update” part of the for loop.
There is also a labeled form of the continue statement that jumps to the header of the loop.
Tip Many programmers find the break and continue statements confusing.
These statements are entirely optional—you can always express the same logic without them.
If the precision of the basic integer and floating-point types is not sufficient, you can turn to.
These are classes for manipulating numbers with an arbitrarily long sequence of digits.
Instead, you must use methods such as add and multiply in the big number classes.
The language designers did overload the + operator to denote concatenation of strings.
They chose not to overload other operators, and they did not give Java programmers the opportunity to overload operators in their own classes.
BigDecimal divide(BigDecimal other, RoundingMode mode) 5.0 returns the sum, difference, product, or quotient of this big decimal and other.
To compute the quotient, you must supply a rounding mode.
An array is a data structure that stores a collection of values of the same type.
For example, if a is an array of integers, then a[i] is the ith integer in the array.
For example, here is the declaration of an array a of integers:
It does not yet initialize a with an actual array.
The array length need not be a constant: new int[n] creates an array of length n.
Once the array is created, you can fill the elements in an array, for example, by using a loop:
When you create an array of numbers, all elements are initialized with zero.
Arrays of objects are initialized with the special value null, which indicates that they do not (yet) hold any objects.
Once you create an array, you cannot change its size (although you can, of course, change an individual array element)
If you frequently need to expand the size of an array while your program is running, you should use a different data structure called an array list.
Java has a powerful looping construct that allows you to loop through each element in an.
The collection expression must be an array or an object of a class that implements the Iterable interface, such as ArrayList.
But this loop was a late addition to the Java language, and in the end nobody wanted to break the old code that already contained methods or variables with these names (such as System.in)
However, there are still plenty of opportunities to use the traditional for loop.
For example, you may not want to traverse the entire collection, or you may need the index value inside the loop.
Tip There is an even easier way to print all values of an array, using the toString method of the Arrays class.
Java has a shorthand to create an array object and supply initial values at the same time.
Notice that you do not call new when you use this syntax.
Note It is legal to have arrays of length 0
Such an array can be useful if you write a method that computes an array result and the result happens to be empty.
Note that an array of length 0 is not the same as null.
You can copy one array variable into another, but then both variables refer to the same.
If you actually want to copy all values of one array into a new array, you use the copyOf method in the Arrays class:
The second parameter is the length of the new array.
A common use of this method is to increase the size of an array:
Conversely, if the length is less than the length of the original array, only the initial values are copied.
It is, however, essentially the same as a pointer to an array allocated on the heap.
Furthermore, there is no pointer arithmetic—you can’t increment a to point to the next element in the array.
You have already seen one example of a Java array repeated quite a few times.
This parameter indicates that the main method receives an array of strings—namely, the arguments specified on the command line.
If the program is called as java Message -g cruel world.
C++ Note In the main method of a Java program, the name of the program is not stored in the args array.
To sort an array of numbers, you can use one of the sort methods in the Arrays class:
This method uses a tuned version of the QuickSort algorithm that is claimed to be very efficient on most data sets.
The Arrays class provides several other convenience methods for arrays that are included in the API notes at the end of this section.
This program draws a random combination of numbers for a lottery game.
Now we must be sure never to draw that number again—all lottery numbers must be distinct.
The point is that in each draw we pick an index, not the actual value.
The index points into an array that contains the values that have not yet been drawn.
Otherwise, a negative value r is returned; -r - 1 is the spot at which v should be inserted to keep a sorted.
Multidimensional arrays use more than one index to access array elements.
You can safely skip this section until you have a need for this storage mechanism.
You can store this information in a two-dimensional array (matrix), which we call balances.
In other cases, if you know the array elements, you can use a shorthand notation for initializing a multidimensional array without a call to new.
The example program stores a one-dimensional array interest of interest rates and a twodimensional array balances of account balances, one for each year and interest rate.
We initialize the first row of the array with the initial balance:
Instead, it loops through the rows, which are themselves onedimensional arrays.
To visit all elements of a two-dimensional array a, nest two loops, like this:
Tip To print out a quick-and-dirty list of the elements of a two-dimensional array, call.
So far, what you have seen is not too different from other programming languages.
For example, the balances array in the preceding example is actually an array that contains ten elements, each of which is an array of six floating-point numbers (Figure 3.15)
It is itself an array, and balances[i][j] refers to the jth element of that array.
As j can never be larger than i, the matrix is triangular.
We allow choosing 0 elements; there is one way to make such a choice.) To build this ragged array, first allocate the array holding the rows.
Now that the array is allocated, we can access the elements in the normal way, provided we do not overstep the bounds.
Mercifully, this loop is automatic when you ask for a new double[10][6]
When you want ragged arrays, you allocate the row arrays separately.
You have now seen the fundamental programming structures of the Java language.
If you do not have a background in object-oriented programming, you will want to read this chapter carefully.
Object-oriented programming requires a different way of thinking than procedural languages.
The transition is not always easy, but you do need some familiarity with object concepts to go further with Java.
For experienced C++ programmers, this chapter, like the previous chapter, presents familiar information; however, there are enough differences between the two languages that you should read the later sections of this chapter carefully.
You’ll find the C++ notes helpful for making the transition.
Object-oriented programming, or OOP for short, is the dominant programming.
Since Java is object-oriented, you have to be familiar with OOP to become productive with Java.
Each object has a specific functionality, exposed to its users, and a hidden implementation.
Many objects in your programs will be taken “off-the-shelf” from a library; others will be custom-designed.
Whether you build an object or buy it might depend on your budget or on time.
But, basically, as long as an object satisfies your specifications, you don’t care how the functionality is implemented.
Traditional structured programming consists of designing a set of procedures (or algorithms) to solve a problem.
Once the procedures are determined, the traditional next step was to find appropriate ways to store the data.
Notice that in Wirth’s title, algorithms come first, and data structures come second.
First, they decided on the procedures for manipulating the data; then, they decided what structure to impose on the data to make the manipulations easier.
For small problems, the breakdown into procedures works very well.
It might require 2,000 procedures for its implementation, all of which manipulate a set of global data.
This structure is much easier for a programmer to grasp.
Suppose the data of a particular object is in an incorrect state.
A class is the template or blueprint from which objects are made.
As you have seen, all code that you write in Java is inside a class.
Nonetheless, in Java you still have to create your own classes to describe the objects of your application’s problem domain.
Encapsulation (sometimes called information hiding) is a key concept in working with objects.
Formally, encapsulation is simply combining data and behavior in one package and hiding the implementation details from the users of the object.
The bits of data in an object are called its instance fields, and the procedures that operate on the data are called its methods.
A specific object that is an instance of a class will have specific values of its instance fields.
The set of those values is the current state of the object.
Whenever you invoke a method on an object, its state may change.
The key to making encapsulation work is to have methods never directly access instance fields in a class other than their own.
Programs should interact with object data only through the object’s methods.
This means a class may totally change how it stores its data, but as long as it continues to use the same methods to manipulate the data, no other object will know or care.
When you start writing your own classes in Java, another tenet of OOP will make this easier: Classes can be built by extending other classes.
You will learn more about the Object class in the next chapter.
When you extend an existing class, the new class has all the properties and methods of the class that you extend.
You then supply new methods and data fields that apply to your new class only.
The concept of extending a class to obtain another class is called inheritance.
To work with OOP, you should be able to identify three key characteristics of objects:
All objects that are instances of the same class share a family resemblance by supporting the same behavior.
The behavior of an object is defined by the methods that you can call.
Next, each object stores information about what it currently looks like.
An object’s state may change over time, but not spontaneously.
A change in the state of an object must be a consequence of method calls.
If an object’s state changed without a method call on that object, someone broke encapsulation.)
However, the state of an object does not completely describe it, because each object.
For example, in an order processing system, two orders are distinct even if they request identical items.
Notice that the individual objects that are instances of a class always differ in their identity and usually differ in their state.
For example, the state of an object can influence its behavior.
In a traditional procedural program, you start the process at the top, with the main.
When designing an object-oriented system, there is no “top,” and newcomers to OOP often wonder where to begin.
The answer is, identify your classes and then add methods to each class.
A simple rule of thumb in identifying classes is to look for nouns in the problem analysis.
These nouns may lead to the classes Item, Order, and so on.
For example, when a new item is added to an order, the order object should be the one in charge because it knows how it stores and sorts items.
That is, add should be a method of the Order class that takes an Item object as a parameter.
The dependence, or “uses–a” relationship, is the most obvious and also the most general.
For example, the Order class uses the Account class because Order objects need to access Account objects to check for credit status.
But the Item class does not depend on the Account class, because Item objects never need to worry about customer accounts.
Thus, a class depends on another class if its methods use or manipulate objects of that class.
Try to minimize the number of classes that depend on each other.
And this means that changes to B do not introduce bugs into A.) In software engineering terminology, you want to minimize the coupling between classes.
The aggregation, or “has–a” relationship, is easy to understand because it is concrete; for example, an Order object contains Item objects.
Containment means that objects of class A contain objects of class B.
Note Some methodologists view the concept of aggregation with disdain and prefer to use a more general “association” relationship.
From the point of view of modeling, that is understandable.
But for programmers, the “has–a” relationship makes a lot of sense.
We like to use aggregation for another reason as well: The standard notation for associations is less clear.
The inheritance, or “is–a” relationship, expresses a relationship between a more special and a more general class.
For example, a RushOrder class inherits from an Order class.
The specialized RushOrder class has special methods for priority handling and a different method for computing shipping charges, but its other methods, such as adding items and billing, are inherited from the Order class.
In general, if class A extends class B, class A inherits methods from class B but has more capabilities.
We describe inheritance more fully in the next chapter, in which we discuss this important notion at some length.)
Many programmers use the UML (Unified Modeling Language) notation to draw class diagrams that describe the relationships between classes.
You can see an example of such a diagram in Figure 4.2
You draw classes as rectangles, and relationships as arrows with various adornments.
You can’t do anything in Java without classes, and you have already seen several.
However, not all of these show off the typical features of object orientation.
You have seen that you can use methods of the Math class, such as Math.random, without needing to know how they are implemented—all you need to know is the name and parameters (if any)
That’s the point of encapsulation, and it will certainly be true of all classes.
But the Math class only encapsulates functionality; it neither needs nor hides data.
In the next section, we will look at a more typical class, the Date class.
You will see how to construct objects and call methods of this class.
To work with objects, you first construct them and specify their initial state.
In the Java programming language, you use constructors to construct new instances.
A constructor is a special method whose purpose is to construct and initialize objects.
But actually, how suitable is the Visual Basic design? In some locales, dates are specified as month/day/year, in others as day/month/year.
Are the language designers really equipped to foresee these kinds of issues? If they do a poor job, the language becomes an unpleasant muddle, but unhappy programmers are powerless to do anything about it.
With classes, the design task is offloaded to a library designer.
If the class is not perfect, other programmers can easily write their own classes to enhance or replace the system classes.
To prove the point: The Java date library is a bit muddled, and a major redesign is underway; see http://jcp.org/en/jsr/detail?id=310.)
Constructors always have the same name as the class name.
Thus, the constructor for the Date class is called Date.
To construct a Date object, you combine the constructor with the new operator, as follows:
If you like, you can pass the object to a method:
Here is how you would apply the toString method to a newly constructed Date object:
There is an important difference between objects and object variables.
Date deadline; // deadline doesn't refer to any object defines an object variable, deadline, that can refer to objects of type Date.
Or you can set the variable to refer to an existing object: deadline = birthday;
Now both variables refer to the same object (see Figure 4.4)
It is important to realize that an object variable doesn’t actually contain an object.
In Java, the value of any object variable is a reference to an object that is stored elsewhere.
The return value of the new operator is also a reference.
You can explicitly set an object variable to null to indicate that it currently refers to no object.
You must initialize them, either by calling new or by setting them to null.
But in C++ there are no null references, and references cannot be assigned.
You should think of Java object variables as analogous to object pointers in C++
Of course, a Date* pointer isn’t initialized until you initialize it with a call to new.
The syntax is almost the same in C++ and Java.
You don’t have to worry about memory management, because the garbage collector takes care of it.
C++ makes quite an effort, with its support for copy constructors and assignment operators, to allow the implementation of objects that copy themselves automatically.
For example, a copy of a linked list is a new linked list with the same contents but with an independent set of links.
This makes it possible to design classes with the same copy behavior as the built-in types.
In Java, you must use the clone method to get a complete copy of an object.
In the preceding examples, we used the Date class that is a part of the standard Java.
An instance of the Date class has a state, namely a particular point in time.
Although you don’t need to know this when you use the Date class, the time is.
But as it turns out, the Date class is not very useful for manipulating dates.
This particular description follows the Gregorian calendar, which is the calendar used in most countries of the world.
The same point in time would be described quite differently in the Chinese or Hebrew lunar calendars, not to mention the calendar used by your customers from Mars.
Note Throughout human history, civilizations grappled with the design of calendars to attach names to dates and bring order to the solar and lunar cycles.
For a fascinating explanation of calendars around the world, from the French Revolutionary calendar to the Mayan long count, see Calendrical Calculations by Nachum Dershowitz and Edward M.
The library designers decided to separate the concerns of keeping time and attaching names to points in time.
Therefore, the standard Java library contains two separate classes: the Date class, which represents a point in time, and the GregorianCalendar class, which expresses dates in the familiar calendar notation.
In fact, the GregorianCalendar class extends a more generic Calendar class that describes the properties of calendars in general.
The standard Java library also contains implementations of the Thai Buddhist and Japanese imperial calendar.
In general, it is a good idea to use separate classes to express different concepts.
The Date class has only a small number of methods that allow you to compare two points in time.
For example, the before and after methods tell you if one point in time comes before or after another:
Note Actually, the Date class has methods such as getDay, getMonth, and getYear, but these methods are deprecated.
A method is deprecated when a library designer realizes that the method should have never been introduced in the first place.
These methods were a part of the Date class before the library designers realized that it makes more sense to supply separate calendar classes.
When the calendar classes were introduced, the Date methods were tagged as deprecated.
You can still use them in your programs, but you will get unsightly compiler warnings if you do.
It is a good idea to stay away from using deprecated methods because they may be removed in a future version of the library.
The GregorianCalendar class has many more methods than the Date class.
You can construct a calendar object for midnight on a specific date by supplying year,
Without looking at the source code, it is impossible to know the representation that the class uses internally.
But, of course, the point of encapsulation is that this doesn’t matter.
At this point, you are probably asking yourself: How do I get at the current day or.
The job of a calendar is to compute attributes, such as the date, weekday, month, or.
To query one of these settings, use the get method of the GregorianCalendar class.
The API notes list all the constants that you can use.
There is also a convenience method to set the year, month, and day with a single call:
If you add a negative number, then the calendar is moved backwards.
There is a conceptual difference between the get method on the one hand and the.
The get method only looks up the state of the object and reports on it.
The set and add methods modify the state of the object.
Methods that change instance fields are called mutator methods, and those that only access instance fields without modifying them are called accessor methods.
A method that is not declared as const is assumed to be a mutator.
However, in the Java programming language, no special syntax distinguishes accessors from mutators.
A common convention is to prefix accessor methods with the prefix get and mutator methods with the prefix set.
For example, the GregorianCalendar class has methods getTime and setTime that get and set the point in time that a calendar object represents:
These methods are particularly useful for converting between the GregorianCalendar and Date classes.
Suppose you know the year, month, and day and you want to make a Date object with those settings.
Since the Date class knows nothing about calendars, first construct a GregorianCalendar object and then call the getTime method to obtain a date:
Conversely, if you want to find the year, month, or day of a Date object, construct a GregorianCalendar object, set the time, and then call the get method:
We finish this section with a program that puts the GregorianCalendar class to work.
The program displays a calendar for the current month, like this:
As you can see, the program needs to know how to compute the length of a month and the weekday of a given day.
Let us go through the key steps of the program.
First, we construct a calendar object that is initialized with the current date.
The variable weekday is set to Calendar.SUNDAY if the first day of the month is a Sunday, to Calendar.MONDAY if it is a Monday, and so on.
Note that the first line of the calendar is indented, so that the first day of the month falls on the appropriate weekday.
This is a bit tricky since there are varying conventions about the starting day of the week.
In the United States, the week starts with Sunday and ends with Saturday, whereas in Europe, the week starts with Monday and ends with Sunday.
The Java virtual machine is aware of the locale of the current user.
The locale describes local formatting conventions, including the start of the week and the names of the weekdays.
Tip If you want to see the program output in a different locale, add a line such as the following as the first line of the main method:
The getFirstDayOfWeek method gets the starting weekday in the current locale.
To determine the required indentation, we subtract 1 from the day of the calendar object until we reach the first day of the week.
Now, we are ready to print the body of the calendar.
We indent the first line and set the date object back to the start of the month.
We enter a loop in which d traverses the days of the month.
If d is today, the date is marked with an *
If we reach the beginning of each new week, we print a new line.
Once d has moved into the next month, the program terminates.
As you can see, the GregorianCalendar class makes it possible to write a calendar.
You don’t need to know how the GregorianCalendar class computes months and weekdays.
You just use the interface of the class—the get, set, and add methods.
The point of this example program is to show you how you can use the interface of a class to carry out fairly sophisticated tasks without having to know the implementation details.
Adds the specified amount of time to the given time field.
Date getTime() gets the point in time that is represented by the current value of this calendar object.
Uses Calendar weekday and month constants as array index values.
To build a complete program, you combine several classes, one of which has a main method.
Consider the following, very simplified, version of an Employee class that might be used by a business in writing a payroll system.
We break down the implementation of this class, in some detail, in the sections that follow.
First, though, Listing 4.2 is a program that shows the Employee class in action.
In the program, we construct an Employee array and fill it with three employee objects:
Next, we use the raiseSalary method of the Employee class to raise each employee’s salary by 5%:
Finally, we print out information about each employee, by calling the getName, getSalary, and getHireDay methods:
Note that the example program consists of two classes: the Employee class and a class EmployeeTest with the public access specifier.
The main method with the instructions that we just described is contained in the EmployeeTest class.
You can only have one public class in a source file, but you can have any number of nonpublic classes.
You then start the program by giving the bytecode interpreter the name of the class that contains the main method of your program:
This code in turn constructs three new Employee objects and shows you their state.
The program in Listing 4.2 has two classes in a single source file.
If you like this arrangement, then you have two choices for compiling the program.
You may find it surprising that the second choice works even though the Employee.java file is never explicitly compiled.
If it does not find that file, it automatically searches for Employee.java and compiles it.
Moreover, if the timestamp of the version of Employee.java that it finds is newer than that of the existing Employee.class file, the Java compiler will automatically recompile the file.
Note If you are familiar with the make facility of UNIX (or one of its Windows cousins, such as nmake), then you can think of the Java compiler as having the make functionality already built in.
In the sections that follow, we will dissect the Employee class.
As you can see by examining the source code, this class has one constructor and four methods:
The keyword public means that any method in any class can call the method.
The four possible access levels are covered in this and the next chapter.)
Next, notice the three instance fields that will hold the data manipulated inside an instance of the Employee class.
The private keyword makes sure that the only methods that can access these.
No outside method can read or write to these fields.
Note You could use the public keyword with your instance fields, but it would be a very bad idea.
Having public data fields would allow any part of the program to read and modify the instance fields, completely ruining encapsulation.
Any method of any class can modify public fields—and, in our experience, some code will take advantage of that access privilege when you least expect it.
We strongly recommend to make all your instance fields private.
Finally, notice that two of the instance fields are themselves objects: The name and hireDay fields are references to String and Date objects.
This is quite usual: Classes will often contain instance fields of class type.
Let’s look at the constructor listed in our Employee class.
As you can see, the name of the constructor is the same as the name of the class.
This constructor runs when you construct objects of the Employee class—giving the instance fields the initial state you want them to have.
There is an important difference between constructors and other methods.
A constructor can only be called in conjunction with the new operator.
You can’t apply a constructor to an existing object to reset the instance fields.
We will have more to say about constructors later in this chapter.
Keep in mind, however, that all Java objects are constructed on the heap and that a constructor must be combined with new.
It is a common error of C++ programmers to forget the new operator:
Caution Be careful not to introduce local variables with the same names as the instance fields.
For example, the following constructor will not set the salary:
This is a nasty error that can be hard to track down.
You just have to be careful in all of your methods to not use variable names that equal the names of instance fields.
The first parameter, called the implicit parameter, is the object of type Employee that appears before the method name.
The second parameter, the number inside the parentheses after the method name, is an.
As you can see, the explicit parameters are explicitly listed in the method declaration,
The implicit parameter does not appear in the method declaration.
In every method, the keyword this refers to the implicit parameter.
If you like, you can write the raiseSalary method as follows:
Some programmers prefer that style because it clearly distinguishes between instance fields and local variables.
If you define a method inside a class, then it is, automatically, an inline method.
In Java, all methods are defined inside the class itself.
Finding opportunities for inline replacement is the job of the Java virtual machine.
The just-in-time compiler watches for calls to methods that are short, commonly called, and not overridden, and optimizes them away.
Finally, let’s look more closely at the rather simple getName, getSalary, and.
Wouldn’t it be easier to make the name, salary, and hireDay fields public, instead of.
Thus, we have a guarantee that the name field will never be corrupted.
The salary field is not read-only, but it can only be changed by the raiseSalary method.
In particular, should the value ever turn out wrong, only that method needs to be debugged.
Had the salary field been public, the culprit for messing up the value could have been anywhere.
Sometimes, it happens that you want to get and set the value of an instance field.
This is a lot more tedious than supplying a single public data field, but there are considerable benefits.
First, you can change the internal implementation without affecting any code other than the methods of the class.
For example, if the storage of the name is changed to.
This change is completely invisible to the remainder of the program.
Of course, the accessor and mutator methods may need to do a lot of work and.
That leads us to our second benefit: Mutator methods can perform error checking, whereas code that simply assigns to a field may not go into the trouble.
For example, a setSalary method might check that the salary is never less than 0
Caution Be careful not to write accessor methods that return references to mutable objects.
We violated that rule in our Employee class in which the getHireDay method returns an object of class Date:
Both d and harry.hireDay refer to the same object (see Figure 4.5)
Applying mutator methods to d automatically changes the private state of the employee object!
If you need to return a reference to a mutable object, you should clone it first.
A clone is an exact copy of an object stored in a new location.
As a rule of thumb, always use clone whenever you need to return a copy of a mutable data field.
You know that a method can access the private data of the object on which it is.
What many people find surprising is that a method can access the private data of all objects of its class.
This method accesses the private fields of harry, which is not surprising.
This is legal because boss is an object of type Employee, and a method of the Employee class is permitted to access the private fields of any object of type Employee.
A method can access the private features of any object of its class, not just of the implicit parameter.
When implementing a class, we make all data fields private because public data are.
But what about the methods? While most methods are public, private methods are useful in certain circumstances.
Sometimes, you may wish to break up the code for a computation into separate helper methods.
Typically, these helper methods should not be part of the public interface—they may be too close to the current implementation or require a special protocol or calling order.
To implement a private method in Java, simply change the public keyword to private.
By making a method private, you are under no obligation to keep it available if you change your implementation.
The method may well be harder to implement or unnecessary if the data representation changes: This is irrelevant.
The point is that as long as the method is private, the designers of the class can be assured that it is never used outside the other class, so they can simply drop it.
If a method is public, you cannot simply drop it because other code might rely on it.
That is, you must guarantee that the field value has been set after the end of every constructor.
For example, the name field of the Employee class may be declared as final because it never changes after the object is constructed—there is no setName method.
A class is immutable if none of its methods ever mutate its objects.
For example, the String class is immutable.) For mutable classes, the final modifier is likely to confuse the reader.
That does not mean that the hiredate object is constant.
Any method is free to invoke the setTime mutator on the object to which hiredate refers.
In all sample programs that you have seen, the main method is tagged with the.
We are now ready to discuss the meaning of this modifier.
If you define a field as static, then there is only one such field per class.
In contrast, each object has its own copy of all instance fields.
For example, let’s suppose we want to assign a unique identification number to each employee.
We add an instance field id and a static field nextId to the Employee class:
Every employee object now has its own id field, but there is only one nextId field that is shared among all instances of the class.
Even if there are no employee objects, the static field nextId is present.
It belongs to the class, not to any individual object.
Note In some object-oriented programming languages, static fields are called class fields.
Then, the id field of harry is set to the current value of the static field nextId, and.
You can access this constant in your programs as Math.PI.
If the keyword static had been omitted, then PI would have been an instance field.
That is, you would need an object of this class to access PI, and every Math object would have its own copy of PI.
Another static constant that you have used many times is System.out.
As we mentioned several times, it is never a good idea to have public fields, because everyone can modify them.
Since out has been declared as final, you cannot reassign another print stream to it:
Note If you look at the System class, you will notice a method setOut that sets System.out to a different stream.
You may wonder how that method can change the value of a final variable.
However, the setOut method is a native method, not implemented in the Java programming language.
Native methods can bypass the access control mechanisms of the Java language.
This is a very unusual workaround that you should not emulate in your programs.
Static methods are methods that do not operate on objects.
It does not use any Math object to carry out its task.
You can think of static methods as methods that don’t have a this parameter.
Since static methods don’t operate on objects, you cannot access instance fields from a static method.
However, static methods can access the static fields in their class.
Could you have omitted the keyword static for this method? Yes, but then you would need to have an object reference of type Employee to invoke the method.
Note It is legal to use an object to call a static method.
The getNextId method doesn’t look at harry at all to compute the result.
We recommend that you use class names, not objects, to invoke static methods.
Use static methods in two situations: • When a method doesn’t need to access the object state because all needed parameters are supplied as explicit parameters (example: Math.pow)
In C++, you use the :: operator to access a static field or method outside its scope, such as Math::PI.
At first, the keyword static was introduced in C to denote local variables that don’t go away when a block is exited.
In that context, the term “static” makes sense: The variable stays around and is still there when the block is entered again.
Then static got a second meaning in C, to denote global variables and functions that cannot be accessed from other files.
The keyword static was simply reused, to avoid introducing a new keyword.
That is the same meaning the keyword has in Java.
Why doesn’t the NumberFormat class use a constructor instead? There are two reasons:
The constructor name is always the same as the class name.
But we want two different names to get the currency instance and the percent instance.
When you use a constructor, you can’t vary the type of the constructed object.
But the factory methods actually return objects of the class DecimalFormat, a subclass that inherits from NumberFormat.
Note that you can call static methods without having any objects.
For the same reason, the main method is a static method.
In fact, when a program starts, there aren’t any objects yet.
The static main method executes, and constructs the objects that the program needs.
For example, you can add a main method to the Employee class:
If you want to test the Employee class in isolation, simply execute.
The program in Listing 4.3 contains a simple version of the Employee class with a static field nextId and a static method getNextId.
We fill an array with three Employee objects and then print the employee information.
Finally, we print the next available identification number, to demonstrate the static method.
Note that the Employee class also has a static main method for unit testing.
Let us review the computer science terms that describe how parameters can be.
The term call by value means that the method gets just the value that the caller provides.
In contrast, call by reference means that the method gets the location of the variable that the caller provides.
Thus, a method can modify the value stored in a variable passed by reference but not in one passed by value.
There is also a call by name that is mainly of historical interest, being employed in the Algol programming language, one of the oldest high-level languages.)
That means that the method gets a copy of all parameter values.
In particular, the method cannot modify the contents of any parameter variables passed to it.
No matter how the method is implemented, we know that after the method call, the value of percent is still 10
Let us look a little more closely at this situation.
Suppose a method tried to triple the value of a method parameter:
After the method call, the value of percent is still 10
The method ends, and the parameter variable x is no longer in use.
You have seen that it is impossible for a method to change a primitive type parameter.
You can easily implement a method that triples the salary of an employee:
The Employee object to which both x and harry refer gets its salary raised by 200 percent.
The method ends, and the parameter variable x is no longer in use.
Of course, the object variable harry continues to refer to the object whose salary was tripled (see Figure 4.7)
The method gets a copy of the object reference, and both the original and the copy refer to the same object.
Many programming languages (in particular, C++ and Pascal) have two mechanisms for parameter passing: call by value and call by reference.
Some programmers (and unfortunately even some book authors) claim that Java uses call by reference for objects.
As this is such a common misunderstanding, it is worth examining a counterexample in detail.
Let’s try to write a method that swaps two employee objects:
If the Java programming language used call by reference for objects, this method would work:
However, the method does not actually change the object references that are stored in the variables a and b.
The x and y parameters of the swap method are initialized with copies of these references.
When the method ends, the parameter variables x and y are abandoned.
The original variables a and b still refer to the same objects as they did before the method call (see Figure 4.8)
This demonstrates that the Java programming language does not use call by reference for objects.
Here is a summary of what you can and cannot do with method parameters in Java: • A method cannot modify a parameter of a primitive type (that is, numbers or boolean values)
A method can change the state of an object parameter.
A method cannot make an object parameter refer to a new object.
The program first tries to triple the value of a number parameter and does not succeed:
After the method, the state of the object to which harry refers has changed.
This is possible because the method modified the state through a copy of the object reference.
As you can see, the parameter variables x and y are swapped, but the variables a and b are not affected.
You have seen how to write simple constructors that define the initial state of your.
However, since object construction is so important, Java offers quite a variety of mechanisms for writing constructors.
We go over these mechanisms in the sections that follow.
Recall that the GregorianCalendar class had more than one constructor.
Overloading occurs if several methods have the same name (in this case, the GregorianCalendar constructor method) but different parameters.
It picks the correct method by matching the parameter types in the headers of the various methods with the types of the values used in the specific method call.
A compile-time error occurs if the compiler cannot match the parameters or if more than one match is possible.
Note Java allows you to overload any method—not just constructor methods.
Thus, to completely describe a method, you need to specify its name together with its parameter types.
For example, the String class has four public methods called indexOf.
The return type is not part of the method signature.
That is, you cannot have two methods with the same names and parameter types but different return types.
If you don’t set a field explicitly in a constructor, it is automatically set to a default.
Some people consider it poor programming practice to rely on the defaults.
Certainly, it makes it harder for someone to understand your code if fields are being initialized invisibly.
Note This is an important difference between fields and local variables.
You must always explicitly initialize local variables in a method.
But in a class, if you don’t initialize a field, it is automatically initialized to a default (0, false, or null)
By default, the salary field would be initialized with 0 and the name and hireDay fields would be initialized with null.
If anyone called the getName or getHireDay method, they would get a null reference that they probably don’t expect:
Many classes contain a constructor with no arguments that creates an object whose.
For example, here is a constructor with no arguments for the Employee class:
If you write a class with no constructors whatsoever, then a no-argument constructor is provided for you.
This constructor sets all the instance fields to their default values.
So, all numeric data contained in the instance fields would be 0, all boolean values would be false, and all object variables would be set to null.
If a class supplies at least one constructor but does not supply a no-argument constructor, it is illegal to construct objects without supplying arguments.
For example, our original Employee class in Listing 4.2 provided a single constructor:
Employee(String name, double salary, int y, int m, int d) With that class, it was not legal to construct default employees.
Caution Please keep in mind that you get a free no-argument constructor only when your class has no other constructors.
If you write your class with even a single constructor of your own and you want the users of your class to have the ability to create an instance by a call to.
Of course, if you are happy with the default values for all fields, you can simply supply.
By overloading the constructor methods in a class, you can build many ways to set.
This syntax is particularly useful if all constructors of a class need to set a particular instance field to the same value.
The initialization value doesn’t have to be a constant value.
Here is an example in which a field is initialized with a method call.
Consider an Employee class where each employee has an id field.
However, C++ has a special initializer list syntax, such as.
In Java, there is no need for that because objects have no subobjects, only pointers to other objects.
When you write very trivial constructors (and you’ll write a lot of them), it can be.
However, the drawback is that you need to read the code to tell what the n and s parameters mean.
Any reader can immediately figure out the meaning of the parameters.
Another commonly used trick relies on the fact that parameter variables shadow instance fields with the same name.
For example, if you call a parameter salary, then salary refers to the parameter, not the instance field.
But you can still access the instance field as this.salary.
Recall that this denotes the implicit parameter, that is, the object that is being constructed.
The letters m and x are common choices.) For example, the salary field might be called _salary, mSalary, or xSalary.
The keyword this refers to the implicit parameter of a method.
If the first statement of a constructor has the form this(
When you call new Employee(60000), the Employee(double) constructor calls the Employee(String, double) constructor.
Using the this keyword in this manner is useful—you only need to write common construction code once.
However, in C++ it is not possible for one constructor to call another.
If you want to factor out common initialization code in C++, you must write a separate method.
You have already seen two ways to initialize a data field:
By setting a value in a constructor • By assigning a value in the declaration.
There is a third mechanism in Java, called an initialization block.
These blocks are executed whenever an object of that class is constructed.
In this example, the id field is initialized in the object initialization block, no matter which constructor is used to construct an object.
The initialization block runs first, and then the body of the constructor is executed.
It is usually more straightforward to place the initialization code inside a constructor.
Note It is legal to set fields in initialization blocks even if they are only defined later in the class.
However, to avoid circular definitions, it is not legal to read from fields that are only initialized later.
The exact rules are spelled out in section 8.3.2.3 of the Java Language Specification (http://docs.oracle.com/javase/specs)
The rules are complex enough to baffle the compiler implementors—early versions of Java implemented them with subtle errors.
Therefore, we suggest that you always place initialization blocks after the field definitions.
With so many ways of initializing data fields, it can be quite confusing to give all possible pathways for the construction process.
Here is what happens in detail when a constructor is called:
All data fields are initialized to their default values (0, false, or null)
All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration.
If the first line of the constructor calls a second constructor, then the body of the second constructor is executed.
Naturally, it is always a good idea to organize your initialization code so that another programmer could easily understand it without having to be a language lawyer.
For example, it would be quite strange and somewhat error-prone to have a class whose constructors depend on the order in which the data fields are declared.
To initialize a static field, either supply an initial value or use a static initialization block.
Place the code inside a block and tag it with the keyword static.
Like instance fields, static fields are 0, false, or null unless you explicitly set them to another value.
All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration.
You can avoid that blemish by calling System.exit(0) at the end of the static initialization block.
The program in Listing 4.5 shows many of the features that we discussed in this section:
The most common activity in a destructor is reclaiming the memory set aside for objects.
Since Java does automatic garbage collection, manual memory reclamation is not needed, so Java does not support destructors.
Of course, some objects utilize a resource other than memory, such as a file or a handle to another object that uses system resources.
In this case, it is important that the resource be reclaimed and recycled when it is no longer needed.
The finalize method will be called before the garbage collector sweeps away the object.
In practice, do not rely on the finalize method for recycling any resources that are in short supply—you simply cannot know when this method will be called.
However, this method is inherently unsafe and has been deprecated.
If a resource needs to be closed as soon as you have finished using it, you need to manage it manually.
Supply a close method that does the necessary cleanup, and call it when you are done with the object.
Java allows you to group classes in a collection called a package.
The standard Java library is distributed over a number of packages, including java.lang, java.util, java.net, and so on.
Just as you have nested subdirectories on your hard disk, you can organize packages by using levels of nesting.
All standard Java packages are inside the java and javax package hierarchies.
The main reason for using packages is to guarantee the uniqueness of class names.
Suppose two programmers come up with the bright idea of supplying an Employee class.
As long as both of them place their class into different packages, there is no conflict.
In fact, to absolutely guarantee a unique package name, use an Internet domain name (which is known to be unique) written in reverse.
For example, horstmann.com is a domain that one of the authors registered.
Written in reverse order, it turns into the package com.horstmann.
From the point of view of the compiler, there is absolutely no relationship between nested packages.
For example, the packages java.util and java.util.jar have nothing to do with each other.
A class can use all classes from its own package and all public classes from other.
The simpler, and more common, approach is to use the import statement.
The point of the import statement is to give you a shorthand to refer to the classes in the package.
Once you use import, you no longer have to give the classes their full names.
You can import a specific class or the whole package.
You place import statements at the top of your source files (but below any package statements)
For example, you can import all classes in the java.util package with the statement.
However, if you import classes explicitly, the reader of your code knows exactly which classes you use.
Package statements such as import java.util.*; are automatically expanded into a list of specific imports such as.
However, note that you can only use the * notation to import a single package.
Most of the time, you just import the packages that you need, without worrying too much about them.
The only time that you need to pay attention to packages is when you have a name conflict.
For example, both the java.util and java.sql packages have a Date class.
The compiler cannot figure out which Date class you want.
You can solve this problem by adding a specific import statement:
What if you really need both Date classes? Then you need to use the full package name with every class name.
Locating classes in packages is an activity of the compiler.
The bytecodes in class files always use full package names to refer to other classes.
The Java compiler will happily look inside other files provided you tell it where to look.
In Java, you can entirely avoid the import mechanism by explicitly naming all classes, such as java.util.Date.
You can refer to a class by a name shorter than the full package name.
In C++, the construction analogous to the package mechanism is the namespace feature.
Think of the package and import statements in Java as the analogs of the namespace and using directives in C++
A form of the import statement permits the importing of static methods and fields,
In practice, it seems doubtful that many programmers will want to abbreviate System.out or System.exit.
To place classes inside a package, you must put the name of the package at the top of your source file, before the code that defines the classes in the package.
For example, the file Employee.java in Listing 4.7 starts out like this:
Up to now, all our example classes were located in the default package.
Place source files into a subdirectory that matches the full package name.
The compiler places the class files into the same directory structure.
To compile this program, simply change to the base directory and run the command javac PackageTest.java.
In this situation, you still must compile and run classes from the base directory, that is, the directory containing the com directory:
Note again that the compiler operates on files (with file separators and an extension .java), whereas the Java interpreter loads a class (with dot separators)
Tip Starting with the next chapter, we will use packages for the source code.
That way, you can make an IDE project for each chapter instead of each section.
Caution The compiler does not check the directory structure when it compiles source files.
For example, suppose you have a source file that starts with the directive.
You have already encountered the access modifiers public and private.
Private features can be used only by the class that defines them.
If you don’t specify either public or private, the feature (that is, the class, method, or variable) can be accessed by all methods in the same package.
The Employee class was not defined as a public class.
Variables must explicitly be marked private, or they will default to being package-visible.
The problem is that it is awfully easy to forget to type the private keyword.
Here is an example from the Window class in the java.awt package, which is part of the source code supplied with the JDK:
Actually, the only methods that access this variable are in the Window class, so it would have been entirely appropriate to make the variable private.
We suspect that the programmer typed the code in a hurry and simply forgot the private modifier.
We won’t mention the programmer’s name to protect the guilty—you can look into the source file yourself.)
Note Amazingly enough, this problem has never been fixed, even though we have pointed it out in eight editions of this book—apparently the library implementors don’t read Core Java.
Not only that—new fields have been added to the class over time, and about half of them aren’t private either.
That is, anyone can add more classes to a package.
Of course, hostile or clueless programmers can then add code that modifies variables with package visibility.
For example, in early versions of Java, it was an easy matter to smuggle another class into the java.awt package.
Through this subterfuge, it was possible to set the warning string (see Figure 4.9)
Starting with version 1.2, the JDK implementors rigged the class loader to explicitly disallow loading of user-defined classes whose package name starts with "java."
Of course, your own classes won’t benefit from that protection.
Instead, you can use another mechanism, package sealing, to address the issue of promiscuous package.
If you seal a package, no further classes can be added to it.
You will see in Chapter 10 how you can produce a JAR file that contains sealed packages.
As you have seen, classes are stored in subdirectories of the file system.
Class files can also be stored in a JAR (Java archive) file.
When you use a third-party library in your programs, you will usually be given one or more JAR files to include.
The JDK also supplies a number of JAR files, such as the file jre/lib/rt.jar that contains thousands of library classes.
You will see in Chapter 10 how to create your own JAR files.
Tip JAR files use the ZIP format to organize files and subdirectories.
You can use any ZIP utility to peek inside rt.jar and other JAR files.
To share classes among programs, you need to do the following: 1
Note that this directory is the base directory for the package tree.
The class path is the collection of all locations that can contain class files.
In UNIX, the * must be escaped to prevent shell expansion.
All JAR files (but not .class files) in the archives directory are included in this class.
The runtime library files (rt.jar and the other JAR files in the jre/lib and jre/lib/ext directories) are always searched for classes; don’t include them explicitly in the class path.
Caution The javac compiler always looks for files in the current directory, but the java virtual machine launcher only looks into the current directory if the “.” directory is on the class path.
But if you have set the class path and forgot to include the “.” directory, your programs will compile without error, but they won’t run.
The class path lists all directories and archive files that are starting points for locating classes.
It first looks in the system class files that are stored in archives in the jre/lib and jre/lib/ext directories.
It won’t find the class file there, so it turns to the class path.
The compiler has a harder time locating files than does the virtual machine.
If you refer to a class without specifying its package, the compiler first needs to find out the package that contains the class.
It consults all import directives as possible sources for the class.
It searches for each of these classes in all of the locations of the class path.
It is a compile-time error if more than one class is found.
Classes must be unique, so the order of the import statements doesn’t matter.)
It looks at the source files to see if the source is newer than the class file.
Recall that you can import only public classes from other packages.
A source file can only contain one public class, and the names of the file and the public class must match.
Therefore, the compiler can easily locate source files for public classes.
However, you can import nonpublic classes from the current package.
These classes may be defined in source files with different names.
If you import a class from the current package, the compiler searches all source files of the current package to see which one defines the class.
The entire command must be typed onto a single line.
It is a good idea to place such a long command line into a shell script or a batch file.
Using the -classpath option is the preferred approach for setting the class path.
Caution Some people recommend to set the CLASSPATH environment variable permanently.
People forget the global setting, and are surprised when their classes are not loaded properly.
A particularly reprehensible example is Apple’s QuickTime installer in Windows.
For several years, it globally set CLASSPATH to point to a JAR file it needed, but did not include the current directory in the classpath.
As a result, countless Java programmers were driven to distraction when their programs compiled but failed to run.
Caution Some people recommend to bypass the class path altogether, by dropping all JAR files into the jre/lib/ext directory.
Archives that manually load other classes do not work correctly when they are placed in the extension directory.
See Volume II, Chapter 9 for more information on class loaders.) Moreover, programmers have a tendency to forget about the files they placed there months ago.
Then, they scratch their heads when the class loader seems to ignore their carefully crafted class path because it is actually loading long-forgotten classes from the extension directory.
The JDK contains a very useful tool, called javadoc, that generates HTML.
If you add comments that start with the special delimiter /** to your source code, you too can easily produce professional looking documentation.
This is a very nice approach because it lets you keep your code and documentation in one place.
If you put your documentation into a separate file, then, as you probably know, the code and comments will tend to diverge over time.
When documentation comments are in the same file as the source code, it is an easy matter to update both and run javadoc again.
You can (and should) supply a comment for each of these features.
The first sentence of the free-form text should be a summary statement.
The javadoc utility automatically generates summary pages that extract these sentences.
Note If your comments contain links to other files such as images (for example, diagrams or images of user interface components), place those files into a subdirectory of the directory containing the source file, named doc-files.
The javadoc utility will copy the doc-files directories and their contents from the source directory to the documentation directory.
The class comment must be placed after any import statements, directly before the.
Note There is no need to add an * in front of every line.
A <code>Card</code> object represents a playing card, such as "Queen of Hearts"
However, most IDEs supply the asterisks automatically and rearrange them when the line breaks change.
Each method comment must immediately precede the method that it describes.
The description can span multiple lines and can use HTML tags.
All @param tags for one method must be kept together.
The description can span multiple lines and can use HTML tags.
You only need to document public fields—generally that means static constants.
The following tags can be used in class documentation comments:
You can have multiple @author tags, one for each author.
The text can be any description of the current version.
The text can be any description of the version that introduced this feature.
You supply the name of a class, method, or variable, and javadoc inserts a hyperlink to the documentation.
You can omit the name of the package, or both the package and class name.
Then, the feature will be located in the current package or class.
Note that you must use a #, not a period, to separate the class from the method or variable name.
The Java compiler itself is highly skilled in guessing the various meanings of the period character as separator between packages, subpackages, classes, inner classes, and methods and variables.
In each of these cases, you can specify an optional label that will appear as the link anchor.
If you omit the label, the user will see the target code name or URL as the anchor.
If you like, you can place hyperlinks to other classes or methods anywhere in any of your documentation comments.
The feature description follows the same rules as for the @see tag.
You place the class, method, and variable comments directly into the Java source.
However, to generate package comments, you need to add a separate file in each package directory.
You can also supply an overview comment for all source files.
Place it in a file called overview.html, located in the parent directory that contains all the source files.
This comment is displayed when the user selects “Overview” from the navigation bar.
Here, docDirectory is the name of the directory where you want the HTML files to go.
Change to the directory that contains the source files you want to document.
This is the directory that contains the overview.html file, if you supplied one.)
If your files are in the default package, run instead.
If you omit the -d docDirectory option, the HTML files are extracted to the current directory.
The javadoc program can be fine-tuned by numerous command-line options.
By default, they are omitted.) Another useful option is -link, to include hyperlinks to standard classes.
If you use the -linksource option, each source file is converted to HTML (without.
For additional options, we refer you to the online documentation of the javadoc utility at http://docs.oracle.com/javase/1.5.0/docs/guide/javadoc.
Clearly, this is a specialized need; for details on doclets, we refer you to the online documentation at http://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/doclet/overview.html.
Without trying to be comprehensive or tedious, we want to end this chapter with.
This is first and foremost; doing anything else violates encapsulation.
You may need to write an accessor or mutator method occasionally, but you are still better off keeping the instance fields private.
Bitter experience shows that the data representation may change, but how this data are used will change much less frequently.
When data are kept private, changes in their representation will not affect the user of the class, and bugs are easier to detect.
Java won’t initialize local variables for you, but it will initialize instance fields of objects.
Don’t rely on the defaults, but initialize all variables explicitly, either by supplying a default or by setting defaults in all constructors.
The idea is to replace multiple related uses of basic types with other classes.
This keeps your classes easier to understand and to change.
For example, replace the following instance fields in a Customer class:
This way, you can easily cope with changes to addresses, such as the need to deal with international addresses.
You may need to get and set an employee’s salary.
You certainly won’t need to change the hiring date once the object is constructed.
And, quite often, objects have instance fields that you don’t want others to get or set, such as an array of state abbreviations in an Address class.
However, if there is an obvious way to break one complicated class into two classes that are conceptually simpler, seize the opportunity.
On the other hand, don’t go overboard; ten classes, each with only one method, are usually an overkill.) Here is an example of a bad design:
This class really implements two separate concepts: a deck of cards, with its shuffle and draw methods, and a card, with the methods to inspect its value and suit.
It makes sense to introduce a Card class that represents an individual card.
Now you have two classes, each with its own responsibilities:
Make the names of your classes and methods reflect their responsibilities.
Just as variables should have meaningful names that reflect what they represent, so should classes.
The standard library certainly contains some dubious examples, such as the Date class that describes time.) A good convention is that a class name should be a noun (Order), or a noun preceded by an adjective (RushOrder) or a gerund (an “-ing” word, like BillingAddress)
As for methods, follow the standard convention that accessor methods begin with a lowercase get (getSalary) and mutator methods use a lowercase set (setSalary)
In this chapter, we covered the fundamentals of objects and classes that make Java an “object-based” language.
In order to be truly object-oriented, a programming language must also support inheritance and polymorphism.
The Java support for these features is the topic of the next chapter.
In this chapter, you will learn about inheritance, another fundamental concept of object-oriented programming.
The idea behind inheritance is that you can create new classes that are built on existing classes.
When you inherit from an existing class, you reuse (or inherit) its methods, and you can add new methods and fields to adapt your new class to new situations.
This chapter also covers reflection, the ability to find out more about classes and their properties in a running program.
Reflection is a powerful feature, but it is undeniably complex.
Since reflection is of greater interest to tool builders than to application programmers, you can probably glance over that part of the chapter upon first reading and come back to it later.
Let’s return to the Employee class that we discussed in the previous chapter.
Suppose (alas) you work for a company at which managers are treated differently from other employees.
Managers are, of course, just like employees in many respects.
However, while employees are expected to complete their assigned tasks in return for receiving their salary, managers get bonuses if they actually achieve what they are supposed to do.
This is the kind of situation that cries out for inheritance.
Why? Well, you need to define a new class, Manager, and add functionality.
But you can retain some of what you have already programmed in the Employee class, and all the fields of the original class can be preserved.
More abstractly, there is an obvious “is–a” relationship between Manager and Employee.
Every manager is an employee: This “is–a” relationship is the hallmark of inheritance.
Here is how you define a Manager class that inherits from the Employee class.
Java uses the extends keyword instead of the : token.
All inheritance in Java is public inheritance; there is no analog to the C++ features of private and protected inheritance.
The keyword extends indicates that you are making a new class that derives from an existing class.
The existing class is called the superclass, base class, or parent class.
The new class is called the subclass, derived class, or child class.
The terms superclass and subclass are those most commonly used by Java programmers, although some programmers prefer the parent/child analogy, which also ties in nicely with the “inheritance” theme.
The Employee class is a superclass, but not because it is superior to its subclass or contains more functionality.
In fact, the opposite is true: Subclasses have more functionality than their superclasses.
For example, as you will see when we go over the rest of the Manager class code, the Manager class encapsulates more data and has more functionality than its superclass Employee.
Note The prefixes super and sub come from the language of sets used in theoretical computer science and mathematics.
The set of all employees contains the set of all managers, and this is said to be a superset of the set of managers.
Or, to put it another way, the set of all managers is a subset of the set of all employees.
Our Manager class has a new field to store the bonus, and a new method to set it:
If you have a Manager object, you can simply apply the setBonus method.
However, you can use methods such as getName and getHireDay with Manager.
Even though these methods are not explicitly defined in the Manager class, they are automatically inherited from the Employee superclass.
Similarly, the fields name, salary, and hireDay are taken from the superclass.
Every Manager object has four fields: name, salary, hireDay, and bonus.
When defining a subclass by extending its superclass, you only need to indicate the differences between the subclass and the superclass.
When designing classes, you place the most general methods into the superclass and more specialized methods in its subclasses.
Factoring out common functionality by moving it to a superclass is common in object-oriented programming.
However, some of the superclass methods are not appropriate for the Manager subclass.
In particular, the getSalary method should return the sum of the base salary and the bonus.
You need to supply a new method to override the superclass method:
The getSalary method of the Manager class has no direct access to the private fields of the superclass.
This means that the getSalary method of the Manager class cannot directly access the salary field, even though every Manager object has a field called salary.
Only the methods of the Employee class have access to the private fields.
If the Manager methods want to access those private fields, they have to do what every other method does—use the public interface, in this case, the public getSalary method of the Employee class.
You need to call getSalary instead of simply accessing the salary field.
The problem is that the call to getSalary simply calls itself, because the Manager class has a getSalary method (namely, the method we are trying to implement)
The consequence is an infinite chain of calls to the same method, leading to a program crash.
We need to indicate that we want to call the getSalary method of the Employee super-class, not the current class.
Note Some people think of super as being analogous to the this reference.
However, that analogy is not quite accurate: super is not a reference to an object.
For example, you cannot assign the value super to another object variable.
Instead, super is a special keyword that directs the compiler to invoke the superclass method.
As you saw, a subclass can add fields, and it can add methods or override the methods of the superclass.
However, inheritance can never take away any fields or methods.
C++ Note Java uses the keyword super to call a superclass method.
In C++, you would use the name of the superclass with the :: operator instead.
Since the Manager constructor cannot access the private fields of the Employee.
The call using super must be the first statement in the constructor for the subclass.
If the subclass constructor does not call a superclass constructor explicitly, the no-argument constructor of the superclass is invoked.
If the superclass does not have a no-argument constructor and the subclass constructor does not call another superclass constructor explicitly, the Java compiler reports an error.
Note Recall that the this keyword has two meanings: to denote a reference to the implicit parameter and to call another constructor of the same class.
Likewise, the super keyword has two meanings: to invoke a superclass method and to invoke a superclass constructor.
When used to invoke constructors, the this and super keywords are closely related.
The constructor calls can only occur as the first statement in another constructor.
The constructor parameters are either passed to another constructor of the same class (this) or a constructor of the superclass (super)
Having redefined the getSalary method for Manager objects, managers will automatically have the bonus added to their salaries.
We make a new manager and set the manager’s bonus:
However, staff[0] is a Manager object whose getSalary method adds the bonus to the base salary.
Note that the declared type of e is Employee, but the actual type of the object to which e refers can be either Employee or Manager.
When e refers to an Employee object, then the call e.getSalary() calls the getSalary method of the Employee class.
However, when e refers to a Manager object, then the getSalary method of the Manager class is called instead.
The virtual machine knows about the actual type of the object to which e refers, and therefore can invoke the correct method.
The fact that an object variable (such as the variable e) can refer to multiple actual types is called polymorphism.
Automatically selecting the appropriate method at runtime is called dynamic binding.
We discuss both topics in more detail in this chapter.
C++ Note In Java, you do not need to declare a method as virtual.
If you do not want a method to be virtual, you tag it as final.
Inheritance need not stop at deriving one layer of classes.
The collection of all classes extending a common superclass is called an inheritance hierarchy, as shown in Figure 5.1
The path from a particular class to its ancestors in the inheritance hierarchy is its inheritance chain.
There is usually more than one chain of descent from a distant ancestor class.
You could form subclasses Programmer or Secretary that extend Employee, and they would have nothing to do with the Manager class (or with each other)
A simple rule can help you decide whether or not inheritance is the right design.
The “is–a” rule states that every object of the subclass is an object of the superclass.
Thus, it makes sense for the Manager class to be a subclass of the Employee class.
Naturally, the opposite is not true—not every employee is a manager.
Another way of formulating the “is–a” rule is the substitution principle.
A variable of type Employee can refer to an object of type Employee or to an object of any subclass of the Employee class (such as Manager, Executive, Secretary, and so on)
In this case, the variables staff[0] and boss refer to the same object.
However, staff[0] is considered to be only an Employee object by the compiler.
The declared type of staff[0] is Employee, and the setBonus method is not a method of the Employee class.
However, you cannot assign a superclass reference to a subclass variable.
For example, it is not legal to make the assignment.
Caution In Java, arrays of subclass references can be converted to arrays of superclass references without a cast.
After all, if managers[i] is a Manager, it is also an Employee.
Keep in mind that managers and staff are references to the same array.
To make sure no such corruption can occur, all arrays remember the element type with which they were created, and they monitor that only compatible references are stored into them.
For example, the array created as new Manager[10] remembers that it is an array of managers.
It is important to understand what happens when a method call is applied to an.
The compiler looks at the declared type of the object and the method name.
Let’s say we call x.f(param), and the implicit parameter x is declared to be an object of class C.
Note that there may be multiple methods, all with the same name, f, but with different parameter types.
For example, there may be a method f(int) and a method f(String)
The compiler enumerates all methods called f in the class C and all accessible methods called f in the superclasses of C.
Private methods of the superclass are not accessible.) Now the compiler knows all possible candidates for the method to be called.
Next, the compiler determines the types of the parameters that are supplied in the method call.
If among all the methods called f there is a unique method whose parameter types are a best match for the supplied parameters, then that method is chosen to be called.
For example, in a call x.f("Hello"), the compiler picks f(String) and not f(int)
The situation can get complex because of type conversions (int to double, Manager to Employee, and so on)
If the compiler cannot find any method with matching parameter types or if multiple methods all match after applying conversions, the compiler reports an error.
Now the compiler knows the name and parameter types of the method that needs to be called.
Note Recall that the name and parameter type list for a method is called the method’s signature.
For example, f(int) and f(String) are two methods with the same name but different signatures.
If you define a method in a subclass that has the same signature as a superclass method, then you.
However, when you override a method, you need to keep the return type compatible.
A subclass may change the return type to a subtype of the original type.
For example, suppose that the Employee class has a method.
If the method is private, static, final, or a constructor, then the compiler knows exactly which method to call.
The final modifier is explained in the next section.) This is called static binding.
Otherwise, the method to be called depends on the actual type of the implicit parameter, and dynamic binding must be used at runtime.
In our example, the compiler would generate an instruction to call f(String) with dynamic binding.
When the program runs and uses dynamic binding to call a method, then the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers.
Let’s say the actual type is D, a subclass of C.
If the class D defines a method f(String), that method is called.
If not, D’s superclass is searched for a method f(String), and so on.
It would be time-consuming to carry out this search every time a method is called.
Therefore, the virtual machine precomputes for each class a method table that lists all method signatures and the actual methods to be called.
When a method is actually called, the virtual machine simply makes a table lookup.
In our example, the virtual machine consults the method table for the class D and looks up the method to call for f(String)
That method may be D.f(String) or X.f(String), where X is some superclass of D.
If the call is super.f(param), then the compiler consults the method table of the superclass of the implicit parameter.
Let’s look at this process in detail in the call e.getSalary() in Listing 5.1
The Employee class has a single method, called getSalary, with no method parameters.
Therefore, in this case, we don’t worry about overloading resolution.
The getSalary method is not private, static, or final, so it is dynamically bound.
The virtual machine produces method tables for the Employee and Manager classes.
The Employee table shows that all methods are defined in the Employee class itself:
Actually, that isn’t the whole story—as you will see later in this chapter, the Employee class has a superclass Object from which it inherits a number of methods.
Three methods are inherited, one method is redefined, and one method is added.
At runtime, the call e.getSalary() is resolved as follows: 1
First, the virtual machine fetches the method table for the actual type of e.
That may be the table for Employee, Manager, or another subclass of Employee.
Then, the virtual machine looks up the defining class for the getSalary() signature.
Dynamic binding has a very important property: It makes programs extensible without the need for modifying existing code.
Suppose a new class Executive is added and there is the possibility that the variable e refers to an object of that class.
The code containing the call e.getSalary() need not be recompiled.
Caution When you override a method, the subclass method must be at least as visible as the superclass method.
In particular, if the superclass method is public, then the subclass method must also be declared as public.
It is a common error to accidentally omit the public specifier for the subclass method.
The compiler then complains that you try to supply a weaker access privilege.
Occasionally, you want to prevent someone from forming a subclass from one of.
Classes that cannot be extended are called final classes, and you use the final modifier in the definition of the class to indicate this.
For example, let us suppose we want to prevent others from subclassing the Executive class.
Simply declare the class using the final modifier, as follows:
You can also make a specific method in a class final.
If you do this, then no subclass can override that method.
All methods in a final class are automatically final.) For example:
Note Recall that fields can also be declared as final.
A final field cannot be changed after the object has been constructed.
However, if a class is declared final, only the methods, not the fields, are automatically final.
There is only one good reason to make a method or class final: to make sure that its semantics cannot be changed in a subclass.
For example, the getTime and setTime methods of the Calendar class are final.
This indicates that the designers of the Calendar class have taken over responsibility for the conversion between the Date class and the calendar state.
No subclass should be allowed to mess up this arrangement.
In other words, if you have a String reference, you know it refers to a String and nothing but a String.
Some programmers believe that you should declare all methods as final unless you have a good reason to want polymorphism.
That may be a bit extreme, but we agree that it is a good idea to think carefully about final methods and classes when you design a class hierarchy.
In the early days of Java, some programmers used the final keyword hoping to avoid the overhead of dynamic binding.
If a method is not overridden, and it is short, then a compiler can optimize the method call away—a process called inlining.
For example, inlining the call e.getName() replaces it with the field access e.name.
This is a worthwhile improvement—CPUs hate branching because it interferes with their strategy of prefetching instructions while processing the current one.
However, if getName can be overridden in another class, then the compiler cannot inline it because it has no way of knowing what the overriding code may do.
Fortunately, the just-in-time compiler in the virtual machine can do a better job than a traditional compiler.
It knows exactly which classes extend a given class, and it can check whether any class actually overrides a given method.
If a method is short, frequently called, and not actually overridden, the just-in-time compiler can.
What happens if the virtual machine loads another subclass that overrides an inlined method? Then the optimizer must undo the inlining.
Recall from Chapter 3 that the process of forcing a conversion from one type to.
The Java programming language has a special notation for casts.
Just as you occasionally need to convert a floating-point number to an integer, you may need to convert an object reference from one class to another.
To actually make a cast of an object reference, use a syntax similar to what you use for casting a numeric expression.
Surround the target class name with parentheses and place it before the object reference you want to cast.
For example, in the ManagerTest class, the staff array had to be an array of Employee objects because some of its entries were regular employees.
We would need to cast the managerial elements of the array back to Manager to access any of its new variables.
Note that in the sample code for the first section, we made a special effort to avoid the cast.
We initialized the boss variable with a Manager object before storing it in the array.
We needed the correct type to set the bonus of the manager.)
As you know, in Java every object variable has a type.
The type describes the kind of object the variable refers to and what it can do.
For example, staff[i] refers to an Employee object (so it can also refer to a Manager object)
The compiler checks that you do not promise too much when you store a value in a variable.
If you assign a subclass reference to a superclass variable, you are promising less, and the compiler will simply let you do it.
If you assign a super-class reference to a subclass variable, you are promising more.
Then you must use a cast so that your promise can be checked at runtime.
If you do not catch the exception, your program terminates.
Thus, it is good programming practice to find out whether a cast will succeed before attempting it.
Finally, the compiler will not let you make a cast if there is no chance for the cast to succeed.
Use instanceof to check before casting from a superclass to a subclass.
That makes sense: null refers to no object, so it certainly doesn’t refer to an object of type C.
Actually, converting the type of an object by performing a cast is not usually a good idea.
In our example, you do not need to cast an Employee object to a Manager object for most purposes.
The getSalary method will work correctly on both objects of both classes.
The dynamic binding that makes polymorphism work locates the correct method automatically.
The only reason to make the cast is to use a method that is unique to managers, such as setBonus.
If for some reason you find yourself wanting to call setBonus on Employee objects, ask yourself whether this is an indication of a design flaw in the superclass.
It may make sense to redesign the superclass and add a setBonus method.
Remember, it takes only one uncaught ClassCastException to terminate your program.
In general, it is best to minimize the use of casts and the instanceof operator.
In this sense, it is like a C++ cast of references.
In C++, you can take care of the type test and type conversion in one operation.
In Java, you need to use a combination of the instanceof operator and a cast.
As you move up the inheritance hierarchy, classes become more general and.
At some point, the ancestor class becomes so general that you think of it more as a basis for other classes than as a class with specific instances you want to use.
Consider, for example, an extension of our Employee class hierarchy.
An employee is a person, and so is a student.
Let us extend our class hierarchy to include classes Person and Student.
Why bother with so high a level of abstraction? There are some attributes that make sense for every person, such as name.
Both students and employees have names, and introducing a common superclass lets us factor out the getName method to a higher level in the inheritance hierarchy.
Now let’s add another method, getDescription, whose purpose is to return a brief description of the person, such as.
It is easy to implement this method for the Employee and Student classes.
But what information can you provide in the Person class? The Person class knows nothing about the person except the name.
If you use the abstract keyword, you do not need to implement the method at all.
For added clarity, a class with one or more abstract methods must itself be declared abstract.
In addition to abstract methods, abstract classes can have fields and concrete methods.
For example, the Person class stores the name of the person and has a concrete method that returns it.
Tip Some programmers don’t realize that abstract classes can have concrete methods.
You should always move common fields and methods (whether abstract or not) to the superclass (whether abstract or not)
Abstract methods act as placeholders for methods that are implemented in the subclasses.
When you extend an abstract class, you have two choices.
You can leave some or all of the abstract methods undefined; then you must tag the subclass as abstract as well.
Or you can define all methods, and the subclass is no longer abstract.
For example, we will define a Student class that extends the abstract Person class and implements the getDescription method.
None of the methods of the Student class are abstract, so it does not need to be declared as an abstract class.
A class can even be declared as abstract even though it has no abstract methods.
That is, if a class is declared as abstract, no objects of that class can be created.
Note that you can still create object variables of an abstract class, but such a.
Here p is a variable of the abstract type Person that refers to an instance of the nonabstract subclass Student.
A C++ class is abstract if it has at least one pure virtual function.
In C++, there is no special keyword to denote abstract classes.
Therefore, all methods in the Student class are concrete, and the class is no longer an abstract class.
The program shown in Listing 5.4 defines the abstract superclass Person (Listing.
We fill an array of Person references with employee and student objects:
Isn’t this a call to an undefined method? Keep in mind that the variable p never refers to a Person object because it is impossible to construct an object of the abstract Person class.
The variable p always refers to an object of a concrete subclass such as Employee or Student.
Could you have omitted the abstract method altogether from the Person superclass, simply defining the getDescription methods in the Employee and Student subclasses? If you did that, then you wouldn’t have been able to invoke the getDescription method on the variable p.
The compiler ensures that you invoke only methods that are declared in the class.
Abstract methods are an important concept in the Java programming language.
As you know, fields in a class are best tagged as private, and methods are.
Any features declared private won’t be visible to other classes.
As we said at the beginning of this chapter, this is also true for subclasses: A subclass cannot access the private fields of its superclass.
There are times, however, when you want to restrict a method to subclasses only or, less commonly, to allow subclass methods to access a superclass field.
In that case, you declare a class feature as protected.
For example, if the superclass Employee declares the hireDay field as protected instead of private, then the Manager methods can access it directly.
However, the Manager class methods can peek inside the hireDay field of Manager objects only, not of other Employee objects.
This restriction is made so that you can’t abuse the protected mechanism by forming subclasses just to gain access to the protected fields.
Suppose your class is used by other programmers and you designed it with protected fields.
Unknown to you, other programmers may inherit classes from your class and start accessing your protected fields.
In this case, you can no longer change the implementation of your class without upsetting the other programmers.
That is against the spirit of OOP, which encourages data encapsulation.
A class may declare a method as protected if it is tricky to use.
This indicates that the subclasses (which, presumably, know their ancestor well) can be trusted to use the method correctly, but other classes cannot.
As it happens, protected features in Java are visible to all subclasses as well as to all other classes in the same package.
Here is a summary of the four access modifiers in Java that control visibility: 1
The Object class is the ultimate ancestor—every class in Java extends Object.
However, you never have to write class Employee extends Object.
The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned.
Since every class in Java extends Object, it is important to be familiar with the services provided by the Object class.
We go over the basic ones in this chapter; consult the later chapters or view the online documentation for what is not covered here.
Of course, a variable of type Object is only useful as a generic holder for arbitrary values.
To do anything specific with the value, you need to have some knowledge about the original type and apply a cast:
Employee e = (Employee) obj; In Java, only the primitive types (numbers, characters, and boolean values) are.
All array types, no matter whether they are arrays of objects or arrays of.
However, every pointer can be converted to a void* pointer.
The equals method in the Object class tests whether one object is considered equal to another.
The equals method, as implemented in the Object class, determines whether two object references are identical.
This is a pretty reasonable default—if two objects are identical, they should certainly be equal.
For example, it makes little sense to compare two PrintStream objects for equality.
However, you will often want to implement statebased equality testing, in which two objects are considered equal when they have the same state.
For example, let us consider two employees equal if they have the same name, salary, and hire date.
In an actual employee database, it would be more sensible to compare IDs instead.
We use this example to demonstrate the mechanics of implementing the equals method.)
The getClass method returns the class of an object—we discuss this method in detail later in this chapter.
In our test, two objects can only be equal when they belong to the same class.
Tip To guard against the possibility that name or hireDay are null, use the Objects.equals method.
With that method, the last statement of the Employee.equals method becomes.
When you define the equals method for a subclass, first call equals on the superclass.
If that test doesn’t pass, then the objects can’t be equal.
If the superclass fields are equal, then you are ready to compare the instance fields of the subclass.
How should the equals method behave if the implicit and explicit parameters.
In the preceding example, the equals method returns false if the classes don’t match exactly.
The Java Language Specification requires that the equals method has the following properties:
It is reflexive: For any non-null reference x, x.equals(x) should return true.
It is symmetric: For any references x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
It is transitive: For any references x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
It is consistent: If the objects to which x and y refer haven’t changed, then repeated calls to x.equals(y) return the same value.
You wouldn’t want a library implementor to ponder whether to call x.equals(y) or y.equals(x) when locating an element in a data structure.
However, the symmetry rule has subtle consequences when the parameters belong to different classes.
If Employee.equals uses an instanceof test, the call returns true.
Some authors have gone on record that the getClass test is wrong because it violates the substitution principle.
A commonly cited example is the equals method in the AbstractSet class that tests whether two sets have the same elements.
The AbstractSet class has two concrete subclasses, TreeSet and HashSet, that use different algorithms for locating set elements.
You really want to be able to compare any two sets, no matter how they are implemented.
This allows a subclass to implement a more efficient algorithm for the equality test.)
The way we see it, there are two distinct scenarios: • If subclasses can have their own notion of equality, then the symmetry requirement forces you to use the getClass test.
If the notion of equality is fixed in the superclass, then you can use the instanceof test and allow objects of different subclasses to be equal to one another.
In the example with employees and managers, we consider two objects to be equal when they have matching fields.
If we have two Manager objects with the same name, salary, and hire date, but with different bonuses, we want them to be different.
But suppose we used an employee ID for equality testing.
Then we could use the instanceof test, and we should have declared Employee.equals as final.
Here is a recipe for writing the perfect equals method:
It is much cheaper to check for identity than to compare the fields.
Test whether otherObject is null and return false if it is.
If the semantics of equals can change in subclasses, use the getClass test:
Now compare the fields, as required by your notion of equality.
Use == for primitive type fields, Objects.equals for object fields.
Tip If you have fields of array type, you can use the static Arrays.equals method to check that the corresponding array elements are equal.
Caution Here is a common mistake when implementing the equals method.
Override public boolean equals(Object other) If you made a mistake and are defining a new method, the compiler reports an error.
For example, suppose you add the following declaration to the Employee class:
Override public boolean equals(Employee other) An error is reported because this method doesn’t override any method from the Object superclass.
The arrays can have component types Object, int, long, short, char, byte, boolean, float, or double.
A hash code is an integer that is derived from an object.
Table 5.1 lists a few examples of hash codes that result from the hashCode method of the String class.
That hash code is derived from the object’s memory address.
Note that the strings s and t have the same hash code because, for strings, the hash codes are derived from their contents.
The string builders sb and tb have different hash codes because no hashCode method has been defined for the StringBuilder class and the default hashCode method in the Object class derives the hash code from the object’s memory address.
If you redefine the equals method, you will also need to redefine the hashCode method for objects that users might insert into a hash table.
The hashCode method should return an integer (which can be negative)
Just combine the hash codes of the instance fields so that the hash codes for different objects are likely to be widely scattered.
For example, here is a hashCode method for the Employee class: class Employee.
However, as of Java 7, there are two improvements you can make.
First, it is better to use the null-safe method Objects.hashCode.
It returns 0 if its argument is null and the result of calling hashCode on the argument otherwise.
Even better, when you need to combine multiple hash values, call Objects.hash with all of them.
It will call Objects.hashCode for each argument and combine the values.
Your definitions of equals and hashCode must be compatible: If x.equals(y) is true, then x.hashCode() must return the same value as y.hashCode()
For example, if you define Employee.equals to compare employee IDs, then the hashCode method needs to hash the IDs, not employee names or memory addresses.
Tip If you have fields of an array type, you can use the static Arrays.hashCode method to compute a hash code composed of the hash codes of the array elements.
A hash code can be any integer, positive or negative.
Another important method in Object is the toString method that returns a string.
The toString method of the Point class returns a string like this:
Here is an implementation of the toString method for the Employee class:
Of course, the subclass programmer should define its own toString method and.
For example, here is a toString method for the Manager class:
The toString method is ubiquitous for an important reason: Whenever an object is concatenated with a string by the “+” operator, the Java compiler automatically invokes the toString method to obtain a string representation of the object.
Tip Instead of writing x.toString(), you can write "" + x.
This statement concatenates the empty string with the string representation of x that is exactly x.toString()
Unlike toString, this statement even works if x is of primitive type.
The Object class defines the toString method to print the class name and the.
The reason is that the implementor of the PrintStream class didn’t bother to override the toString method.
Caution Annoyingly, arrays inherit the toString method from Object, with the added twist that the array type is printed in an archaic format.
The prefix [I denotes an array of integers.) The remedy is to call the static Arrays.toString method instead.
Many classes in the standard class library define the toString method so that you can get useful information about the state of an object.
Tip We strongly recommend that you add a toString method to each class that you write.
You, as well as other programmers who use your classes, will be grateful for the logging support.
As you will see later in this chapter, Java has a runtime representation for classes that is encapsulated in the Class class.
String toString() returns a string that represents the value of this object.
Class getSuperclass() returns the superclass of this class as a Class object.
Programmers hate this because it forces them into uncomfortable trade-offs.
You can set the size of an array at runtime.
Of course, this code does not completely solve the problem of dynamically modifying arrays at runtime.
Once you set the array size, you cannot change it easily.
Instead, in Java you can deal with this common situation by using another Java class, called ArrayList.
The ArrayList class is similar to an array, but it automatically adjusts its capacity as you add and remove elements, without any additional code.
You will see in Chapter 13 how to define your own generic class, but you don’t need to know any of those technicalities to use the ArrayList type.
It is a bit tedious that the type parameter Employee is used on both sides.
As of Java 7, you can omit the type parameter on the right-hand side:
If it is assigned to a variable, passed into a method, or returned from a method, then the compiler checks the generic type of the variable, parameter, or method.
Note Before Java SE 5.0, there were no generic classes.
It is considered a “raw” type, with the type parameter erased.
Note In even older versions of Java, programmers used the Vector class for dynamic arrays.
However, the ArrayList class is more efficient, and there is no longer any good reason to use the Vector class.
Use the add method to add new elements to an array list.
For example, here is how you populate an array list with employee objects:
The array list manages an internal array of object references.
This is where array lists work their magic: If you call add and the internal array is full, the array list automatically creates a bigger array and copies all the objects from the smaller to the bigger array.
If you already know, or have a good guess, how many elements you want to store, call the ensureCapacity method before filling the array list:
You can also pass an initial capacity to the ArrayList constructor:
The size method returns the actual number of elements in the array list.
Once you are reasonably sure that the array list is at its permanent size, you can call the trimToSize.
This method adjusts the size of the memory block to use exactly as much storage space as is required to hold the current number of elements.
Once you trim the size of an array list, adding new elements will move the block again, which takes time.
You should only use trimToSize when you are sure you won’t add any more elements to the array list.
Java does not have operator overloading, so it must use explicit method calls instead.
If a and b are two vectors, then the assignment a = b makes a into a new vector with the same length as b, and all elements are copied from b to a.
The same assignment in Java makes both a and b refer to the same array list.
ArrayList<T>(int initialCapacity) constructs an empty array list with the specified capacity.
Of course, this is never larger than the array list’s capacity.) • void ensureCapacity(int capacity) ensures that the array list has the capacity to store the given number of elements without reallocating its internal storage array.
The reason is that the ArrayList class is not a part of the Java programming language; it is just a utility class programmed by someone and supplied in the standard library.
Instead of using the pleasant [] syntax to access or change the element of an array, you use the get and set methods.
Caution Do not call list.set(i, x) until the size of the array list is larger than i.
Use the add method instead of set to fill up an array, and use set only to replace a previously added element.
Note When there were no generic classes, the get method of the raw ArrayList class had no choice but to return an Object.
Consequently, callers of get had to cast the returned value to the desired type:
First, make an array list and add all the elements:
Sometimes, you need to add elements in the middle of an array list.
The elements at locations n and above are shifted up to make room for the new entry.
If the new size of the array list after the insertion exceeds the capacity, the array list reallocates its storage array.
The elements located above it are copied down, and the size of the array is reduced by one.
But if you store many elements and frequently insert and remove in the middle of a collection, consider using a linked list instead.
We explain how to program with linked lists in Chapter 13
You use add to add as many elements as you like.
You use size() instead of length to count the number of elements.
You use a.get(i) instead of a[i] to access an element.
In your own code, you will always want to use type parameters for added safety.
The staff object is simply passed to the update method.
Caution Even though you get no error or warning from the compiler, this call is not completely safe.
The update method might add elements into the array list that are not of type Employee.
This sounds scary, but if you think about it, the behavior is simply as it was before generics were added to Java.
In this situation, you do not lose security, but you also do not benefit from the compile-time checks.
Note To see the text of the warning, compile with the option -Xlint:unchecked.
Instead, you get a different warning, telling you that the cast is misleading.
This is the consequence of a somewhat unfortunate limitation of generic types in Java.
In a running program, all array lists are the same—there are no type parameters in the virtual machine.
When you interact with legacy code, study the compiler warnings and satisfy yourself that the warnings are not serious.
Occasionally, you need to convert a primitive type like int to an object.
For example, a class Integer corresponds to the primitive type int.
The first six inherit from the common superclass Number.) The wrapper classes are immutable—you cannot change a wrapped value after the wrapper has been constructed.
Unfortunately, the type parameter inside the angle brackets cannot be a primitive type.
It is OK to declare an array list of Integer objects.
You would only want to use this construct for small collections when programmer convenience is more important than efficiency.
Conversely, when you assign an Integer object to an int value, it is automatically unboxed.
The compiler automatically inserts instructions to unbox the object, increment the resulting value, and box it back.
In most cases, you get the illusion that the primitive types and their wrappers are one and the same.
There is just one point in which they differ considerably: identity.
As you know, the == operator, applied to wrapper objects, only tests whether the objects have identical memory locations.
However, a Java implementation may, if it chooses, wrap commonly occurring values into identical objects, and thus the comparison might succeed.
The remedy is to call the equals method when comparing wrapper objects.
Finally, let us emphasize that boxing and unboxing is a courtesy of the compiler, not the virtual machine.
The compiler inserts the necessary calls when it generates the bytecodes of a class.
You will often see the number wrappers for another reason.
The designers of Java found the wrappers a convenient place to put certain basic methods, such as those for converting strings of digits to numbers.
This has nothing to do with Integer objects—parseInt is a static method.
But the Integer class was a good place to put it.
The API notes show some of the more important methods of the Integer class.
Caution Some people think that the wrapper classes can be used to implement methods that can modify numeric parameters.
Recall from Chapter 4 that it is impossible to write a Java method that increments an integer parameter because parameters to Java methods are always passed by value.
The problem is that Integer objects are immutable: The information contained inside the wrapper can’t change.
You cannot use these wrapper classes to create a method that modifies numeric parameters.
If you do want to write a method to change numeric parameters, you can use one of the holder types defined in the org.omg.CORBA package: IntHolder, BooleanHolder, and so on.
The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method)
The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method)
Before Java SE 5.0, every Java method had a fixed number of parameters.
It denotes that the method can receive an arbitrary number of objects (in addition to the fmt parameter)
The printf method actually receives two parameters: the format string and an Object[] array that holds all other parameters.
If the caller supplies integers or other primitive type values, autoboxing turns them into objects.) It now faces the unenviable task of scanning the fmt string and matching up the ith format specifier with the value args[i]
In other words, for the implementor of printf, the Object...
The compiler needs to transform each call to printf, bundling the parameters into an array and autoboxing as necessary:
Here is a simple example: a function that computes the maximum of a variable number of values.
Note It is legal to pass an array as the last parameter of a method with variable parameters.
You saw in Chapter 3 how to define enumerated types.
Therefore, you never need to use equals for values of enumerated types.
You can, if you like, add constructors, methods, and fields to an enumerated type.
The most useful one is toString, which returns the name of the enumerated constant.
Each enumerated type has a static values method that returns an array of all values of the.
The ordinal method yields the position of an enumerated constant in the enum declaration, counting.
The short program in Listing 5.12 demonstrates how to work with enumerated types.
Note The Enum class has a type parameter that we have ignored for simplicity.
The ordering of the constants is given by the enum declaration.
The reflection library gives you a very rich and elaborate toolset to write programs that manipulate Java code dynamically.
This feature is heavily used in JavaBeans, the component architecture for Java (see Volume II for more on JavaBeans)
Using reflection, Java can support tools like those to which users of Visual Basic have grown accustomed.
In particular, when new classes are added at design time or runtime, rapid application development tools can dynamically inquire about the capabilities of these classes.
A program that can analyze the capabilities of classes is called reflective.
As the next sections show, you can use it to.
Reflection is a powerful and complex mechanism; however, it is of interest mainly to tool builders, not application programmers.
If you are interested in programming applications rather than tools for other Java programmers, you can safely skip the remainder of this chapter and return to it later.
While your program is running, the Java runtime system always maintains what is called runtime type.
This information keeps track of the class to which each object belongs.
Runtime type information is used by the virtual machine to select the correct methods to execute.
However, you can also access this information by working with a special Java class.
The class that holds this information is called, somewhat confusingly, Class.
The getClass() method in the Object class returns an instance of Class type.
Just like an Employee object describes the properties of a particular employee, a Class object describes the properties of a particular class.
Probably the most commonly used method of Class is getName.
If the class is in a package, the package name is part of the class name:
Use this method if the class name is stored in a string that varies at runtime.
This works if className is the name of a class or interface.
Tip At startup, the class containing your main method is loaded.
Each of those loaded classes loads the classes that it needs, and so on.
That can take a long time for a big application, frustrating the user.
You can give users of your program the illusion of a faster start with the following trick.
Then manually force the loading of other classes by calling Class.forName.
A third method for obtaining an object of type Class is a convenient shorthand.
If T is any Java type, then T.class is the matching class object.
Note that a Class object really describes a type, which may or may not be a class.
For example, int is not a class, but int.class is nevertheless an object of type Class.
We are not dwelling on this issue because it would further complicate an already abstract concept.
For most practical purposes, you can ignore the type parameter and work with the raw Class type.
The virtual machine manages a unique Class object for each type.
Therefore, you can use the == operator to compare class objects.
Another example of a useful method is one that lets you create an instance of a class on the fly.
The newInstance method calls the no-argument constructor to initialize the newly created object.
An exception is thrown if the class does not have a noargument constructor.
A combination of forName and newInstance lets you create an object from a class name stored in a string.
Note If you need to provide parameters for the constructor of a class you want to create by name in this manner, you can’t use the above statements.
Instead, you must use the newInstance method in the Constructor class.
However, virtual constructors in C++ are not a language feature but just an idiom that needs to be supported by a specialized library.
The Java Class is quite a bit more versatile than type_info, though.
We cover exception handling fully in Chapter 11, but in the meantime you will occasionally encounter.
If you don’t provide a handler, the program still terminates and prints a message to the console, giving the type of the exception.
You may have already seen exception reports when you accidentally used a null reference or overstepped the bounds of an array.
There are two kinds of exceptions: unchecked exceptions and checked exceptions.
With checked exceptions, the compiler checks that you provide a handler.
However, many common exceptions, such as accessing a null reference, are unchecked.
The compiler does not check whether you provided a handler for these errors—after all, you should spend your mental energy on avoiding these mistakes rather than coding handlers for them.
If an exception can occur despite your best efforts, then the compiler insists that you provide a handler.
The Class.forName method is an example of a method that throws a checked exception.
In Chapter 11, you will see several exception handling strategies.
For now, we just show you the simplest handler implementation.
Place one or more statements that might throw checked exceptions inside a try block.
If the class name doesn’t exist, the remainder of the code in the try block is skipped and the program enters the catch clause.
Here, we print a stack trace by using the printStackTrace method of the Throwable class.
Throwable is the superclass of the Exception class.) If none of the methods in the try block throws an exception, the handler code in the catch clause is skipped.
You only need to supply an exception handler for checked exceptions.
It is easy to find out which methods throw checked exceptions—the compiler will complain whenever you call a method that threatens to throw a checked exception and you don’t supply a handler.
Here is a brief overview of the most important parts of the reflection mechanism for letting you.
All three classes have a method called getName that returns the name of the item.
The Field class has a method getType that returns an object, again of type Class, that describes the field type.
The Method and Constructor classes have methods to report the types of the parameters, and the Method class also reports the return type.
All three of these classes also have a method called getModifiers that returns an integer, with various bits turned on and off, that describes the modifiers used, such as public and static.
Use methods like isPublic, isPrivate, or isFinal in the Modifier class to tell whether a method or constructor was public, private, or final.
All you have to do is have the appropriate method in the Modifier class work on the integer that getModifiers returns.
The getFields, getMethods, and getConstructors methods of the Class class return arrays of the public fields, methods, and constructors that the class supports.
This includes private, package, and protected members, but not members of superclasses.
Listing 5.13 shows you how to print out all information about a class.
The program prompts you for the name of a class and writes out the signatures of all methods and constructors as well as the names of all instance fields of a class.
What is remarkable about this program is that it can analyze any class that the Java interpreter can load, not just the classes that were available when the program was compiled.
We will use this program in the next chapter to peek inside the inner classes that the Java compiler generates automatically.
The methods return an array of length 0 if there are no such fields or if the Class object represents a primitive or array type.
Use the methods in the Modifier class to analyze the return value.
String getName() returns a string that is the name of the constructor, method, or field.
Class getReturnType() (in Method classes) returns a Class object that represents the return type.
In the preceding section, we saw how we can find out the names and types of the data fields of any.
In this section, we will go one step further and actually look at the contents of the fields.
But reflection lets you look at fields of objects that were not known at compile time.
The key method to achieve this examination is the get method in the Field class.
If f is an object of type Field (for example, one obtained from getDeclaredFields) and obj is an object of the class of which f is a field, then f.get(obj) returns an object whose value is the current value of the field of obj.
This is all a bit abstract, so let’s run through an example.
You can only use get to get the values of accessible fields.
The security mechanism of Java lets you find out what fields an object has, but it won’t let you read the values of those fields unless you have access permission.
The default behavior of the reflection mechanism is to respect Java access control.
However, if a Java program is not controlled by a security manager that disallows it, you can override access control.
To do this, invoke the setAccessible method on a Field, Method, or Constructor object.
This feature is provided for debuggers, persistent storage, and similar mechanisms.
We use it for a generic toString method later in this section.
There is another issue with the get method that we need to deal with.
The name field is a String, and so it is not a problem to return the value as an Object.
But suppose we want to look at the salary field.
That is a double, and in Java, number types are not objects.
To handle this, you can either use the getDouble method of the Field class, or you can call get, whereby the reflection mechanism automatically wraps the field value into the appropriate wrapper class—in this case, Double.
Of course, you can also set the values that you can get.
The call f.set(obj, value) sets the field represented by f of the object obj to the new value.
Listing 5.14 shows how to write a generic toString method that works for any class.
It then uses the setAccessible convenience method to make all fields accessible.
For each field, it obtains the name and the value.
Listing 5.14 turns each value into a string by recursively invoking toString.
The complete code in Listing 5.14 needs to address a couple of complexities.
Therefore, the ObjectAnalyzer (Listing 5.15) keeps track of objects that were already visited.
Also, to peek inside arrays, you need a different approach.
This is a hassle-free method for supplying a toString method that you may find useful in your own programs.
A value of true indicates that Java language access checking is suppressed and that the private properties of the object can be queried and set.
Recall how this method can be used to grow an array that has become full.
However, there is a problem with actually using the resulting array.
The type of array that this code returns is an array of objects (Object[]) because we created the array using the line of code.
The point is, as we mentioned earlier, that a Java array remembers the type of its entries—that is, the element type used in the new expression that created it.
To write this kind of generic array code, we need to be able to make a new array of the same type as the original array.
The key is the static newInstance method of the Array class that constructs a new array.
You must supply the type for the entries and the desired length as parameters to this method.
To get the component type of the new array: 1
Use the getComponentType method of the Class class (which is defined only for class objects that represent arrays) to find the right type for the array.
Note that this copyOf method can be used to grow arrays of any type, not just arrays of objects.
To make this possible, the parameter of goodCopyOf is declared to be of type Object, not an array of objects (Object[])
Note that the cast of the return value of badcopyOf will throw an exception.
In C and C++, you can execute an arbitrary function through a function pointer.
In fact, the designers of Java have said that method pointers are dangerous and error-prone, and that Java interfaces (discussed in the next chapter) are a superior solution.
However, the reflection mechanism allows you to call arbitrary methods.
However, inner classes (which we will introduce in the next chapter) are a more useful construct than delegates.
Recall that you can inspect a field of an object with the get method of the Field class.
Similarly, the Method class has an invoke method that lets you call the method that is wrapped in the current Method object.
For a static method, the first parameter is ignored—you can set it to null.
For example, if m1 represents the getName method of the Employee class, the following code shows how.
If the return type is a primitive type, the invoke method will return the wrapper type instead.
For example, suppose that m2 represents the getSalary method of the Employee class.
Then, the returned object is actually a Double, and you must cast it accordingly.
Or, you can call the getMethod method of the Class class.
This is similar to the getField method that takes a string with the field name and returns a Field object.
However, there may be several methods with the same name, so you need to be careful that you get the right one.
For that reason, you must also supply the parameter types of the desired method.
Now that you have seen the rules for using Method objects, let’s put them to work.
Listing 5.17 is a program that prints a table of values for a mathematical function such as Math.sqrt or Math.sin.
The first parameter of invoke is null because we are calling a static method.
That is the method of the Math class that has the name sqrt and a single parameter of type double.
Listing 5.17 shows the complete code of the generic tabulator and a couple of test runs.
As this example clearly shows, you can do anything with Method objects that you can do with function pointers in C (or delegates in C#)
Just as in C, this style of programming is usually quite inconvenient, and always error-prone.
What happens if you invoke a method with the wrong parameters? The invoke method throws an exception.
Also, the parameters and return values of invoke are necessarily of type Object.
That means you must cast back and forth a lot.
As a result, the compiler is deprived of the chance to check your code, so errors surface only during testing, when they are more tedious to find and fix.
Moreover, code that uses reflection to get at method pointers is significantly slower than code that simply calls methods directly.
For that reason, we suggest that you use Method objects in your own programs only when absolutely necessary.
Using interfaces and inner classes (the subject of the next chapter) is almost always a better idea.
In particular, we echo the developers of Java and suggest not using Method objects for callback functions.
Using interfaces for the callbacks (see the next chapter as well) leads to code that runs faster and is a lot more maintainable.
We want to end this chapter with some hints that we have found useful when using inheritance.
This is why we put the name field into the Person class instead of replicating it in the Employee and Student classes.
However, the protected mechanism doesn’t give much protection, for two reasons.
First, the set of subclasses is unbounded—anyone can form a subclass of your classes and then write code that directly accesses protected instance fields, thereby breaking encapsulation.
And second, in the Java programming language, all classes in the same package have access to protected fields, whether or not they are subclasses.
However, protected methods can be useful to indicate methods that are not ready for general use and should be redefined in subclasses.
Inheritance is a handy code-saver, but sometimes people overuse it.
Contractors have names and hire dates, but they do not have salaries.
Instead, they are paid by the hour, and they do not stay around long enough to get a raise.
There is the temptation to form a subclass Contractor from Employee and add an hourlyWage field.
This is not a good idea, however, because now each contractor object has both a salary and hourly wage field.
It will cause you no end of grief when you implement methods for printing paychecks or tax forms.
You will end up writing more code than you would have written by not inheriting in the first place.
A contractor is not a special case of an employee.
Surely every holiday is a day, and days can be expressed as instances of the GregorianCalendar class, so we can use inheritance.
Don’t change the expected behavior when you override a method.
The substitution principle applies not just to syntax but, more importantly, to behavior.
When you override a method, you should not unreasonably change its behavior.
The compiler can’t help you—it cannot check whether your redefinitions make sense.
For example, you can “fix” the issue of the add method in the Holiday class by redefining add, perhaps to do nothing, or to throw an exception, or to move on to the next holiday.
Reasonable and unreasonable people can argue at length about what the expected behavior is.
For example, some authors argue that the substitution principle requires Manager.equals to ignore the bonus field because Employee.equals ignores it.
These discussions are pointless if they occur in a vacuum.
Ultimately, what matters is that you do not circumvent the intent of the original design when you override methods in subclasses.
Code using polymorphic methods or interface implementations is much easier to maintain and extend than code that uses multiple type tests.
The reflection mechanism lets you write programs with amazing generality, by detecting fields and methods at runtime.
This capability can be extremely useful for systems programming, but it is.
Reflection is fragile—with it, the compiler cannot help you find programming errors.
Any errors are found at runtime and result in exceptions.
You have now seen how Java supports the fundamentals of object-oriented programming: classes, inheritance, and polymorphism.
In the next chapter, we will tackle two advanced topics that are very important for using Java effectively: interfaces and inner classes.
You have now seen all the basic tools for object-oriented programming in Java.
This chapter shows you several advanced techniques that are commonly used.
Despite their less obvious nature, you will need to master them to complete your Java tool chest.
The first technique, called interfaces, is a way of describing what classes should do, without specifying how they should do it.
You can then use objects of these implementing classes whenever conformance to the interface is required.
After we cover interfaces, we take up cloning an object (or deep copying, as it is sometimes called)
A clone of an object is a new object that has the same state as the original.
In particular, you can modify the clone without affecting the original.
Next, we move on to the mechanism of inner classes.
Inner classes are technically somewhat complex—they are defined inside other classes, and their methods can access the fields of the surrounding class.
Inner classes are useful when you design collections of cooperating classes.
In particular, inner classes enable you to write concise, professional looking code to handle GUI events.
This chapter concludes with a discussion of proxies, objects that implement arbitrary interfaces.
A proxy is a very specialized construct that is useful for building system-level tools.
In the Java programming language, an interface is not a class but a set of.
Typically, the supplier of some service states: “If your class conforms to a particular.
The sort method of the Arrays class promises to sort an array of objects, but under one condition: The objects must belong to classes that implement the Comparable interface.
This means that any class that implements the Comparable interface is required to compareTo Object.
Note As of Java SE 5.0, the Comparable interface has been enhanced to be a generic type.
For that reason, it is not necessary to supply the keyword public when declaring a method in an interface.
Of course, there is an additional requirement that the interface cannot spell out: When calling x.compareTo(y), the compareTo method must actually be able to compare the two objects and return an indication whether x or y is larger.
The method is supposed to return a negative number if x is smaller than y, zero if they are equal, and a positive number otherwise.
As you will see later, interfaces can also define constants.
What is more important, however, is what interfaces cannot supply.
Interfaces never have instance fields, and the methods are never implemented in the interface.
Supplying instance fields and method implementations is the job of the classes that implement the interface.
You can think of an interface as being similar to an abstract class with no instance fields.
However, there are some differences between these two concepts—we look at them later in some detail.
Now suppose we want to use the sort method of the Arrays class to sort an array of Employee objects.
To make a class implement an interface, you carry out two steps: 1
You declare that your class intends to implement the given interface.
To declare that a class implements an interface, use the implements keyword: class Employee implements Comparable.
Of course, now the Employee class needs to supply the compareTo method.
Let’s suppose that we want to compare employees by their salary.
Here, we use the static Double.compare method that returns a negative if the first argument is less than the second argument, 0 if they are equal, and a positive value otherwise.
Caution In the interface declaration, the compareTo method was not declared public because all methods in an interface are automatically public.
However, when implementing the interface, you must declare the method as public.
Otherwise, the compiler assumes that the method has package visibility—the default for a class.
The compiler then complains that you’re trying to supply a weaker access privilege.
As of Java SE 5.0, we can do a little better.
Note that the unsightly cast of the Object parameter has gone away.
Tip The compareTo method of the Comparable interface returns an integer.
If the objects are not equal, it does not matter what negative or positive value you return.
This flexibility can be useful when you are comparing integer fields.
For example, suppose each employee has a unique integer id and you want to sort by the employee ID number.
That value will be some negative value if the first ID number is less than the other, 0 if they are the same ID, and some positive value otherwise.
However, there is one caveat: The range of the integers must be small enough so that the subtraction does not overflow.
Of course, the subtraction trick doesn’t work for floating-point numbers.
The difference salary - other.salary can round to 0 if the salaries are close together but not identical.
Now you saw what a class must do to avail itself of the sorting service—it must implement a compareTo method.
There needs to be some way for the sort method to compare objects.
But why can’t the Employee class simply provide a compareTo method without implementing the Comparable interface?
The reason for interfaces is that the Java programming language is strongly typed.
When making a method call, the compiler needs to be able to check that the method actually exists.
Somewhere in the sort method will be statements like this:
The compiler must know that a[i] actually has a compareTo method.
If a is an array of Comparable objects, then the existence of the method is assured because every class that implements the Comparable interface must supply the method.
Note You would expect that the sort method in the Arrays class is defined to accept a Comparable[] array so that the compiler can complain if anyone ever calls sort with an array whose element type doesn’t implement the Comparable interface.
Instead, the sort method accepts an Object[] array and uses a clumsy cast:
If a[i] does not belong to a class that implements the Comparable interface, the virtual machine throws an exception.
All elements in the array must belong to classes that implement the Comparable interface, and they must all be comparable to each other.
In plain English, if you flip the parameters of compareTo, the sign (but not necessarily the actual value) of the result must also flip.
As with the equals method, problems can arise when inheritance comes into play.
If Manager chooses to override compareTo, it must be prepared to compare managers to employees.
If x is an Employee and y is a Manager, then the call x.compareTo(y) doesn’t throw an exception—it simply compares x and y as employees.
This is the same situation as with the equals method that we discussed in.
If subclasses have different notions of comparison, then you should outlaw comparison of objects that belong to different classes.
In particular, you can never use the new operator to.
However, even though you can’t construct interface objects, you can still declare interface variables.
Comparable x; // OK An interface variable must refer to an object of a class that implements the interface:
Just as you can build hierarchies of classes, you can extend interfaces.
This allows for multiple chains of interfaces that go from a greater degree of generality to a greater degree of specialization.
Although you cannot put instance fields or static methods in an interface, you can supply constants in them.
Just as methods in an interface are automatically public, fields are always public.
Note It is legal to tag interface methods as public, and fields as public static final.
Some programmers do that, either out of habit or for greater clarity.
However, the Java Language Specification recommends that the redundant keywords not be supplied, and we follow that recommendation.
For example, the standard library contains an interface SwingConstants that defines constants NORTH, SOUTH, HORIZONTAL, and so on.
Any class that chooses to implement the SwingConstants interface automatically inherits these constants.
However, this use of interfaces seems rather degenerate, and we do not recommend it.
While each class can have only one superclass, classes can implement multiple interfaces.
This gives you the maximum amount of flexibility in defining a class’s behavior.
For example, the Java programming language has an important interface built into it, called Cloneable.
We will discuss this interface in detail in the next section.) If your class implements Cloneable, the clone method in the Object class will make an exact copy of your class’s objects.
If you read the section about abstract classes in Chapter 5, you may wonder why the.
The Employee class would then simply extend this abstract class and supply the compareTo method:
There is, unfortunately, a major problem with using an abstract base class to express a generic property.
Suppose that the Employee class already extends a different class, say, Person.
Other programming languages, in particular C++, allow a class to have more than one superclass.
The designers of Java chose not to support multiple inheritance, because it makes the language either very complex (as in C++) or less efficient (as in Eiffel)
Instead, interfaces afford most of the benefits of multiple inheritance while avoiding the complexities and inefficiencies.
Few C++ programmers use multiple inheritance, and some say it should never be used.
Other programmers recommend using multiple inheritance only for the “mix-in” style of inheritance.
In the mix-in style, a primary base class describes the parent object, and additional base classes (the so-called mix-ins) may supply auxiliary characteristics.
That style is similar to a Java class with a single base class and additional interfaces.
However, in C++, mix-ins can add default behavior, whereas Java interfaces cannot.
When you make a copy of a variable, the original and the copy are references to the.
See Figure 6.1.) This means a change to either variable also affects the other.
If you would like copy to be a new object that begins its life being identical to original but whose state can diverge over time, use the clone method.
The clone method is a protected method of Object, which means that your code cannot simply call it.
Think about the way in which the Object class can implement clone.
It knows nothing about the object at all, so it can make only a field-by-field copy.
If all data fields in the object are numbers or other basic types, copying the fields is just fine.
But if the object contains references to subobjects, then copying the field gives you another reference to the same subobject,
To visualize that phenomenon, let’s consider the Employee class that was introduced.
Figure 6.2 shows what happens when you use the clone method of the Object class to clone such an Employee object.
As you can see, the default cloning operation is “shallow”—it doesn’t clone objects that are referenced inside other objects.
Does it matter if the copy is shallow? It depends.
If the subobject shared between the original and the shallow clone is immutable, then the sharing is safe.
This certainly happens if the subobject belongs to an immutable class, such as String.
Alternatively, the subobject may simply remain constant throughout the lifetime of the object, with no mutators touching it and no methods yielding a reference to it.
Quite frequently, however, subobjects are mutable, and you must redefine the clone method to make a deep copy that clones the subobjects as well.
In our example, the hireDay field is a Date, which is mutable.
The default clone method can be patched up by calling clone on the mutable subobjects; and 3
To choose either the first or the second option, a class must.
Note The clone method is declared protected in the Object class, so that your code can’t simply call anObject.clone()
A subclass can call a protected clone method only to clone its own objects.
You must redefine clone to be public to allow objects to be cloned by any method.
In this case, the appearance of the Cloneable interface has nothing to do with the normal use of interfaces.
In particular, it does not specify the clone method—that method is inherited from the Object class.
The interface merely serves as a tag, indicating that the class designer understands the cloning process.
Objects are so paranoid about cloning that they generate a checked exception if an object requests cloning but does not implement that interface.
Note The Cloneable interface is one of a handful of tagging interfaces that Java provides.
Some programmers call them marker interfaces.) Recall that the usual purpose of an interface such as Comparable is to ensure that a class implements a particular method or set of methods.
A tagging interface has no methods; its only purpose is to allow the use of instanceof in a type inquiry:
We recommend that you do not use tagging interfaces in your own programs.
Even if the default (shallow copy) implementation of clone is adequate, you still need to implement the Cloneable interface, redefine clone to be public, and call super.clone()
Note Before Java SE 5.0, the clone method always had return type Object.
Nowadays, the covariant return type feature lets you specify the correct return.
The clone method that you just saw adds no functionality to the shallow copy provided by Object.clone.
To make a deep copy, you have to work harder and clone the mutable instance fields.
Of course, the Employee and Date classes implement the Cloneable interface, so the exception won’t be thrown.
Otherwise, it is a good idea to leave the throws specifier in place.
For example, once you have defined the clone method for the Employee class, anyone can use it to clone Manager objects.
Can the Employee clone method do the job? It depends on the fields of the Manager class.
In our case, there is no problem because the bonus field has primitive type.
But Manager might have acquired fields that require a deep copy or are not cloneable.
There is no guarantee that the implementor of the subclass has fixed clone to do the right thing.
For that reason, the clone method is declared as protected in the Object class.
But you don’t have that luxury if you want users of your classes to invoke clone.
Should you implement clone in your own classes? If your clients need to make deep copies, then you probably should.
Some authors feel that you should avoid clone altogether and instead implement another method for the same purpose.
At any rate, cloning is less common than you may think.
Less than 5 percent of the classes in the standard library implement clone.
The raiseSalary method changes the value of the salary field, whereas the setHireDay method changes the state of the hireDay field.
Neither mutation affects the original object because clone has been defined to make a deep copy.
Note All array types have a clone method that is public, not protected.
You can use it to make a new array that contains copies of all elements.
Note Chapter 1 of Volume II shows an alternate mechanism for cloning objects, using the object serialization feature of Java.
That mechanism is easy to implement and safe, but not very efficient.
For example, you may want a particular action to occur when a button is clicked or a menu item is selected.
However, as you have not yet seen how to implement user interfaces, we will consider a similar but simpler situation.
The javax.swing package contains a Timer class that is useful if you want to be notified whenever a time interval has elapsed.
When you construct a timer, you set the time interval and you tell it what it should do whenever the time interval has elapsed.
How do you tell the timer what it should do? In many programming languages, you supply the name of a function that the timer should call periodically.
However, the classes in the Java standard library take an object-oriented approach.
The timer then calls one of the methods on that object.
Passing an object is more flexible than passing a function because the object can carry additional information.
Of course, the timer needs to know what method to call.
The timer requires that you specify an object of a class that implements the ActionListener interface of the java.awt.event package.
The timer calls the actionPerformed method when the time interval has expired.
However, they are difficult to use, slower, and cannot be checked for type safety at compile time.
Whenever you would use a function pointer in C++, you should consider using an interface in Java.
Suppose you want to print a message “At the tone, the time is.
You would define a class that implements the ActionListener interface.
You would then place whatever statements you want to have executed inside the actionPerformed method.
However, detailed information about the event is not important in this program, and you can safely ignore the parameter.
The first parameter of the Timer constructor is the time interval that must elapse between notifications, measured in milliseconds.
Listing 6.5 puts the timer and its action listener to work.
While the program waits for the user, the current time is displayed at 10-second intervals.
If parent is null, the dialog is centered on the screen.
Once stopped, the timer no longer calls actionPerformed on its listeners.
An inner class is a class that is defined inside another class.
Inner classes can be hidden from other classes in the same package.
Anonymous inner classes are handy when you want to define callbacks without writing a lot of code.
We will break up this rather complex topic into several steps.
Starting on page 307, you will see a simple inner class that accesses an instance field of its outer class.
On page 311, we cover the special syntax rules for inner classes.
Starting on page 312, we peek inside inner classes to see how they are translated into regular classes.
Starting on page 318, we introduce anonymous inner classes and show how they are commonly used to implement callbacks.
Finally, starting on page 322, you will see how static inner classes can be used for nested helper classes.
A nested class is contained inside the scope of the enclosing class.
Here is a typical example: A linked list class defines a class to hold the links, and a class to define an iterator position.
A LinkedList object does not have subobjects of type Iterator or Link.
In Java, this benefit is not as important because Java packages give the same kind of name control.
Note that the Link class is in the private part of the LinkedList class.
For that reason, it is safe to make its data fields public.
They can be accessed by the methods of the LinkedList class (which has a legitimate need to access them), and they are not visible elsewhere.
In Java, this kind of control was not possible until inner classes were introduced.
However, the Java inner classes have an additional feature that makes them richer and more useful than nested classes in C++
An object that comes from an inner class has an implicit reference to the outer class object that instantiated it.
Through this pointer, it gains access to the total state of the outer object.
You will see the details of the Java mechanism later in this chapter.
In Java, static inner classes do not have this added pointer.
They are the Java analog to nested classes in C++
We refactor the TimerTest example and extract a TalkingClock class.
A talking clock is constructed with two parameters: the interval between announcements and a flag to turn beeps on or off.
Note that the TimePrinter class is now located inside the TalkingClock class.
This does not mean that every TalkingClock has a TimePrinter instance field.
As you will see, the TimePrinter objects are constructed by methods of the TalkingClock class.
Note that the actionPerformed method checks the beep flag before emitting a beep.
The TimePrinter class has no instance field or variable named beep.
Instead, beep refers to the field of the TalkingClock object that created this TimePrinter.
Traditionally, a method could refer to the data fields of the object invoking the method.
An inner class method gets to access both its own data fields and those of the outer object creating it.
For this to work, an object of an inner class always gets an implicit reference to the object that created it.
An inner class object has a reference to an outer class object.
This reference is invisible in the definition of the inner class.
However, to illuminate the concept, let us call the reference to the outer object outer.
The compiler modifies all inner class constructors, adding a parameter for the outer class reference.
The TimePrinter class defines no constructors; therefore, the compiler synthesizes a no-argument constructor, generating code like this:
We just use it to illustrate the mechanism involved in an inner class.
When a TimePrinter object is constructed in the start method, the compiler passes the this reference to the current talking clock into the constructor:
Listing 6.6 shows the complete program that tests the inner class.
Had the TimePrinter class been a regular class, it would have needed to access the beep flag through a public method of the TalkingClock class.
There is no need to provide accessors that are of interest only to one other class.
Note We could have declared the TimePrinter class as private.
Then only TalkingClock methods would be able to construct TimePrinter objects.
In the preceding section, we explained the outer class reference of an inner class by.
Actually, the proper syntax for the outer reference is a bit more complex.
Conversely, you can write the inner object constructor more explicitly, using the syntax.
However, it is also possible to set the outer class reference to another object by explicitly naming it.
For example, since TimePrinter is a public inner class, you can construct a TimePrinter for any talking clock:
It gets more complex as we study anonymous inner classes later in this chapter.) It is not obvious how inner classes interact with other features of the language, such as access control and security.
By adding a feature that was elegant and interesting rather than needed, has Java started down the road to ruin which has afflicted so many other languages?
While we won’t try to answer this question completely, it is worth noting that inner.
Inner classes are translated into regular class files with $ (dollar signs) delimiting outer and inner class names, and the virtual machine does not have any special knowledge about them.
Note If you use UNIX, remember to escape the $ character if you supply the class name on the command line.
You can plainly see that the compiler has generated an additional instance field, this$0, for the reference to the outer class.
If the compiler can automatically do this transformation, couldn’t you simply program the same mechanism by hand? Let’s try it.
We would make TimePrinter a regular class, outside the TalkingClock class.
When constructing a TimePrinter object, we pass it the this reference of the object that is creating it.
The inner class can access the private data of the outer class, but our external TimePrinter class cannot.
Thus, inner classes are genuinely more powerful than regular classes because they have more access privileges.
You may well wonder how inner classes manage to acquire those added access privileges, if they are translated to regular classes with funny names—the virtual machine knows nothing at all about them.
To solve this mystery, let’s again use the ReflectionTest program to spy on the TalkingClock class:
Notice the static access$0 method that the compiler added to the outer class.
It returns the beep field of the object that is passed as a parameter.
The method name might be slightly different, such as access$000, depending on your compiler.)
Of course, access$0 is not a legal name for a Java method.
However, hackers who are familiar with the structure of class files can easily produce a class file with virtual machine instructions to call that method, for example, by using a hex editor.
Since the secret access methods have package visibility, the attack code would need to be placed inside the same package as the class under attack.
To summarize, if an inner class accesses a private data field, then it is possible to access that data field through other classes added to the package of the outer class, but to do so requires skill and determination.
A programmer cannot accidentally obtain access but must intentionally build or modify a class file for that purpose.
Skip this note if you are squeamish.) Suppose we turn TimePrinter into a private inner class.
There are no private classes in the virtual machine, so the compiler produces the next best thing: a package-visible class with a private constructor.
If you look carefully at the code of the TalkingClock example, you will find that you.
Local classes are never declared with an access specifier (that is, public or private)
Their scope is always restricted to the block in which they are declared.
Local classes have one great advantage: They are completely hidden from the outside world—not even other code in the TalkingClock class can access them.
No method except start has any knowledge of the TimePrinter class.
Not only can they access the fields of their outer classes; they can even access local variables! However, those local variables must be declared final.
Let’s move the interval and beep parameters from the TalkingClock constructor to the start method.
Note that the TalkingClock class no longer needs to store a beep instance field.
It simply refers to the beep parameter variable of the start method.
To see why there is a subtle issue here, let’s consider the flow of control more closely.
The object variable listener is initialized by a call to the constructor of the inner class TimePrinter.
The listener reference is passed to the Timer constructor, the timer is started, and the start method exits.
At this point, the beep parameter variable of the start method no longer exists.
For the code in the actionPerformed method to work, the TimePrinter class must have copied the beep field, as a local variable of the start method, before the beep parameter value went away.
Note the boolean parameter to the constructor and the val$beep instance variable.
When an object is created, the value beep is passed into the constructor and stored in the val$beep field.
The compiler detects access of local variables, makes matching instance fields for each one of them, and copies the local variables into the constructor so that the instance fields can be initialized.
From the programmer’s point of view, local variable access is quite pleasant.
As we already mentioned, the methods of a local class can refer only to local variables that are declared final.
For that reason, the beep parameter was declared final in our example.
A local variable that is declared final cannot be modified after it has been initialized.
Thus, it is guaranteed that the local variable and the copy that is made inside the local class will always have the same value.
Note You have seen final variables used for constants, such as.
Suppose, for example, that you want to update a counter in the enclosing scope.
Here, we want to count how often the compareTo method is called during sorting:
You can’t declare counter as final because you clearly need to update it.
You can’t replace it with an Integer because Integer objects are immutable.
The remedy is to use an array of length 1:
The array variable is still declared as final, but that merely means that you can’t have it refer to a different array.
When inner classes were first invented, the prototype compiler automatically made this transformation for all local variables that were modified in the inner class.
However, some programmers were fearful of having the compiler produce heap objects behind their backs, and the final restriction was adopted instead.
It is possible that a future version of the Java language will revise this decision.
When using local inner classes, you can often go a step further.
Here, SuperType can be an interface, such as ActionListener; then, the inner class implements that interface.
SuperType can also be a class; then, the inner class extends that class.
An anonymous inner class cannot have constructors because the name of a constructor must be the same as the name of a class, and the class has no name.
Instead, the construction parameters are given to the superclass constructor.
In particular, whenever an inner class implements an interface, it cannot have any construction parameters.
Nevertheless, you must supply a set of parentheses as in.
You have to look carefully to see the difference between the construction of a new object of a class and the construction of an object of an anonymous inner class.
If the closing parenthesis of the construction parameter list is followed by an opening brace, then an anonymous inner class is being defined.
Are anonymous inner classes a great idea or are they a great way of writing obfuscated code? Probably a bit of both.
Listing 6.7 contains the complete source code for the talking clock program with an anonymous inner class.
If you compare this program with Listing 6.6, you will find that in this case, the solution with the anonymous inner class is quite a bit shorter, and, hopefully, with a bit of practice, as easy to comprehend.
Note The following trick, called double brace initialization, takes advantage of the inner class syntax.
Suppose you want to construct an array list and pass it to a method:
If you don’t need the array list again, it would be nice to make it anonymous.
But then how can you add the elements? Here is how:
Caution It is often convenient to make an anonymous subclass that is almost, but not quite, like its superclass.
But you need to be careful with the equals method.
In Chapter 5, we recommended that your equals methods use a test.
Tip When you produce logging or debugging messages, you often want to include the name of the current class, such as.
Occasionally, you may want to use an inner class simply to hide one class inside.
You can suppress the generation of that reference by declaring the inner class static.
Here is a typical example of where you would want to do this.
Consider the task of computing the minimum and maximum value in an array.
Of course, you write one method to compute the minimum and another method to compute the maximum.
When you call both methods, the array is traversed twice.
It would be more efficient to traverse the array only once, computing both the minimum and the maximum simultaneously.
We can achieve that by defining a class Pair that holds two values:
The caller of the method uses the getFirst and getSecond methods to retrieve the answers:
Of course, the name Pair is an exceedingly common name, and in a large project, it is quite possible that some other programmer had the same bright idea—but made a.
We can solve this potential name clash by making Pair a public inner class inside ArrayAlg.
Then the class will be known to the public as ArrayAlg.Pair:
That reference can be suppressed by declaring the inner class static:
A static inner class is exactly like any other inner class, except that an object of a static inner class does not have a reference to the outer class object that generated it.
In our example, we must use a static inner class because the inner class object is constructed inside a static method:
Had the Pair class not been declared as static, the compiler would have complained that there was no implicit object of type ArrayAlg available to initialize the inner class object.
Note Use a static inner class whenever the inner class does not need to access an outer class object.
Some programmers use the term nested class to describe static inner classes.
Note Inner classes that are declared inside an interface are automatically static and public.
Listing 6.8 contains the complete source code of the ArrayAlg class and the nested Pair class.
In the final section of this chapter, we discuss proxies.
Proxies are only necessary when you don’t yet know at compile time which interfaces you need to implement.
This is not a common situation for application programmers, and you should feel free to skip this section if you are not interested in advanced wizardry.
However, for certain systems programming applications, the flexibility that proxies offer can be very important.
Suppose you want to construct an object of a class that implements one or more interfaces whose exact nature you may not know at compile time.
To construct an actual class, you can simply use the newInstance method or use reflection to find a constructor.
You need to define a new class in a running program.
To overcome this problem, some programs generate code, place it into a file, invoke the compiler, and then load the resulting class file.
Naturally, this is slow, and it also requires deployment of the compiler together with the program.
Such a proxy class implements the interfaces that you specify.
All methods required by the specified interfaces; and • All methods defined in the Object class (toString, equals, and so on)
However, you cannot define new code for these methods at runtime.
An invocation handler is an object of any class that implements the InvocationHandler interface.
Object invoke(Object proxy, Method method, Object[] args) Whenever a method is called on the proxy object, the invoke method of the.
The invocation handler must then figure out how to handle the call.
To create a proxy object, use the newProxyInstance method of the Proxy class.
As part of the Java security model, different class loaders can be used for system classes, classes that are downloaded from the Internet, and so on.
We will discuss class loaders in Chapter 9 of Volume II.
For now, we specify null to use the default class loader.
An array of Class objects, one for each interface to be implemented.
In our example program, we use proxies and invocation handlers to trace method calls.
We define a TraceHandler wrapper class that stores a wrapped object.
Its invoke method simply prints the name and parameters of the method to be called and then calls the method with the wrapped object as the implicit parameter.
Here is how you construct a proxy object that causes the tracing behavior whenever one of its methods is called:
Now, whenever a method from one of the interfaces is called on proxy, the method name and parameters are printed out and the method is then invoked on value.
In the program shown in Listing 6.9, we use proxy objects to trace a binary search.
We fill an array with proxies to the integers 1
Then we invoke the binarySearch method of the Arrays class to search for a random integer in the array.
It has a name such as $Proxy0.) That class also implements the Comparable interface.
However, its compareTo method calls the invoke method of the proxy object’s handler.
However, at runtime, all generic types are erased and the proxy is constructed with the class object for the raw Comparable class.
Since we filled the array with proxy objects, the compareTo calls call the invoke method of the TraceHandler class.
That method prints the method name and parameters and then invokes compareTo on the wrapped Integer object.
The println method calls toString on the proxy object, and that call is also redirected to the invocation handler.
You can see how the binary search algorithm homes in on the key by cutting the search interval in half in every step.
Note that the toString method is proxied even though it does not belong to the Comparable interface—as you will see in the next section, certain Object methods are always proxied.
Now that you have seen proxy classes in action, let’s go over some of their.
Remember that proxy classes are created on the fly in a running program.
However, once they are created, they are regular classes, just like any other classes in the virtual machine.
A proxy class has only one instance field— the invocation handler, which is defined in the Proxy superclass.
For example, when we proxied Comparable objects in the program shown in Listing 6.9, the TraceHandler wrapped the actual objects.
All proxy classes override the toString, equals, and hashCode methods of the Object class.
Like all proxy methods, these methods simply call invoke on the invocation handler.
The other methods of the Object class (such as clone and getClass) are not redefined.
The Proxy class in Oracle’s virtual machine generates class names that begin with the string $Proxy.
There is only one proxy class for a particular class loader and ordered set of interfaces.
That is, if you call the newProxyInstance method twice with the same class loader and interface array, you get two objects of the same class.
You can also obtain that class with the getProxyClass method:
Otherwise, all non-public interfaces must belong to the same package, and the proxy class will also belong to that package.
You can test whether a particular Class object represents a proxy class by calling the isProxyClass method of the Proxy class.
All methods call the invoke method of the given handler object.
This ends our final chapter on the fundamentals of the Java programming language.
Interfaces and inner classes are concepts that you will encounter frequently.
However, as we already mentioned, proxies are an advanced technique that is of interest mainly to tool builders, not application programmers.
You are now ready to go on to learn about graphics and user interfaces, starting with Chapter 7
To this point, you have seen only how to write programs that take input from the keyboard, fuss with it, and display the results on a console screen.
Modern programs don’t work this way and neither do web pages.
This chapter starts you on the road to writing Java programs that use a graphical user interface (GUI)
In particular, you will learn how to write programs that size and locate windows on the screen, display text with multiple fonts in a window, display images, and so on.
This gives you a useful, valuable repertoire of skills that you will put to good use in subsequent chapters as you write interesting programs.
The next two chapters show you how to process events, such as keystrokes and mouse clicks, and how to add interface elements, such as menus and buttons, to your applications.
When you finish these three chapters, you will know the essentials of writing graphical applications.
For more sophisticated graphics programming techniques, we refer you to Volume II.
If, on the other hand, you intend to use Java for server-side programming only and are not interested in writing GUI programming, you can safely skip these chapters.
When Java 1.0 was introduced, it contained a class library, which Sun called the Abstract.
The basic AWT library deals with user interface elements by delegating their creation and behavior to the native GUI toolkit on each target platform (Windows, Solaris, Macintosh, and so on)
For example, if you used the original AWT to put a text box on a Java window, an underlying “peer” text box actually handled the text input.
The peer-based approach worked well for simple applications, but it soon became apparent that it was fiendishly difficult to write a high-quality portable graphics library depending on native user interface elements.
User interface elements such as menus, scrollbars, and text fields can have subtle differences in behavior on different platforms.
It was hard, therefore, to give users a consistent and predictable experience with this approach.
Moreover, some graphical environments (such as X11/Motif) do not have as rich a collection of user interface components as does Windows or the Macintosh.
As a result, GUI applications built with the AWT simply did not look as nice as native Windows or Macintosh applications, nor did they have the kind of functionality that users of those platforms had come to expect.
More depressingly, there were different bugs in the AWT user interface library on the different platforms.
In 1996, Netscape created a GUI library they called the IFC (Internet Foundation Classes) that used an entirely different approach.
User interface elements, such as buttons, menus, and so on, were painted onto blank windows.
The only functionality required from the underlying windowing system was a way to put up windows and to paint on the window.
Thus, Netscape’s IFC widgets looked and behaved the same no matter which platform the program ran on.
The full JFC is vast and contains far more than the Swing GUI toolkit; besides the Swing components, it also has an accessibility API, a 2D API, and a drag-and-drop API.
Note Swing is not a complete replacement for the AWT—it is built on top of the AWT architecture.
Whenever you write a Swing program, you use the foundations of the AWT—in particular, event handling.
Of course, Swing-based user interface elements will be somewhat slower to appear on the user’s screen than the peer-based components used by the AWT.
In our experience, on any reasonably modern machine the speed difference shouldn’t be a problem.
On the other hand, the reasons to choose Swing are overwhelming:
Swing has a rich and convenient set of user interface elements.
Swing has few dependencies on the underlying platform; it is therefore less prone to platform-specific bugs.
Still, the third plus is also a potential drawback: If the user interface elements look the same on all platforms, they look different from the native controls, so users will be less familiar with them.
Now the Metal look supports multiple themes—minor variations in colors and fonts.
In Java SE 6, Sun improved the support for the native look-and-feel for Windows and GTK.
A Swing application will now pick up the color scheme customizations and faithfully render the throbbing buttons and scrollbars that have become fashionable.
Nimbus uses vector drawings, not bitmaps, and is therefore independent of the screen resolution.
Some users prefer their Java applications to use the native look-and-feel of their platforms, others like Metal or a third-party look-and-feel.
As you will see in Chapter 8, it is very easy to let your users choose their favorite look-and-feel.
Note Although we won’t have space in this book to tell you how to do it, Java programmers can extend an existing look-and-feel or even design a totally new one.
This is a tedious process that involves specifying how each Swing component is painted.
Some developers have done just that, especially when porting Java to nontraditional platforms such as kiosk terminals or handheld devices.
Java SE 5.0 introduced a look-and-feel, called Synth, that makes this process easier.
In Synth, you can define a new look-and-feel by providing image files and XML descriptors, without doing any programming.
Tip The Napkin look-and-feel (http://napkinlaf.sourceforge.net) gives a hand-drawn appearance to all user interface elements.
This is very useful when you show prototypes to your customers, sending a clear message that you’re not giving them a finished product.
Note Most Java user interface programming is nowadays done in Swing, with one notable exception.
The Eclipse integrated development environment uses a graphics toolkit called SWT that is similar to the AWT, mapping to the native components on various platforms.
Oracle is developing an alternate technology, called JavaFX, that may at some point become a replacement for Swing.
If you have programmed Microsoft Windows applications with Visual Basic or C#, you know about the ease of use that comes with the graphical layout tools and resource editors these products provide.
These tools let you design the visual appearance of your application, and then they generate much (often all) of the GUI code for you.
The remainder of this chapter shows you the basics of displaying windows and painting their contents.
A top-level window (that is, a window that is not contained inside another window) is called.
The AWT library has a class, called Frame, for this top level.
The Swing version of this class is called JFrame and extends the Frame class.
The JFrame is one of the few Swing components that is not painted on a canvas.
Thus, the decorations (buttons, title bar, icons, and so on) are drawn by the user’s windowing system, not by Swing.
Caution Most Swing component classes start with a “J”: JButton, JFrame, and so on.
There are classes such as Button and Frame, but they are AWT components.
If you accidentally omit a “J”, your program may still compile and run, but the mixture of Swing and AWT components can lead to visual and behavioral inconsistencies.
In this section, we will go over the most common methods for working with a Swing JFrame.
However, it is present in every Java SE implementation since version 1.2
In the main method of the SimpleFrameTest class, we construct a SimpleFrame object and make it visible.
There are two technical issues that we need to address in every Swing program.
First, all Swing components must be configured from the event dispatch thread, the thread.
The following code fragment is used to execute statements in the event dispatch thread:
For now, you should simply consider it a magic incantation that is used to start a Swing program.
Note You will see many Swing programs that do not initialize the user interface in the event dispatch thread.
It used to be perfectly acceptable to carry out the initialization in the main thread.
Sadly, as Swing components got more complex, the developers of the JDK were no longer able to guarantee the safety of that approach.
The probability of an error is extremely low, but you would not want to be one of the unlucky few who encounter an intermittent problem.
It is better to do the right thing, even if the code looks rather mysterious.
Next, we define what should happen when the user closes the application’s frame.
For this particular program, we want the program to exit.
By default, a frame is hidden when the user closes it, but the program does not terminate.
It might have been nice if the program terminated once the last frame becomes invisible, but that is not how Swing works.)
That gives the programmer the chance to add components into the frame before showing it for the first time.
To show the frame, the main method calls the setVisible method of the frame.
Note Before Java SE 5.0, it was possible to use the show method that the JFrame class inherits from the superclass Window.
The Window class has a superclass Component that also has a show method.
You are supposed to call setVisible(true) instead if you want to show a component.
However, until Java SE 1.4, the Window.show method was not deprecated.
In fact, it was quite useful, making the window visible and bringing it to the front.
Sadly, that benefit was lost on the deprecation police, and Java SE 5.0 deprecated the show method for windows as well.
Note that exiting main does not terminate the program—just the main thread.
The event dispatch thread keeps the program alive until it is terminated, either by closing the frame or by calling the System.exit method.
The running program is shown in Figure 7.5 on p.
As you can see in the figure, the title bar and the surrounding decorations, such as resize corners, are drawn by the operating system and not the Swing library.
If you run the same program in Windows, GTK, and the Mac, the frame decorations will be different.
In this program, it just fills the frame with a default background color.
Positioning a Frame / / / / The JFrame class itself has only a few methods for changing how frames look.
Figure 7.6 illustrates the inheritance hierarchy for the JFrame class.
Inheritance hierarchy for the frame and component classes in AWT and Swing.
Tip The API notes for this section give what we think are the most important methods for giving frames the proper look-and-feel.
Some of these methods are defined in the JFrame class.
At some point, you may need to search the API docs to see if there are methods for some special purpose.
Unfortunately, that is a bit tedious to do with inherited methods.
For example, the toFront method is applicable to objects of type JFrame, but since it’s simply inherited from the Window class, the JFrame documentation doesn’t explain it.
If you feel that there should be a method to do something and it isn’t mentioned in the documentation for the class you are working with, try looking at the API documentation for the methods of the superclasses of that class.
The top of each API page has hyperlinks to the superclasses, and inherited methods are listed below the.
As the API notes indicate, the Component class (which is the ancestor of all GUI objects) and the Window class (which is the superclass of the Frame class) are where you need to look for the methods to resize and reshape frames.
For example, the setLocation method in the Component class is one way to reposition a component.
Similarly, the setBounds method in Component lets you resize and relocate a component (in particular, a JFrame) in one step, as.
Note For a frame, the coordinates of the setLocation and setBounds are taken relative to the whole screen.
As you will see in Chapter 9, for other components inside a container, the measurements are taken relative to the container.
Many methods of component classes come in getter/setter pairs, such as the following.
The name is obtained by changing the first letter after the get or set to lowercase.
For example, the Frame class has a property with name title and type String.
When we set the property, we expect the title to change on the user’s screen.
When we get the property, we expect to get back the value that we have set.
We do not know (or care) how the Frame class implements this property.
Perhaps it simply uses its peer frame to store the title.
Perhaps they do more, such as notifying the windowing system whenever the title changes.
There is one exception to the get/set convention: For properties of type boolean, the getter starts with is.
For example, the following two methods define the locationByPlatform property:
We will look at properties in much greater detail in Chapter 8 of Volume II.
Note Many programming languages, in particular Visual Basic and C#, have built-in support for properties.
It is possible that a future version of Java may also add a language construct for properties.
However, in a professional application, you should check the resolution of the user’s screen and write code that resizes the frames accordingly: A window that looks nice on a laptop screen will look like a postage stamp on a high-resolution screen.
To find out the screen size, use the following steps.
Call the static getDefaultToolkit method of the Toolkit class to get the Toolkit object.
The Toolkit class is a dumping ground for a variety of methods interfacing with the native windowing system.) Then call the getScreenSize method, which returns the screen size as a Dimension object.
A Dimension object simultaneously stores a width and a height, in public (!) instance variables width and height.
We use 50% of these values for the frame size, and tell the windowing system to position the frame:
Depending on your operating system, you can see the icon in various places.
For example, in Windows, the icon is displayed in the top left corner of the window, and you can see it in the list of active tasks when you press Alt+Tab.
Here are a few additional tips for dealing with frames: • If your frame contains only standard components such as buttons and text fields, you can simply call the pack method to set the frame size.
The frame will be set to the smallest size that contains all components.
It is quite common to set the main frame of a program to the maximum size.
As of Java SE 1.4, you can simply maximize a frame by calling.
The GraphicsDevice class also lets you execute your application in full-screen mode.
Components are initially visible, with the exception of top-level components such as JFrame.
The x and y coordinates use the coordinates of the container if the component is not a top-level component, or the coordinates of the screen if the component is top-level (for example, a JFrame)
When the property is set before this window is displayed, the platform picks a suitable location.
When the property is set, the user can resize the frame.
String getTitle() • void setTitle(String s) gets or sets the title property that determines the text in the title bar for the frame.
Image getIconImage() • void setIconImage(Image image) gets or sets the iconImage property that determines the icon for the frame.
The windowing system may display the icon as part of the frame decoration or in other locations.
When the property is set, the frame is displayed without decorations such as a title bar or close button.
This method must be called before the frame is displayed.
In this section, we will show you how to display information inside a frame.
You could draw the message string directly onto a frame, but that is not considered good programming practice.
In Java, frames are really designed to be containers for components, such as a menu bar and other user interface elements.
You normally draw on another component which you add to the frame.
Look at Figure 7.8, which shows the makeup of a JFrame.
As you can see, four panes are layered in a JFrame.
The root pane, layered pane, and glass pane are of no interest to us; they are required to organize the menu bar and content pane and to implement the look-and-feel.
The part that most concerns Swing programmers is the content pane.
When designing a frame, you add components into the content pane, using code such as the following:
In our case, we want to add a single component to the frame onto which we will draw our message.
To draw on a component, you define a class that extends JComponent and override the paintComponent method in that class.
A Graphics object remembers a collection of settings for drawing images and text, such as the font you set or the current color.
All drawing in Java must go through a Graphics object.
Note The Graphics parameter is similar to a device context in Windows or a graphics context in X11 programming.
Here’s how to make a component onto which you can draw:
Each time a window needs to be redrawn, no matter what the reason, the event handler notifies the component.
This causes the paintComponent methods of all components to be executed.
It is called automatically whenever a part of your application needs to be redrawn, and you should not interfere with this automatic process.
What sorts of actions trigger this automatic response? For example, painting occurs when the user increases the size of the window, or minimizes and then restores the window.
If the user popped up another window that covered an existing window and then made the overlaid window disappear, the window that was covered is now corrupted and will need to be repainted.
The graphics system does not save the pixels underneath.) And, of course, when the window is displayed for the first time, it needs to process the code that specifies how and where it should draw the initial elements.
Tip If you need to force repainting of the screen, call the repaint method instead of paintComponent.
The repaint method will cause paintComponent to be called for all components, with a properly configured Graphics object.
As you saw in the code fragment above, the paintComponent method takes a single parameter of type Graphics.
Measurement on a Graphics object for screen display is done in pixels.
The Graphics class has a drawString method that has the following syntax:
Finally, a component should tell its users how big it would like to be.
When you fill a frame with one or more components, and you simply want to use their preferred size, call the pack method instead of the setSize method:
Note Instead of extending JComponent, some programmers prefer to extend the JPanel class.
A JPanel is intended to be a container that can contain other components, but it is also possible to paint on it.
A panel is opaque, which means that it is responsible for painting all pixels within its bounds.
Component add(Component c) adds and returns the given component to the content pane of this frame.
Starting with Java 1.0, the Graphics class has methods to draw lines, rectangles, ellipses,
For example, you cannot vary the line thickness and cannot rotate the shapes.
The Java 2D library organizes geometric shapes in an object-oriented fashion.
In particular, there are classes to represent lines, rectangles, and ellipses:
To draw a shape, you first create an object of a class that implements the Shape interface and then call the draw method of the Graphics2D class.
Note Before the Java 2D library appeared, programmers used methods of the Graphics class, such as drawRectangle, to draw shapes.
In many cases, that is a great convenience because it allows you to specify your shapes in coordinates that are meaningful to you (such as millimeters or inches) and then translate them to pixels.
The Java 2D library uses single-precision float quantities for many of its internal floatingpoint calculations.
Single precision is sufficient—after all, the ultimate purpose of the geometric computations is to set pixels on the screen or printer.
Furthermore, float computations are faster on some platforms, and float values require half the storage of double values.
However, manipulating float values is sometimes inconvenient for the programmer because Java is adamant about requiring casts when converting double values into float values.
The remedy is to add an F suffix to the floatingpoint constant:
This statement does not compile either, for the same reason.
In this book, we fall into the second camp and use double coordinates whenever we can.)
The library designers chose a curious, and initially confusing, method for packaging these choices.
This is an abstract class with two concrete subclasses, which are also static inner classes:
For more information on static inner classes, see Chapter 6.)
You can simply use Rectangle2D variables to hold the rectangle references.
That is, you only need to use the pesky inner classes when you construct the shape objects.
The construction parameters denote the top left corner, width, and height of the rectangle.
Tip Simply use the Double shape classes to avoid dealing with float values altogether.
However, if you are constructing thousands of shape objects, consider using the Float classes to conserve memory.
What we just discussed for the Rectangle2D classes holds for the other shape classes as well.
Admittedly, ellipses are not rectangular, but they have a bounding rectangle (see Figure 7.10)
Finally, a couple of legacy classes from Java 1.0 have been fitted into the shape class hierarchy.
The x and y coordinates of the top left corner; and • The width and height.
However, sometimes you don’t have the top left corner readily available.
It is quite common to have two diagonal corner points of a rectangle, but perhaps they aren’t the top left and bottom right corners.
When constructing an ellipse, you usually know the center, width, and height, but not the corner points of the bounding rectangle (which don’t even lie on the ellipse)
The setFrameFromCenter method uses the center point, but it still requires one of the four corner points.
Thus, you will usually end up constructing an ellipse as follows:
To construct a line, you supply the start and end points, either as Point2D objects or as pairs of numbers:
The setPaint method of the Graphics2D class lets you select a color that is used for all.
You can fill the interiors of closed shapes (such as rectangles or ellipses) with a color.
To draw in multiple colors, select a color, draw or fill, then select another color, and draw or fill again.
Note The fill method paints one fewer pixel to the right and the bottom.
If you fill the same rectangle, those pixels are not painted.
The java.awt.Color class offers predefined constants for the following 13 standard colors:
Note Before Java SE 1.4, color constant names were lowercase, such as Color.red.
This is odd because the standard coding convention is to write constants in uppercase.
You can now write the standard color names in uppercase or, for backward compatibility, lowercase.
You can specify a custom color by creating a Color object by its red, green, and blue components.
Using a scale of 0–255 (that is, one byte) for the redness, blueness, and greenness, call the Color constructor like this:
Color(int redness, int greenness, int blueness) Here is an example of setting a custom color:
In addition to solid colors, you can select more complex “paint” settings, such as varying hues or images.
If you use a Graphics object instead of a Graphics2D object, you need to use the setColor method to set colors.
To set the background color, use the setBackground method of the Component class, an ancestor of JComponent.
It specifies the default color that is used for drawing on the component.
Tip The brighter() and darker() methods of the Color class produce, as their names suggest, either brighter or darker versions of the current color.
Using the brighter method is also a good way to highlight an item.
Java gives you predefined names for many more colors in its SystemColor class.
The constants in this class encapsulate the colors used for various elements of the user’s system.
The background is filled in whenever the window is repainted.) Using the colors in the SystemColor class is particularly useful when you want to draw user interface elements so that the colors match those already found on the user’s desktop.
Table 7.1 lists the system color names and their meanings.
Therefore, you can use this method to set the paint attribute to a solid color.
Often, you will want to show your text in a different font.
You can specify a font by its font face name.
The method returns an array of strings containing the names of all available fonts.
The following program prints the names of all fonts on your system:
Font face names can be trademarked, and font designs can be copyrighted in some.
Thus, the distribution of fonts often involves royalty payments to a font foundry.
Of course, just as there are inexpensive imitations of famous perfumes, there are lookalikes for name-brand fonts.
For example, the Helvetica imitation that is shipped with Windows is called Arial.
These names are always mapped to some fonts that actually exist on the client machine.
For example, on a Windows system, SansSerif is mapped to Arial.
To draw characters in a font, you must first create an object of the class Font.
Specify the font face name, the font style, and the point size.
Here is an example of how you construct a Font object:
You can use a logical font name in place of the font face name in the Font constructor.
Specify the style (plain, bold, italic, or bold italic) by setting the second Font constructor argument to one of the following values:
You can read font files in TrueType, OpenType, or PostScript Type 1 formats.
You need an input stream for the font—typically from a file or URL.
See Chapter 1 of Volume II for more information on streams.) Then, call the static Font.createFont method:
The font is plain with a font size of 1 point.
Use the deriveFont method to get a font of the.
Caution There are two overloaded versions of the deriveFont method.
One of them (with a float parameter) sets the font size, the other (with an int parameter) sets the font style.
The Java fonts contain the usual ASCII characters as well as symbols.
For example, if you print the character '\u2297' in the Dialog font, you get a  character.
Only the symbols defined in the Unicode character set are available.
Next, let’s center the string in its component instead of drawing it at an arbitrary position.
We need to know the width and height of the string in pixels.
Simply pass that object to the getStringBounds method of the Font class:
The getStringBounds method returns a rectangle that encloses the string.
To interpret the dimensions of that rectangle, you should know some basic typesetting.
The baseline is the imaginary line where, for example, the bottom of a character like “e” rests.
Leading is the space between the descent of one line and the ascent of the next line.
The width of the rectangle that the getStringBounds method returns is the horizontal extent of the string.
The height of the rectangle is the sum of ascent, descent, and leading.
The rectangle has its origin at the baseline of the string.
Thus, you can obtain string width, height, and ascent as follows:
If you need to know the descent or leading, use the getLineMetrics method of the Font class.
That method returns an object of the LineMetrics class, which has methods to obtain the descent and leading:
To understand the centering, consider that getWidth() returns the width of the component.
Therefore, the blank space on each side is half the difference.
Note When you need to compute layout dimensions outside the paintComponent method, you can’t obtain the font render context from the Graphics2D object.
To show that the positioning is accurate, the sample program also draws the baseline and the bounding rectangle.
String getFontName() gets the font face name (such as "Helvetica Bold")
String getFamily() gets the font family name (such as "Helvetica")
String getName() gets the logical name (such as "SansSerif") if the font was created with a logical font name; otherwise, gets the font face name.
The top y coordinate of the rectangle equals the negative of the ascent.
The height of the rectangle equals the sum of ascent, descent, and leading.
Font deriveFont(int style, float size) 1.2 returns a new font that is equal to this font, except that it has the given size and style.
The FontMetrics class is a precursor to the LineMetrics class.
You have already seen how to build up simple drawings by painting lines and shapes.
Complex images, such as photographs, are usually generated externally—for example, with a scanner or special image-manipulation software.
As you will see in Volume II, it is also possible to produce an image, pixel by pixel.
Once images are stored in local files or someplace on the Internet, you can read them into a Java application and display them on Graphics objects.
Here, we use the ImageIcon class that you already saw:
Listing 7.6 takes this a little bit further and tiles the window with the graphics image.
The result looks like the screen shown in Figure 7.15
We first draw one copy of the image in the top left corner and then use the copyArea call to copy it into the entire window:
Listing 7.6 shows the full source code of the image display program.
Note: This call may return before the image is drawn.
The system scales the image to fit into a region with the given width and height.
Note: This call may return before the image is drawn.
For more advanced techniques, refer to the discussion of 2D graphics and image manipulation in Volume II.
In the next chapter, you will learn how your programs can react to user input.
Event handling is of fundamental importance to programs with a graphical user interface.
To implement user interfaces, you must master the way in which Java handles events.
This chapter explains how the Java AWT event model works.
You will see how to capture events from user interface components and input devices.
We will also show you how to work with actions, which represent a more structured approach for processing action events.
Any operating environment that supports GUIs constantly monitors events such as.
The operating environment reports these events to the programs that are running.
Each program then decides what, if anything, to do in response to these events.
In languages like Visual Basic, the correspondence between events and code is obvious.
One writes code for each specific event of interest and places the code in what is usually called an event procedure.
The code in this procedure executes whenever that button is clicked.
Each Visual Basic GUI component responds to a fixed set of events, and it is impossible to change the events to which it responds.
On the other hand, if you use a language like raw C to do event-driven programming, you need to write the code that constantly checks the event queue for what the operating environment is reporting; this is usually done by encasing your code in a loop with a massive switch statement.
This technique is obviously rather ugly and, in any case, much more difficult to code.
Its advantage is that the events you can respond to are not as limited as in the languages which, like Visual Basic, go to great lengths to hide the event queue from the programmer.
The Java programming environment takes an approach somewhere in between the Visual Basic and the raw C in terms of power and the resulting complexity.
Within the limits of the events that the AWT knows about, you completely control how events are transmitted from the event sources (such as buttons or scrollbars) to event listeners.
You can designate any object to be an event listener—in practice, you pick an object that can conveniently carry out the desired response to the event.
This event delegation model gives you much more flexibility than is possible with Visual.
Event sources have methods that allow you to register event listeners with them.
When an event happens to the source, the source sends a notification of that event to all the listener objects that were registered for that event.
As one would expect in an object-oriented language like Java, the information about the event is encapsulated in an event object.
Of course, there are subclasses for each event type, such as ActionEvent and WindowEvent.
For example, a button can send ActionEvent objects, whereas a window can send WindowEvent objects.
To sum up, here’s an overview of how event handling in the AWT works: • A listener object is an instance of a class that implements a special interface called (naturally enough) a listener interface.
An event source is an object that can register listener objects and send them event objects.
The event source sends out event objects to all registered listeners when that event occurs.
The listener objects will then use the information in the event object to determine their reaction to the event.
Figure 8.1 shows the relationship between the event handling classes and interfaces.
For buttons, as you might expect, an action event is a button click.
To implement the ActionListener interface, the listener class must have a method called actionPerformed that receives an ActionEvent object as a parameter.
An event source such as a button can have multiple listeners.
In that case, the button calls the actionPerformed methods of all listeners whenever the user clicks the button.
Figure 8.2 shows the interaction between the event source, event listener, and event object.
As a way of getting comfortable with the event delegation model, let’s work.
For this example, we will show a panel populated with three buttons.
Three listener objects are added as action listeners to the buttons.
With this scenario, each time a user clicks on any of the buttons on the panel, the associated listener object receives an ActionEvent that indicates a button click.
In our sample program, the listener object will then change the background color of the panel.
Before we can show you the program that listens to button clicks, we first need to explain how to create buttons and how to add them to a panel.
To create a button, specify a label string, an icon, or both in the button constructor.
Next, we need to add code that listens to these buttons.
This requires classes that implement the ActionListener interface, which, as we just mentioned, has one method: actionPerformed, whose signature looks like this:
Note The ActionListener interface we used in the button example is not restricted to button clicks.
The way to use the ActionListener interface is the same in all situations: The actionPerformed method (which is the only method in ActionListener) takes an object of type ActionEvent as a parameter.
This event object gives you information about the event that happened.
When a button is clicked, we want the background color of the panel to change to.
We then construct one object for each color and set the objects as the button listeners.
For example, if a user clicks on the button marked “Yellow,” the actionPerformed method of the yellowAction object is called.
Its backgroundColor instance field is set to Color.YELLOW, and it can now proceed to set the panel’s background color.
The ColorAction object doesn’t have access to the buttonPanel variable.
You can store the panel in the ColorAction object and set it in the ColorAction constructor.
Or, more conveniently, you can make ColorAction into an inner class of the ButtonFrame class.
Here is how you place the ColorAction class inside the ButtonFrame class:
Event listener objects usually need to carry out some action that affects other objects.
Some people dislike inner classes because they feel that a proliferation of classes.
You don’t need a new class for every user interface component.
In our example, all three buttons share the same listener class.
Of course, each of them has a separate listener object.
They each contain a color value and a reference to the panel.
And the traditional solution, with if/else statements, also references the same color objects that the action listeners store—just as local variables, not as instance fields.
Here is a good example of how anonymous inner classes can actually simplify your code.
If you look at the code of Listing 8.1, you will note that each button requires the same treatment:
As with all local variables that are accessed in the inner class, the parameter needs to be declared as final.)
As you saw in Chapter 6, the inner class mechanism automatically generates a constructor that stores all local final variables that are used in one of the methods of the inner class.
But you can get used to deciphering them if you train your eyes to glaze over the routine code, like this:
As long as the event handler consists of just a few statements, we think this can be quite readable, particularly if you don’t worry about the inner class mechanics.
Note You are completely free to designate any object of a class that implements the ActionListener interface as a button listener.
We prefer to use objects of a new class expressly created for carrying out the desired button actions.
However, some programmers are not comfortable with inner classes and choose a different strategy.
They make the container of the event sources implement the ActionListener interface.
Then, the container sets itself as the listener, like this:
Therefore, the actionPerformed method must figure out which button was clicked.
As you can see, this gets quite messy, and we do not recommend it.
If the action event originated from a button, the command string equals the button label, unless it has been changed with the setActionCommand method.
You can specify simple event listeners without programming inner classes.
If the listener calls a method with a single parameter that can be obtained from the event parameter, you can use another form of the create method.
The property names source and text turn into method calls getSource and getText.
Otherwise, the reflection mechanism will not be able to locate and invoke the target method.
Either the named method or all methods of the interface carry out the given action on the target object.
The action can be a method name or a property of the target.
If it is a property, its setter method is executed.
For example, an action "text" is turned into a call of the setText method.
The event property consists of one or more dot-separated property names.
The first property is read from the parameter of the listener method, the second property is read from the resulting object, and so on.
For example, the property "source.text" is turned into calls to the getSource and getText methods.
The first is to supply a file swing.properties in the jre/lib subdirectory of your Java installation.
Note that the Metal look-and-feel is located in the javax.swing package.
The other look-and-feel packages are located in the com.sun.java package and need not be present in every Java implementation.
Currently, for copyright reasons, the Windows and Macintosh look-and-feel packages are only shipped with the Windows and Macintosh versions of the Java runtime environment.
You must restart your program to switch the look-and-feel in this way.
A Swing program reads the swing.properties file only once, at startup.
You need to supply one component to that method; it will find all others.
As always, we ask you to gloss over the exceptionhandling code and wait until Chapter 11 for a full explanation.
Here is an example showing how you can switch to the Motif look-and-feel in your program:
Following the advice of the preceding section, we use a helper method makeButton and an anonymous inner class to specify the button action—namely, to switch the look-and-feel.
Recall from Chapter 6 that the outer object’s this pointer must be prefixed by the outer class name:
String getClassName() returns the name of the implementation class for the look-and-feel.
Not all events are as simple to handle as button clicks.
When the user closes the frame, you want to put up a dialog and exit the program only when the user agrees.
When the user tries to close a window, the JFrame object is the source of a WindowEvent.
If you want to catch that event, you must have an appropriate listener object and add it to the frame’s list of window listeners.
The window listener must be an object of a class that implements the WindowListener interface.
The frame calls them as the responses to seven distinct events that could happen to a window.
As is always the case in Java, any class that implements an interface must implement all its methods; in this case, that means implementing seven methods.
Recall that we are only interested in one of these seven methods, namely, the windowClosing method.
Of course, we can define a class that implements the interface, add a call to System.exit(0) in the windowClosing method, and write do-nothing functions for the other six methods:
Typing code for six methods that don’t do anything is the kind of tedious busy-work that nobody likes.
To simplify this task, each of the AWT listener interfaces that have more than one method comes with a companion adapter class that implements all the methods in the interface but does nothing with them.
This means the adapter class automatically satisfies the technical requirements that Java imposes for implementing the associated.
You can extend the adapter class to specify the desired reactions to some, but not all, of the event types in the interface.
An interface such as ActionListener that has only a single method does not need an adapter class.)
We can extend the WindowAdapter class, inherit six of the do-nothing methods, and override the windowClosing method:
Whenever the frame generates a window event, it passes it to the listener object by calling one of its seven methods (see Figure 8.5)
Six of those methods do nothing; the windowClosing method calls System.exit(0), terminating the application.
Caution If you misspell the name of a method when extending an adapter class, the compiler won’t catch your error.
For example, if you define a method windowIsClosing in a WindowAdapter class, you will get a class with eight methods, and the windowClosing method will do nothing.
Creating a listener class that extends the WindowAdapter is an improvement, but we can go even further.
There is no need to give a name to the listener object.
Again, the syntax for using anonymous inner classes takes some getting used to.
The payoff is that the resulting code is as short as possible.
Note that the window will close only if its hide or dispose method is called.
Typically, the window manager decorates the active window—for example, by highlighting the title bar.
It is common to have multiple ways to activate the same command.
This is easy to achieve in the AWT event model: link all events to the same listener.
For example, suppose blueAction is an action listener whose actionPerformed method changes the background color to blue.
You can attach the same object as a listener to several event sources:
The color change command will now be handled in a uniform way, no matter whether it was caused by a button click, a menu selection, or a key press.
The Swing package provides a very useful mechanism to encapsulate commands and to attach them to multiple event sources: the Action interface.
The first method is the familiar method in the ActionListener interface: In fact, the Action interface extends the ActionListener interface.
Therefore, you can use an Action object whenever an ActionListener object is expected.
The next two methods let you enable or disable the action and check whether the action is currently enabled.
When an action is attached to a menu or toolbar and the action is disabled, the option is grayed out.
The putValue and getValue methods let you store and retrieve arbitrary name/value pairs in the action object.
If the action object is added to a menu or toolbar, the name and icon are automatically retrieved and displayed in the menu item or toolbar button.
The final two methods of the Action interface allow other objects, in particular menus or toolbars that trigger the action, to be notified when the properties of the action object change.
For example, if a menu is added as a property change listener of an action object and the action object is subsequently disabled, the menu is called and can gray out the action name.
Property change listeners are a general construct that is a part of the “JavaBeans” component model.
You can find out more about beans and their properties in Volume II.
Any class implementing this interface must implement the seven methods we just discussed.
Fortunately, a friendly soul has provided a class AbstractAction that implements all methods except for actionPerformed.
That class takes care of storing all name/value pairs and managing the property change listeners.
Let’s build an action object that can execute color change commands.
We store the name of the command, an icon, and the desired color.
We store the color in the table of name/value pairs that the AbstractAction class provides.
The constructor sets the name/value pairs, and the actionPerformed method carries out the color change action.
That is easy because we can use a JButton constructor that takes an Action object.
You can see the icons and a tooltip in Figure 8.6
As we demonstrate in the next chapter, it is just as easy to add the same action to a menu.
Finally, we want to add the action objects to keystrokes so that an action is carried out when the user types a keyboard command.
To associate actions with keystrokes, you first need to generate objects of the KeyStroke class.
This is a convenience class that encapsulates the description of a key.
To generate a KeyStroke object, you don’t call a constructor but instead use the static getKeyStroke method of the KeyStroke class.
A user interface can have many buttons, menus, scrollbars, and other components.
When you hit a key, it is sent to the component that has focus.
For example, in the Java look-and-feel, a button with focus has a thin rectangular border around the button text.
You can use the Tab key to move the focus between components.
When you press the space bar, the button with focus is clicked.
Other keys carry out different actions; for example, the arrow keys can move a scrollbar.
However, in our case, we do not want to send the keystroke to the component that has focus.
This is a common problem, and the Swing designers came up with a convenient solution.
Every JComponent has three input maps, each mapping KeyStroke objects to associated actions.
The three input maps correspond to three different conditions (see Table 8.2)
Keystroke processing checks these maps in the following order: 1
Check the WHEN_FOCUSED map of the component with input focus.
As soon as a map with the keystroke is found, execute the corresponding action.
Give these components (in the order of their keystroke registration) a chance to execute the corresponding action.
As soon as the first enabled action is executed, stop processing.
To obtain an input map from the component, use the getInputMap method.
One of the buttons, not the panel, has the input focus.
Either of the other two map choices works fine for inserting the color change keystrokes.
The InputMap doesn’t directly map KeyStroke objects to Action objects.
Instead, it maps to arbitrary objects, and a second map, implemented by the ActionMap class, maps objects to actions.
That makes it easier to share the same actions among keystrokes that come from different input maps.
Thus, each component has three input maps and one action map.
To tie them together, you need to come up with names for the actions.
Here is how you can tie a key to an action:
It is customary to use the string "none" for a do-nothing action.
Caution The JDK documentation suggests using the action name as the action’s key.
The action name is displayed on buttons and menu items; thus, it can change at the whim of the UI designer and may be translated into multiple languages.
Such unstable strings are poor choices for lookup keys, so we recommend that you come up with action names that are independent of the displayed names.
To summarize, here is what you do to carry out the same action in response to a button, a menu item, or a keystroke:
You may be able to use the same class for multiple related actions.
Construct a button or menu item from the action object.
The constructor will read the label text and icon from the action object.
For actions that can be triggered by keystrokes, you have to carry out additional steps.
First, locate the top-level component of the window, such as a panel that contains all other components.
Make an action key object, such as a string that describes your action.
Add the pair (keystroke, action key) into the input map.
Add the pair (action key, action object) into the map.
Listing 8.3 shows the complete code of the program that maps both buttons and keystrokes to action objects.
Object getValue(String key) returns the value of a stored name/value pair.
The description starts with zero or more modifiers shift control ctrl meta alt altGraph and ends with either the string typed, followed by a one-character string (for example, "typed a") or an optional event specifier (pressed or released, with pressed being the default), followed by a key code.
InputMap getInputMap(int flag)1.3 gets the input map that maps key strokes to action map keys.
You do not need to handle mouse events explicitly if you just want the user to be.
These mouse operations are handled internally by the various components in the user interface.
However, if you want to enable the user to draw with the mouse, you will need to trap mouse move, click, and drag events.
In this section, we will show you a simple graphics editor application that allows the user to place, move, and erase squares on a canvas (see Figure 8.7)
When the user clicks a mouse button, three listener methods are called: mousePressed when the mouse is first pressed, mouseReleased when the mouse is released, and, finally, mouseClicked.
If you are only interested in complete clicks, you can ignore the first two methods.
By using the getX and getY methods on the MouseEvent argument, you can obtain the x and y coordinates of the mouse pointer when the mouse was clicked.
To distinguish between single, double, and triple (!) clicks, use the getClickCount method.
We find this practice reprehensible, but if you disagree, you will find that checking for mouse buttons and keyboard modifiers is a mess.
Use bit masks to test which modifiers have been set.
In the original API, two of the button masks equal two keyboard modifier masks, namely.
This was done so that users with a one-button mouse could simulate the other mouse buttons by holding down modifier keys instead.
However, as of Java SE 1.4, a different approach is recommended.
The getModifiersEx method accurately reports the mouse buttons and keyboard modifiers of a mouse event.
Note that BUTTON3_DOWN_MASK tests for the right (nonprimary) mouse button under Windows.
For example, you can use code like this to detect whether the right mouse button is down:
In our sample program, we supply both a mousePressed and a mouseClicked methods.
When you click onto a pixel that is not inside any of the squares that have.
We implemented this in the mousePressed method so that the user receives immediate feedback and does not have to wait until the mouse button is released.
When a user double-clicks inside an existing square, it is erased.
We implemented this in the mouseClicked method because we need the click count.
As the mouse moves over a window, the window receives a steady stream of mouse movement events.
This is done for efficiency—there are a lot of mouse events as the user moves the mouse around, and a listener that just cares about mouse clicks will not be bothered with unwanted mouse moves.
Our test application traps mouse motion events to change the cursor to a different shape (a cross hair) when it is over a square.
Table 8.3 lists the constants to use with this method along with what the cursors look like under Windows.
Note You can also define your own cursor types through the use of the createCustomCursor method in the Toolkit class:
The first parameter of the createCustomCursor points to the cursor image.
The third parameter is a string that describes the cursor.
For example, a screen reader program can read the cursor shape description to a user who is visually impaired or who simply is not facing the screen.
If the user presses a mouse button while the mouse is in motion, mouseDragged calls are generated instead of mouseMoved calls.
Our test application lets a user drag the square under the cursor.
We simply update the currently dragged rectangle to be centered under the mouse position.
Then, we repaint the canvas to show the new mouse position.
Note The mouseMoved method is only called as long as the mouse stays inside the component.
However, the mouseDragged method keeps getting called even when the mouse is being dragged outside the component.
There are two other mouse event methods: mouseEntered and mouseExited.
These methods are called when the mouse enters or exits a component.
Mouse clicks are reported through the mouseClicked procedure, which is part of the MouseListener interface.
In our program we are interested in both types of mouse events.
The MouseHandler class extends the MouseAdapter class because it defines only two of the five MouseListener methods.
The time interval for what constitutes “consecutive” is system dependent.)
Use the following mask values to test the returned value:
Having given you a taste of how event handling works, we finish this chapter with.
As we briefly mentioned earlier, event handling in Java is object-oriented, with all.
The common superclass is not called Event because that is the name of the event class in the old event model.
Although the old model is now deprecated, its classes are still a part of the Java library.)
The EventObject class has a subclass AWTEvent, which is the parent of all AWT event classes.
Figure 8.8 shows the inheritance diagram of the AWT events.
Some of the Swing components generate event objects of yet more event types; these directly extend EventObject, not AWTEvent.
The event objects encapsulate information about the event that the event source communicates to its listeners.
When necessary, you can then analyze the event objects that were passed to the listener object, as we did in the button example with the getSource and getActionCommand methods.
Some of the AWT event classes are of no practical use for the Java programmer.
For example, the AWT inserts PaintEvent objects into the event queue, but these objects are not delivered to listeners.
Java programmers don’t listen to paint events; instead, they override the paintComponent method to control repainting.
The AWT makes a useful distinction between low-level and semantic events.
In the case of a button click, this is a mouse down, a series of mouse moves, and a mouse up (but only if the mouse up is inside the button area)
Or it might be a keystroke, which happens if the user selects the button with the Tab key and then activates it with the space bar.
Similarly, adjusting a scrollbar is a semantic event, but dragging the mouse is a low-level event.
Here are the most commonly used semantic event classes in the java.awt.event package:
Several of the AWT listener interfaces, namely those that have more than one method, come with a companion adapter class that implements all the methods in the interface to do nothing.
The other interfaces have only a single method each, so there is no benefit in having adapter classes for these interfaces.) Here are the commonly used adapter classes:
Table 8.4 shows the most important AWT listener interfaces, events, and event sources.
The next chapter shows you how to put together the most common Swing components, along with a detailed coverage of the events they generate.
The last chapter was written primarily to show you how to use the event model in Java.
In the process, you took the first steps toward learning how to build a graphical user interface.
This chapter shows you the most important tools you’ll need to build more full-featured GUIs.
We start out with a tour of the architectural underpinnings of Swing.
We then show you how to use the most common user interface components in Swing, such as text fields, radio buttons, and menus.
Next, you will learn how to use the nifty layout manager features of Java to arrange these components in a window, regardless of the look-and-feel of a particular user interface.
Finally, you’ll see how to implement dialog boxes in Swing.
This chapter covers the basic Swing components such as text components, buttons, and sliders.
These are the essential user interface components that you will need most frequently.
As promised, we start this chapter with a description of the architecture of Swing.
When solving a problem, you don’t usually figure out a solution from first principles.
Design patterns are a method for presenting this expertise in a structured way.
In recent years, software engineers have begun to assemble catalogs of such patterns.
The pioneers in this area were inspired by the architectural design patterns of the architect Christopher Alexander.
In his book, The Timeless Way of Building (Oxford University Press, 1979), Alexander gives a catalog of patterns for designing public and private living spaces.
Window Place Everybody loves window seats, bay windows, and big windows with low sills and comfortable chairs drawn up to them.
A room which does not have a place like this seldom allows you to feel comfortable or perfectly at ease.
Each pattern in Alexander’s catalog, as well as those in the catalogs of software patterns, follows a particular format.
The pattern first describes a context, a situation that gives rise to a design problem.
Then, the problem is explained, usually as a set of conflicting forces.
Finally, the solution shows a configuration that balances these forces.
The conflicting forces are that you want to sit down and be comfortable and that you are drawn to the light.
There may be multiple visual representations of the same data that need to be updated together.
The visual representations may change, for example, to accommodate various lookand-feel standards.
The interaction mechanisms may change, for example, to support voice commands.
The solution is to distribute responsibilities into three separate interacting components: the model, the view, and the controller.
One important aspect of design patterns is that they become part of the culture.
Thus, patterns become an efficient way of talking about design problems.
You will find a formal description of numerous useful software patterns in the seminal book of the pattern movement, Design Patterns—Elements of Reusable Object-Oriented Software , by Erich Gamma et al.
We also highly recommend the excellent book A System of Patterns by Frank Buschmann et al.
Let’s step back for a minute and think about the pieces that make up a user interface.
Even a seemingly simple component such as a button exhibits some moderately complex interaction among these characteristics.
Obviously, the visual appearance of a button depends on the look-and-feel.
A Metal button looks different from a Windows button or a Motif button.
In addition, the appearance depends on the button state; when a button is pushed in, it needs to be redrawn to look different.
The state depends on the events that the button receives.
When the user depresses the mouse inside the button, the button is pushed in.
Of course, when you use a button in your programs, you simply consider it as a button; you don’t think too much about the inner workings and characteristics.
That, after all, is the job of the programmer who implemented the button.
However, programmers who implement buttons and all other user interface components are motivated to think a little harder about them, so that they work well no matter what look-and-feel is in effect.
This pattern, like many other design patterns, goes back to one of the principles of object-oriented design that we mentioned way back in Chapter 5: Don’t make one object responsible for too much.
Instead, have the look-and-feel of the component associated with one object and store the content in another object.
The model stores the content and has no user interface.
For a button, the content is pretty trivial—just a small set of flags that tells whether the button is currently pushed in or out, whether it is active or inactive, and so on.
For a text field, the content is a bit more interesting.
It is a string object that holds the current text.
The model must implement methods to change the content and to discover what the content.
For example, a text model has methods to add or remove characters in the current text and to return the current text as a string.
Again, keep in mind that the model is completely nonvisual.
It is the job of a view to draw the data stored in the model.
Note The term “model” is perhaps unfortunate because we often think of a model as a representation of an abstract concept.
Car and airplane designers build models to simulate real cars and planes.
In this design pattern, the model stores the complete content, and the view gives a (complete or incomplete) visual representation of the content.
A better analogy might be the model who poses for an artist.
It is up to the artist to look at the model and create a view.
Depending on the artist, that view might be a formal portrait, an impressionist painting, or a cubist drawing that shows the limbs in strange contortions.
When the model is updated through the controller of one of the views, it tells both attached views about the change.
Of course, for a simple user interface component such as a button, you won’t have multiple views of the same model.
The controller handles the user-input events, such as mouse clicks and keystrokes.
It then decides whether to translate these events into changes in the model or the view.
But if the user presses a cursor key, the controller may tell the view to scroll.
Scrolling the view has no effect on the underlying text, so the model never knows that this event happened.
Figure 9.4 shows the interactions among model, view, and controller objects.
Each user interface component has a wrapper class (such as JButton or JTextField) that stores the model and the view.
When you want to inquire about the content (for example, the text in a text field), the wrapper class asks the model and returns the answer to you.
When you want to change the view (for example, move the caret position in a text field), the wrapper class forwards that request to the view.
However, occasionally the wrapper class doesn’t work hard enough on forwarding commands.
You don’t have to work directly with the view— that is the job of the look-and-feel code.)
The model of a button or text field is independent of the look-and-feel—but, of course, the visual representation is completely dependent on the user interface design of a particular look-and-feel.
For example, in a voice-controlled device, the controller must cope with an entirely different set of events than on a standard computer with a keyboard and a mouse.
By separating out the underlying model from the user interface, the Swing designers can reuse the code for the models and can even switch the lookand-feel in a running program.
Of course, patterns are only intended as guidance, not as religion.
Models are easy to separate, and each user interface component has a model class.
But the responsibilities of the view and the controller are not always clearly separated and are distributed over a number of different classes.
Of course, as a user of these classes, you won’t be concerned about this.
In fact, as we pointed out before, you often won’t have to worry about the models either—you can just use the component wrapper classes.
You already learned how to use buttons in the previous chapter, without having to worry.
You will encounter similar kinds of classes and interfaces for the more sophisticated Swing components.
For most components, the model class implements an interface whose name ends in Model; in this case, the interface is called ButtonModel.
Classes implementing that interface can define the state of the various kinds of buttons.
In practice, you won’t care—the minutiae of the button state are only of interest to the view that draws it.
The JButton then asks its model, of course, to retrieve that information.)
Have another look at the ButtonModel interface to see what isn’t there.
The model does not store the button label or icon.
There is no way to find out what’s on the face of a button just by looking at its model.
Of course, each of these button types has different views and controllers.
When using the Metal look-and-feel, the JButton uses a class called BasicButtonUI for the view and a class called ButtonUIListener as controller.
In general, each Swing component has an associated view object that ends in UI.
So, having read this short introduction to what is going on under the hood in a JButton, you may be wondering: Just what is a JButton really? It is simply a wrapper class inheriting from JComponent that holds the DefaultButtonModel object, some view data (such as the button label and icons), and a BasicButtonUI object that is responsible for the button view.
Before we go on to discussing individual Swing components, such as text fields and radio.
You need to write code to position (lay out) the user interface components where you want them to be.
Of course, if you have a Java-enabled development environment, it will probably have a layout tool that automates some or all of these tasks.
The buttons are contained in a JPanel object and are managed by the flow layout manager, the default layout manager for a panel.
Figure 9.6 shows what happens when you add more buttons to the panel.
As you can see, a new row is started when there is no more room.
A panel with six buttons managed by a flow layout.
Moreover, the buttons stay centered in the panel, even when the user resizes the frame (see Figure 9.7)
In general, components are placed inside containers, and a layout manager determines the positions and sizes of the components in the container.
Buttons, text fields, and other user interface elements extend the class Component.
Containers can themselves be put inside other containers, so the class Container extends Component.
Note Unfortunately, the inheritance hierarchy is somewhat unclean in two respects.
First, top-level windows, such as JFrame, are subclasses of Container and hence Component, but they cannot be placed inside other containers.
Each container has a default layout manager, but you can always set your own.
The border layout manager is the default layout manager of the content pane of every.
Unlike the flow layout manager, which completely controls the position of each component, the border layout manager lets you choose where you want to place each component.
You can choose to place the component in the center, north, south, east, or west of the content pane (see Figure 9.9)
The edge components are laid out first, and the remaining available space is occupied by the center.
When the container is resized, the dimensions of the edge components are unchanged, but the center component changes its size.
However, if you accidentally misspell a string, the compiler won’t catch that error.
Unlike the flow layout, the border layout grows all components to fill the available space.
The flow layout leaves each component at its preferred size.) This is a problem when you add a button:
And, if you were to add another button to the southern region, it would just displace the first button.
The three buttons at the bottom of the screen are all contained in a panel.
The panel is put into the southern region of the content pane.
To achieve this configuration, first create a new JPanel object, then add the individual buttons to the panel.
The default layout manager for a panel is a FlowLayout, which is a good choice for this situation.
Add the individual buttons to the panel, using the add method you have seen before.
The position and size of the buttons is under the control of the FlowLayout manager.
This means the buttons stay centered within the panel and do not expand to fill the entire panel area.
Finally, add the panel to the content pane of the frame.
The border layout expands the size of the panel to fill the entire southern region.
The grid layout arranges all components in rows and columns like a spreadsheet.
The calculator program in Figure 9.12 uses a grid layout to arrange the calculator buttons.
When you resize the window, the buttons grow and shrink, but all buttons have identical sizes.
In the constructor of the grid layout object, you specify how many rows and columns you need.
Listing 9.1 shows the panel class of the calculator program.
In this program, we call the pack method after adding the component to the frame.
This method uses the preferred sizes of all components to compute the width and height of the frame.
Of course, few applications have as rigid a layout as the face of a calculator.
In practice, small grids (usually with just one row or one column) can be useful to organize partial areas of a window.
For example, if you want to have a row of buttons of identical sizes, you can put the buttons inside a panel that is governed by a grid layout with a single row.
One of rows and columns (but not both) may be zero, denoting an arbitrary number of components per row or column.
We are finally ready to start introducing the Swing user interface components.
You can use the JTextField and JTextArea components for text input.
A text field can accept only one line of text; a text area can accept multiple lines of text.
A JPasswordField accepts one line of text without showing the contents.
All three of these classes inherit from a class called JTextComponent.
You will not be able to construct a JTextComponent yourself because it is an abstract class.
For example, the methods that get or set the text in a text field or text area are actually in JTextComponent.
The usual way to add a text field to a window is to add it to a panel or other container—just.
This code adds a text field and initializes it by placing the string "Default input" inside it.
One column is the expected width of one character in the font you are using for the text.
The idea is that if you expect the inputs to be n characters or less, you are supposed to specify n as the column width.
Also, keep in mind that the number of columns is only a hint to the AWT that gives the preferred size.
If the layout manager needs to grow or shrink the text field, it can adjust its size.
The column width that you set in the JTextField constructor is not an upper limit on the number of characters the user can enter.
The user can still type in longer strings, but the input scrolls when the text exceeds the length of the field.
Users tend to find scrolling text fields irritating, so you should size the fields generously.
If you need to reset the number of columns at runtime, you can do that with the setColumns method.
Tip After changing the size of a text box with the setColumns method, call the revalidate method of the surrounding container.
The revalidate method recomputes the size and layout of all components in a container.
After you use the revalidate method, the layout manager resizes the container, and the changed size of the text field will be visible.
It doesn’t immediately resize the component but merely marks it for resizing.
This approach avoids repetitive calculations if multiple components request to be resized.
However, if you want to recompute all components inside a JFrame, you have to call the validate method.
In general, users add text (or edit an existing text) in a text field.
To make a blank text field, just leave out the string as a parameter for the JTextField constructor:
And, as was mentioned in the previous section, you can find out what the user typed by calling the getText method.
This method returns the exact text that the user has typed.
To trim any extraneous leading and trailing spaces from the data in a text field, apply the trim method to the return value of getText:
JTextField(String text, int cols) constructs a new JTextField with an initial string and the specified number of columns.
If the component is a container, the positions and sizes of its components are recomputed.
For example, unlike buttons, text fields have no label to identify them.
Place it close enough to the component you want to identify so that the user can see that the label identifies the correct component.
The constructor for a JLabel lets you specify the initial text or icon and, optionally, the alignment of the content.
You use constants from the SwingConstants interface to specify alignment.
That interface defines a number of useful constants such as LEFT, RIGHT, CENTER, NORTH, EAST, and so on.
The JLabel class is one of several Swing classes that implement this interface.
Tip You can use both plain and HTML text in buttons, labels, and menu items.
We don’t recommend HTML in buttons—it interferes with the look-and-feel.
Labels can be positioned inside a container like any other component.
This means you can use the techniques you have seen before to place your labels where you need them.
String getText() • void setText(String text) gets or sets the text of this label.
Icon getIcon() • void setIcon(Icon icon) gets or sets the icon of this label.
To prevent nosy bystanders from seeing your password, the characters that the user enters are not actually displayed.
Instead, each typed character is represented by an echo character, typically an asterisk (*)
Swing supplies a JPasswordField class that implements such a text field.
The password field uses the same model to store the data as a regular text field, but its view has been changed to display all characters as echo characters.
This is advisory; a particular look-andfeel may insist on its own choice of echo character.
A value of 0 resets the echo character to the default.
For stronger security, you should overwrite the content of the returned array after use.
Sometimes, you need to collect user input that is more than one line long.
When you place a text area component in your program, a user can enter any number of lines of text, using the Enter key to separate them.
In the constructor for the JTextArea component, specify the number of rows and columns for the text area.
Also, as before, the user is not restricted to the number of rows and columns; the text simply scrolls when the user inputs too much.
These numbers only indicate the preferred size—the layout manager can still grow or shrink the text area.
If there is more text than the text area can display, the remaining text is simply clipped.
You can avoid clipping long lines by turning on line wrapping:
If you want scrollbars, you have to place the text area inside a scroll pane.
The scroll pane now manages the view of the text area.
Scrollbars automatically appear if there is more text than the text area can display, and they vanish again if text is deleted and the remaining text fits inside the area.
The scrolling is handled internally by the scroll pane— your program does not need to process scroll events.
This is a general mechanism that works for any component, not just text areas.
To add scrollbars to a component, put them inside a scroll pane.
This program shows a text field, a password field, and a text area with scrollbars.
Click on “Insert” to insert the field contents into the text area.
Note The JTextArea component displays plain text only, without special fonts or formatting.
To display formatted text (such as HTML), you can use the JEditorPane class that is discussed in Volume II.
If it is false, long lines are broken without taking word boundaries into account.
Note that the tabs aren’t converted to spaces but cause alignment with the next tab stop.
Scrollbars are supplied when the component is larger than the view.
You now know how to collect text input from users, but there are many occasions where you would rather give users a finite set of choices than have them enter the data in a text component.
Using a set of buttons or a list of items tells your users what choices they have.
It also saves you the trouble of error checking.) In this section, you will learn how to program checkboxes, radio buttons, lists of choices, and sliders.
The user can check the box by clicking inside it and turn off the checkmark by clicking inside the box again.
Pressing the space bar when the focus is in the checkbox also toggles the checkmark.
Figure 9.14 shows a simple program with two checkboxes, one for turning on or off the italic attribute of a font, and the other for boldface.
Note that the second checkbox has focus, as indicated by the rectangle around the label.
Each time the user clicks one of the checkboxes, the screen is refreshed, using the new font attributes.
Checkboxes need a label next to them to identify their purpose.
When the user clicks on a checkbox, this triggers an action event.
In our program, the two checkboxes share the same action listener.
The actionPerformed method queries the state of the bold and italic checkboxes and sets the font of the panel to plain, bold, italic, or both bold and italic.
Listing 9.3 is the complete program listing for the checkbox example.
JCheckBox(String label, boolean state) constructs a checkbox with the given label and initial state.
In the previous example, the user could check either, both, or neither of the two checkboxes.
In many cases, we want the user to check only one of several boxes.
When another box is checked, the previous box is automatically unchecked.
Such a group of boxes is often called a radio button group because the buttons work like the station selector buttons on a radio.
When you push in one button, the previously depressed button pops out.
Then, you add objects of type JRadioButton to the button group.
The button group object is responsible for turning off the previously set button when a new button is clicked.
The second argument of the constructor is true for the button that should be checked initially and false for all others.
Note that the button group controls only the behavior of the buttons; if you want to group the buttons for layout purposes, you also need to add them to a container such as a JPanel.
Radio buttons are round and contain a dot when selected.
The event notification mechanism for radio buttons is the same as for any other buttons.
When the user checks a radio button, the button generates an action event.
In our example program, we define an action listener that sets the font size to a particular value:
Compare this listener setup to that of the checkbox example.
Each listener object knows exactly what it needs to do—set the font size to a particular value.
With checkboxes, we used a different approach: Both checkboxes have the same action listener that calls a method looking at the current state of both checkboxes.
Could we follow the same approach here? We could have a single listener that computes the size as follows:
However, we prefer to use separate action listener objects because they tie the size values more closely to the buttons.
Note If you have a group of radio buttons, you know that only one of them is selected.
It would be nice to be able to quickly find out which, without having to query all the buttons in the group.
The ButtonGroup object controls all buttons, so it would be convenient if this object could give us a reference to the selected button.
Indeed, the ButtonGroup class has a getSelection method, but that method doesn’t return the radio button that is selected.
Instead, it returns a ButtonModel reference to the model attached to the button.
The ButtonModel interface inherits a method getSelectedObjects from the ItemSelectable interface that, rather uselessly, returns null.
Only if you explicitly set the action commands of all radio buttons with the setActionCommand method do the action command values of the models also get set.
Listing 9.4 is the complete program for font size selection that puts a set of radio buttons to work.
ButtonModel getSelection() returns the button model of the selected button.
If you have multiple groups of radio buttons in a window, you will want to visually indicate.
Swing provides a set of useful borders for this purpose.
You can apply a border to any component that extends JComponent.
The most common usage is to place a border around a panel and fill that panel with other user interface elements, such as radio buttons.
You can choose from quite a few borders, but you need to follow the same steps for all of them.
Call a static method of the BorderFactory to create a border.
Run the program in Listing 9.5 to get an idea what the various borders look like.
Different borders have different options for setting border widths and colors; see the API.
True border enthusiasts will appreciate that there is also a SoftBevelBorder class for beveled borders with softened corners and that a LineBorder can have rounded corners as well.
You can construct these borders only by using one of the class constructors— there is no BorderFactory method for them.
If you have more than a handful of alternatives, radio buttons are not a good choice because.
When the user clicks on this component, a list of choices drops down, and the user can then select one of them (see Figure 9.17)
If the drop-down list box is set to be editable, then you can edit the current selection as if it were a text field.
For that reason, this component is called a combo box—it combines the flexibility of a text field with a set of predefined choices.
As of Java SE 7, the JComboBox class is a generic class.
Call the setEditable method to make the combo box editable.
It does not change the list of choices in any way.
You can obtain the current selection, which may have been edited if the combo box is editable, by calling the getSelectedItem method.
However, for an editable combo box, that item may have any type, depending on the editor that takes the user edits and turns the result into an object.
See Volume II, Chapter 6 for a discussion of editors.) If your combo box isn’t editable, you are better off calling.
In the example program, the user can choose a font style from a list of styles (Serif,
This method adds the string to the end of the list.
You can add new items anywhere in the list with the insertItemAt method:
If you need to remove items at runtime, use the removeItem or removeItemAt method,
Tip If you need to add a large number of items to a combo box, the addItem method will perform poorly.
When the user selects an item from a combo box, the combo box generates an action event.
To find out which item was selected, call getSource on the event parameter to get a reference to the combo box that sent the event.
Then call the getSelectedItem method to retrieve the currently selected item.
You will need to cast the returned value to the appropriate type, usually String.
Note If you want to show a permanently displayed list instead of a drop-down list, use the JList component.
Combo boxes let users choose from a discrete set of values.
The most common way of constructing a slider is as follows:
Or if you want the slider to be vertical, use the following constructor call:
As the user slides the slider bar, the value of the slider moves between the minimum and the maximum values.
When the value changes, a ChangeEvent is sent to all change listeners.
To be notified of the change, call the addChangeListener method and install an object that implements the ChangeListener interface.
For example, in the sample program, the second slider uses the following settings:
These instructions only set the units for the tick marks.
Until the slider has actually snapped, the change listener still reports slider values that don’t.
You can also supply other tick mark labels, such as strings or icons (see Figure 9.18)
You need to fill a hash table with keys of type Integer and values of type Component.
Listing 9.7 also shows a slider with icons as tick labels.
To suppress the “track” in which the slider moves, call.
We started this chapter by introducing the most common components that you might want to place into a.
Swing also supports another type of user interface element—the pull-down menus that are familiar from GUI applications.
A menu bar at the top of a window contains the names of the pull-down menus.
Clicking on a name opens the menu containing menu items and submenus.
When the user clicks on a menu item, all menus are closed and a message is sent to the program.
You can see separators in Figure 9.19 below the Paste and Read-only menu items.
When the user selects a menu, an action event is triggered.
It often happens that menu items trigger commands that can also be activated through other user interface elements such as toolbar buttons.
In Chapter 8, you saw how to specify commands through Action objects.
You define a class that implements the Action interface, usually by extending the AbstractAction convenience class, specify the menu item label in the constructor of the AbstractAction object, and override the actionPerformed method to hold the menu action handler.
This command adds a menu item to the menu, using the action name.
JMenuItem add(JMenuItem item) adds a menu item (or a menu)
JMenuItem add(String label) adds a menu item with the given label to this menu and returns the item.
JMenuItem add(Action a) adds a menu item with the given action to this menu and returns the item.
JMenuItem insert(JMenuItem menu, int index) adds a new menu item (or submenu) to the menu at a specific index.
JMenuItem insert(Action a, int index) adds a new menu item with the given action at a specific index.
JMenuItem(Action a) 1.3 constructs a menu item for the given action.
You can specify the icon with the JMenuItem(String, Icon) or JMenuItem(Icon) constructor, or you can set it with the setIcon method that the JMenuItem class inherits from the AbstractButton class.
Alternatively, you can set the icon in the AbstractAction constructor:
Checkbox and radio button menu items display a checkbox or radio button next to the name (see Figure 9.19
When the user selects the menu item, the item automatically toggles between checked and unchecked.
Apart from the button decoration, treat these menu items just as you would any others.
For example, here is how you create a checkbox menu item:
The radio button menu items work just like regular radio buttons.
When one of the buttons in a group is selected, all others are automatically deselected.
With these menu items, you don’t necessarily want to be notified when the user selects the item.
Instead, you can simply use the isSelected method to test the current state of the menu item.
Of course, that means that you should keep a reference to the menu item stored in an instance field.) Use the setSelected method to set the state.
A pop-up menu is a menu that is not attached to a menu bar but floats somewhere (see Figure 9.20)
Unlike the regular menu bar that is always shown at the top of the frame, you must explicitly display a pop-up menu by using the show method.
Specify the parent component and the location of the pop-up, using the coordinate system of the parent.
In Windows and Linux, the pop-up trigger is the nonprimary (usually, the right) mouse button.
To pop up a menu when the user clicks on a component, using the pop-up trigger, simply call the method.
If the property is set and this component’s pop-up menu is null, it uses its parent’s pop-up menu.
It is a real convenience for the experienced user to select menu items by keyboard mnemonics.
When the menu is displayed, the user just needs to press the A key, and the menu item is selected.
If the mnemonic letter is not part of the menu string, then typing it still selects the item, but the mnemonic is not displayed in the menu.
Sometimes, you don’t want to underline the first letter of the menu item that matches the mnemonic.
To select a top-level menu from the menu bar, press the Alt key together with the mnemonic letter.
For example, press Alt+H to select the Help menu from the menu bar.
Keyboard mnemonics let you select a submenu or menu item from the currently open menu.
In contrast, accelerators are keyboard shortcuts that let you select menu items without ever opening a menu.
Use the setAccelerator method to attach an accelerator key to a menu item.
For example, the following call attaches the accelerator Ctrl+O to the openItem menu item:
You can attach accelerators only to menu items, not to menus.
Instead, they directly fire the action event associated with a menu.
Conceptually, adding an accelerator to a menu item is similar to the technique of adding an accelerator to a.
But this is not an accelerator to be programmed in Java.
This key combination will always trigger the WindowClosing event for the active window regardless of whether there is a Close item on the menu.
Use this method if you don’t want the first occurrence of the mnemonic character to be underlined.
Occasionally, a particular menu item should be selected only in certain contexts.
Of course, we could remove the item from the menu with the JMenu.remove method, but users would react with some surprise to menus whose content keeps changing.
Instead, it is better to deactivate the menu items that lead to temporarily inappropriate commands.
A deactivated menu item is shown in gray, and it cannot be selected (see Figure 9.23)
There are two strategies for enabling and disabling menu items.
Each time circumstances change, you can call setEnabled on the relevant menu items or actions.
For example, as soon as a document has been set to readonly mode, you can locate the Save and Save As menu items and disable them.
Alternatively, you can disable items just before displaying the menu.
The menuSelected method is called before the menu is displayed.
It can therefore be used to disable or enable menu items.
The following code shows how to disable the Save and Save As actions whenever the Read Only checkbox menu item is selected:
Caution Disabling menu items just before displaying the menu is a clever idea, but it does not work for menu items that also have accelerator keys.
Since the menu is never opened when the accelerator key is pressed, the action is never disabled, and is still triggered by the accelerator key.
Listing 9.8 is a sample program that generates a set of menus.
It shows all the features that you saw in this section: nested menus, disabled menu items, checkbox and radio button menu items, a pop-up menu, and keyboard mnemonics and accelerators.
A toolbar is a button bar that gives quick access to the most commonly used commands in a program (see.
What makes toolbars special is that you can move them elsewhere.
You can drag the toolbar to one of the four borders of the frame (see Figure 9.25)
When you release the mouse button, the toolbar is dropped into the new location (see Figure 9.26)
Note Toolbar dragging works if the toolbar is inside a container with a border layout, or any other layout manager that supports the North, East, South, and West constraints.
The toolbar can even be completely detached from the frame.
A detached toolbar is contained in its own frame (see Figure 9.27)
When you close the frame containing a detached toolbar, the toolbar jumps back into the original frame.
The JToolBar class also has a method to add an Action object.
For example, you can add a combo box to a toolbar.
A disadvantage of toolbars is that users are often mystified by the meanings of the tiny icons in toolbars.
A tooltip is activated when the cursor rests for a moment over a button.
When the user moves the mouse away, the tooltip disappears.
Listing 9.9 shows how the same Action objects can be added to a menu and a toolbar.
Note that the action names show up as the menu item names in the menu, and the short descriptions as the tooltips in the toolbar.
JButton add(Action a) constructs a new button inside the toolbar with name, icon, short description, and action callback from the given action, and adds the button to the end of the toolbar.
We have managed to lay out the user interface components of our sample applications so far by using only.
For more complex tasks, this is not going to be enough.
In this section, we will discuss advanced layout management in detail.
Windows programmers may well wonder why Java makes so much fuss about layout managers.
After all, in Windows, layout management is not a big deal; you just use a dialog editor to drag and drop your components onto the surface of a dialog, and then use editor tools to line up components, to space them equally, to center them, and so on.
If you are working on a big project, you probably don’t have to worry about component layout at all—a skilled user interface designer does all this for you.
The problem with this approach is that the resulting layout must be manually updated if the sizes of the components change.
Why would the component sizes change? There are two common cases.
First, a user may choose a larger font for button labels and other dialog text.
If you try this out for yourself in Windows, you will find that many applications deal with this exceedingly poorly.
The buttons do not grow, and the larger font is simply crammed into the same space as before.
The same problem can occur when the strings in an application are translated to a foreign language.
Why don’t Windows buttons simply grow to accommodate the labels? Because the designer of the user interface gave no instructions in which direction they should grow.
After the dragging and dropping and arranging, the dialog editor merely remembers the pixel position and size of each component.
It does not remember why the components were arranged in this fashion.
The Java layout managers are a much better approach to component layout.
With a layout manager, the layout comes with instructions about the relationships among the components.
This was particularly important in the original AWT, which used native user interface elements.
The size of a button or a list box in Motif, Windows, and the Macintosh could vary widely, and an application or applet would not know a priori on which platform it would display its user interface.
To some extent, that degree of variability has gone away with Swing.
If your application forces a particular look-and-feel, such as Metal, it looks identical on all platforms.
However, if you let users of your application choose their favorite look-and-feel, then you again need to rely on the flexibility of layout managers to arrange the components.
Since Java 1.0, the AWT includes the grid bag layout that lays out components in rows and columns.
The row and column sizes are flexible, and components can span multiple rows and columns.
This layout manager is very flexible, but also very complex.
In an unsuccessful attempt to design a layout manager that would free programmers from the tyranny of the grid bag layout, the Swing designers came up with the box layout.
You use imaginary springs to connect the components in a container.
As the container is resized, the springs stretch or shrink, thereby adjusting the positions of the components.
In 2005, the NetBeans team invented the Matisse technology, which combines a layout tool and a layout manager.
A user interface designer uses the tool to drop components into a container and to indicate which components should line up.
The tool translates the designer’s intentions into instructions for the group layout manager.
This is much more convenient than writing the layout management code by hand.
The group layout manager is now a part of Java SE.
Even if you don’t use NetBeans as your IDE, we think you should consider using its GUI builder tool.
You can design your GUI in NetBeans and paste the resulting code into your IDE of choice.
In the coming sections, we will cover the grid bag layout because it is commonly used and is still the easiest mechanism for producing layout code for older Java versions.
We will show you a strategy that makes grid bag layouts relatively painless in common situations.
Next, we will cover the Matisse tool and the group layout manager.
You will want to know how the group layout manager works so that you can check whether Matisse recorded the correct instructions when you visually positioned your components.
Finally, we will show you how you can bypass layout management altogether and place your components manually, and how you can write your own layout manager.
The grid bag layout is the mother of all layout managers.
You can think of a grid bag layout as a grid layout.
In a grid bag layout, the rows and columns can have variable sizes.
You can join adjacent cells to make room for larger components.
Many word processors, as well as HTML, provide similar capabilities for tables: You can start out with a grid and then merge adjacent cells as necessary.) The components need not fill the entire cell area, and you can specify their alignment within cells.
Now, chop up the container into a grid of cells, as shown in Figure 9.30
The rows and columns need not have equal size.) Each checkbox spans two columns, and the text area spans four rows.
We’ll go over the various constraints in more detail in the sections that follow—so don’t worry if you don’t know what some of the constraints do.)
The trick is knowing how to set the state of the GridBagConstraints object.
We’ll discuss using this object in the sections that follow.
The gridx, gridy, gridwidth, and gridheight constraints define where the component is located in the grid.
The gridx and gridy values specify the column and row positions of the upper left corner of the component to be added.
The gridwidth and gridheight values determine how many columns and rows the component occupies.
You always need to set the weight fields (weightx and weighty) for each area in a grid bag layout.
If you set the weight to 0, the area never grows or shrinks beyond its initial size in that direction.
In the grid bag layout for Figure 9.29 on p.
This allows the labels to keep constant width when you resize the window.
On the other hand, if you set the weights for all areas to 0, the container will huddle in the center of its allotted area instead of stretching to fill it.
Conceptually, the problem with the weight parameters is that weights are properties of rows and columns, not individual cells.
But you need to specify them for cells because the grid bag layout does not expose the rows and columns.
The row and column weights are computed as the maxima of the cell weights in each row or column.
Thus, if you want a row or column to stay at a fixed size, you need to set the weights of all components in it to zero.
Note that the weights don’t actually give the relative sizes of the columns.
They tell what proportion of the “slack” space should be allocated to each area if the container exceeds its preferred size.
Then, run the program and see how the layout looks.
Resize the dialog to see how the rows and columns adjust.
If you find that a particular row or column should not.
You can tinker with other weight values, but it is usually not worth the effort.
If you don’t want a component to stretch out and fill the entire area, set the fill constraint.
If the component does not fill the entire area, you can specify where in the area you want it by setting the anchor field.
You can surround a component with additional blank space by setting the insets field of GridBagConstraints.
Set the left, top, right and bottom values of the Insets object to the amount of space that you want to have around the component.
These values are added to the minimum width and height of the component.
This ensures that the component does not shrink down to its minimum size.
Then, add the components to the grid bag layout in a standardized order, going from left to right in the first row, then moving along the next row, and so on.
You would still specify the number of rows and columns spanned, by giving the appropriate gridheight and gridwidth fields.
This tells the layout manager that the component is the last one in its row.
But it sounds really goofy to hide the actual placement information from the layout manager and hope that it will rediscover it.
All this sounds like a lot of trouble and complexity.
But in practice, the following recipe makes grid bag layouts relatively trouble-free:
Sketch out the component layout on a piece of paper.
Find a grid such that the small components are each contained in a cell and the larger components span multiple cells.
You can now read off the gridx, gridy, gridwidth, and gridheight values.
For each component, ask yourself whether it needs to fill its cell horizontally or vertically.
If not, how do you want it aligned? This tells you the fill and anchor parameters.
However, if you want a particular row or column to always stay at its default size, set the weightx or weighty to 0 in all components that belong to that row or column.
The most tedious aspect of the grid bag layout is writing the code that sets the constraints.
Most programmers write helper functions or a small helper class for this purpose.
We present such a class after the complete code for the font dialog example.
Use a GBC object when adding a component, such as.
Once you understand the grid bag constraints, this kind of code is fairly easy to read and debug.
Note The tutorial at http://docs.oracle.com/javase/tutorial/uiswing/layout/gridbag.html suggests that you reuse the same GridBagConstraints object for all components.
We find the resulting code hard to read and error-prone.
Was it really intended that the buttons are stretched horizontally, or did the programmer just forget to turn off the fill constraint?
Use the latter if your application may be localized for right-to-left or top-to-bottom text.
Insets insets specifies the “external” padding along the cell boundaries.
This constructor should only be used by automatic code generators because it makes your source code very hard to read.
Before discussing the API of the GroupLayout class, let us have a quick look at the Matisse GUI builder in.
Here is the workflow for laying out the top of the dialog in Figure 9.13 on p.
Start a new project and add a new JFrame form.
Drag a label until two guidelines appear that separate it from the container borders:
Drag a text field so that its baseline lines up with the baseline of the first label.
Finally, line up a password field with the label to the left and the text field above.
That looks a bit scary, but fortunately you don’t have to write this code.
However, it is helpful to have a basic understanding of the layout actions so that you can spot errors.
The API notes at the end of this section explain each of the classes and methods in detail.
The various add methods of the group classes return the group object, so that method calls can be chained like this:
To visualize the horizontal computations, imagine that the components are flattened so they have zero height,
If the labels have different lengths, the text field and the password field won’t line up.
We have to tell Matisse that we want the fields to line up.
Select both fields, right-click, and select Align -> Left to Column from the menu.
Now the labels and fields are each placed in a parallel group.
The first group has an alignment of TRAILING (which means alignment to the right when the text direction is left-to-right):
It seems like magic that Matisse can translate the designer’s instructions into nested groups—but, as Arthur C.
Clarke said, any sufficiently advanced technology is indistinguishable from magic.
Now you should think of the components as having no width.
We have a sequential group that contains two parallel groups, separated by gaps:
As you can see from the code, the components are aligned by their baselines.
The baseline is the line on which the component text is aligned.)
You can force a set of components to have equal size.
For example, we may want to make sure that the widths of the text field and the password field match exactly.
The code in Listing 9.12 shows how to lay out the font selector of the preceding section using the GroupLayout instead of the GridBagLayout.
The code may not look any simpler than that of Listing 9.10 on p.
We used Matisse to do the layout and then cleaned up the code a bit.
When true (the default), nonvisible components are not laid out.
When false, they are laid out as if they were visible.
This is useful when you temporarily hide some components and don’t want the layout to change.
When true, gaps are automatically added between components or at the container boundaries.
A true value is useful when you manually produce a GroupLayout.
When DEFAULT_SIZE is used, the component’s getMinimumSize, getPreferredSize, or getMaximumSize is called.
When PREFERRED_SIZE is used, the component’s getPreferredSize method is called.
There will be times when you don’t want to bother with layout managers but just want to drop a component.
Here is what you do to place a component at a fixed location:
You can design your own LayoutManager class that manages components in a special way.
The first two methods are called when a component is added or removed.
If you don’t keep any additional information about the components, you can make them do nothing.
The next two methods compute the space required for the minimum and the preferred layout of the components.
The fifth method does the actual work and invokes setBounds on all components.
Note The AWT has a second interface, called LayoutManager2, with ten methods to implement rather than five.
The main point of the LayoutManager2 interface is to allow the user to use the add method with constraints.
For example, the BorderLayout and GridBagLayout implement the LayoutManager2 interface.
Listing 9.13 shows the code for the CircleLayout manager which, uselessly enough, lays out the components along a circle inside the parent.
The frame class of the sample program is in Listing 9.14
When you add many components into a window, you need to give some thought to the traversal order.
Each time the user presses the Tab key, the next component gains focus.
Recall that a component that has the keyboard focus can be manipulated with the keyboard.
For example, a button can be “clicked” with the space bar when it has focus.) You may not personally care about using the Tab key to navigate through a set of controls, but plenty of users do.
Among them are the mouse haters and those who cannot use a mouse, perhaps because of a handicap or because they are navigating the user interface by voice.
For that reason, you need to know how Swing handles traversal order.
The traversal order is straightforward: first, left to right, and then, top to bottom.
For example, in the font dialog example, the components are traversed in the following order (see Figure 9.35):
Face combo box Sample text area (press Ctrl+Tab to move to the next field; the Tab character is considered text input) Size combo box Bold checkbox.
The situation is more complex if your container contains other containers.
When the focus is given to another container, it automatically ends up within the top left component in that container and then traverses all other components in that container.
Finally, the focus is given to the component following the container.
You can use this to your advantage by grouping related elements in another container such as a panel.
This is useful for painted components that don’t take keyboard input.
So far, all our user interface components have appeared inside a frame window that was.
This is the most common situation if you write applets that run inside a web browser.
But if you write applications, you usually want separate dialog boxes to pop up to give information to, or get information from, the user.
Just as with most windowing systems, AWT distinguishes between modal and modeless dialog boxes.
A modal dialog box won’t let users interact with the remaining windows of the application until he or she deals with it.
Use a modal dialog box when you need information from the user before you can proceed with execution.
For example, when the user wants to read a file, a modal file dialog box is the one to pop up.
The user must specify a file name before the program can begin the read operation.
Only when the user closes the modal dialog box can the application proceed.
A modeless dialog box lets the user enter information in both the dialog box and the remainder of the application.
The toolbar can stay in place as long as needed, and the user can interact with both the application window and the toolbar as needed.
We will start this section with the simplest dialogs—modal dialogs with just a single message.
Swing has a convenient JOptionPane class that lets you put up a simple dialog without writing any special dialog box code.
Next, you will see how to write more complex dialogs by implementing your own dialog windows.
Finally, you will see how to transfer data from your application into a dialog and back.
We’ll conclude this section by looking at two standard dialogs: file dialogs and color dialogs.
File dialogs are complex, and you definitely want to be familiar with the Swing JFileChooser for this purpose—it would be a real challenge to write your own.
The JColorChooser dialog is useful when you want users to pick colors.
Swing has a set of ready-made simple dialogs that suffice to ask the user for a single piece of.
The JOptionPane has four static methods to show these simple dialogs:
The input dialog has an additional component for user input.
This can be a text field into which the user can type an arbitrary string, or a combo box from which the user can select one item.
The exact layout of these dialogs, and the choice of icons for standard message types, depend.
The icon on the left side depends on one of five message types:
Each dialog type also has a method that lets you supply your own icon instead.
This message can be a string, an icon, a user interface component, or any other object.
You can see these options by running the program in Listing 9.15 on p.
Of course, supplying a message string is by far the most common case.
The buttons at the bottom depend on the dialog type and the option type.
When calling showMessageDialog and showInputDialog, you get only a standard set of buttons (OK and OK/Cancel, respectively)
When calling showConfirmDialog, you can choose among four option types:
With the showOptionDialog you can specify an arbitrary set of options.
The showConfirmDialog and showOptionDialog return integers to indicate which button the user chose.
For the option dialog, this is simply the index of the chosen option or the value CLOSED_OPTION if the user closed the dialog instead of choosing an option.
For the confirmation dialog, the return value can be one of the following:
This all sounds like a bewildering set of choices, but in practice it is simple.
Choose the icon (error, information, warning, question, none, or custom)
Choose the message (string, icon, custom component, or a stack of them)
For an option dialog, choose the options (strings, icons, or custom components) and the default option.
For an input dialog, choose between a text field and a combo box.
Locate the appropriate method to call in the JOptionPane API.
For example, suppose you want to show the dialog in Figure 9.36
The dialog shows a message and asks the user to confirm or cancel.
When you click on the Show button, the selected dialog is displayed.
An internal dialog is rendered entirely within its owner’s frame.)
An internal dialog is rendered entirely within its owner’s frame.) Returns the index of the option selected by the user, or CLOSED_OPTION if the user canceled the dialog.
An internal dialog is rendered entirely within its owner’s frame.) Returns the input string typed by the user, or null if the user canceled the dialog.
In the last section, you saw how to use the JOptionPane class to show a simple dialog.
To implement a dialog box, you extend the JDialog class.
This is essentially the same process as extending JFrame for the main window for an application.
In the constructor of your dialog box, call the constructor of the superclass JDialog.
When you call the superclass constructor, you will need to supply the owner frame, the title of the dialog, and the modality.
You can supply null as the owner; then, the dialog is owned by a hidden frame.
The modality specifies which other windows of your application are blocked while the dialog is displayed.
A modal dialog blocks all other windows of the application (except for the children of the dialog)
You would use a modeless dialog for a toolbox that the user can always access.
On the other hand, you would use a modal dialog if you want to force the user to supply required information before continuing.
Note As of Java SE 6, there are two additional modality types.
A document-modal dialog blocks all windows belonging to the same “document,” or more precisely, all windows with the same parentless root window as the dialog.
In older versions, users were unable to interact with the help windows when a modal dialog was popped up.
A toolkit-modal dialog blocks all windows from the same “toolkit.” A toolkit is a Java program that launches multiple applications, such as the applet engine in a browser.
As you can see, the constructor adds user interface elements—in this case, labels and a button.
It adds a handler to the button and sets the size of the dialog.
Actually, in the sample code below, we create the dialog box only once, and we can reuse it whenever the user clicks the About button.
When the user clicks the OK button, the dialog box should close.
This is handled in the event handler of the OK button:
When the user closes the dialog by clicking the Close button, the dialog is also hidden.
Listing 9.17 is the code for the frame class of the test program.
The dialog is not visible until it is explicitly shown.
The most common reason to put up a dialog box is to get information from the user.
Now let’s see how to transfer data in and out of a dialog box.
Consider the dialog box in Figure 9.39 that could be used to obtain a user name and a password to connect to some online service.
Your dialog box should provide methods to set default data.
For example, the PasswordChooser class of the example program has a method, setUser, to place default values into the next fields:
Once you set the defaults (if desired), show the dialog by calling setVisible(true)
The user then fills in the information and clicks the OK or Cancel button.
The event handlers for both buttons call setVisible(false), which terminates the call to setVisible(true)
If you did not install a window listener for the dialog, the default window closing operation applies: The dialog becomes invisible, which also terminates the call to setVisible(true)
The important issue is that the call to setVisible(true) blocks until the user has dismissed the dialog.
You want to know whether the user has accepted or canceled the dialog.
Our sample code sets the ok flag to false before showing the dialog.
Only the event handler for the OK button sets the ok flag to true.
In that case, you can retrieve the user input from the dialog.
Note Transferring data out of a modeless dialog is not as simple.
When a modeless dialog is displayed, the call to setVisible(true) does not block and the program continues running while the dialog is displayed.
If the user selects items on a modeless dialog and then clicks OK, the dialog needs to send an event to some listener in the program.
When you construct a JDialog object, you need to specify the owner frame.
However, quite often you want to show the same dialog with different owner frames.
It is better to pick the owner frame when you are ready to show the dialog, not when you construct the PasswordChooser object.
The trick is to have the PasswordChooser extend JPanel instead of JDialog.
Note that it is safe to have owner equal to null.
Many dialogs have a default button, which is automatically selected if the user presses a trigger key (Enter in most look-and-feel implementations)
The default button is specially marked, often with a thick outline.
If you follow our suggestion of laying out the dialog in a panel, then you must be careful to set the default button only after you wrapped the panel into a dialog.
Listing 9.19 is for the frame class of the program that illustrates the data flow into and out of a dialog box.
To deactivate the default button, call this method with a null parameter.
In an application, you often want to be able to open and save files.
Fortunately, Swing provides a JFileChooser class that allows you to display a file dialog box similar to the one that most native applications use.
Note that the JFileChooser class is not a subclass of JDialog.
Instead of calling setVisible(true), call showOpenDialog to display a dialog for opening a file, or call showSaveDialog to display a dialog for saving a file.
The button for accepting a file is then automatically labeled Open or Save.
You can also supply your own button label with the showDialog method.
Figure 9.40 shows an example of the file chooser dialog box.
Here are the steps to put up a file dialog box and recover what the user chooses from the box: 1
Unlike the constructor for the JDialog class, you do not supply the parent component.
This allows you to reuse a file chooser dialog with multiple frames.
Tip Reusing a file chooser object is a good idea because the JFileChooser constructor can be quite slow, especially on Windows when the user has many mapped network drives.
For example, suppose the user should choose a GIF image file.
Then, the file chooser should only display files with the extension .gif.
If the user should choose a JPEG image file, the extension can be either .jpg or .jpeg.
The file chooser passes each file to the file filter and displays only those files that the filter accepts.
At the time of this writing, two such subclasses are supplied: the default filter that accepts all files, and a filter that accepts all files with a given extension.
You simply implement the two abstract methods of the FileFilter superclass:
The first method tests whether a file should be accepted.
The second method returns a description of the file type that can be displayed in the file chooser dialog.
Note An unrelated FileFilter interface in the java.io package has a single method, boolean accept(File f)
It is used in the listFiles method of the File class to list files in a directory.
We do not know why the designers of Swing didn’t extend this interface— perhaps the Java class library has now become so complex that even the programmers at Sun were no longer aware of all the standard classes and interfaces.
Once you have a file filter object, use the setFileFilter method of the JFileChooser class to install it into the file chooser object:
The user selects a filter from the combo box at the bottom of the file dialog.
This is a good idea—just in case a user of your program needs to select a file with a nonstandard extension.
Caution If you reuse a single file chooser for loading and saving different file types, call.
Finally, you can customize the file chooser by providing special icons and file descriptions for each file that the file chooser displays.
Normally, you don’t need to supply a file view—the pluggable look-and-feel supplies one for you.
But if you want to show different icons for special file types, you can install your own file view.
You need to extend the FileView class and implement five methods:
Then, use the setFileView method to install your file view into the file chooser.
The file chooser calls your methods for each file or directory that it wants to display.
That is good, because it means you need to deal only with the file types for which you want to do something different.
The file chooser calls the isTraversable method to decide whether to open a directory when a user clicks on it.
The file chooser will then consult the default file view.
In other words, the method returns a Boolean to let you choose among three options: true (Boolean.TRUE), false (Boolean.FALSE), and don’t care (null)
That class shows a particular icon whenever a file matches a file filter.
We use it to display a palette icon for all image files.
The file chooser will then show the palette icon next to all files that pass the filter and use the default file view to show all other files.
Naturally, we use the same filter that we set in the file chooser.
That class lets you associate icons and descriptions with arbitrary extensions.
Finally, you can customize a file dialog by adding an accessory component.
For example, Figure 9.41 shows a preview accessory next to the file list.
This accessory displays a thumbnail view of the currently selected file.
In our case, we extend the JLabel class and set its icon to a scaled copy of the graphics image:
We want to update the preview image whenever the user selects a different file.
The file chooser uses the “JavaBeans” mechanism of notifying interested listeners whenever one of its properties changes.
We discuss this mechanism in greater detail in Chapter 8 of Volume II.
Here is the code that you need to trap the notifications:
In our example program, we add this code to the ImagePreviewer constructor.
All files for which filter.accept returns true will be displayed.
Also, adds the filter to the list of choosable filters.
For example, if f is an HTML document, this method might return its title.
For example, if f is an HTML document, this method might return a string "Hypertext document"
Icon getIcon(File f) returns an icon for the file f, or null.
For example, if f is a JPEG file, this method might return a thumbnail icon.
Boolean isTraversable(File f) returns Boolean.TRUE if f is a directory that the user can open.
This method might return Boolean.FALSE if a directory is conceptually a compound document.
Like all FileView methods, this method can return null to signify that the file chooser should consult the default view instead.
As you saw in the preceding section, a high-quality file chooser is an intricate user interface.
Many user interface toolkits provide other common dialogs: to choose a date/time, currency value, font, color, and so on.
The benefit is twofold: Programmers can simply use a high-quality implementation instead of rolling out their own, and users get a consistent experience with these components.
Like the JFileChooser class, the color chooser is a component, not a dialog, but it contains convenience methods to create dialogs that contain a.
Here is how you make a modeless dialog that sets the background color when the user clicks the OK button:
You can do even better than that and give the user immediate feedback of the color selection.
To monitor the color selections, you need to obtain the selection model of the chooser and add a change listener:
In this case, there is no benefit to the OK and Cancel buttons that the color chooser dialog provides.
You can just add the color chooser component directly into a modeless dialog:
The program in Listing 9.24 shows the three types of dialogs.
If you click on the Modal button, you must select a color before you can do anything else.
If you click on the Modeless button, you get a modeless dialog, but the color change only happens when you click the OK button on the dialog.
If you click the Immediate button, you get a modeless dialog without buttons.
As soon as you pick a different color in the dialog, the background color of the panel is updated.
Color getColor() • void setColor(Color c) gets and sets the current color of this color chooser.
Turn to Volume II for more advanced Swing components and sophisticated graphics techniques.
At this point, you should be comfortable with using most of the features of the Java programming language, and you’ve had a pretty thorough introduction to basic graphics programming in Java.
Now that you are ready to create applications for your users, you will want to know how to package them for deployment on your users’ computers.
An applet is a special kind of Java program that a Java-enabled browser can download from the Internet and run.
The hopes were that users would be freed from the hassles of installing software and that they could access their software from any Javaenabled computer or device with an Internet connection.
For a number of reasons, applets never quite lived up to these expectations.
Therefore, we will start this chapter with instructions for packaging applications.
We then turn to the Java Web Start mechanism—an alternative approach for Internet-based application delivery which fixes some of the problems of applets.
Finally, we will cover applets and show you in which circumstances you still want to use them.
We will also discuss how your applications can store configuration information and user.
When you package your application, you want to give your users a single file, not a directory.
A JAR file can contain both class files and other file types such as image and sound files.
Moreover, JAR files are compressed, using the familiar ZIP compression format.
Tip An alternative to the ZIP format is the “pack200” compression scheme that is specifically tuned to compress class files more efficiently.
Oracle claims a compression rate of close to 90% for class files.
In the default JDK installation, it’s in the jdk/bin directory.) The most common command to make a new JAR file uses the following syntax:
Table 10.1 lists all the options for the jar program.
They are similar to the options of the UNIX tar command.
For example, the runtime library of the JDK is contained in a very large file rt.jar.
In addition to class files, images, and other resources, each JAR file contains a manifest file that describes special features of the archive.
The manifest file is called MANIFEST.MF and is located in a special META-INF subdirectory of the JAR file.
The first section in the manifest is called the main section.
Subsequent entries can specify properties of named entities such as individual files,
To edit the manifest, place the lines that you want to add to the manifest into a text file.
For example, to make a new JAR file with a manifest, run.
Note See http://docs.oracle.com/javase/7/docs/technotes/guides/jar for more information on the JAR and manifest file formats.
You can use the e option of the jar command to specify the entry point of your program—the.
Alternatively, you can specify the main class of your program in the manifest, including a statement of the form.
Caution The last line in the manifest must end with a newline character.
It is a common error to produce a text file containing just the Main-Class line without a line terminator.
With either method, users can simply start the program as java -jar MyProgram.jar.
Depending on the operating system configuration, users may even be able to launch the application by double-clicking the JAR file icon.
On Windows, the Java runtime installer creates a file association for the “.jar” extension that launches the file with the javaw -jar command.
On Mac OS X, the operating system recognizes the “.jar” file extension and executes the Java program when you double-click a JAR file.
However, a Java program in a JAR file does not have the same feel as a native application.
On Windows, you can use third-party wrapper utilities that turn JAR files into Windows executables.
A wrapper is a Windows program with the familiar .exe extension that locates and launches the Java virtual machine (JVM) or tells the user what to do when no JVM is found.
The open source installer generator IzPack (http://izpack.org) also contains a native launcher.
The Jar Bundler utility that is a part of XCode lets you turn a JAR file into a first-class Mac application.
Classes used in both applets and applications often have associated data files, such as.
In Java, such an associated file is called a resource.
Note In Windows, the term “resource” has a more specialized meaning.
Windows resources also consist of images, button labels, and so on, but they are attached to the executable file and accessed by a standard programming interface.
In contrast, Java resources are stored as separate files, not as part of class files.
It is up to each program to access and interpret the resource data.
For example, consider a class, AboutPanel, that displays a message such as the one in Figure 10.1
Of course, the book title and copyright year in the panel will change for the next edition of the book.
To make it easy to track this change, we will put the text inside a file and not hardcode it as a string.
But where should you put a file such as about.txt? Of course, it would be convenient to simply place it with the rest of the program files inside the JAR file.
The class loader knows how to search for class files until it has located them somewhere on the class path, or in an archive, or on a web server.
The resource mechanism gives you the same convenience for files that aren’t class files.
Get the Class object of the class that has a resource—for example, AboutPanel.class.
The point is that the class loader remembers how to locate the class, so it can then search for the associated resource in the same location.
Instead of placing a resource file inside the same directory as the class file, you can place it in a subdirectory.
You can then use a hierarchical resource name such as.
Note that you must always use the / separator, regardless of the directory separator on the system that actually stores the resource files.
For example, on the Windows file system, the resource loader automatically translates / to \ separators.
A resource name starting with a / is called an absolute resource name.
It is located in the same way a class inside a package would be located.
Automating the loading of files is all the resource loading feature does.
Each program must have its own way of interpreting its resource files.
Languagedependent strings, such as messages and user interface labels, are stored in resource files, with one file per language.
Returns null if the resource isn’t found, so does not throw an exception for an I/O error.
We mentioned in Chapter 4 that you can seal a Java language package to ensure that no further classes can add themselves to it.
You would want to seal a package if you use packagevisible classes, methods, and fields in your code.
Without sealing, other classes can place themselves into the same package and thereby gain access to its package-visible features.
You can change that global default by placing the line Sealed: true.
For each individual package, you can specify whether you want the package sealed or not, by adding another section to the JAR file manifest, like this:
To seal a package, make a text file with the manifest instructions.
Java Web Start is a technology for delivering applications over the Internet.
Once a Java Web Start application has been downloaded, it can be started without using a browser.
The application is displayed in its own frame, outside the browser.
They do not use the Java implementation of the browser.
The browser simply launches an external application whenever it loads a Java Web Start application descriptor.
That is the same mechanism used to launch other helper applications such as Adobe Acrobat or RealAudio.
Digitally signed applications can be given arbitrary access rights on the local machine.
Unsigned applications run in a “sandbox,” which prohibits potentially dangerous operations.
To prepare an application for delivery by Java Web Start, package it in one or more JAR files.
Then, prepare a descriptor file in the Java Network Launch Protocol (JNLP) format.
Browsers use the MIME type to determine which helper application to launch.) Consult your web server documentation for details.
Tomcat is a container for servlets and JSP pages, but it also serves web pages.
It is preconfigured to serve the correct MIME type for JNLP files.
Let’s try out Java Web Start to deliver the calculator application from Chapter 9
Place the JAR file and the launch file on your web server so that the URL matches the codebase entry in the JNLP file.
If you installed the JDK, the configuration should be automatic.
You should see the launch window for Java Web Start (see Figure 10.2)
Soon afterward, the calculator should come up, with a border marking it as a Java application (see Figure 10.3)
When you access the JNLP file again, the application is retrieved from the cache.
You can review the cache content by using the Java Plug-in control panel (see Figure 10.4)
In Windows, look for the Java Plug-in control inside the Windows control panel.
Tip If you don’t want to run a web server while you are testing your JNLP configuration, you can temporarily override the codebase URL in the launch file by running.
For example, in UNIX, you can simply issue this command from the directory containing the JNLP file:
Of course, you don’t want to tell your users to launch the cache viewer whenever they want to run your application again.
You can have the installer offer to install desktop and menu shortcuts.
Note that these icons are not related to the application icon.
If you want the application to have an icon, you need to add a separate icon image into the JAR file and call the setIconImage method on the frame class.
Whenever code is loaded from a remote site and then executed locally, security becomes.
Clicking a single link can launch a Java Web Start application.
Visiting a web page automatically starts all applets on the page.
If clicking a link or visiting a web page could install arbitrary code on the user’s computer, criminals would have an easy time stealing confidential information, accessing financial data, or taking over users’ machines to send spam.
To ensure that the Java technology cannot be used for nefarious purposes, Java has an elaborate security model that we discuss in detail in Volume II.
By default, it only allows those operations that are harmless.
To allow additional operations, the code must be digitally signed and the user must approve the signing certificate.
What can remote code do on all platforms? It is always OK to show images and play sounds, get keystrokes and mouse clicks from the user, and send user input back to the host from which the code was loaded.
That is enough functionality to show facts and figures or to get user input for placing an order.
The restricted execution environment is often called the “sandbox.” Code that plays in the sandbox cannot alter the user’s system or spy on it.
In particular, programs in the sandbox have the following restrictions: • They can never run any local executable program.
They cannot read from or write to the local computer’s file system.
They cannot find out any information about the local computer, except for the Java version used and a few harmless operating system details.
In particular, code in the sandbox cannot find out the user’s name, e-mail address, and so on.
Remotely loaded programs need user consent to communicate with any host other than the server from which they were downloaded; that server is called the originating host.
This message is a security feature to ensure that users do not mistake the window for a local application.
The fear is that an unsuspecting user could visit a web page, be tricked into running remote code, and then type in a password or credit card number, which can be sent back to the web server.
Now it is a minuscule warning triangle that only the most observant users will notice.
It is possible to control in great detail which rights to grant a particular application; we discuss this in Chapter 9 of Volume II.
Of course, an application can simply request to have all permissions of a desktop application, and quite a few Java Web Start applications do just that.
This is accomplished by adding the following tags to the JNLP file:
To run outside the sandbox, the JAR files of a Java Web Start application must be digitally signed.
A signed JAR file carries with it a certificate that indicates the identity of the signer.
Cryptographic techniques ensure that such a certificate cannot be forged, and that any effort to tamper with the signed file will be detected.
For example, suppose you receive an application that is produced and digitally signed by yWorks GmbH, using a certificate issued by Thawte (see Figure 10.6)
When you receive the application, you will be assured of the following:
The code is exactly as it was when it was signed; no third party has tampered with it.
Java Web Start knows how to check certificates from Thawte and a few other vendors.)
You do not know that the code is inherently safe.
Should you install and run the application? That really depends on your trust in yWorks GmbH.
Getting a certificate from one of the supported vendors costs hundreds of dollars per year.
Many developers simply generate their own and use them for code signing.
Of course, Java Web Start has no way of checking the accuracy of these certificates.
The code is exactly as it was when it was signed; no other party has tampered with it.
Someone has signed the code, but Java Web Start cannot verify who it was.
This is quite worthless; anyone could have tampered with the code and then signed it, claiming to be the author.
Nevertheless, Java Web Start will be perfectly happy to present the certificate for your approval (see Figure 10.7)
It is theoretically possible to verify the certificate through another way, but few users have the technical savvy to do that.
Of course, many people download and run applications from the Internet every day.
If you find that your users trust your application and your web infrastructure, go ahead and use a selfsigned certificate.
See http://docs.oracle.com/javase/6/docs/technotes/guides/javaws/developersguide/development.html for details.) If not, give your users the benefit of safety and stay within the sandbox.
With the JNLP API (which we discuss in the next section), you can still allow your program to selectively access resources, subject to user approval.
The JNLP API allows unsigned applications to run in the sandbox and at the same time access.
For example, there are services to load and save files.
The application can’t look at the file system and it can’t specify file names.
Instead, a file dialog is popped up, and the user selects the file.
But before the file dialog is popped up, the user is alerted and must agree to proceed (see Figure 10.8)
Furthermore, the API doesn’t actually give the program access to a File object.
In particular, the application has no way of finding out the file location.
Note You must include the file javaws.jar in the class path if you want to compile programs that use the JNLP API.
That file is included in the jre/lib subdirectory of the JDK.
To save a file, provide suggestions for the initial path name and file extensions for the file dialog, the data to be saved, and a suggested file name.
It prints the information to be saved to the PrintStream.
You will learn more about streams in Chapter 1 of Volume II.
For now, you can just gloss over the details in the sample program.
To read data from a file, use the FileOpenService instead.
Its openFileDialog receives suggestions for the initial path name and file extensions for the file dialog and returns a FileContents object.
You can then call the getInputStream and getOutputStream methods to read and write the file data.
If the user didn’t choose a file, the openFileDialog method returns null.
Note that your application does not know the name or location of the file.
Conversely, if you want to open a specific file, use the ExtendedService:
The user of your program must agree to the file access (see Figure 10.9)
To display a document in the default browser, use the BasicService interface.
Note that some systems may not have a default browser.
A rudimentary PersistenceService lets an application store small amounts of configuration information and retrieve it when the application runs again.
The URLs don’t have to point to a real web resource.
The service simply uses them as a convenient hierarchical naming scheme.
For any given URL key, an application can store arbitrary binary data.
The store may restrict the size of the data block.)
For applications to be isolated from each other, each application can only use URL keys that start with its codebase (as specified in the JNLP file)
For example, if an application is downloaded from http://myserver.com/apps, it can only use keys of the form http://myserver.com/apps/subkey1/subkey2/...
An application can call the getCodeBase method of the BasicService to find its codebase.
Create a new key with the create method of the PersistenceService.
To access the information associated with a particular key, call the get method.
That method returns a FileContents object through which you can read and write the key data.
Unfortunately, there is no convenient way to find out whether a key already exists or whether you need to create it.
You can hope that the key exists and call get.
Note Both Java Web Start applications and applets can print, using the normal printing API.
A security dialog pops up, asking the user for permission to access the printer.
For more information on the printing API, turn to Chapter 7 of Volume II.
The program in Listing 10.2 is a simple enhancement of the calculator application.
This calculator has a virtual paper tape that keeps track of all calculations.
To demonstrate the persistent store, the application lets you set the frame title.
If you run the application again, it retrieves your title choice from the persistent store (see Figure 10.10)
If overwrite is true, then the existing contents of the file are overwritten.
String getName() returns the file name (but not the full directory path)
Returns content descriptors of the file or files that the user selected, or null if the user didn’t choose a file.
Writes the data and returns content descriptors of the file or files that the user selected, or null if the user didn’t choose a file.
String[] getNames(URL url) returns the relative key names of all keys that start with the given URL.
FileContents get(URL key) gets a content descriptor through which you can modify the data associated with the given key.
Applets are Java programs that are included in an HTML page.
As you might expect, the tag needed to use an applet must tell the browser where to get the class files, and how the applet is positioned on the web page (size, location, and so on)
The browser then retrieves the class files from the Internet (or from a directory on the user’s machine) and automatically runs the applet.
When applets were first developed, you had to use Sun’s HotJava browser to view web pages that contained applets.
Naturally, few users were willing to use a separate browser just to enjoy a new web feature.
Java applets became really popular when Netscape included a Java virtual machine in its Navigator browser.
Unfortunately, Microsoft cut off Netscape’s air supply by reluctantly supporting outdated Java versions in Internet Explorer, before dropping Java support altogether.
Using browser extension mechanisms, it seamlessly plugs in to a variety of browsers and enables them to execute Java applets by using an external Java runtime environment.
Note To run the applets in this chapter in a browser, you need to install the current version of the Java Plug-in and make sure your browser is connected with the plug-in.
For tradition’s sake, let’s write a NotHelloWorld program as an applet.
In this book, we will use Swing to implement applets.
All of our applets will extend the JApplet class, the superclass for Swing applets.
As you can see in Figure 10.11, JApplet is an immediate subclass of the ordinary Applet class.
Note If your applet contains Swing components, you must extend the JApplet class.
Create an HTML file that tells the browser which class file to load first and how to size the applet.
Before you view the applet in a browser, it is a good idea to test it in the applet viewer program that is a part of the JDK.
The command-line argument for the applet viewer program is the name.
Tip You can also run applets from inside your integrated environment.
The applet viewer is good for the first stage of testing, but at some point you need to run your applets in a browser to see them as a user might see them.
In particular, the applet viewer program shows you only the applet, not the surrounding HTML text.
If your HTML file contains multiple applet tags, the applet viewer pops up multiple windows.
To properly view the applet, simply load the HTML file into the browser (see Figure 10.13)
If the applet doesn’t show up, you need to install the Java Plug-in.
Tip If you make a change to your applet and recompile, you need to restart the browser so that it loads the new class files.
Simply refreshing the HTML page will not load the new code.
This is a hassle when you are debugging an applet.
You can avoid the painful browser restart from the Java console.
Launch the console and issue the x command, which clears the classloader cache.
Then you can reload the HTML page, and the new applet code is used.
Under Linux, run jcontrol and request that the Java console be displayed.
The console will pop up whenever an applet is loaded.
It is easy to convert a graphical Java application into an applet that you can embed in a web page.
Essentially, all of the user interface code can stay the same.
Make an HTML page with the appropriate tag to load the applet code.
Move any initialization code from the frame window constructor to the init method of the applet.
You don’t need to explicitly construct the applet object—the browser instantiates it for you and calls the init method.
Remove the call to setSize; for applets, sizing is done with the width and height parameters in the HTML file.
An applet cannot be closed; it terminates when the browser exits.
If the application calls setTitle, eliminate the call to the method.
You can, of course, title the web page itself, using the HTML title tag.) 8
This would be a great method if it worked on web pages; unfortunately, it does not work in current browsers because it interferes with their page-layout mechanisms.
In its most basic form, an example applet tag looks like this:
You also need a matching </applet> tag that marks the end of the HTML tagging needed for an applet.
If any are missing, the browser cannot load your applet.
All this information would usually be embedded in an HTML page that, at the very least, might look like this:
You can use the following attributes within the applet tag: • width, height These attributes are required and give the width and height of the applet, measured in pixels.
In the applet viewer, this is the initial size of the applet.
You can resize any window that the applet viewer creates.
You will need to make a good guess about how much space your applet requires to show up well for all users.
The attribute values are the same as for the align attribute of the HTML img tag.
These optional attributes specify the number of pixels above and below the applet (vspace) and on each side of the applet (hspace)
This name is taken relative to the codebase (see below) or relative to the current page if the codebase is not specified.
The path name must match the package of the applet class.
Use the codebase attribute if your class file is located elsewhere.
The code attribute specifies only the name of the class that contains the applet class.
Once the browser’s class loader loads the class containing the applet, it will realize that it needs more class files and will load them.
Either the code or the object attribute (see below) is required.
You can use an absolute URL, even to a different server.
Most commonly, though, this is a relative URL that points to a subdirectory.
These files are fetched from the web server before the applet is loaded.
This technique speeds up the loading process significantly because only one HTTP request is necessary to load a JAR file containing many smaller files.
An object is serialized when you write all its instance fields to a file.
We discuss serialization in Chapter 1 of Volume II.) To display the applet, the object is deserialized from the file to return it to its previous state.
When you use this attribute, the init method is not called, but the applet’s start method is called.
Before serializing an applet object, you should call its stop method.
This feature is useful for implementing a persistent browser that automatically reloads its applets and has them return to the same state that they were in when the browser was closed.
This is a specialized feature, not normally encountered by web page designers.
Either code or object must be present in every applet tag.
Scripters will want to give the applet a name attribute that they can use to refer to the applet when scripting.
Both Netscape and Internet Explorer let you call methods of an applet on a page through JavaScript.
To access an applet from JavaScript, you first have to give it a name.
Through the magic of the integration between Java and JavaScript that both Netscape and Internet Explorer provide, you can call applet methods:
This is a good example of the integration between Java and JavaScript.
You can then use the alt attribute to display a message to these unfortunate souls.
If a browser cannot process applets at all, it ignores the unknown applet and param tags.
You can display messages between these tags for those poor folks that use a prehistoric browser.
The various positioning attributes such as align and height work exactly as they did for the applet tag.
The key attribute in the object tag for your Java applets is the classid attribute.
Of course, object tags can load different kinds of objects, such as Java applets, ActiveX components, or the Java Plug-in itself.
In the codetype attribute, you can specify the nature of the object.
For example, Java applets have a code type of application/java.
Here is an object tag to load a Java applet:
Note that the classid attribute can be followed by a codebase attribute that works exactly as it did with the applet tag.
Just as applications can use command-line information, applets can use parameters that are embedded in the HTML file.
This is done by the HTML tag called param along with attributes that you define.
For example, suppose you want to let the web page determine the style of the font to use in your applet.
You can then pick up the value of the parameter using the getParameter method of the Applet class:
Note You can call the getParameter method only in the init method of the applet, not in the constructor.
When the applet constructor is executed, the parameters are not yet prepared.
Since the layout of most nontrivial applets is determined by parameters, we recommend that you don’t supply constructors to applets.
You need to convert the string to a numeric type if that is what is called for.
You do this in the standard way by using the appropriate method, such as parseInt of the Integer class.
For example, if we want to add a size parameter for the font, the HTML code might look like this:
Note A case-insensitive comparison is used when matching the name attribute value in the param tag and the argument of the getParameter method.
In addition to ensuring that the parameters match in your code, you should find out whether or not the size parameter was left out.
You can do this with a simple test for null.
The applet draws a bar chart, shown in Figure 10.14
This applet takes the labels and the heights of the bars from the param values in the HTML file.
Here is what the HTML file for Figure 10.14 looks like:
You could have set up an array of strings and an array of numbers in the applet, but there are two advantages to using the parameter mechanism instead.
You can have multiple copies of the same applet on your web page, showing different graphs: just put two applet tags with different sets of parameters on the page.
And you can change the data that you want to chart.
Admittedly, the diameters of the planets will stay the same for quite some time, but suppose.
It is easy to update the web page because it is plain text.
Editing and recompiling a Java file weekly is more tedious.
In fact, there are commercial JavaBeans components (beans) that make much fancier graphs than the one in our chart applet.
If you buy one, you can drop it into your web page and feed it parameters without ever needing to know how the applet renders the graphs.
Listing 10.4 is the source code of our chart applet.
Note that the init method reads the parameters, and the paintComponent method draws the chart.
Each row contains three entries: the name, the type, and a description of the parameter.
As we write this, images must be in GIF, PNG, or.
Specify the locations of image and audio files with relative URLs.
The base URL is usually obtained by calling the getDocumentBase or getCodeBase method.
The former gets the URL of the HTML page in which the applet is contained, the latter the URL of the applet’s codebase directory.
You saw in Chapter 7 how to display an image.
To play an audio clip, simply invoke its play method.
You can also call the play method of the Applet class without first loading the audio clip.
That is either the absolute URL of the directory referenced by the codebase attribute or the directory of the HTML file if no codebase is specified.
The second form uses the string to provide a path relative to the URL in the first parameter.
AudioClip getAudioClip(URL url) • AudioClip getAudioClip(URL url, String name) The first form gets an audio clip from the given URL.
The methods return null if the audio clip cannot be found.
Image getImage(URL url) • Image getImage(URL url, String name) returns an image object that encapsulates the image specified by the URL.
If the image does not exist, it immediately returns null.
Otherwise, a separate thread is launched to load the image.
An applet runs inside a browser or the applet viewer.
The ambient browser can carry out these requests, or it can ignore them.
For example, if an applet running inside the applet viewer asks the applet viewer program to display a web page, nothing happens.
To communicate with the browser, an applet calls the getAppletContext method.
That method returns an object that implements an interface of type AppletContext.
You can think of the concrete implementation of the AppletContext interface as a communication path between the applet and the ambient browser.
In addition to getAudioClip and getImage, the AppletContext interface contains several useful methods, which we discuss in the next few sections.
If a web page contains multiple applets from the same codebase, they can communicate with each other.
Naturally, this is an advanced technique that you probably will not need very often.
If you give name attributes to each applet in the HTML file, you can use the getApplet method of the AppletContext interface to get a reference to the applet.
We will learn about enumeration objects in Chapter 13.) Here is a loop that prints the class names of all applets on the current page:
An applet cannot communicate with an applet on a different web page.
You have access to two areas of the ambient browser: the status line and the web page display area.
You can display a string in the status line at the bottom of the browser with the showStatus message.
You can tell the browser to show a different web page with the showDocument method.
The simplest is a call to showDocument with one argument, the URL you want to show.
The problem with this call is that it opens the new web page in the same window as your current page, thereby displacing your applet.
To return to your applet, the user must click the Back button of the browser.
You can tell the browser to show the document in another window by giving a second parameter in the call to showDocument (see Table 10.2)
If you supply the special string "_blank", the browser opens a new window with the document, instead of displacing the current document.
More importantly, if you take advantage of the frame feature in HTML, you can split a browser window into multiple frames, each having a name.
You can put your applet into one frame and have it show documents in other frames.
We show you an example of how to do this in the next section.
In most browsers, you can use this information to control the browser in which the applet is running.
Applet getApplet(String name) returns the applet in the current context with the given name; returns null if none exists.
In the first form, the new page displaces the current page.
The second form uses the target parameter to identify the target frame (see Table 10.2 on p.
Users of your applications will usually expect that their preferences and customizations are.
First, we will cover the simple approach that Java applications have traditionally taken—storing configuration information in property files.
We then turn to the preferences API that provides a more robust solution.
A property map is a data structure that stores key/value pairs.
Property maps have three particular characteristics: • The keys and values are strings.
The set can easily be saved to a file and loaded from a file.
The Java class that implements a property map is called Properties.
Property maps are useful in specifying configuration options for programs.
Use the store method to save this list of properties to a file.
The second argument is a comment that is included in the file.
It is customary to store program properties in a subdirectory of the user’s home directory.
The directory name is often chosen to start with a dot—on a UNIX system, this convention indicates a system directory which is hidden from the user.
There is also a convenience method to read a single key:
First, whenever you look up the value of a string, you can specify a default that should be used automatically when the key is not present.
If you find it too tedious to specify the default in every call to getProperty, you can pack all.
Yes, you can even specify defaults to defaults if you give another property map parameter to the defaultSettings constructor, but it is not something one would normally do.
Listing 10.5 shows how you can use properties for storing and loading program state.
But the Properties class has no methods that help organize such a hierarchy.
If you store complex configuration information, you should use the Preferences class instead—see the next section.
Returns the string associated with the key, or the string associated with the key in the default table if it wasn’t present in the table, or null if the key wasn’t present in the default table either.
String getProperty(String key, String defaultValue) gets a property with a default value if the key is not found.
Returns the string associated with the key, or the default string if it wasn’t present in the table.
The application must have permission to retrieve all properties, or a security exception is thrown.
String getProperty(String key) retrieves the system property with the given key name.
The application must have permission to retrieve the property, or a security exception is thrown.
As you have seen, the Properties class makes it simple to load and save configuration.
However, using property files has these disadvantages: • Some operating systems have no concept of a home directory, making it difficult to find a uniform location for configuration files.
There is no standard convention for naming configuration files, increasing the likelihood of name clashes as users install multiple Java applications.
Some operating systems have a central repository for configuration information.
In Windows, the Preferences class uses the registry for storage; on Linux, the information is stored in the local file system instead.
Of course, the repository implementation is transparent to the programmer using the Preferences class.
As with package names, name clashes are avoided as long as programmers start the paths with reversed domain names.
In fact, the designers of the API suggest that the configuration node paths match the package names in your program.
Each node in the repository has a separate table of key/value pairs that you can use to store numbers, strings, or byte arrays.
The API designers felt that the serialization format is too fragile for long-term storage.
Of course, if you disagree, you can save serialized objects in byte arrays.
Each program user has one tree; an additional tree, called the system tree, is available for settings that are common to all users.
A convenient shortcut gets a node whose path name equals the package name of a class.
Once you have a node, you can access the key/value table with methods.
Note that you must specify a default value when reading the information, in case the repository data is not available.
The data might be missing because the user never specified a preference.
Conversely, you can write data to the repository with put methods such as put(String key, String value) putInt(String key, int value)
You can enumerate all keys stored in a node with the method.
String[] keys() There is currently no way to find out the type of the value of a particular key.
Central repositories such as the Windows registry traditionally suffer from two problems:
Configuration data gets entangled into the repository, making it difficult to move preferences to a new platform.
The Preferences class has a solution for the second problem.
You can export the preferences of a subtree (or, less commonly, a single node) by calling the methods.
If your program uses preferences, you should give your users the opportunity of exporting and importing them, so they can easily migrate their settings from one computer to another.
The program simply saves the position, size, and title of the main window.
The window will be just like you left it when you exited.
Preferences userRoot() returns the root preferences node of the user of the calling program.
Preferences node(String path) returns a node that can be reached from the current node by the given path.
If path is absolute (that is, starts with a /), then the node is located starting from the root of the tree containing this preference node.
If there isn’t a node with the given path, it is created.
In the next chapter, you will learn how to use exceptions to tell your programs what to do when problems arise at runtime.
We will also give you tips and techniques for testing and debugging so that not too many things will.
In a perfect world, users would never enter data in the wrong form, files they choose to open would always exist, and code would never have bugs.
So far, we have mostly presented code as if we lived in this kind of perfect world.
It is now time to turn to the mechanisms the Java programming language has for dealing with the real world of bad data and buggy code.
If a user loses all the work he or she did during a program session because of a programming mistake or some external circumstance, that user may forever turn away from your program.
For exceptional situations, such as bad input data with the potential to bomb the program, Java uses a form of error trapping called, naturally enough, exception handling.
Exception handling in Java is similar to that in C++ or Delphi.
During testing, you need to run lots of checks to make sure your program does the right thing.
But those checks can be time-consuming and unnecessary after testing has completed.
You could just remove the checks and stick them back in when additional testing is required—but that is tedious.
The second part of this chapter shows you how to use the assertion facility for selectively activating checks.
When your program does the wrong thing, you can’t always communicate with the user or terminate.
Instead, you may want to record the problem for later analysis.
The third part of this chapter discusses the standard Java logging framework.
Finally, we will give you some tips on how to get useful information out of a running Java application, and how to use an IDE debugger.
Suppose an error occurs while a Java program is running.
Users expect that programs will act sensibly when errors happen.
If an operation cannot be completed because of an error, the program ought to either.
Return to a safe state and enable the user to execute other commands; or • Allow the user to save all work and terminate the program gracefully.
This may not be easy to do, because the code that detects (or even causes) the error condition is.
The mission of exception handling is to transfer control from where the error occurred to an error handler that can deal with the situation.
To handle exceptional situations in your program, you must take into account the errors and problems that may occur.
In addition to the inevitable typos, some users like to blaze their own trail instead of following directions.
Suppose, for example, that a user asks to connect to a URL that is syntactically wrong.
Your code should check the syntax, but suppose it does not.
Hardware does not always do what you want it to.
Devices will often fail in the middle of a task.
For example, a printer may run out of paper during printing.
Disks can fill up; you can run out of available memory.
For example, it could deliver wrong answers or use other methods incorrectly.
Computing an invalid array index, trying to find a nonexistent entry in a hash table, or trying to pop an empty stack are all examples of a code error.
The traditional reaction to an error in a method is to return a special error code that the calling method analyzes.
For example, methods that read information back from files often return a -1 endof-file value marker rather than a standard character.
This can be an efficient method for dealing with many exceptional conditions.
Another common return value to denote an error condition is the null reference.
Unfortunately, it is not always possible to return an error code.
There may be no obvious way of distinguishing valid and invalid data.
Instead, as we mentioned back in Chapter 5, Java allows every method an alternative exit path if it is unable to complete its task in the normal way.
In this situation, the method does not return a value.
Instead, it throws an object that encapsulates the error information.
Note that the method exits immediately; it does not return its normal (or any) value.
Moreover, execution does not resume at the code that called the method; instead, the exception-handling mechanism begins its search for an exception handler that can deal with this particular error condition.
Exceptions have their own syntax and are part of a special inheritance hierarchy.
We’ll take up the syntax first and then give a few hints on how to use this language feature effectively.
In the Java programming language, an exception object is always an instance of a class derived.
As you will soon see, you can create your own exception classes if the ones built into Java do not suit your needs.
Figure 11.1 is a simplified diagram of the exception hierarchy in Java.
Notice that all exceptions descend from Throwable, but the hierarchy immediately splits into two branches: Error and Exception.
The Error hierarchy describes internal errors and resource exhaustion situations inside the Java runtime system.
There is little you can do if such an internal error occurs, beyond notifying the user and trying to terminate the program gracefully.
When doing Java programming, you focus on the Exception hierarchy.
The Exception hierarchy also splits into two branches: exceptions that derive from RuntimeException and those that do not.
The general rule is this: A RuntimeException happens because you made a programming error.
Any other exception occurs because a bad thing, such as an I/O error, happened to your otherwise good program.
Thus, the notion of “existence” depends on the environment, not just on your code.
The Java Language Specification calls any exception that derives from the class Error or the class.
The compiler checks that you provide exception handlers for all checked exceptions.
Of course, all of the errors we are discussing occur at runtime.
The logic_error class is the equivalent of Java’s RuntimeException and also denotes logical errors in the program.
The runtime_error class is the base class for exceptions caused by unpredictable problems.
It is equivalent to those exceptions in Java that are not of type RuntimeException.
A Java method can throw an exception if it encounters a situation it cannot handle.
For example, code that attempts to read from a file knows that the file might not exist or that it might be empty.
The code that tries to process the information in a file therefore will need to notify the compiler that it can throw some sort of IOException.
The place in which you advertise that your method can throw an exception is the header of the method; the header changes to reflect the checked exceptions the method can throw.
For example, here is the declaration of one of the constructors of the FileInputStream class from the standard library.
When you write your own methods, you don’t have to advertise every possible throwable object that your method might actually throw.
To understand when (and what) you have to advertise in the throws clause of the methods you write, keep in mind that an exception is thrown in any of the following four situations:
You call a method that throws a checked exception—for example, the FileInputStream constructor.
You detect an error and throw a checked exception with the throw statement (we cover the throw statement in the next section)
An internal error occurs in the virtual machine or runtime library.
If either of the first two scenarios occurs, you must tell the programmers who will use your method about the possibility of an exception.
If no handler catches the exception, the current thread of execution terminates.
As with Java methods that are part of the supplied classes, you declare that your method may.
If a method might throw more than one checked exception type, you must list all exception classes in the header.
However, you do not need to advertise internal Java errors—that is, exceptions inheriting from Error.
Any code could potentially throw those exceptions, and they are entirely beyond your control.
If you are so concerned about array index errors, you should spend your time fixing them instead of advertising the possibility that they can happen.
In summary, a method must declare all the checked exceptions that it might throw.
Unchecked exceptions are either beyond your control (Error) or result from conditions that you should not have allowed in the first place (RuntimeException)
If your method fails to faithfully declare all checked exceptions, the compiler will issue an error message.
Of course, as you have already seen in quite a few examples, instead of declaring the exception, you can also catch it.
Then the exception won’t be thrown out of the method, and no throws specification is necessary.
You will see later in this chapter how to decide whether to catch an exception or to enable someone else to catch it.
Caution If you override a method from a superclass, the checked exceptions that the subclass method declares cannot be more general than those of the superclass method.
It is OK to throw more specific exceptions, or not to throw any exceptions in the subclass method.) In particular, if the superclass method throws no checked exception at all, neither can the subclass.
When a method in a class declares that it throws an exception that is an instance of a particular class, then it may throw an exception of that class or of any of its subclasses.
For example, the FileInputStream constructor could have declared that it throws an IOException.
In that case, you would not have known what kind of IOException it is; it could be a plain IOException or an object of.
In C++, throw specifiers are enforced at runtime, not at compile time.
That is, the C++ compiler pays no attention to exception specifications.
But if an exception is thrown in a function that is not part of the throw list, the unexpected function is called, and, by default, the program terminates.
Also, in C++, a function may throw any exception if no throw specification is given.
In Java, a method without a throws specifier may not throw any checked exceptions at all.
You may decide this situation is so abnormal that you want to throw an exception.
The EOFException has a second constructor that takes a string argument.
You can put this to good use by describing the exceptional condition more carefully.
As you can see, throwing an exception is easy if one of the existing exception classes works for you.
Once a method throws an exception, it does not return to its caller.
This means that you do not have to worry about cooking up a default return value or an error code.
Your code may run into a problem which is not adequately described by any of the standard.
In this case, it is easy enough to create your own exception class.
Just derive it from Exception or from a child class of Exception such as IOException.
It is customary to give both a default constructor and a constructor that contains a detailed message.
The toString method of the Throwable superclass returns a string containing that detailed message, which is handy for debugging.)
Throwable(String message) constructs a new Throwable object with the specified detailed message.
By convention, all derived exception classes support both a default constructor and a constructor with a detailed message.
String getMessage() gets the detailed message of the Throwable object.
It is pretty easy: You throw it and you forget it.
If an exception occurs that is not caught anywhere, the program will terminate and print a.
When you are debugging a GUI program, it is a good idea to keep the console available on the screen and not minimized.)
If any code inside the try block throws an exception of the class specified in the catch clause, then.
The program skips the remainder of the code in the try block.
The program executes the handler code inside the catch clause.
If none of the code inside the try block throws an exception, then the program skips the catch clause.
If any of the code in a method throws an exception of a type other than the one named in the catch clause, this method exits immediately.
Hopefully, one of its callers has already provided a catch clause for that type.)
Notice that most of the code in the try clause is straightforward: It reads and processes bytes until we encounter the end of the file.
As you can see by looking at the Java API, there is the possibility that the read method will throw an IOException.
In that case, we skip out of the entire while loop, enter the catch clause, and generate a stack trace.
For a toy program, that seems like a reasonable way to deal with this exception.
Often, the best choice is to do nothing at all and simply pass the exception on to the caller.
If an error occurs in the read method, let the caller of the read method worry about it! If we take that approach, then we have to advertise the fact that the method may throw an IOException.
If you call a method that throws a checked exception, you must either handle it or pass it on.
Which of the two is better? As a general rule, you should catch those exceptions that you know how to handle and propagate those that you do not know how to handle.
When you propagate an exception, you must add a throws specifier to alert the caller that an exception may be thrown.
Look at the Java API documentation to see what methods throw which exceptions.
It is better to direct an exception to a competent handler than to squelch it.
Please keep in mind that there is, as we mentioned earlier, one exception to this rule.
If you are writing a method that overrides a superclass method which throws no exceptions (such as paintComponent in JComponent), then you must catch each checked exception in the method’s code.
You are not allowed to add more throws specifiers to a subclass method than are present in the superclass method.
This is not needed in Java because all exceptions derive from a common superclass.
You can catch multiple exception types in a try block and handle each type differently.
The exception object may contain information about the nature of the exception.
As of Java SE7, you can catch multiple exception types in the same catch clause.
This feature is only needed when catching exception types that are not subclasses of one another.
Note When you catch multiple exceptions, the exception variable is implicitly final.
For example, you cannot assign a different value to e in the body of the clause.
Note Catching multiple exceptions doesn’t just make your code look simpler but also more efficient.
The generated bytecodes contain a single block for the shared catch clause.
Typically, you do this when you want to change the.
If you build a subsystem that other programmers use, it makes a lot of sense to use an exception type that indicates a failure of the subsystem.
An example of such an exception type is the ServletException.
The code that executes a servlet may not want to know in minute detail what went wrong, but it definitely wants to know that the servlet was at fault.
Here, the ServletException is constructed with the message text of the exception.
However, it is a better idea to set the original exception as the “cause” of the new exception:
It allows you to throw high-level exceptions in subsystems without losing the details of the original failure.
Tip The wrapping technique is also useful if a checked exception occurs in a method that is not allowed to throw a checked exception.
You can catch the checked exception and wrap it into a runtime exception.
Sometimes, you just want to log an exception and rethrow it without any change:
Before Java SE 7, there was a problem with this approach.
Suppose the code is inside a method public void updateRecord() throws SQLException.
The Java compiler looked at the throw statement inside the catch block, then at the type of e, and complained that this method might throw any Exception, not just a SQLException.
The compiler now tracks the fact that e originates from the try block.
Provided that the only checked exceptions in that block are SQLException instances, and provided that e is not changed in the catch block, it is valid to declare the enclosing method as throws SQLException.
When your code throws an exception, it stops processing the remaining code in your method and exits the method.
This is a problem if the method has acquired some local resource, which only this method knows about, and that resource must be cleaned up.
But this solution is tedious because you need to clean up the resource allocation in two places—in the normal code and in the exception code.
Here we show you how to properly close a file in Java.
If you do any database programming, you will need to use the same technique to close connections to the database.
As you will see in Chapter 4 of Volume II, it is very important to close all database connections properly, even when exceptions occur.
The code in the finally clause executes whether or not an exception was caught.
In the following example, the program will dispose of the graphics context under all circumstances:
Let us look at the three possible situations in which the program will execute the finally clause.
In this case, the program first executes all the code in the try block.
Afterwards, execution continues with the first statement after the finally clause.
The code throws an exception that is caught in a catch clause—in our case, an IOException.
For this, the program executes all code in the try block, up to the point at which the exception was thrown.
The program then executes the code in the matching catch clause, and then the code in the finally clause.
If the catch clause does not throw an exception, the program executes the first line after the finally clause.
The code throws an exception that is not caught in any catch clause.
Here, the program executes all code in the try block until the exception is thrown.
Then, the code in the finally clause is executed, and the exception is thrown back to the caller of this method.
You can use the finally clause without a catch clause.
The in.close() statement in the finally clause is executed whether or not an exception is encountered in the try block.
Of course, if an exception is encountered, it is rethrown and must be caught in another catch clause.
In fact, as explained in the following tip, we think it is a very good idea to use the finally clause in this way whenever you need to close a resource.
Tip We strongly suggest that you decouple try/catch and try/finally blocks.
The inner try block has a single responsibility: to make sure that the input stream is closed.
The outer try block has a single responsibility: to ensure that errors are reported.
Not only is this solution clearer, it is also more functional: Errors in the finally clause are reported.
Caution A finally clause can yield unexpected results when it contains return statements.
Suppose you exit the middle of a try block with a return statement.
If the finally block also contains a return statement, then it masks the original return value.
Sometimes the finally clause gives you grief—namely, if the cleanup method can also throw an exception.
Suppose you want to make sure that you close a stream when an exception hits in the stream processing code.
Now suppose that the code in the try block throws some exception other than an IOException which is of interest to the caller of the code.
The finally block executes, and the close method is called.
That method can itself throw an IOException! When it does, then the original exception is lost and the exception of the close method is thrown instead.
This is a problem because the first exception is likely to be more interesting.
If you want to do the right thing and rethrow the original exception, the code becomes incredibly tedious.
Fortunately, Java SE 7 has made it much easier to deal with closing resources, as you will see in the next section.
Java SE 7 provides a useful shortcut to the code pattern.
It is a subinterface of AutoCloseable, also with a single close method.
When the try block exits, then res.close() is called automatically.
Here is a typical example— reading all words of a file:
When the block exits normally, or when there was an exception, the in.close() method is called, exactly as if you had used a finally block.
No matter how the block exits, both in and out are closed.
If you programmed this by hand, you would need two nested try/finally statements.
As you have seen in the preceding section, a difficulty arises when the try block throws an exception and the close method also throws an exception.
The original exception is rethrown, and any exceptions thrown by close methods are considered “suppressed”
They are automatically caught and added to the original exception with the addSuppressed method.
If you are interested in them, call the getSuppressed method which yields an array of the suppressed expressions from close methods.
Use the try-with-resources statement whenever you need to close a resource.
Note A try-with-resources statement can itself have catch clauses and a finally clause.
In practice, it’s probably not a good idea to pile so much onto a single try statement.
A stack trace is a listing of all pending method calls at a particular point in the execution of a.
You have almost certainly seen stack trace listings—they are displayed whenever a Java program terminates with an uncaught exception.
You can access the text description of a stack trace by calling the printStackTrace method of the.
A more flexible approach is the getStackTrace method that yields an array of StackTraceElement objects, which you can analyze in your program.
The StackTraceElement class has methods to obtain the file name and line number, as well as the class and method name, of the executing line of code.
The toString method yields a formatted string containing all of this information.
Listing 11.1 prints the stack trace of a recursive factorial function.
Throwable getCause() 1.4 gets the exception object that was set as the cause for this object, or null if no cause was set.
This happens in a try-with-resources statement where t is an exception thrown by a close method.
Typically, these are exceptions thrown by a close method in a try-with-resources statement.
String getClassName() gets the fully qualified name of the class containing the execution point of this element.
String getMethodName() gets the name of the method containing the execution point of this element.
You can’t distinguish between overloaded methods with the same name.
String toString() returns a formatted string containing the class and method name and the file name and line number, if available.
There is a certain amount of controversy about the proper use of exceptions.
We think that exceptions (even checked exceptions) have their place, and offer you these tips for their proper use.
Exception handling is not supposed to replace a simple test.
As an example of this, we wrote some code that tries 10,000,000 times to pop an empty stack.
It first does this by finding out whether the stack is empty.
On our test machine, the version that calls isEmpty ran in 646 milliseconds.
As you can see, it took far longer to catch an exception than to perform a simple test.
Many programmers wrap every statement in a separate try block.
Think about the task that you want the code to accomplish.
Here, we want to pop 100 numbers off a stack and save them to a file.
Never mind why—it is just a toy example.) There is nothing we can do if a problem rears its ugly head.
If the stack is empty, it will not become occupied.
If the file contains an error, the error will not magically go away.
It therefore makes sense to wrap the entire task in a try block.
If any one operation fails, you can then abandon the task.
It fulfills one of the promises of exception handling: to separate normal processing from error handling.
Checked exceptions are inherently burdensome—don’t throw them for logic errors.
Callers often need to catch exceptions that they know can never happen.) Do not hesitate to turn an exception into another exception that is more appropriate.
In Java, there is a tremendous temptation to shut up exceptions.
If you’re writing a method that calls a method that might throw an exception once a century, the compiler whines because you have not declared the exception in the throws list of your method.
You do not want to put it in the throws list because then the compiler will whine about all the methods that call your method.
If you believe that exceptions are at all important, you should make some effort to handle them right.
Some programmers worry about throwing exceptions when they detect errors.
Many programmers feel compelled to catch all exceptions that are thrown.
If they call a method that throws an exception, such as the FileInputStream constructor or the readLine method, they instinctively catch the exception that may be generated.
Often, it is actually better to propagate the exception instead of catching it:
Higher-level methods are often better equipped to inform the user of errors or to abandon unsuccessful commands.
The assertion mechanism allows you to put in checks during testing and to have them.
Note The sole purpose of the expression part is to produce a message string.
The AssertionError object does not store the actual expression value, so you can’t query it later.
To assert that x is non-negative, you can simply use the statement.
C++ Note The assert macro of the C language turns the assertion condition into a string that is printed if the assertion fails.
In Java, the condition is not automatically part of the error report.
Enable them by running the program with the enableassertions or -ea option: java -enableassertions MyApp.
Note that you do not have to recompile your program to enable or disable assertions.
Enabling or disabling assertions is a function of the class loader.
When assertions are disabled, the class loader strips out the assertion code so that it won’t slow execution.
You can even turn on assertions in specific classes or in entire packages.
You can also disable assertions in certain classes and packages with the -disableassertions or -da option:
However, the -ea and -da switches that enable or disable all assertions do not apply to the.
It is also possible to programmatically control the assertion status of class loaders.
See the API notes at the end of this section.
The Java language gives you three mechanisms to deal with system failures:
Assertion checks are turned on only during development and testing.
Therefore, you would not use assertions for signaling recoverable conditions to another part of the program or for communicating problems to the program user.
Assertions should only be used to locate internal program errors during testing.
Let’s look at a common scenario—the checking of method parameters.
Should you use assertions to check for illegal index values or null references? To answer that question, you have to look at the documentation of the method.
Sorts the specified range of the specified array into ascending numerical order.
The range to be sorted extends from fromIndex, inclusive, to toIndex, exclusive.
The documentation states that the method throws an exception if the index values are incorrect.
That behavior is part of the contract that the method makes with its callers.
If you implement the method, you have to respect that contract and throw the indicated exceptions.
Should you assert that a is not null? That is not appropriate either.
The method documentation is silent on the behavior of the method when a is null.
The callers have the right to assume that the method will return successfully in that case and not throw an assertion error.
However, suppose the method contract had been slightly different: @param a the array to be sorted (must not be null)
Now the callers of the method have been put on notice that it is illegal to call the method with a null array.
The revised method has a single precondition: that a is not null.
If the caller fails to fulfill the precondition, then all bets are off and the method can do anything it wants.
In fact, with the assertion in place, the method has a rather unpredictable behavior when it is called illegally.
It sometimes throws an assertion error, and sometimes a null pointer exception, depending on how its class loader is configured.
Of course, it would make even more sense to think through the issue a bit more thoroughly.
Thus, the real assumption is that i is not negative.
At any rate, this example shows a good use of assertions as a self-check for the programmer.
In contrast, logging is a strategic tool for the entire life cycle of a program.
Of course, once you have figured out the cause of trouble, you remove the print statements, only to put them back in when the next problem surfaces.
It is easy to suppress all log records or just those below a certain level, and just as easy to turn them back on.
Suppressed logs are very cheap, so that there is only a minimal penalty for leaving the logging code in your application.
Log records can be directed to different handlers—for displaying in the console, writing to a file, and so on.
Filters can discard boring log entries, using any criteria supplied by the filter implementor.
Log records can be formatted in different ways—for example, in plain text or XML.
By default, the logging configuration is controlled by a configuration file.
For simple logging, use the global logger and call its info method:
There is no semantic relationship between a package and its parent, but logger parents and children share certain properties.
For example, if you set the log level on the logger "com.mycompany", then the child loggers inherit that level.
You can also use Level.ALL to turn on logging for all levels or Level.OFF to turn all logging off.
Tip The default logging configuration logs all records with the level of INFO or higher.
Therefore, you should use the levels CONFIG, FINE, FINER, and FINEST for debugging messages that are useful for diagnostics but meaningless to the user.
Caution If you set the logging level to a value finer than INFO, you also need to change the log handler configuration.
The default log record shows the name of the class and method that contain the logging call, as inferred from the call stack.
However, if the virtual machine optimizes execution, accurate call information may not be available.
You can use the logp method to give the precise location of the calling class and method.
There are convenience methods for tracing execution flow: void entering(String className, String methodName) void entering(String className, String methodName, Object param) void entering(String className, String methodName, Object[] params) void exiting(String className, String methodName) void exiting(String className, String methodName, Object result)
These calls generate log records of level FINER that start with the strings ENTRY and RETURN.
A common use for logging is to log unexpected exceptions.
Two convenience methods include a description of the exception in the log record.
The throwing call logs a record with level FINER and a message that starts with THROW.
You can change various properties of the logging system by editing a configuration file.
Caution The log manager is initialized during VM startup, before main executes.
To change the default logging level, edit the configuration file and modify the line .level=INFO.
That is, append the .level suffix to the logger name.
As you will see later in this section, the loggers don’t actually send the messages to the console—
To see FINE messages on the console, you also need to set.
Caution The settings in the log manager configuration are not system properties.
Alternatively, you can keep the standard log manager and still bypass the initialization from the logging properties file.
See the API documentation for the LogManager class for more information.
It is also possible to change logging levels in a running program by using the jconsole program.
You may want to localize logging messages so that they are readable for international users.
Briefly, here are the points to keep in mind when localizing logging messages.
A resource bundle consists of a set of mappings for various locales (such as United States or Germany)
For example, a resource bundle may map the string "readingFile" into strings "Reading file" in English or "Achtung! Datei wird eingelesen" in German.
A program may contain multiple resource bundles, for example, one for menus and another for log messages.
To add mappings to a resource bundle, you supply a file for each locale.
The en and de are the language codes.) You place the.
These files are plain text files, consisting of entries such as.
By default, loggers send records to a ConsoleHandler that prints them to the System.err stream.
Specifically, the logger sends the record to the parent handler, and the ultimate ancestor (with name "") has a ConsoleHandler.
For a record to be logged, its logging level must be above the threshold of both the logger and the handler.
The log manager configuration file sets the logging level of the default console handler as.
Alternatively, you can bypass the configuration file altogether and install your own handler.
By default, a logger sends records both to its own handlers and the handlers of the parent.
Our logger is a child of the primordial logger (with name "") that sends all records with level INFO and above to the console.
We don’t want to see those records twice, however, so we set the useParentHandlers property to false.
The logging API provides two useful handlers for this purpose: a FileHandler and a SocketHandler.
The SocketHandler sends records to a specified host and port.
Of greater interest is the FileHandler that collects records in a file.
The records are sent to a file javan.log in the user’s home directory, where n is a number to make the file unique.
You can modify the default behavior of the file handler by setting various parameters in the log manager configuration (see Table 11.1), or by using another constructor (see the API notes at the end of this section)
You probably don’t want to use the default log file name.
See Table 11.2 for an explanation of the pattern variables.)
If multiple applications (or multiple copies of the same application) use the same log file, you should turn the append flag on.
Alternatively, use %u in the file name pattern so that each application.
It is also a good idea to turn file rotation on.
Log files are kept in a rotation sequence, such as.
Whenever a file exceeds the size limit, the oldest log is deleted, the other files are renamed, and a new file with generation number 0 is created.
Tip Many programmers use logging as an aid for the technical support staff.
If a program misbehaves in the field, the user can send back the log files for inspection.
In that case, you should turn the append flag on, use rotating logs, or both.
You can also define your own handlers by extending the Handler or the StreamHandler class.
We define such a handler in the example program at the end of this section.
That handler displays the records in a window (see Figure 11.2)
The handler extends the StreamHandler class and installs a stream whose write methods display the stream output in a text area.
There is just one problem with this approach—the handler buffers the records and only writes them to the stream when the buffer is full.
Therefore, we override the publish method to flush the buffer after each record:
If you want to write more exotic stream handlers, extend the Handler class and define the publish, flush, and close methods.
By default, records are filtered according to their logging levels.
To define a filter, implement the Filter interface and define the method.
For example, a particular filter may only be interested in the messages generated by the entering and exiting methods.
To install a filter into a logger or handler, simply call the setFilter method.
Note that you can have at most one filter at a time.
The ConsoleHandler and FileHandler classes emit the log records in text and XML formats.
You need to extend the Formatter class and override the method.
String format(LogRecord record) Format the information in the record in any way you like and return the resulting string.
That method formats the message part of the record, substituting parameters and applying localization.
Many file formats (such as XML) require a head and tail parts that surround the formatted records.
Finally, call the setFormatter method to install the formatter into the handler.
With so many options for logging, it is easy to lose track of the fundamentals.
Therefore, reserve these levels for messages that are meaningful to the users of your program.
The level FINE is a good choice for logging messages that are intended for programmers.
Listing 11.2 puts this recipe to use with an added twist: Logging messages are also displayed in a log window.
Filter getFilter() • void setFilter(Filter f) gets and sets the filter of this handler.
Level getLevel() • void setLevel(Level l) gets and sets the level of this handler.
String getLoggerName() gets the name of the logger that is logging this record.
String getMessage() gets the “raw” message before localization or formatting.
Object[] getParameters() gets the parameter objects, or null if none is provided.
Throwable getThrown() gets the thrown object, or null if none is provided.
This information may be supplied by the logging code or automatically inferred from the runtime stack.
It might be inaccurate if the logging code supplied the wrong value or if the running code was optimized so that the exact location cannot be inferred.
These IDs are assigned by the LogRecord class and have no relationship to other thread IDs.
String getHead(Handler h) • String getTail(Handler h) returns the strings that should appear at the head and tail of the document containing the log records.
The Formatter superclass defines these methods to return the empty string; override them if necessary.
Suppose you wrote your program and made it bullet-proof by catching and properly handling all.
Then you run it, and it does not work right.
Now what? (If you never have this problem, you can skip the remainder of this chapter.)
Of course, it is best if you have a convenient and powerful debugger.
Debuggers are available as a part of professional development environments such as Eclipse and NetBeans.
In this section, we offer you a number of tips that may be worth trying before you launch the debugger.
If x is a number, it is converted to its string equivalent.
If x is an object, then Java calls its toString method.
To get the state of the implicit parameter object, print the state of the this object.
Make a few objects, call all methods, and check that each of them does the right thing.
You can leave all these main methods in place and launch the Java virtual machine separately on each of the files to run the tests.
When you run an applet, none of these main methods are ever called.
When you run an application, the Java virtual machine calls only the main method of the startup class.
If you liked the preceding tip, you should check out JUnit from http://junit.org.
JUnit is a very popular unit testing framework that makes it easy to organize suites of test cases.
Run the tests whenever you make changes to a class, and add another test case whenever you find a bug.
A logging proxy is an object of a subclass that intercepts method calls, logs them, and then calls the superclass.
For example, if you have trouble with the nextDouble method of the Random class, you can create a proxy object as an instance of an anonymous subclass:
Whenever the nextDouble method is called, a log message is generated.
To find out who called the method, generate a stack trace.
The following code catches any exception, prints the exception object and the stack trace, and rethrows the exception so it can find its intended handler.
You don’t even need to catch an exception to generate a stack trace.
Having the stack traces of uncaught exceptions show up in System.err is not ideal.
These messages are confusing to end users if they happen to see them, and they are not available for diagnostic purposes when you need them.
A better approach is to log them to a file.
To watch class loading, launch the Java virtual machine with the -verbose flag.
This can occasionally be helpful to diagnose class path problems.
The term “lint” originally described a tool for locating potential problems in C programs, but is now generically applied to any tools that flag constructs that are questionable but not illegal.) The following options are available:
The Java VM has support for monitoring and management of Java applications, allowing the installation of agents in the virtual machine that track memory consumption, thread usage, class loading, and so on.
This feature is particularly important for large and long-running Java programs, such as application servers.
As a demonstration of these capabilities, the JDK ships with a graphical tool called jconsole that displays statistics about the performance of a virtual machine (see Figure 11.3)
Find out the ID of the operating system process that runs the virtual machine.
In UNIX/Linux, run the ps utility; in Windows, use the task manager.
The console gives you a wealth of information about your running program.
You can use the jmap utility to get a heap dump that shows you every object on the heap.
You will get a web application that lets you drill down into the contents of the heap at the time of the dump.
If you launch the Java virtual machine with the -Xprof flag, it runs a rudimentary profiler that keeps track of the methods in your code that were executed most often.
The output also tells you which methods were compiled by the just-in-time compiler.
Caution The -X options of the compiler are not officially supported and may not be present in all versions of the JDK.
Run java -X to get a listing of all nonstandard options.
In this section, we will give a few additional debugging tips that are specific to GUI programming.
Then, we will show you how to use the AWT robot to automate GUI testing.
Press Ctrl+Shift+F1 to get a printout of all components in the hierarchy:
If you design your own custom Swing component and it doesn’t seem to be displayed correctly, you’ll really love the Swing graphics debugger.
Even if you don’t write your own component classes, it is instructive and fun to see exactly how the contents of a component are drawn.
The magic incantation for turning on the flash option is.
Simply place these lines at the end of your frame constructor.
When the program runs, you will see the content pane filled in slow motion.
Control freaks can set the duration, count, and color of the flashes—see the online documentation of the DebugGraphics class for details.
If you want to get a record of every AWT event generated in your GUI application, you can install a listener in every component that emits events.
This is easily automated, due to the power of reflection.
To spy on messages, add the component whose events you want to trace to an event tracer:
You will then get a textual description of all events, as shown in Figure 11.4
The Robot class can send keystrokes and mouse clicks to any AWT program.
To get a robot, you need to first get a GraphicsDevice object.
The idea is that you simulate key and mouse input and then take a screenshot to see whether the application did what it was supposed to.
Finally, you will usually want to add a small delay between robot instructions so that the.
Use the delay method and give it the number of milliseconds to delay.
Then the robot waits for two seconds so that you can see what it has done.
After the delay, the robot simulates the Tab key and another space bar press to click on the next button.
Finally, it simulates a mouse click on the third button.
You may need to adjust the x and y coordinates of the program to actually press the buttons.) The program ends by taking a screen capture and displaying it in another frame (see Figure 11.5)
Note You need to run the robot in a separate thread, as shown in the example code.
As you can see from this example, the Robot class is not by itself suitable for convenient user interface testing.
Instead, it is a basic building block that can be a foundational part of a testing tool.
A professional testing tool can capture, store, and replay user interaction scenarios and find out the screen locations of the components so that mouse clicks aren’t guesswork.
Note that computers with multiple monitors have one graphics device per screen—use the getScreenDevices method to obtain an array of all screen devices.
Debugging with print statements is not one of life’s more joyful experiences.
A debugger runs your program in full motion until it reaches a breakpoint, and then you can look at everything that interests you.
When you click on any of the buttons, nothing happens.
Look at the source code—button clicks are supposed to set the background color to the color specified by the button name.
In a program this short, you may be able to find the bug just by reading the source code.
Let us pretend that scanning the source code for errors is not practical.
We show you how to use the Eclipse debugger to locate the error.
Note If you use a stand-alone debugger such as JSwat (http://code.google.
Set a breakpoint at the first line of the actionPerformed method: Right-click in the left margin, next to the line of code, and choose Toggle Breakpoint.
The breakpoint will be hit as soon as Java starts processing code in the actionPerformed method.
The debugger breaks at the start of the actionPerformed method (Figure 11.6)
There are two basic commands to single-step through a program.
The Step Over command goes to the next line without stepping inside any further method calls.
Issue the Step Over command twice and see where you are.
Inspect the local variables and check the value of the arg variable:
The value of arg was "Yellow", with an uppercase Y, but the comparison tested.
To quit the debugger, select Run -> Terminate from the menu.
There are more advanced debugging commands in Eclipse, but you can get a long way with the.
Other debuggers, such as the NetBeans debugger, have very similar commands.
This chapter introduced you to exception handling and gave you some useful hints for testing and debugging.
The next two chapters cover generic programming and its most important application: the Java collections framework.
Generic classes constitute the most significant change in the Java programming language since the 1.0 release.
The expert group spent about five years on specifications and test implementations.
Generic classes are desirable because they let you write code that is safer and easier to read than code littered with Object variables and casts.
Generics are particularly useful for collection classes, such as the ubiquitous ArrayList.
In C++, as in Java, templates were first added to the language to support strongly typed collections.
After reading this chapter, you may find novel uses for Java generics in your programs.
Why Generic Programming? Generic programming means writing code that can be reused for objects of many.
For example, you don’t want to program separate classes to collect String and File objects.
And you don’t have to—the single class ArrayList collects objects of any class.
Before generic classes were added to Java, generic programming was achieved with inheritance.
The ArrayList class simply maintained an array of Object references:
Elsewhere, casting the result of get to a String will cause an error.
The ArrayList class now has a type parameter that indicates the element type:
Note As we already mentioned, in Java SE 7 and beyond, you can omit the generic type in the constructor:
The compiler can make good use of the type information too.
The compiler knows that the return type is String, not Object:
That is a lot safer than having an Object parameter.
Now the compiler can check that you don’t insert objects of the wrong type.
A compiler error is much better than a class cast exception at runtime.
This is the appeal of type parameters: They make your programs easier to read and safer.
Who Wants to Be a Generic Programmer? It is easy to use a generic class such as ArrayList.
Of course, array lists are better than arrays because they can expand automatically.)
However, it is not so easy to implement a generic class.
The programmers who use your code will want to plug in all sorts of classes for your type parameters.
They expect everything to work without onerous restrictions and confusing error messages.
Your job as a generic programmer, therefore, is to anticipate all the potential future uses of your class.
How hard can this get? Here is a typical issue that the designers of the standard class library had to grapple with.
The ArrayList class has a method addAll to add all elements of another collection.
But, of course, doing it the other way round should not be legal.
How do you allow one call and disallow the other? The Java language designers invented an ingenious new concept, the wildcard type, to solve this problem.
Wildcard types are rather abstract, but they allow a library builder to make methods as flexible as possible.
Most application programmers will want to stay at that level until something goes wrong.
You may encounter a confusing error message when mixing different generic classes, or when interfacing with legacy code that knows nothing about type parameters.
At that point, you need to learn enough about Java generics to solve problems systematically rather than through random tinkering.
Finally, of course, you may want to implement your own generic classes and methods.
The JDK developers have already done the heavy lifting and supplied type parameters for all the collection classes.
As a rule of thumb, only code that traditionally involved lots of casts from very general types (such as Object or the Comparable interface) will benefit from using type parameters.
In this chapter, we will show you everything you need to know to implement your own generic code.
However, we expect that most readers will use this knowledge primarily for help with troubleshooting and to satisfy their curiosity about the inner workings of the parameterized collection classes.
A generic class is a class with one or more type variables.
This class allows us to focus on generics without being distracted by data storage details.
A generic class can have more than one type variable.
For example, we could have defined the Pair class with separate types for the first and second field:
For example: private T first; // uses the type variable.
Note It is common practice to use uppercase letters for type variables, and to keep them short.
You instantiate the generic type by substituting types for the type variables, such as.
Pair<String> You can think of the result as an ordinary class with constructors.
In other words, the generic class acts as a factory for ordinary classes.
The program in Listing 12.1 puts the Pair class to work.
Recall that the compareTo method compares two strings, returning 0 if the strings are identical, a negative integer if the first string comes before the second in dictionary order, and a positive integer otherwise.
The only obvious difference is that Java has no special template keyword.
However, as you will see throughout this chapter, there are substantial differences between these two mechanisms.
In the preceding section, you have seen how to define a generic class.
This method is defined inside an ordinary class, not inside a generic class.
However, it is a generic method, as you can see from the angle brackets and the type variable.
Note that the type variables are inserted after the modifiers (public.
You can define generic methods both inside ordinary classes and inside generic.
When you call a generic method, you can place the actual types, enclosed in.
In this case (and indeed in most cases), you can omit the <String> type parameter from the method call.
The compiler has enough information to infer the method that you want.
Occasionally, the compiler gets it wrong, and you’ll need to decipher an error report.
In a nutshell, the compiler autoboxed the parameters into a Double and two Integer objects, and then it tried to find a common supertype of these classes.
It actually found two: Number and the Comparable interface, which is itself a generic type.
In this case, the remedy is to write all parameters as double values.
In plain English, you can assign the result to Object, Serializable, or Comparable.
Sometimes, a class or a method needs to place restrictions on type variables.
The variable smallest has type T, which means that it could be an object of an arbitrary class.
How do we know that the class to which T belongs has a compareTo method?
The solution is to restrict T to a class that implements the Comparable interface— a standard interface with a single method, compareTo.
You can achieve this by giving a bound for the type variable T:
Now, the generic min method can only be called with arrays of classes that implement the Comparable interface, such as String, Date, and so on.
Calling min with a Rectangle array is a compile-time error because the Rectangle class does not implement Comparable.
If a programmer instantiates a template with an inappropriate type, an (often obscure) error message is reported inside the template code.
You may wonder why we use the extends keyword rather than the implements keyword in this situation—after all, Comparable is an interface.
The extends keyword was chosen because it is a reasonable approximation of the subtype concept, and the Java designers did not want to add a new keyword (such as sub) to the language.
The bounding types are separated by ampersands (&) because commas are used to separate type variables.
As with Java inheritance, you can have as many interface supertypes as you like, but at most one of the bounds can be a class.
If you have a class as a bound, it must be the first one in the bounds list.
In the next sample program (Listing 12.2), we rewrite the minmax method to be generic.
The method computes the minimum and maximum of a generic array, returning a Pair<T>
The virtual machine does not have objects of generic types—all objects belong to.
Whenever you define a generic type, a corresponding raw type is automatically provided.
The name of the raw type is simply the name of the generic type, with the type parameters removed.
The type variables are erased and replaced by their bounding types (or Object for variables without bounds.)
Since T is an unbounded type variable, it is simply replaced by Object.
The result is an ordinary class, just as you might have implemented it before.
Your programs may contain different kinds of Pair, such as Pair<String> or.
The raw type replaces type variables with the first bound, or Object if no bounds are given.
For example, the type variable in the class Pair<T> has no explicit bounds, hence the raw type replaces T with Object.
In that case, the raw type replaces T with Serializable, and the compiler inserts casts to Comparable when necessary.
For efficiency, you should therefore put tagging interfaces (that is, interfaces without methods) at the end of the bounds list.
When you program a call to a generic method, the compiler inserts casts when.
That is, the compiler translates the method call into two virtual machine instructions:
A call to the raw method Pair.getFirst • A cast of the returned Object to the type Employee.
Casts are also inserted when you access a generic field.
Suppose the first and second fields of the Pair class were public.
Not a good programming style, perhaps, but it is legal Java.) Then the expression.
Employee buddy = buddies.first; also has a cast inserted in the resulting byte codes.
A date interval is a pair of Date objects, and we’ll want to override the methods to ensure that the second value is never smaller than the first.
Perhaps surprisingly, there is another setSecond method, inherited from Pair, namely,
Our expectation is that the call to setSecond is polymorphic and that the appropriate method is called.
The problem is that the type erasure interferes with polymorphism.
To fix this problem, the compiler generates a bridge method in the DateInterval class:
The virtual machine calls that method on the object to which pair refers.
In the DateInterval class, there are two getSecond methods: Date getSecond() // defined in DateInterval Object getSecond() // overrides the method defined in Pair to call the first method.
You could not write Java code like that; it would be illegal to have two methods with the same parameter types—here, with no parameters.
However, in the virtual machine, the parameter types and the return type specify a method.
Therefore, the compiler can produce bytecodes for two methods that differ only in their return type, and the virtual machine will handle this situation correctly.
We already noted in Chapter 5 that it is legal for a method to specify a more restrictive return type when overriding another method.
The Object.clone and Employee.clone methods are said to have covariant return types.
Employee clone() // defined above Object clone() // synthesized bridge method, overrides Object.clone.
In summary, you need to remember these facts about translation of Java generics:
There are no generics in the virtual machine, only ordinary classes and methods.
When Java generics were designed, a major goal was to allow interoperability between generics and legacy code.
To set the labels of a JSlider, you use the method.
However, when you populate the dictionary, you should use the generic type.
That breaks the guarantee that the keys have type Integer, and future operations may cause bad cast exceptions.
There isn’t much you can do with this warning, except ponder it and ask what the JSlider is likely going to do with this Dictionary object.
In our case, it is pretty clear that the JSlider only reads the information, so we can ignore the warning.
Now consider the opposite case, in which you get an object of a raw type from a legacy class.
You can assign it to a variable whose type uses generics, but of course you will get a warning.
That’s OK—review the warning and make sure that the label table really contains Integer and Component objects.
A malicious coder might have installed a different Dictionary in the slider.
But again, the situation is no worse than it was before generics.
In the worst case, your program will throw an exception.
After you are done pondering the warning, you can use an annotation to make it disappear.
This annotation turns off checking for all code inside the method.
In the following sections, we discuss a number of restrictions that you need to.
You cannot substitute a primitive type for a type parameter.
After erasure, the Pair class has fields of type Object, and you can’t use them to store double values.
This is an annoyance, to be sure, but it is consistent with the separate status of primitive types in the Java language.
It is not a fatal flaw—there are only eight primitive types, and you can always handle them with separate classes and methods when wrapper types are not an acceptable substitute.
Objects in the virtual machine always have a specific nongeneric type.
The same is true for the test if (a instanceof Pair<T>) // ERROR.
To remind you of the risk, you will get a compiler error (with instanceof) or warning (with casts) when you try to inquire whether an object belongs to a generic type.
In the same spirit, the getClass method always returns the raw type.
The comparison yields true because both calls to getClass return Pair.class.
Note that only the creation of these arrays is outlawed.
In the preceding section, you saw that Java doesn’t support arrays of generic.
In this section, we discuss a related issue: passing instances of a generic type to a method with a variable number of arguments.
Recall that the parameter ts is actually an array that holds all supplied arguments.
In order to call this method, the Java virtual machine must make an array of Pair<String>, which is against the rules.
However, the rules have been relaxed for this situation, and you only get a warning, not an error.
You can suppress the warning in one of two ways.
You can use this annotation for any methods that merely read the elements of the parameter array, which is bound to be the most common use case.
Note You can use the @SafeVarargs annotation to defeat the restriction against generic array creation, using this method:
You cannot use type variables in expression such as new T(...), new T[...], or.
Type erasure would change T to Object, and surely you don’t want to call new Object()
Instead, you must design the API so that you are handed a Class object, like this:
For example, String.class is an instance (indeed, the sole instance) of Class<String>
Therefore, the makePair method can infer the type of the pair that it is making.
Type erasure would cause this method to always construct an array Comparable[2]
If the array is only used as a private instance field of a class, you can declare the array as Object[] and use casts when retrieving elements.
For example, the ArrayList class could be implemented as follows:
Here, the cast E[] is an outright lie, but type erasure makes it undetectable.
This technique does not work for our minmax method since we are returning a T[]
The toArray method of the ArrayList class is not so lucky.
It needs to produce a T[] array, but it doesn’t have the component type.
Otherwise, a new array of sufficient size is created, using the component type of result.
You cannot reference type variables in static fields or methods.
After type erasure there is only one Singleton class, and only one singleInstance field.
For that reason, static fields and methods with type variables are simply outlawed.
You can neither throw nor catch objects of a generic class.
You cannot use a type variable in a catch clause.
However, it is OK to use type variables in exception specifications.
A bedrock principle of Java exception handling is that you must provide a handler for all checked exceptions.
The following turns all exceptions into those that the compiler believes to be unchecked:
The user will override the body method to supply a particular action.
When calling toThread, you get an object of the Thread class whose run method doesn’t mind checked exceptions.
We simply throw the exception, tricking the compiler into believing that it is not a checked exception.
Using generic classes, erasure, and the @SuppressWarnings annotation, we were able to defeat an essential part of the Java type system.
It is illegal to create conditions that cause clashes when generic types are erased.
Conceptually, it has two equals methods: boolean equals(String) // defined in Pair<T> boolean equals(Object) // inherited from Object.
The remedy is, of course, to rename the offending method.
The generics specification cites another rule: “To support translation by erasure,
It is not obvious what this restriction has to do with type erasure.
There would be a conflict with the synthesized bridge methods.
When you work with generic classes, you need to learn a few rules about.
Let’s start with a situation which many programmers find unintuitive.
Consider a class and a subclass, such as Employee and Manager.
This seems like a cruel restriction, but it is necessary for type safety.
We now managed to pair up the CFO with a lowly employee, which should not be possible for a Pair<Manager>
Note You just saw an important difference between generic types and Java arrays.
You can always convert a parameterized type to a raw type.
For example, Pair<Employee> is a subtype of the raw type Pair.
Can you convert to the raw type and then cause a type error? Unfortunately, you can.
However, keep in mind that you are no worse off than you were with older versions of Java.
The security of the virtual machine is not at stake.
When the foreign object is retrieved with getFirst and assigned to a Manager variable, a ClassCastException is thrown, just as in the good old days.
You merely lose the added safety that generic programming normally provides.
Finally, generic classes can extend or implement other generic classes.
In this regard, they are no different from ordinary classes.
It was known for some time among researchers of type systems that a rigid.
Let’s say you want to write a method that prints out pairs of employees, like this:
As you saw in the preceding section, you cannot pass a Pair<Manager> to that.
The compiler only knows that it needs some subtype of Employee, but it doesn’t know which type.
We don’t have this problem with getFirst: It is perfectly legal to assign the return value of getFirst to an Employee reference.
Wildcard bounds are similar to type variable bounds, but they have an added.
It was a stroke of good luck that the existing super keyword describes the relationship so accurately.)
You can supply parameters to methods, but you can’t use the return values.
The compiler doesn’t know the exact type of the setFirst method and therefore can’t call it with an object of type Employee or Object, but only with type Manager or a subtype such as Executive.
Moreover, if you call getFirst, there is no guarantee about the type of the returned object.
We have an array of managers and want to put the manager with the lowest and highest bonus into a Pair object.
Intuitively speaking, wildcards with supertype bounds let you write to a generic object, while wildcards with subtype bounds let you read from a generic object.
Here, the type variable indicates the type of the other parameter.
Now that Comparable is a generic type, perhaps we should have done a better job with the min method of the ArrayAlg class? We could have declared it as.
For example, if you compute the minimum of a String array, then T is the type String, and String is a subtype of Comparable<String>
But we run into a problem when processing an array of GregorianCalendar objects.
Now the compareTo method has the form int compareTo(? super T)
At any rate, it is safe to pass an object of type T to the compareTo method.
This is unfortunate, because the intent of this declaration is to help application programmers by removing unnecessary restrictions on the call parameters.
Application programmers with no interest in generics will probably learn quickly to gloss over these declarations and just take for granted that library programmers will do the right thing.
If you are a library programmer, you’ll need to get used to wildcards, or your users will curse you and throw random casts at their code until it compiles.
The return value of getFirst can only be assigned to an Object.
The setFirst method can never be called, not even with an Object.
That’s the essential difference between Pair<?> and Pair: you can call the setFirst method of the raw Pair class with any Object.
Why would you ever want such a wimpy type? It is useful for very simple.
For example, the following method tests whether a pair contains a null reference.
You could have avoided the wildcard type by turning hasNulls into a generic method:
Let us write a method that swaps the elements of a pair:
That’s a problem because we need to temporarily hold the first element when we do the swapping.
In this case, the parameter T of the swapHelper method captures the wildcard.
It isn’t known what type the wildcard denotes, but it is a definite type, and the definition of <T>swapHelper makes perfect sense when T denotes that type.
Of course, in this case, we were not compelled to use a wildcard.
However, consider this example in which a wildcard type occurs naturally in the middle of a computation:
The test program in Listing 12.3 gathers up the various methods that we discussed in the preceding sections, so that you can see them in context.
The type parameter is useful because it allows the methods of Class<T> to be.
The following methods of Class<T> take advantage of the type parameter:
The newInstance method returns an instance of the class, obtained from the noargument constructor.
Its return type can now be declared to be T, the same type as the class that is being described by Class<T>
The cast method returns the given object, now declared as type T if its type is indeed a subtype of T.
The getEnumConstants method returns null if this class is not an enum class or an array of the enumeration values which are known to be of type T.
The Constructor class has also been made generic so that its newInstance method has the correct return type.
It is sometimes useful to match the type variable of a Class<T> parameter in a.
The type parameter T of the makePair method matches Employee, and the compiler can infer that the method returns a Pair<Employee>
One of the notable features of Java generics is the erasure of generic types in the virtual machine.
Perhaps surprisingly, the erased classes still retain some faint memory of their generic origin.
In other words, you can reconstruct everything about generic classes and methods that their implementors declared.
However, you won’t know how the type parameters were resolved for specific objects or method calls.
Note The type information contained in class files to enable reflection of generics is incompatible with older virtual machines.
Note that the last four subtypes are interfaces—the virtual machine instantiates suitable classes that implement these interfaces.
Listing 12.4 uses the generic reflection API to print out what it discovers about a given class.
If you run it with the Pair class, you get this report:
If you run it with ArrayAlg in the PairTest2 directory, the report displays the following method:
If the method has no parameters, an array of length 0 is returned.
Type getOwnerType() gets the outer class type if this is an inner type, or null if this is a toplevel type.
You now know how to use generic classes and how to program your own generic classes and methods if the need arises.
Just as importantly, you know how to decipher the generic type declarations that you may encounter in the API documentation and in error messages.
For an exhaustive discussion of everything there is to know about Java generics, turn to Angelika Langer’s excellent list of frequently (and not so frequently) asked questions at http://angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html.
In the next chapter, you will see how the Java collections framework puts generics to work.
The data structures that you choose can make a big difference when you try to implement methods in a natural style or are concerned with performance.
This chapter shows how the Java library can help you accomplish the traditional data structuring needed for serious programming.
In college computer science programs, a course called Data Structures usually takes a semester to complete, and there are many, many books devoted to this important topic.
Our coverage differs from that of a college course; we will skip the theory and just show you how to use the collection classes in the standard library.
The initial release of Java supplied only a small set of classes for the most useful.
That was certainly a wise choice—it takes time and skill to come up with a comprehensive collection class library.
With the advent of Java SE 1.2, the designers felt that the time had come to roll out a full-fledged set of data structures.
They wanted the library to be small and easy to learn.
They wanted the legacy classes to fit into the new framework.
As all designers of collections libraries do, they had to make some hard choices, and they came up with a number of idiosyncratic design decisions along the way.
In this section, we will explore the basic design of the Java collections framework, show you how to put it to work, and explain the reasoning behind some of the more controversial features.
As is common with modern data structure libraries, the Java collection library separates interfaces and implementations.
Let us look at that separation with a familiar data structure, the queue.
A queue interface specifies that you can add elements at the tail end of the queue, remove them at the head, and find out how many elements are in the queue.
The interface tells you nothing about how the queue is implemented.
Each implementation can be expressed by a class that implements the Queue interface.
When you use a queue in your program, you don’t need to know which implementation is actually used once the collection has been constructed.
Therefore, it makes sense to use the concrete class only when you construct the collection object.
With this approach, if you change your mind, you can easily use a different implementation.
You only need to change your program in one place—in the constructor call.
If you decide that a LinkedListQueue is a better choice after all, your code becomes.
Why would you choose one implementation over another? The interface says nothing about the efficiency of an implementation.
A circular array is somewhat more efficient than a linked list, so it is generally preferable.
The circular array is a bounded collection—it has a finite capacity.
If you don’t have an upper limit on the number of objects that your program will collect, you may be better off with a linked list implementation after all.
When you study the API documentation, you will find another set of classes whose name begins with Abstract, such as AbstractQueue.
In the (perhaps unlikely) event that you want to implement your own queue class, you will find it easier to extend AbstractQueue than to implement all the methods of the Queue interface.
The fundamental interface for collection classes in the Java library is the Collection interface.
There are several methods in addition to these two; we will discuss them later.
The add method returns true if adding the element actually changes the collection, and false if the collection is unchanged.
For example, if you try to add an object to a set and the object is already present, the add request has no effect because sets reject duplicates.
The iterator method returns an object that implements the Iterator interface.
You can use the iterator object to visit the elements in the collection one by one.
By repeatedly calling the next method, you can visit the elements from the collection one by one.
Therefore, you need to call the hasNext method before calling next.
That method returns true if the iterator object still has more elements to visit.
If you want to inspect all elements in a collection, request an iterator and then keep calling the next method while hasNext returns true.
As of Java SE 5.0, there is an elegant shortcut for this loop.
The order in which the elements are visited depends on the collection type.
If you iterate over an ArrayList, the iterator starts at index 0 and increments the index in each step.
However, if you visit the elements in a HashSet, you will get them in an essentially random order.
This is usually not a problem because the ordering does not matter for computations such as computing totals or counting matches.
Note Old-timers will notice that the next and hasNext methods of the Iterator interface serve the same purpose as the nextElement and hasMoreElements methods of an Enumeration.
The designers of the Java collections library could have chosen to make use of the Enumeration interface.
But they disliked the cumbersome method names and instead introduced a new interface with shorter method names.
There is an important conceptual difference between iterators in the Java collections library and iterators in other libraries.
In traditional collections libraries, such as the Standard Template Library of C++, iterators are modeled after array indexes.
Given such an iterator, you can look up the element that is stored at that position, much like you can look up an array element a[i] if you have an array index i.
Independently of the lookup, you can advance the iterator to the next position.
This is the same operation as advancing an array index by calling i++, without performing a lookup.
The only way to look up an element is to call next, and that lookup advances the position.
When you call next, the iterator jumps over the next element, and it returns a reference to the element that it just passed (see Figure 13.3)
You can think of Iterator.next as the equivalent of InputStream.read.
Reading a byte from a stream automatically “consumes” the byte.
The next call to read consumes and returns the next byte from the input.
Similarly, repeated calls to next let you read all elements in a collection.
The remove method of the Iterator interface removes the element that was returned by the last call to next.
In many situations, that makes sense—you need to see the element before you can decide that it is the one that should be removed.
But if you want to remove an element in a particular position, you still need to skip past the element.
For example, here is how you remove the first element in a collection of strings:
More importantly, there is a dependency between the calls to the next and remove methods.
It is illegal to call remove if it wasn’t preceded by a call to next.
If you want to remove two adjacent elements, you cannot simply call.
The Collection and Iterator interfaces are generic, which means you can write utility methods that operate on any kind of collection.
For example, here is a generic method that tests whether an arbitrary collection contains a given element:
The designers of the Java library decided that some of these utility methods are so useful that the library should make them available.
That way, library users don’t have to keep reinventing the wheel.
In fact, the Collection interface declares quite a few useful methods that all implementing classes must supply.
Many of these methods are self-explanatory; you will find full documentation in the API notes at the end of this section.
Of course, it is a bother if every class that implements the Collection interface has to supply so many routine methods.
To make life easier for implementors, the library supplies a class AbstractCollection that leaves the fundamental methods size and iterator abstract but implements the routine methods in terms of them.
A concrete collection class can now extend the AbstractCollection class.
It is up to the concrete collection class to supply an iterator method, but the contains method has been taken care of by the AbstractCollection superclass.
However, if the subclass has a more efficient way of implementing contains, it is free to do so.
The users of the collection classes have a richer set of methods available in the generic interface, but the implementors of the actual data structures are not burdened with implementing all the routine methods.
Returns true if the collection changed as a result of this call.
Returns true if the collection changed as a result of this call.
Returns true if the collection changed as a result of this call.
Returns true if the collection changed as a result of this call.
Object[] toArray() returns an array of the objects in the collection.
If arrayToFill has sufficient length, it is filled with the elements of this collection.
Otherwise, a new array with the same component type as arrayToFill and the same length as the size of this collection is allocated and filled.
Before getting into details about all the interfaces, we thought it would be helpful.
Once we have thoroughly described the classes you might want to use, we will return to abstract considerations and see how the collections framework organizes these classes.
Table 13.1 shows the collections in the Java library and briefly describes the purpose of each collection class.
We already used arrays and their dynamic cousin, the ArrayList class, for many.
However, arrays and array lists suffer from a major drawback.
Removing an element from the middle of an array is expensive since all array elements beyond the removed one must be moved toward the beginning of the array (see Figure 13.4)
The same is true for inserting elements in the middle.
Another well-known data structure, the linked list, solves this problem.
Where an array stores object references in consecutive memory locations, a linked list stores each object in a separate link.
Each link also stores a reference to the next link in the sequence.
In the Java programming language, all linked lists are actually doubly linked; that is, each link also stores a reference to its predecessor (see Figure 13.5)
Perhaps you once took a data structures course in which you learned how to implement linked lists.
You may have bad memories of tangling up the links when removing or adding elements in the linked list.
If so, you will be pleased to learn that the Java collections library supplies a class LinkedList ready for you to use.
The following code example adds three elements and then removes the second one:
There is, however, an important difference between linked lists and generic collections.
A linked list is an ordered collection in which the position of the objects matters.
The LinkedList.add method adds the object to the end of the list.
But you will often want to add objects somewhere in the middle of a list.
This positiondependent add method is the responsibility of an iterator, since iterators describe positions in collections.
Using iterators to add elements makes sense only for collections that have a natural ordering.
For example, the set data type that we discuss in the next section does not impose any ordering on its elements.
Therefore, there is no add method in the Iterator interface.
Instead, the collections library supplies a subinterface ListIterator that contains an add method:
Unlike Collection.add, this method does not return a boolean—it is assumed that the add operation always modifies the list.
In addition, the ListIterator interface has two methods that you can use for traversing a list backwards.
Like the next method, the previous method returns the object that it skipped over.
The listIterator method of the LinkedList class returns an iterator object that implements the ListIterator interface.
If you call the add method multiple times, the elements are simply added in the order in which you supplied them.
They are all added in turn before the current iterator position.
When you use the add operation with an iterator that was freshly returned from the listIterator method and that points to the beginning of the linked list, the newly added element becomes the new head of the list.
When the iterator has passed the last element of the list (that is, when hasNext returns false), the added element becomes the new tail of the list.
For example, if a linked list contains three elements, A, B, and C, there are four possible positions (marked as |) for inserting a new element:
The remove operation does not work exactly like the Backspace key.
Immediately after a call to next, the remove method indeed removes the element to the left of the iterator, just like the Backspace key would.
However, if you have just called previous, the element to the right will be removed.
Unlike the add method, which depends only on the iterator position, the remove method depends on the iterator state.
Finally, a set method replaces the last element, returned by a call to next or previous, with a new element.
For example, the following code replaces the first element of a list with a new value:
As you might imagine, if an iterator traverses a collection while another iterator is modifying it, confusing situations can occur.
For example, suppose an iterator points before an element that another iterator has just removed.
The iterator is now invalid and should no longer be used.
The linked list iterators have been designed to detect such modifications.
To avoid concurrent modification exceptions, follow this simple rule: You can attach as many iterators to a collection as you like, provided that all of them are only readers.
Alternatively, you can attach a single iterator that can both read and write.
The collection keeps track of the number of mutating operations (such as adding and removing elements)
Each iterator keeps a separate count of the number of mutating operations that it was responsible for.
At the beginning of each iterator method, the iterator simply checks whether its own mutation count equals that of the collection.
Note There is, however, a curious exception to the detection of concurrent modifications.
The linked list only keeps track of structural modifications to the list, such as adding and removing links.
The set method does not count as a structural modification.
You can attach multiple iterators to a linked list, all of which call set to change the contents of existing links.
This capability is required for a number of algorithms in the Collections class that we discuss later in this chapter.
Now you have seen the fundamental methods of the LinkedList class.
Use a ListIterator to traverse the elements of the linked list in either direction and to add and remove elements.
As you saw in the preceding section, many other useful methods for operating on linked lists are declared in the Collection interface.
These are, for the most part, implemented in the AbstractCollection superclass of the LinkedList class.
Use the contains method to check whether an element is present in a linked list.
The library also supplies a number of methods that are, from a theoretical perspective, somewhat dubious.
For that reason, programmers don’t usually use linked lists in situations where elements need to be accessed by an integer index.
Nevertheless, the LinkedList class supplies a get method that lets you access a particular element:
If you find yourself using it, you are probably using a wrong data structure for your problem.
You should never use this illusory random access method to step through a linked list.
Each time you look up another element, the search starts again from the beginning of the list.
The LinkedList object makes no effort to cache the position information.
Note The get method has one slight optimization: If the index is at least size() / 2, the search for the element starts at the end of the list.
If you have a linked list with only a handful of elements, you don’t have to be overly paranoid about the cost of the get and set methods.
But then, why use a linked list in the first place? The only reason to use a linked list is to minimize the cost of insertion and removal in the middle of the list.
If you have only a few elements, you can just use an ArrayList.
We recommend that you simply stay away from all methods that use an integer index to denote a position in a linked list.
If you want random access into a collection, use an array or ArrayList, not a linked list.
The program in Listing 13.1 puts linked lists to work.
It simply creates two lists, merges them, then removes every second element from the second list, and finally tests the removeAll method.
We recommend that you trace the program flow and pay special attention to the iterators.
You may find it helpful to draw diagrams of the iterator positions, like this:
ListIterator<E> listIterator(int index) returns a list iterator for visiting the elements of the list whose first call to next will return the element with the given index.
In the preceding section, you saw the List interface and the LinkedList class.
The List interface describes an ordered collection in which the position of elements matters.
There are two protocols for visiting the elements: through an iterator and by random access with methods get and set.
The latter is not appropriate for linked lists, but of course get and set make a lot of sense for arrays.
The collections library supplies the familiar ArrayList class that also implements the List interface.
Note If you are a veteran Java programmer, you may have used the Vector class whenever you need a dynamic array.
Why use an ArrayList instead of a Vector? For one simple reason: All methods of the Vector class are synchronized.
It is safe to access a Vector object from two threads.
We recommend that you use an ArrayList instead of a Vector whenever you don’t need synchronization.
Linked lists and arrays let you specify the order in which you want to arrange the.
However, if you are looking for a particular element and don’t remember.
That can be timeconsuming if the collection contains many elements.
If you don’t care about the ordering of the elements, there are data structures that let you find elements much faster.
The drawback is that those data structures give you no control over the order in which the elements appear.
These data structures organize the elements in an order that is convenient for their own purposes.
A well-known data structure for finding objects quickly is the hash table.
A hash table computes an integer, called the hash code, for each object.
A hash code is somehow derived from the instance fields of an object, preferably in such a way that objects with different data yield different codes.
Table 13.2 lists a few examples of hash codes that result from the hashCode method of the String class.
Your implementation needs to be compatible with the equals method: If a.equals(b), then a and b must have the same hash code.
What’s important for now is that hash codes can be computed quickly and that the computation depends only on the state of the object that needs to be hashed, not on the other objects in the hash table.
In Java, hash tables are implemented as arrays of linked lists.
To find the place of an object in the table, compute its hash code and reduce it modulo the total number of buckets.
The resulting number is the index of the bucket that holds the element.
Perhaps you are lucky and there is no other element in that bucket.
Of course, sometimes you will hit a bucket that is already filled.
Then, compare the new object with all objects in that bucket to see if it is already present.
If the hash codes are reasonably randomly distributed and the number of buckets is large enough, only a few comparisons should be necessary.
If you want more control over the performance of the hash table, you can specify the initial bucket count.
The bucket count gives the number of buckets used to collect objects with identical hash values.
If too many elements are inserted into a hash table, the number of collisions increases and retrieval performance suffers.
If you know how many elements, approximately, will eventually be in the table, you can set the bucket count.
Some researchers believe that it is a good idea to make the bucket count a prime number to prevent a clustering of keys.
Any value you supply for the table size is automatically rounded to the next power of 2.)
Of course, you do not always know how many elements you need to store, or your initial guess may be too low.
If the hash table gets too full, it needs to be rehashed.
To rehash the table, a table with more buckets is created, all elements are inserted into the new table, and the original table is discarded.
The load factor determines when a hash table is rehashed.
For most applications, it is reasonable to leave the load factor at 0.75
Hash tables can be used to implement several important data structures.
The add method of a set first tries to find the object to be added, and adds it only if it is not yet present.
The Java collections library supplies a HashSet class that implements a set based.
The contains method is redefined to make a fast lookup to see if an element is already present in the set.
It checks only the elements in one bucket and not all elements in the collection.
Since hashing scatters the elements around in the table, they are visited in a seemingly random order.
You would only use a HashSet if you don’t care about the ordering of the elements in the collection.
The sample program at the end of this section (Listing 13.2) reads words from System.in, adds them to a set, and finally prints out all words in the set.
Alice in Wonderland has 5,909 unique words, including the copyright notice at the beginning.) The words appear in random order.
If the hash code of an element were to change, the element would no longer be in the correct position in the data structure.
HashSet(int initialCapacity) constructs an empty hash set with the specified capacity (number of buckets)
A hash code can be any integer, positive or negative.
The definitions of equals and hashCode must be compatible: If x.equals(y) is true, then x.hashCode() must be the same value as y.hashCode()
The TreeSet class is similar to the hash set, with one added improvement.
When you iterate through the collection, the values are automatically presented in sorted order.
For example, suppose you insert three strings and then visit all elements that you added.
Then, the values are printed in sorted order: Amy Bob Carl.
As the name of the class suggests, the sorting is accomplished by a tree data structure.
For a detailed description of red-black trees see, for example, Introduction to Algorithms by Thomas Cormen, Charles Leiserson,
Therefore, the iterator always visits the elements in sorted order.
Adding an element to a tree is slower than adding it to a hash table, but it is still much faster than adding it into the right place in an array or linked list.
If the tree contains n elements, then an average of log2n comparisons are required to find the correct position for the new element.
How does the TreeSet know how you want the elements sorted? By default, the.
The call a.compareTo(b) must return 0 if a and b are equal, a negative integer if a comes before b in the sort order, and a positive integer if a comes after b.
Its compareTo method compares strings in dictionary order (sometimes called lexicographic order)
If you insert your own objects, you must define a sort order yourself by implementing the Comparable interface.
For example, here is how you can sort Item objects by part number:
If you compare two positive integers, such as part numbers in our example, you can simply return their difference—it will be negative if the first item should come before the second item, zero if the numbers are identical, and positive otherwise.
Caution This trick only works if the integers are from a small enough range.
If x is a large positive integer and y is a large negative integer, then the difference x - y can overflow.
However, using the Comparable interface for defining the sort order has obvious limitations.
In those situations, you tell the tree set to use a different comparison method, by passing a Comparator object into the TreeSet constructor.
The Comparator interface declares a compare method with two explicit parameters:
Just like the compareTo method, the compare method returns a negative integer if a comes before b, zero if they are identical, or a positive integer otherwise.
To sort items by their description, simply define a class that implements the Comparator interface:
If you construct a tree with a comparator, it uses this object whenever it needs.
Note Actually, the Comparator<T> interface is declared to have two methods: compare and equals.
Of course, every class has an equals method; thus, there seems little benefit in adding the method to the interface declaration.
The API documentation explains that you need not override the equals method but that doing so may yield improved performance in some cases.
For example, the addAll method of the TreeSet class can work more effectively if you add elements from another set that uses the same comparator.
If you look back at Table 13.3, you may well wonder if you should always use a tree set instead of a hash set.
After all, adding elements does not seem to take much longer, and the elements are automatically sorted.
The answer depends on the data that you are collecting.
If you don’t need the data sorted, there is no reason to pay for the sorting overhead.
More important, with some data it is much more difficult to come up with a sort order than a hash function.
A hash function only needs to do a reasonably good job of scrambling the objects, whereas a comparison function must tell objects apart with complete precision.
To make this distinction more concrete, consider the task of collecting a set of rectangles.
You can have two different rectangles with different coordinates but the same area.
The sort order for a tree must be a total ordering.
Any two elements must be comparable, and the comparison can only be zero if the elements are equal.
There is such a sort order for rectangles (the lexicographic ordering on its coordinates), but it is unnatural and cumbersome to compute.
In contrast, a hash function is already defined for the Rectangle class.
That interface adds several convenient methods for locating elements and for backward traversal.
The program in Listing 13.3 builds two tree sets of Item objects.
The first one is sorted by part number, the default sort order of Item objects.
The second set is sorted by description, using a custom comparator.
As we already discussed, a queue lets you efficiently add elements at the tail and.
A double-ended queue, or deque, lets you efficiently add or remove elements at the head and tail.
It is implemented by the ArrayDeque and LinkedList classes, both of which provide deques whose size grows as needed.
In Chapter 14, you will see bounded queues and deques.
A priority queue retrieves elements in sorted order after they were inserted in.
That is, whenever you call the remove method, you get the smallest element currently in the priority queue.
However, the priority queue does not sort all its elements.
If you iterate over the elements, they are not necessarily sorted.
The priority queue makes use of an elegant and efficient data structure called a heap.
A heap is a self-organizing binary tree in which the add and remove operations cause the smallest element to gravitate to the root, without wasting time on sorting all elements.
Just like a TreeSet, a priority queue can either hold elements of a class that implements the Comparable interface or a Comparator object you supply in the constructor.
A typical use for a priority queue is job scheduling.
Whenever a new job can be started, the highest priority job is removed from the queue.
Unlike iteration in a TreeSet, the iteration here does not visit the elements in sorted order.
A set is a collection that lets you quickly find an existing element.
That isn’t a very common lookup—usually, you have some key information, and you want to look up the associated element.
You can find a value if you provide the key.
For example, you may store a table of employee records, where the keys are the employee IDs and the values are Employee objects.
The Java library supplies two general-purpose implementations for maps: HashMap.
A hash map hashes the keys, and a tree map uses a total ordering on the keys.
The hash or comparison function is applied only to the keys.
The values associated with the keys are not hashed or compared.
Should you choose a hash map or a tree map? As with sets, hashing is a bit faster, and it is the preferred choice if you don’t need to visit the keys in sorted order.
Whenever you add an object to a map, you must supply a key as well.
In our case, the key is a string, and the corresponding value is an Employee object.
If no information is stored in the map with the particular key specified, get returns null.
If you call the put method twice with the same key, the second value replaces the first one.
In fact, put returns the previous value stored with its key parameter.
The remove method removes an element with a given key from the map.
The size method returns the number of entries in the map.
The collections framework does not consider a map itself as a collection.
Other frameworks for data structures consider a map as a collection of pairs, or as a collection of values indexed by the keys.) However, you can obtain views of the map—objects that implement the Collection interface or one of its subinterfaces.
There are three views: the set of keys, the collection of values (which is not a set), and the set of key/value pairs.
The keys and key/value pairs form a set because there can be only one copy of a key in a map.
The elements of the entry set are objects of the static inner class Map.Entry.)
Note that the keySet is not a HashSet or TreeSet, but an object of some other class that implements the Set interface.
Therefore, you can use a keySet as you would use any collection.
If you invoke the remove method of the iterator, you actually remove the key and its associated value from the map.
However, you cannot add an element to the key set view.
It makes no sense to add a key without also adding a value.
The entry set view has the same restriction, even though it would make conceptual sense to add a new key/value pair.
Then, we remove one key from the map, which removes its associated value as well.
Next, we change the value that is associated with a key and call the get method to look up a value.
If the key is already present, the new object replaces the old one previously associated with the key.
This method returns the old value of the key, or null if the key was not previously present.
You can remove elements from this set and they are removed from the map, but you cannot add any elements.
Set<K> keySet() returns a set view of all keys in the map.
You can remove elements from this set and the keys and associated values are removed from the map, but you cannot add any elements.
Collection<V> values() returns a collection view of all values in the map.
You can remove elements from this set and the removed value and its key are removed from the map, but you cannot add any elements.
The collection class library has several map classes for specialized needs that we.
The WeakHashMap class was designed to solve an interesting problem.
What happens with a value whose key is no longer used anywhere in your program? Suppose the last reference to a key has gone away.
Then, there is no longer any way to refer to the value object.
But, as no part of the program has the key any more, the key/value pair cannot be removed from the map.
As long as the map object is live, all buckets in it are live and won’t be reclaimed.
Thus, your program should take care to remove unused values from long-lived maps.
This data structure cooperates with the garbage collector to remove key/value pairs when the only reference to the key is the one from the hash table entry.
A WeakReference object holds a reference to another object —in our case, a hash table key.
Objects of this type are treated in a special way by the garbage collector.
Normally, if the garbage collector finds that a particular object has no references to it, it simply reclaims the object.
However, if the object is reachable only by a WeakReference, the garbage collector still reclaims the object, but places the weak reference that led to it into a queue.
The operations of the WeakHashMap periodically check that queue for newly arrived weak references.
The arrival of a weak reference in the queue signifies that the key was no longer used by anyone and has been collected.
Java SE 1.4 added classes LinkedHashSet and LinkedHashMap that remember in.
That way, you can avoid the seemingly random order of items in a hash table.
As entries are inserted into the table, they are joined in a doubly linked list (see Figure 13.9)
A linked hash map can alternatively use access order, not insertion order, to iterate through the map entries.
Every time you call get or put, the affected entry is removed from its current position and placed at the end of the linked list of entries.
Only the position in the linked list of entries is affected, not the hash table bucket.
An entry always stays in the bucket that corresponds to the hash code of the key.) To construct such a hash map, call.
For example, you may want to keep frequently accessed entries in memory and read less frequently accessed objects from a database.
When you don’t find an entry in the table, and the table is already pretty full, you can get an iterator into the table and remove the first few elements that it enumerates.
For example, the following cache is kept at a size of at most 100 elements:
Alternatively, you can consider the eldest entry to decide whether to remove it.
For example, you may want to check a time stamp stored with the entry.
The EnumSet is an efficient set implementation with elements that belong to an enumerated type.
Since an enumerated type has a finite number of instances, the EnumSet is internally implemented simply as a sequence of bits.
A bit is turned on if the corresponding value is present in the set.
You can use the usual methods of the Set interface to modify an EnumSet.
An EnumMap is a map with keys that belong to an enumerated type.
You need to specify the key type in the constructor:
In the API documentation for EnumSet, you will see odd-looking type parameters of the form E extends Enum<E>
Java SE 1.4 added another class IdentityHashMap for another quite specialized purpose.
That’s the method that Object.hashCode uses to compute a hash code from the object’s memory address.
Also, for comparison of objects, the IdentityHashMap uses ==, not equals.
In other words, different key objects are considered distinct even if they have equal contents.
This class is useful for implementing object traversal algorithms (such as object serialization), in which you want to keep track of which objects have already been traversed.
The accessOrder parameter is true for access order, false for insertion order.
The eldest parameter is the entry whose removal is being contemplated.
This method is called after an entry has been added to the map.
The default implementation returns false—old elements are not removed by default.
However, you can redefine this method to selectively return true—for example, if the eldest entry fits a certain condition or the map exceeds a certain size.
A framework is a set of classes that form the basis for building advanced.
A framework contains superclasses with useful functionality, policies, and mechanisms.
The user of a framework forms subclasses to extend the functionality without having to reinvent the basic mechanisms.
The Java collections library forms a framework for collection classes.
It defines a number of interfaces and abstract classes for implementors of collections (see Figure 13.10), and it prescribes certain mechanisms, such as the iteration protocol.
You can use the collection classes without having to know much about the framework—we did just that in the preceding sections.
However, if you want to implement generic algorithms that work for multiple collection types, or if you want to add a new collection type, it is helpful to understand the framework.
There are two fundamental interfaces for collections: Collection and Map.
Elements are added into a particular position in the container.
An object can be placed into its position in two ways: by an integer index and by a list iterator.
As already discussed, the List interface provides these random access methods whether or not they are efficient for a particular implementation.
To avoid carrying out costly random access operations, Java SE 1.4 introduced a tagging interface, RandomAccess.
That interface has no methods, but you can use it to test whether a particular collection supports efficient random access:
Note From a theoretical point of view, it would have made sense to have a separate Array interface that extends the List interface and declares the random access methods.
If there were a separate Array interface, then those algorithms that require random access would use Array parameters and you could not accidentally apply them to collections with slow random access.
However, the designers of the collections framework chose not to define a separate interface, because they wanted to keep the number of interfaces in the library small.
Also, they did not want to take a paternalistic attitude toward programmers.
You are free to pass a linked list to algorithms that use random access—you just need to be aware of the performance costs.
The ListIterator interface defines a method for adding an element before the iterator position:
The Set interface is identical to the Collection interface, but the behavior of the.
The equals method of a set should be defined so that two sets are identical if they have the same elements, but not necessarily in the same order.
The hashCode method should be defined so that two sets with the same elements yield the same hash code.
Why make a separate interface if the method signatures are the same? Conceptually, not all collections are sets.
Making a Set interface enables programmers to write methods that accept only sets.
The SortedSet and SortedMap interfaces expose the comparator object used for sorting, and they define methods to obtain views of subsets of the collections.
Finally, Java SE 6 introduced interfaces NavigableSet and NavigableMap that contain additional methods for searching and traversal in sorted sets and maps.
Ideally, these methods should have simply been included in the SortedSet and SortedMap interface.) The TreeSet and TreeMap classes implement these interfaces.
Now, let us turn from the interfaces to the classes that implement them.
We already discussed that the collection interfaces have quite a few methods that can be trivially implemented from more fundamental methods.
If you implement your own collection class, then you probably want to extend one of these classes so that you can pick up the implementations of the routine operations.
Finally, a number of “legacy” container classes have been present since the first release of Java, before there was a collections framework:
By using views, you can obtain other objects that implement the Collection or Map interfaces.
You saw one example of this with the keySet method of the map classes.
At first glance, it appears as if the method creates a new set, fills it with all the keys of the map, and returns it.
Instead, the keySet method returns an object of a class that implements the Set interface and whose methods manipulate the original map.
The technique of views has a number of useful applications in the collections framework.
The static asList method of the Arrays class returns a List wrapper around a plain Java array.
This method lets you pass the array to a method that expects a.
It is a view object with get and set methods that access the underlying array.
As of Java SE 5.0, the asList method is declared to have a variable number of arguments.
Instead of passing an array, you can also pass individual elements.
For example, the following call creates a List containing 100 strings, all set to.
There is very little storage cost—the object is stored only once.
Note The Collections class contains a number of utility methods with parameters or return values that are collections.
The returned object implements an immutable single-element set without the overhead of data structure.
You can form subrange views for a number of collections.
Use the subList method to obtain a view into the subrange of the list:
You can apply any operations to the subrange, and they automatically reflect the.
The elements get automatically cleared from the staff list, and group2 becomes empty.
For sorted sets and maps, you use the sort order, not the element position, to form subranges.
These return the subsets of all elements that are larger than or equal to from and strictly smaller than to.
The NavigableSet interface that was introduced in Java SE 6 gives more control over these subrange operations.
The Collections class has methods that produce unmodifiable views of collections.
These views add a runtime check to an existing collection.
If an attempt to modify the collection is detected, an exception is thrown and the collection remains untouched.
For example, suppose you want to let some part of your code look at, but not touch, the contents of a collection.
Of course, the lookAt method can call all methods of the List interface, not just the accessors.
The unmodifiable view does not make the collection itself immutable.
And you can still call mutator methods on the elements of the collection.
The views wrap the interface and not the actual collection object, so you only have access to those methods that are defined in the interface.
For example, the LinkedList class has convenience methods, addFirst and addLast, that are not part of the List interface.
Instead, it inherits the equals method of the Object class, which just tests whether the objects are identical.
If you turn a set or list into just a collection, you can no longer test for equal contents.
The view acts in this way because equality testing is not well-defined at this level of the hierarchy.
The views treat the hashCode method in the same way.
However, the unmodifiableSet and unmodifiableList methods use the equals and hashCode methods of the underlying collections.
If you access a collection from multiple threads, you need to ensure that the collection is not accidentally damaged.
For example, it would be disastrous if one thread tried to add to a hash table while another thread was rehashing the elements.
Instead of implementing thread-safe collection classes, the library designers used the view mechanism to make regular collections thread-safe.
For example, the static synchronizedMap method in the Collections class can turn any map into a Map with synchronized access methods:
You can now access the map object from multiple threads.
The methods such as get and put are serialized—each method call must be finished completely before another thread can call another method.
We discuss the issue of synchronized access to data structures in greater detail in Chapter 14
Instead, a class cast exception will happen later when another part of the code calls get and casts the result to a String.
The view’s add method checks that the inserted object belongs to the given class and immediately throws a ClassCastException if it does not.
The advantage is that the error is reported at the correct location:
Caution The checked views are limited by the runtime checks that the virtual machine can carry out.
A view usually has some restriction—it may be read-only, it may not be able to change the size, or it may support removal but not insertion (as is the case for the key view of a map)
After all, isn’t the purpose of an interface to lay out the methods that a class must implement? Indeed, this arrangement is unsatisfactory from a theoretical perspective.
A better solution might have been to design separate interfaces for read-only views and views that can’t change the size of a collection.
However, that would have tripled the number of interfaces, which the designers of the library found unacceptable.
Even though collections are used frequently, the coding style for implementing them is not typical for other problem domains.
The designers of a collection class library have to resolve a particularly brutal set of conflicting requirements.
Users want the library to be easy to learn, convenient to use, completely generic, idiot-proof, and at the same time as efficient as hand-coded.
It is plainly impossible to achieve all these goals simultaneously, or even to come close.
But in your own programming problems, you will rarely encounter such an extreme set of constraints.
You should be able to find solutions that do not rely on the extreme measure of “optional” interface operations.
The boolean flags determine whether the bounds are included in the view.
So far, most of our examples used an iterator to traverse a collection one.
However, you can often avoid iteration by using one of the bulk operations in the library.
Suppose you want to find the intersection of two sets—the elements that two sets have in common.
You can carry this idea further and apply a bulk operation to a view.
Since the key set is a view into the map, the keys and associated employee names are automatically removed from the map.
By using a subrange view, you can restrict bulk operations to sublists and subsets.
For example, suppose you want to add the first ten elements of a list to another container.
Large portions of the Java platform API were designed before the collections framework was created.
As a result, you will occasionally need to translate between traditional arrays and the more modern collections.
If you have an array that you need to turn into a collection, the Arrays.asList wrapper serves this purpose.
Obtaining an array from a collection is a bit trickier.
Even if you know that your collection contained objects of a specific type, you cannot use a cast:
Instead, use a variant of the toArray method and give it an array of length 0 of the type that you’d like.
The returned array is then created as the same array type:
Note You may wonder why you can’t simply pass a Class object (such as String.class) to the toArray method.
Generic collection interfaces have a great advantage—you only need to.
For example, consider a simple algorithm to compute the maximum element in a collection.
Traditionally, programmers would implement such an algorithm as a loop.
Here is how you can find the largest element of an array.
Of course, to find the maximum of an array list, you would write the code slightly differently.
What about a linked list? You don’t have efficient random access in a linked list, but you can use an iterator.
Think of the minimal collection interface that you need to efficiently carry out the algorithm.
Random access with get and set comes higher in the food chain than simple iteration.
As you have seen in the computation of the maximum element in a linked list, random access is not required for this task.
Computing the maximum can be done simply by iterating through the elements.
Therefore, you can implement the max method to take any object that implements the Collection interface.
Now you can compute the maximum of a linked list, an array list, or an array, with a single method.
In fact, the standard C++ library has dozens of useful algorithms, each operating on a generic collection.
The Java library is not quite so rich, but it does contain the basics: sorting, binary search, and some utility algorithms.
Computer old-timers will sometimes reminisce about how they had to use.
Nowadays, of course, sorting algorithms are part of the standard library for most programming languages, and the Java programming language is no exception.
The sort method in the Collections class sorts a collection that implements the List interface.
This method assumes that the list elements implement the Comparable interface.
If you want to sort the list in some other way, you can pass a Comparator object as a second parameter.
You may wonder how the sort method sorts a list.
However, the implementation in the Java programming language does not do that.
It simply dumps all elements into an array, sorts the array by using a different variant of merge sort, and then copies the sorted sequence back into the list.
The merge sort algorithm used in the collections library is a bit slower than QuickSort, the traditional choice for a general-purpose sorting algorithm.
However, it has one major advantage: It is stable, that is, it doesn’t switch equal elements.
Why do you care about the order of equal elements? Here is a common scenario.
Suppose you have an employee list that you already sorted by name.
What happens to employees with equal salary? With a stable sort, the ordering by name is preserved.
In other words, the outcome is a list that is sorted first by salary, then by name.
Collections need not implement all of their “optional” methods, so all methods that receive collection parameters must describe when it is safe to pass a collection to an algorithm.
For example, you clearly cannot pass an unmodifiableList list to the sort algorithm.
What kind of list can you pass? According to the documentation, the list must be modifiable but need not be resizable.
The terms are defined as follows: • A list is modifiable if it supports the set method.
A list is resizable if it supports the add and remove operations.
The Collections class has an algorithm shuffle that does the opposite of sorting —it randomly permutes the order of the elements in a list.
If you supply a list that does not implement the RandomAccess interface, the shuffle method copies the elements into an array, shuffles the array, and copies the shuffled elements back into the list.
It then randomly shuffles the list and selects the first 6 values from the shuffled list.
The algorithm is guaranteed to run in O(n log n) time, where n is the length of the list.
This algorithm runs in O(n a(n)) time, where n is the length of the list and a(n) is the average time to access an element.
To find an object in an array, you normally visit all elements until you find a.
However, if the array is sorted, you can look at the middle element and check whether it is larger than the element that you are trying to find.
If so, keep looking in the first half of the array; otherwise, look in the second half.
That cuts the problem in half, and you keep going in the same way.
Note that the collection must already be sorted, or the algorithm will return the wrong answer.
To find an element, supply the collection (which must implement the List interface—more on that in the note below) and the element to be located.
If the collection is not sorted by the compareTo element of the Comparable interface, supply a comparator object as well.
A non-negative return value from the binarySearch method denotes the index of the matching object.
That is, c.get(i) is equal to element under the comparison order.
If the value is negative, then there is no matching element.
However, you can use the return value to compute the location where you should insert element into the collection to keep it sorted.
Therefore, the binarySearch algorithm reverts to a linear search if you give it a linked list.
Now the binarySearch method checks whether the list parameter implements the.
If it does, the method carries out a binary search; otherwise, it uses a linear search.
The methods are guaranteed to run in O(a(n) log n) time, where n is the length of the list and a(n) is the average time to access an element.
The methods return either the index of the key in the list, or a negative value i if the key is not present in the list.
In that case, the key should be inserted at index -i - 1 for the list to stay sorted.
Others include copying elements from one list to another, filling a container with a constant value, and reversing a list.
Why supply such simple algorithms in the standard library? Surely most programmers could easily implement them with simple loops.
We like the algorithms because they make life easier for the programmer reading the code.
When you read a loop that was implemented by someone else, you have to decipher the original programmer’s intentions.
When you see a call to a method such as Collections.max, you know right away what the code does.
The following API notes describe the simple algorithms in the Collections class.
The target list must be at least as long as the source list.
This method runs in O(n) time, where n is the length of the list.
This method runs in O(n) time, where n is the length of the list.
If you write your own algorithm (or, in fact, any method that has a collection as.
For example, suppose you want to fill a JMenu with a set of menu items.
Traditionally, such a method might have been implemented like this:
However, you now constrained the caller of your method—the caller must supply.
If the choices happen to be in another container, they first need to be repackaged.
It is much better to accept a more general collection.
You should ask yourself this: What is the most general collection interface that can do the job? In this case, you just need to visit all elements, a capability of the basic Collection interface.
Here is how you can rewrite the fillMenu method to accept collections of any kind:
Now, anyone can call this method with an ArrayList or a LinkedList, or even with an array wrapped with the Arrays.asList wrapper.
Note If it is such a good idea to use collection interfaces as method parameters, why doesn’t the Java library follow this rule more often? For example, the JComboBox class has two constructors:
If you write a method that returns a collection, you may also want to return an interface instead of a class because you can then change your mind and reimplement the method later with a different collection.
Later, you can decide that you don’t want to copy the items but simply provide a view into them.
You can achieve this by returning an anonymous subclass of AbstractList.
If you employ it, be careful to document exactly which “optional” operations are supported.
In this case, you must advise the caller that the returned object is an unmodifiable list.
In this section, we discuss the collection classes that existed in the Java.
The classic Hashtable class serves the same purpose as the HashMap and has essentially the same interface.
Just like methods of the Vector class, the Hashtable methods are synchronized.
If you do not require synchronization or compatibility with legacy code, you should use the HashMap instead.
Note The name of the class is Hashtable, with a lowercase t.
Under Windows, you’ll get strange error messages if you use HashTable, because the Windows file system is not case-sensitive but the Java compiler is.
The legacy collections use the Enumeration interface for traversing sequences of.
These are entirely analogous to the hasNext and next methods of the Iterator interface.
For example, the elements method of the Hashtable class yields an object for enumerating the values in the table:
You will occasionally encounter a legacy method that expects an enumeration parameter.
Note In C++, it is quite common to use iterators as parameters.
Fortunately, on the Java platform, very few programmers use this idiom.
It is much smarter to pass around the collection than to pass an iterator.
The recipients can always obtain the iterator from the collection when they need to do so, plus they have all the collection methods at their disposal.
However, you will find enumerations in some legacy code because they were the only available mechanism for generic collections until the collections framework appeared in Java SE 1.2
Enumeration<V> elements() returns an enumeration object that traverses the elements of the hash table.
A property map is a map structure of a very special type.
The table can be saved to a file and loaded from a file.
The Java platform class that implements a property map is called Properties.
Property maps are commonly used in specifying configuration options for.
String getProperty(String key) gets a property association; returns the string associated with the key, or the string associated with the key in the default table if it wasn’t present in the map.
String getProperty(String key, String defaultValue) gets a property with a default value if the key is not found; returns the string associated with the key, or the default string if it wasn’t present in the map.
Since version 1.0, the standard library had a Stack class with the familiar push.
However, the Stack class extends the Vector class, which is not satisfactory from a theoretical perspective—you can apply such un-stack-like operations as insert and remove to insert and remove values anywhere, not just at the top of the stack.
The Java platform BitSet class stores a sequence of bits.
A bit set packs the bits into bytes, so it is far more efficient to use a bit set than an ArrayList of Boolean objects.
The BitSet class gives you a convenient interface for reading, setting, and resetting individual bits.
Using this interface avoids the masking and other bitfiddling operations that are necessary if you store bits in int or long variables.
It isn’t a good benchmark either, because it mainly tests bit operations.)
Oh well, we bow to tradition and present an implementation.
There are 148,933 primes in this interval, so you probably don’t want to print them all out.)
Without going into too many details of this program, the idea is to march through a bit set with 2 million bits.
After that, we turn off the bits that are multiples of numbers known to be prime.
The positions of the bits that remain after this process are themselves prime numbers.
Note Even though the sieve isn’t a good benchmark, we couldn’t resist timing the two implementations of the algorithm.
Java could only match that if the program ran long enough to trigger the Hotspot just-in-time compiler.
As you have seen, the Java library offers a wide variety of collection classes for your programming needs.
In the final chapter of this book, we will cover the important topic of concurrent programming.
You are probably familiar with multitasking—your operating system’s ability to have more than one program working at what seems like the same time.
For example, you can print while editing or downloading your email.
Nowadays, you are likely to have a computer with more than one CPU, but the number of concurrently executing processes is not limited by the number of CPUs.
The operating system assigns CPU time slices to each process, giving the impression of parallel activity.
Multithreaded programs extend the idea of multitasking by taking it one level lower: Individual programs will appear to do multiple tasks at the same time.
Each task is usually called a thread, which is short for thread of control.
Programs that can run more than one thread at once are said to be multithreaded.
So, what is the difference between multiple processes and multiple threads? The essential difference is that while each process has a complete set of its own variables, threads share the same data.
This sounds somewhat risky, and indeed it can be, as you will see later in this chapter.
However, shared variables make communication between threads more efficient and easier to program than interprocess communication.
A web server needs to be able to serve concurrent requests.
Graphical user interface (GUI) programs have a separate thread for gathering user interface events from the host operating environment.
This chapter shows you how to add multithreading capability to your Java applications.
In this chapter, we cover all the tools that an application programmer is likely to need.
However, for more intricate system-level programming, we suggest that you turn to a more advanced reference, such as Java Concurrency in Practice by Brian Goetz et al.
What Are Threads? Let us start by looking at a program that does not use multiple threads and.
After we dissect it, we will show you how easy it is to have this program run separate threads.
This program animates a bouncing ball by continually moving the ball, finding out if it bounces against a wall, and then redrawing it.
As soon as you click the Start button, the program launches a ball from the upper left corner of the screen and the ball begins bouncing.
The handler of the Start button calls the addBall method.
Each call to move moves the ball by a small amount, adjusts the direction if it bounces against a wall, and redraws the panel.
The call to Thread.sleep does not create a new thread—sleep is a static method of the Thread class that temporarily stops the activity of the current thread for the given number of milliseconds.
For now, we simply terminate the bouncing if this exception occurs.
If you run the program, the ball bounces around nicely, but it completely takes over the application.
If you become tired of the bouncing ball before it has finished its 1,000 moves and click the Close button, the ball continues bouncing anyway.
You cannot interact with the program until the ball has finished bouncing.
Note If you carefully look over the code at the end of this section, you will notice the call.
That is pretty strange—normally, you’d call repaint and let the AWT worry about getting the graphics context and doing the painting.
But if you try to call comp.repaint() in this program, you’ll find that the panel is only repainted after the addBall method has returned.
Also note that the ball component extends JPanel; this makes it easier to erase the background.
In the next program, in which we use a separate thread to compute the ball position, we can go back to the familiar use of repaint and JComponent.
You would not want the programs you use to behave in this way when you ask them to do a timeconsuming job.
After all, when you are reading data over a network connection, it is all too common to be stuck in a task that you would really like to interrupt.
For example, suppose you download a large image and decide, after seeing a piece of it, that you do not need or want to see the rest; you certainly would like to be able to click a Stop or Back button to interrupt the loading process.
In the next section, we will show you how to keep the user in control by running crucial.
We will make our bouncing ball program more responsive by running the code.
In fact, you will be able to launch multiple balls, each moved by its own thread.
In addition, the AWT event dispatch thread will continue running in parallel, taking care of user interface events.
Since each thread gets a chance to run, the event dispatch thread has the opportunity to notice that the user clicks the Close button while the balls are bouncing.
We use ball-bouncing code as an example to give you a visual impression of the need for concurrency.
In general, you need to be wary of any long-running computation.
Your computation is likely to be a part of some bigger framework, such as a GUI or web framework.
Whenever the framework calls one of your methods, there is usually an expectation of a quick return.
If you need to do any task that takes a long time, you should use a separate thread.
Here is a simple procedure for running a task in a separate thread: 1
Place the code for the task into the run method of a class that implements the Runnable interface.
To make our bouncing ball program into a separate thread, we need only to implement a class BallRunnable and place the code for the animation inside the run method:
Typically, interruption is used to request that a thread terminates.
Whenever the Start button is clicked, the addBall method launches a new thread (see Figure 14.2):
That’s all there is to it! You now know how to run tasks in parallel.
The remainder of this chapter tells you how to control the interaction between threads.
Note You can also define a thread by forming a subclass of the Thread class, like this:
Then you construct an object of the subclass and call its start method.
You should decouple the task that is to be run in parallel from the mechanism of running it.
If you have many tasks, it is too expensive to create a separate thread for each one of them.
Caution Do not call the run method of the Thread class or the Runnable object.
Calling the run method directly merely executes the task in the same thread—no new thread is started.
It will create a new thread that executes the run method.
A thread terminates when its run method returns—by executing a return.
In the initial release of Java, there also was a stop method that another thread could call to terminate a thread.
There is a way to force a thread to terminate.
However, the interrupt method can be used to request termination of a thread.
When the interrupt method is called on a thread, the interrupted status of the thread is set.
This is a boolean flag that is present in every thread.
Each thread should occasionally check whether it has been interrupted.
However, if a thread is blocked, it cannot check the interrupted status.
There are blocking I/O calls that cannot be interrupted; you should consider interruptible alternatives.
There is no language requirement that a thread which is interrupted should terminate.
The interrupted thread can decide how to react to the interruption.
Some threads are so important that they should handle the exception and continue.
But quite commonly, a thread will simply want to interpret an interruption as a request for termination.
The run method of such a thread has the following form:
The isInterrupted check is neither necessary nor useful if you call the sleep method (or another interruptible method) after every work iteration.
If you call the sleep method when the interrupted status is set, it doesn’t sleep.
Therefore, if your loop calls sleep, don’t check the interrupted status.
Note There are two very similar methods, interrupted and isInterrupted.
The interrupted method is a static method that checks whether the current thread has been interrupted.
Furthermore, calling the interrupted method clears the interrupted status of the thread.
On the other hand, the isInterrupted method is an instance method that you can use to check whether any thread has been interrupted.
Don’t do that! If you can’t think of anything good to do in the catch clause, you still have two reasonable choices:
Then the caller (or, ultimately, the run method) can catch it.
The interrupted status of the thread is set to true.
The call has a side effect—it resets the interrupted status of the current thread to false.
Unlike the static interrupted method, this call does not change the interrupted status of the thread.
Each of these states is explained in the sections that follow.
To determine the current state of a thread, simply call the getState method.
When a thread is in the new state, the program has not started executing code inside of it.
A certain amount of bookkeeping needs to be done before a thread can run.
Once you invoke the start method, the thread is in the runnable state.
It is up to the operating system to give the thread time to run.
The Java specification does not call this a separate state, though.
Once a thread is running, it doesn’t necessarily keep running.
In fact, it is desirable that running threads occasionally pause so that other threads have a chance to run.
The details of thread scheduling depend on the services that the operating system provides.
Preemptive scheduling systems give each runnable thread a slice of time to perform its task.
When that slice of time is exhausted, the operating system preempts the thread and gives another thread an opportunity to work (see Figure 14.4 on p.
All modern desktop and server operating systems use preemptive scheduling.
However, small devices such as cell phones may use cooperative scheduling.
In such a device, a thread loses control only when it calls the yield method, or it is blocked or waiting.
On a machine with multiple processors, each processor can run a thread, and you can have multiple threads run in parallel.
Of course, if there are more threads than processors, the scheduler still has to do time-slicing.
Always keep in mind that a runnable thread may or may not be running at any given time.
When a thread is blocked or waiting, it is temporarily inactive.
It is up to the thread scheduler to reactivate it.
The details depend on how the inactive state was reached.
When the thread waits for another thread to notify the scheduler of a condition, it enters the waiting state.
In practice, the difference between the blocked and waiting state is not significant.
Calling them causes the thread to enter the timed waiting state.
This state persists either until the timeout expires or the appropriate notification has been received.
Methods with timeout include Thread.sleep and the timed versions of Object.wait, Thread.join, Lock.tryLock, and Condition.await.
Figure 14.3 shows the states that a thread can have and the possible transitions from one state to another.
When a thread is blocked or waiting (or, of course, when it terminates), another thread will be scheduled to run.
When a thread is reactivated (for example, because its timeout has expired or it has succeeded in acquiring a lock), the scheduler checks to see if it has a higher priority than the currently running threads.
If so, it preempts one of the current threads and picks a new thread to run.
It dies a natural death because the run method exits normally.
It dies abruptly because an uncaught exception terminates the run method.
In particular, you can kill a thread by invoking its stop method.
That method throws a ThreadDeath error object that kills the thread.
However, the stop method is deprecated, and you should never call it in your own code.
This method is only valid after suspend() has been invoked.
In the following sections, we discuss miscellaneous properties of threads:
In the Java programming language, every thread has a priority.
You can increase or decrease the priority of any thread with the setPriority method.
Whenever the thread scheduler has a chance to pick a new thread, it prefers threads with higher priority.
When the virtual machine relies on the thread implementation of the host platform, the Java thread priorities are mapped to the priority levels of the host platform, which may have more or fewer thread priority levels.
Some of the Java priorities will map to the same operating system level.
In the Oracle JVM for Linux, thread priorities are ignored altogether—all threads have the same priority.
Caution If you do use priorities, you should be aware of a common beginner’s error.
If you have several threads with a high priority that don’t become inactive, the lower-priority threads may never execute.
Whenever the scheduler decides to run a new thread, it will choose among the highest-priority threads first, even though that may starve the lowerpriority threads completely.
If there are other runnable threads with a priority at least as high as the priority of this thread, they will be scheduled next.
You can turn a thread into a daemon thread by calling.
There is no point in keeping the program running if all remaining threads are daemons.
Daemon threads are sometimes mistakenly used by beginners who don’t want to think about shutdown actions.
A daemon thread should never access a persistent resource such as a file or database since it can terminate at any time, even in the middle of an operation.
This method must be called before the thread is started.
The run method of a thread cannot throw any checked exceptions, but it can.
However, there is no catch clause to which the exception can be propagated.
Instead, just before the thread dies, the exception is passed to a handler for uncaught exceptions.
A replacement handler might use the logging API to send reports of uncaught exceptions into a log file.
If you don’t install a default handler, the default handler is null.
However, if you don’t install a handler for an individual thread, the handler is the thread’s ThreadGroup object.
Note A thread group is a collection of threads that can be managed together.
By default, all threads that you create belong to the same thread group, but it is possible to establish other groupings.
Since there are now better features for operating on collections of threads, we recommend that you do not use thread groups in your programs.
Otherwise, if the Throwable is an instance of ThreadDeath, nothing happens.
Otherwise, the name of the thread and the stack trace of the Throwable are printed on System.err.
That is the stack trace that you have undoubtedly seen many times in your programs.
If no handler is installed, the thread group object is the handler.
However, if e is a ThreadDeath object, the stack trace is suppressed.
In most practical multithreaded applications, two or more threads need to.
What happens if two threads have access to the same object and each calls a method that modifies the state of the object? As you might imagine, the threads can step on each other’s toes.
Depending on the order in which the data were accessed, corrupted objects can result.
To avoid corruption of shared data by multiple threads, you must learn how to.
In this section, you’ll see what happens if you do not use synchronization.
In the next section, you’ll see how to synchronize data access.
In the next test program, we simulate a bank with a number of accounts.
We randomly generate transactions that move money between these accounts.
Each transaction moves a random amount of money from the account serviced by the thread to another random account.
This method transfers some amount of money from one account to another.
We don’t yet worry about negative account balances.) Here is the code for the transfer method of the Bank class.
Its run method keeps moving money out of a fixed bank account.
In each iteration, the run method picks a random target account and a random amount, calls transfer on the bank object, and then sleeps.
But we do know that the total amount of money in all the accounts should remain unchanged because all we do is move money from one account to another.
At the end of each transaction, the transfer method recomputes the total and prints it.
When you run this program, errors may happen quickly, or it may take a very long time for the balance to become corrupted.
This situation does not inspire confidence, and you would probably not want to deposit your hard-earned money in this bank.
See if you can spot the problems with the code.
In the previous section, we ran a program in which several threads updated.
After a while, errors crept in and some amount of money was either lost or spontaneously created.
This problem occurs when two threads are simultaneously trying to update an account.
Suppose the second thread awakens and updates the same entry in the account array.
Then, the first thread awakens and completes its Step 3
That action wipes out the modification of the other thread.
Of course, there is a slight chance of false alarms if the thread is interrupted as it is performing the tests!)
Note You can actually peek at the virtual machine bytecodes that execute each statement in our class.
The point is that the increment command is made up of several instructions, and the thread executing them can be interrupted at any instruction.
What is the chance of this corruption occurring? We boosted the chance of observing the problem by interleaving the print statements with the statements that update the balance.
If you omit the print statements, the risk of corruption is quite a bit lower because each thread does so little work before going to sleep again, and it is unlikely that the scheduler will preempt it in the middle of the computation.
However, the risk of corruption does not go away completely.
If you run lots of threads on a heavily loaded machine, the program will still fail even after you have eliminated the print statements.
The failure may take a few minutes or hours or days to occur.
Frankly, there are few things worse in the life of a programmer than an error that only manifests itself once every few days.
The real problem is that the work of the transfer method can be interrupted in the middle.
If we could ensure that the method runs to completion before the thread loses control, the state of the bank account object would never be corrupted.
There are two mechanisms for protecting a code block from concurrent access.
The Java language provides a synchronized keyword for this purpose, and Java SE 5.0 introduced the ReentrantLock class.
The synchronized keyword automatically provides a lock as well as an associated “condition,” which makes it powerful and convenient for most cases that require explicit locking.
However, we believe that it is easier to understand the synchronized keyword after you have seen locks and conditions in isolation.
This construct guarantees that only one thread at a time can enter the critical section.
As soon as one thread locks the lock object, no other thread can get past the lock statement.
When other threads call lock, they are deactivated until the first thread unlocks the lock object.
Caution It is critically important that the unlock operation is enclosed in a finally clause.
If the code in the critical section throws an exception, the lock must be unlocked.
Note When you use locks, you cannot use the try-with-resources statement.
But even if it was renamed, the try-with-resources statement wouldn’t work.
But when you use a lock, you want to keep using the same variable that is shared among threads.
Suppose one thread calls transfer and gets preempted before it is done.
It is deactivated and must wait for the first thread to finish executing the transfer method.
When the first thread unlocks the lock, then the second thread can proceed (see Figure 14.5)
Add the locking code to the transfer method and run the program again.
You can run it forever, and the bank balance will not become corrupted.
Note that each Bank object has its own ReentrantLock object.
If two threads try to access the same Bank object, then the lock serves to serialize the access.
However, if two threads access different Bank objects, each thread acquires a different lock and neither thread is blocked.
This is as it should be, because the threads cannot interfere with one another when they manipulate different Bank instances.
The lock is called reentrant because a thread can repeatedly acquire a lock.
The lock has a hold count that keeps track of the nested calls to the lock method.
The thread has to call unlock for every call to lock in order to relinquish the lock.
Because of this feature, code protected by a lock can call another method that uses the same locks.
For example, the transfer method calls the getTotalBalance method, which also locks the bankLock object, which now has a hold count of 2
When the getTotalBalance method exits, the hold count is back to 1
When the transfer method exits, the hold count is 0, and the thread relinquishes the lock.
In general, you will want to protect blocks of code that update or inspect a shared object, so you can be assured that these operations run to completion before another thread can use the same object.
Caution Be careful to ensure that the code in a critical section is not bypassed by throwing of an exception.
If an exception is thrown before the end of the section, the finally clause will relinquish the lock, but the object may be in a damaged state.
A fair lock favors the thread that has been waiting for the longest time.
However, this fairness guarantee can be a significant drag on performance.
Therefore, by default, locks are not required to be fair.
It sounds nice to be fair, but fair locks are a lot slower than regular locks.
You should only enable fair locking if you truly know what you are doing and have a specific reason to consider fairness essential for your program.
Even if you use a fair lock, you have no guarantee that the thread scheduler is fair.
If the thread scheduler chooses to neglect a thread that has been waiting a long time for the lock, it doesn’t get the chance to be treated fairly by the lock.
Often, a thread enters a critical section only to discover that it can’t proceed.
Use a condition object to manage threads that have acquired a lock but cannot do useful work.
In this section, we introduce the implementation of condition objects in the Java library.
For historical reasons, condition objects are often called condition variables.)
We do not want to transfer money out of an account that does not have the funds to cover the transfer.
It is entirely possible that the current thread will be deactivated between the successful outcome of the test and the call to transfer.
By the time the thread is running again, the account balance may have fallen below the withdrawal amount.
You must make sure that no other thread can modify the balance between the test and the transfer action.
You do so by protecting both the test and the transfer action with a lock:
Now, what do we do when there is not enough money in the account? We wait until some other thread has added funds.
A lock object can have one or more associated condition objects.
It is customary to give each condition object a name that evokes the condition that it represents.
The current thread is now deactivated and gives up the lock.
This lets in another thread that can, we hope, increase the account balance.
There is an essential difference between a thread that is waiting to acquire a lock and a thread that has called await.
Once a thread calls the await method, it enters a wait set for that condition.
The thread is not made runnable when the lock is available.
Instead, it stays deactivated until another thread has called the signalAll method on the same condition.
When the threads are removed from the wait set, they are again runnable and the scheduler will eventually activate them again.
At that time, they will attempt to reenter the object.
As soon as the lock is available, one of them will acquire the lock and continue where it left off, returning from the call to await.
At this time, the thread should test the condition again.
There is no guarantee that the condition is now fulfilled—the signalAll method merely signals to the waiting threads that it may be fulfilled at this time and that it is worth checking for the condition again.
Note In general, a call to await should be inside a loop of the form.
It is crucially important that some other thread calls the signalAll method eventually.
When a thread calls await, it has no way of reactivating itself.
If none of them bother to reactivate the waiting thread, it will never run again.
If all other threads are blocked and the last active thread calls await without unblocking one of the others, it also blocks.
No thread is left to unblock the others, and the program hangs.
When should you call signalAll? The rule of thumb is to call signalAll whenever the state of an object changes in a way that might be advantageous to waiting threads.
For example, whenever an account balance changes, the waiting threads should be given another chance to inspect the balance.
In our example, we call signalAll when we have finished the funds transfer.
Note that the call to signalAll does not immediately activate a waiting thread.
It only unblocks the waiting threads so that they can compete for entry into the object after the current thread has exited the synchronized method.
Another method, signal, unblocks only a single thread from the wait set, chosen at random.
That is more efficient than unblocking all threads, but there is a danger.
If the randomly chosen thread finds that it still cannot proceed, it becomes blocked again.
If no other thread calls signal again, then the system deadlocks.
Caution A thread can only call await, signalAll, or signal on a condition if it owns the lock of the condition.
If you run the sample program in Listing 14.8, you will notice that nothing ever goes wrong.
In the preceding sections, you saw how to use Lock and Condition objects.
Before going any further, let us summarize the key points about locks and conditions:
A lock protects sections of code, allowing only one thread to execute the.
A lock manages threads that are trying to enter a protected code segment.
A lock can have one or more associated condition objects.
Each condition object manages threads that have entered a protected code section but that cannot proceed.
The Lock and Condition interfaces give programmers a high degree of control over locking.
However, in most situations, you don’t need that control—you can use a mechanism that is built into the Java language.
Ever since version 1.0, every object in Java has an intrinsic lock.
If a method is declared with the synchronized keyword, the object’s lock protects the entire method.
That is, to call the method, a thread must acquire the intrinsic object lock.
For example, instead of using an explicit lock, we can simply declare the transfer method of the Bank class as synchronized.
The wait method adds a thread to the wait set, and the notifyAll/notify methods unblock waiting threads.
In other words, calling wait or notifyAll is the equivalent of.
Note The wait, notifyAll, and notify methods are final methods of the Object class.
The Condition methods had to be named await, signalAll, and signal so that they don’t conflict with those methods.
As you can see, using the synchronized keyword yields code that is much more concise.
Of course, to understand this code, you have to know that each object has an intrinsic lock, and that the lock has an intrinsic condition.
The lock manages the threads that try to enter a synchronized method.
It is also legal to declare static methods as synchronized.
If such a method is called, it acquires the intrinsic lock of the associated class object.
For example, if the Bank class has a static synchronized method, then the lock of the Bank.class object is locked when it is called.
As a result, no other thread can call this or any other synchronized static method of the same class.
Among them: • You cannot interrupt a thread that is trying to acquire a lock.
You cannot specify a timeout when trying to acquire a lock.
It is best to use neither Lock/Condition nor the synchronized keyword.
If the synchronized keyword works for your situation, by all means, use it.
You’ll write less code and have less room for error.
Use Lock/Condition if you really need the additional power that these constructs give you.
This method can only be called from within a synchronized method or block.
This method can only be called from within a synchronized method or block.
This method can only be called from within a synchronized method.
These methods can only be called from within a synchronized method.
As we just discussed, every Java object has a lock.
There is a second mechanism for acquiring the lock: by entering a synchronized block.
Here, the lock object is created only to use the lock that every Java object possesses.
Sometimes, programmers use the lock of an object to implement additional atomic operations—a practice known as client-side locking.
Consider, for example, the Vector class, which is a list whose methods are synchronized.
Now suppose we stored our bank balances in a Vector<Double>
The get and set methods of the Vector class are synchronized, but that doesn’t help us.
It is entirely possible for a thread to be preempted in the transfer method after the first call to get has been completed.
Another thread may then store a different value into the same position.
This approach works, but it is entirely dependent on the fact that the Vector class uses the intrinsic lock for all of its mutator methods.
You have to carefully study the source code and hope that future versions do not introduce unsynchronized mutators.
As you can see, client-side locking is very fragile and not generally recommended.
Locks and conditions are powerful tools for thread synchronization, but they.
For many years, researchers have looked for ways to make multithreading safe without forcing programmers to think about explicit locks.
One of the most successful solutions is the monitor concept that was pioneered by Per Brinch Hansen and Tony Hoare in the 1970s.
In the terminology of Java, a monitor has these properties:
In other words, if a client calls obj.method(), then the lock for obj is automatically acquired at the beginning of the method call and relinquished when the method returns.
Since all fields are private, this arrangement ensures that no thread can access the fields while another thread manipulates them.
Earlier versions of monitors had a single condition, with a rather elegant syntax.
However, research showed that indiscriminate retesting of conditions can be inefficient.
This problem is solved with explicit condition variables, each managing a separate set of threads.
Every object in Java has an intrinsic lock and an intrinsic condition.
If a method is declared with the synchronized keyword, it acts like a monitor method.
However, a Java object differs from a monitor in three important ways, compromising thread safety:
In a scathing review of the multithreading primitives in Java, he wrote: “It is astounding to me that Java’s insecure parallelism is taken seriously by the programming community, a quarter of a century after the invention of monitors and Concurrent Pascal.
Sometimes, it seems excessive to pay the cost of synchronization just to read.
After all, what can go wrong? Unfortunately, with modern processors and compilers, there is plenty of room for error.
Computers with multiple processors can temporarily hold memory values in registers or local memory caches.
Compilers won’t choose an ordering that changes the meaning of the code, but they make the assumption that memory values are only changed when there are explicit instructions in the code.
However, a memory value can be changed by another thread!
If you use locks to protect code that can be accessed by multiple threads, you won’t have these problems.
Compilers are required to respect locks by flushing local caches as necessary and not inappropriately reordering instructions.
Much of the specification is highly complex and technical, but the document also contains a number of clearly explained examples.
The volatile keyword offers a lock-free mechanism for synchronizing access to an instance field.
If you declare a field as volatile, then the compiler and the virtual machine take into account that the field may be concurrently updated by another thread.
For example, suppose an object has a boolean flag done that is set by one thread and queried by another thread.
Perhaps it is not a good idea to use the intrinsic object lock.
If that is a concern, one can use a separate Lock just for this variable.
But this is getting to be a lot of trouble.
As you saw in the preceding section, you cannot safely read a field from.
There is one other situation in which it is safe to access a shared field—when.
Other threads get to see the accounts variable after the constructor has finished.
Without using final, there would be no guarantee that other threads would see the updated value of accounts—they might all see null, not the constructed HashMap.
Of course, the operations on the map are not thread-safe.
If multiple threads mutate and read the map, you still need synchronization.
You can declare shared variables as volatile provided you perform no.
For example, the AtomicInteger class has methods incrementAndGet and decrementAndGet that atomically increment or decrement an integer.
You can safely use an AtomicInteger as a shared counter without synchronization.
There are also AtomicBoolean, AtomicLong, and AtomicReference, and atomic arrays of Boolean values, integers, long values, and references.
These classes should be left to systems programmers who produce concurrency utilities, not.
Locks and conditions cannot solve all problems that might arise in.
It is possible that all threads get blocked because each is waiting for more money.
In our program, a deadlock cannot occur for a simple reason.
The thread moving money out of that account can therefore proceed.
But if you change the run method of the threads to remove the $1,000 transaction limit, deadlocks can occur quickly.
The program will run for a while and then hang.
You will get a thread dump that lists all threads.
Each thread has a stack trace, telling you where it is currently blocked.
Another way to create a deadlock is to make the ith thread responsible for putting money into the ith account, rather than for taking it out of the ith account.
In this case, there is a chance that all threads will gang up on one account, each trying to remove more money from it than it contains.
In the SynchBankTest program, turn to the run method of the TransferRunnable class.
Run the program and see how it deadlocks almost immediately.
Here is another situation in which a deadlock can occur easily: Change the signalAll method to signal in the SynchBankTest program.
Again, it is best to set NACCOUNTS to 10 to observe the effect more quickly.) Unlike signalAll, which notifies all threads that are waiting for added funds, the signal method unblocks only one thread.
If that thread can’t proceed, all threads can be blocked.
Clearly, all threads but Thread 1 are blocked, because there isn’t enough money in their accounts.
The signal method picks a thread at random to unblock.
That thread is awakened, finds that there isn’t enough money in its account, and calls await again.
Unfortunately, there is nothing in the Java programming language to avoid or break these deadlocks.
You must design your program to ensure that a deadlock situation cannot occur.
In the preceding sections, we discussed the risks of sharing variables between.
Sometimes, you can avoid sharing by giving each thread its own instance, using the ThreadLocal helper class.
You could use synchronization, which is expensive; or, you could construct a local SimpleDateFormat object whenever you need it, but that is also wasteful.
The first time you call get in a given thread, the initialValue method is called.
From then on, the get method returns the instance belonging to the current thread.
A similar problem is the generation of random numbers in multiple threads.
But it is still inefficient if multiple threads need to wait for a single shared generator.
You could use the ThreadLocal helper to give each thread a separate generator, but Java SE 7 provides a convenience class for you.
If get is called for the first time, the value is obtained by calling initialize.
A thread blocks indefinitely when it calls the lock method to acquire a lock.
The tryLock method tries to acquire a lock and returns true if it was successful.
Otherwise, it immediately returns false, and the thread can go off and do something else.
If a thread is interrupted while it is waiting to acquire a lock, the interrupted thread continues to be blocked until the lock is available.
If a deadlock occurs, then the lock method can never terminate.
This is clearly a useful feature because it allows a program to break up deadlocks.
It has the same meaning as tryLock with an infinite timeout.
The await method returns if another thread has activated this thread by calling signalAll or signal, or if the timeout has elapsed, or if the thread was interrupted.
This method grabs the lock if it is available even if it has a fair locking policy and other threads have been waiting.
Returns false if the method returned because the time elapsed, true otherwise.
The latter is useful when there are many threads that read from a data structure and fewer threads that modify it.
In that situation, it makes sense to allow shared access for the readers.
Here are the steps that are necessary to use a read/write lock: 1
Lock writeLock() gets a write lock that excludes all other readers and writers.
The initial release of Java defined a stop method that simply terminates a.
The stop and suspend methods have something in common: Both attempt to control the behavior of a given thread without the thread’s cooperation.
The stop method is inherently unsafe, and experience has shown that the suspend method frequently leads to deadlocks.
In this section, you will see why these methods are problematic and what you can do to avoid problems.
This method terminates all pending methods, including the run method.
When a thread is stopped, it immediately gives up the locks on all objects that it has locked.
For example, suppose a TransferRunnable is stopped in the middle of moving money from one account to another, after the withdrawal and before the deposit.
Since the lock has been relinquished, the damage is observable from the other threads that have not been stopped.
When a thread wants to stop another thread, it has no way of knowing when the stop method is safe and when it leads to damaged objects.
You should interrupt a thread when you want it to stop.
The interrupted thread can then stop when it is safe to do so.
Note Some authors claim that the stop method has been deprecated because.
As a consequence, the thread relinquishes the intrinsic object locks that it holds.
Next, let us see what is wrong with the suspend method.
However, if you suspend a thread that owns a lock, then the lock is unavailable until the thread is resumed.
If the thread that calls the suspend method tries to acquire the same lock, the program deadlocks: The suspended thread waits to be resumed, and the suspending thread waits for the lock.
A button labeled Pause suspends the transfer threads, and a button labeled Resume resumes them.
Suppose a paintComponent method paints a chart of each account, calling a getBalances method to get an array of balances.
One of the transfer threads acquires the lock of the bank object.
All transfer threads are suspended; one of them still holds the lock on the bank object.
For some reason, the account chart needs to be repainted.
That method tries to acquire the lock of the bank object.
The event dispatch thread can’t proceed because the lock is owned by one of.
Thus, the user can’t click the Resume button, and the threads won’t ever resume.
If you want to safely suspend a thread, introduce a variable suspendRequested.
When your thread finds that the suspendRequested variable has been set, it should keep waiting until it becomes available again.
You have now seen the low-level building blocks that form the foundations of.
However, for practical programming, you want to stay away from the low-level constructs whenever possible.
It is much easier and safer to use higher-level structures that have been implemented by concurrency experts.
Many threading problems can be formulated elegantly and safely by using one or more queues.
Producer threads insert items into the queue, and consumer threads retrieve them.
The queue lets you safely hand over data from one thread to another.
Instead of accessing the bank object directly, the transfer threads insert transfer instruction objects into a queue.
Another thread removes the instructions from the queue and carries out the transfers.
Only that thread has access to the internals of the bank object.
Of course, the implementors of the thread-safe queue classes had to worry about locks and conditions, but that was their problem, not yours.)
A blocking queue causes a thread to block when you try to add an element.
Blocking queues are a useful tool for coordinating the work of multiple threads.
Worker threads can periodically deposit intermediate results into a blocking queue.
Other worker threads remove the intermediate results and modify them further.
If the first set of threads runs slower than the second, the second set blocks while waiting for the results.
If the first set of threads runs faster, the queue fills up until the second set catches up.
The blocking queue methods fall into three categories that differ by the action they perform when the queue is full or empty.
If you use the queue as a thread management tool, use the put and take methods.
The add, remove, and element operations throw an exception when you try to add to a full queue or get the head of an empty queue.
Of course, in a multithreaded program, the queue might become full or empty at any time, so you will instead want to use the offer, poll, and peek methods.
These methods simply return with a failure indicator instead of throwing an exception if they cannot carry out their tasks.
Note The poll and peek methods return null to indicate failure.
Therefore, it is illegal to insert null values into these queues.
There are also variants of the offer and poll methods with a timeout.
If it succeeds, it returns true; otherwise, it returns false when it times out.
The put method blocks if the queue is full, and the take method blocks if the.
These are the equivalents of offer and poll with no timeout.
The ArrayBlockingQueue is constructed with a given capacity and an optional parameter to require fairness.
If fairness is specified, then the longest-waiting threads are given preferential treatment.
As always, fairness exacts a significant performance penalty, and you should only use it if your problem specifically requires it.
The queue has unbounded capacity, but retrieval will block if the queue is empty.
The getDelay method returns the remaining delay of the object.
Elements can only be removed from a DelayQueue if their delay has elapsed.
Java SE 7 adds a TransferQueue interface that allows a producer thread to wait until a consumer is ready to take on an item.
The program in Listing 14.10 shows how to use a blocking queue to control a.
The program searches through all files in a directory and its subdirectories, printing lines that contain a given keyword.
A producer thread enumerates all files in all subdirectories and places them in a blocking queue.
This operation is fast, and the queue would quickly fill up with.
We use a trick to terminate the application when no further work is required.
In order to signal completion, the enumeration thread places a dummy object into the queue.
In this application, we use the queue data structure as a synchronization mechanism.
Only elements whose delay has expired can be removed from the queue.
If multiple threads concurrently modify a data structure, such as a hash table,
See Chapter 13 for more information on hash tables.) For example, one thread may begin to insert a new element.
Suppose it is preempted in the middle of rerouting the links between the hash table’s buckets.
If another thread starts traversing the same list, it may follow invalid links and create havoc, perhaps throwing exceptions or being trapped in an infinite loop.
You can protect a shared data structure by supplying a lock, but it is usually.
The blocking queues that we discussed in the preceding section are, of course, thread-safe collections.
In the following sections, we discuss the other thread-safe collections that the Java library provides.
These collections use sophisticated algorithms that minimize contention by allowing concurrent access to different parts of the data structure.
Unlike most collections, the size method of these classes does not necessarily operate in constant time.
Determining the current size of one of these collections usually requires traversal.
The concurrent hash map can efficiently support a large number of readers and a fixed number of writers.
By default, it is assumed that there are up to 16 simultaneous writer threads.
There can be many more writer threads, but if more than 16 write at the same time, the others are temporarily blocked.
You can specify a higher number in the constructor, but it is unlikely that you will need to.
The putIfAbsent method atomically adds a new association provided there wasn’t one before.
This is useful for a cache that is accessed by multiple threads, to ensure that only one thread adds an item into the cache.
The first constructor requires that the elements implement the Comparable interface.
The first constructor requires that the keys implement the Comparable interface.
This arrangement is useful if the threads that iterate over the collection greatly outnumber the threads that mutate it.
When you construct an iterator, it contains a reference to the current array.
If the array is later mutated, the iterator still has the old array, but the collection’s array is replaced.
As a consequence, the older iterator has a consistent (but potentially outdated) view that it can access without any synchronization expense.
Ever since the initial release of Java, the Vector and Hashtable classes.
These classes are now considered obsolete, having been replaced by the ArrayList and HashMap classes.
Instead, a different mechanism is supplied in the collections library.
Any collection class can be made thread-safe by means of a synchronization wrapper:
The methods of the resulting collections are protected by a lock, providing thread-safe access.
You should make sure that no thread accesses the data structure through the original unsynchronized methods.
The easiest way to ensure this is not to save any reference to the original object.
Simply construct a collection and immediately pass it to the wrapper, as we did in our examples.
You still need to use “client-side” locking if you want to iterate over the collection while another thread has the opportunity to mutate it:
The synchronization is still required so that the concurrent modification can be reliably detected.
In particular, the ConcurrentHashMap map has been carefully implemented so that multiple threads can access it without blocking each other, provided they access different buckets.
One exception is an array list that is frequently mutated.
A Runnable encapsulates a task that runs asynchronously; you can think of it.
A Callable is similar to a Runnable, but it returns a value.
The Callable interface is a parameterized type, with a single method call.
The type parameter is the type of the returned value.
For example, a Callable<Integer> represents an asynchronous computation that eventually returns an Integer object.
You can start a computation, give someone the Future object, and forget about it.
The owner of the Future object can obtain the result when it is ready.
A call to the first get method blocks until the computation is finished.
The second method throws a TimeoutException if the call timed out before the computation finished.
The isDone method returns false if the computation is still in progress, true if it is finished.
If the computation has not yet started, it is canceled and will never start.
If the computation is currently in progress, it is interrupted if the mayInterrupt parameter is true.
The FutureTask wrapper is a convenient mechanism for turning a Callable into both a Future and a Runnable—it implements both interfaces.
The program in Listing 14.11 puts these concepts to work.
This program is similar to the preceding example that found files containing a given keyword.
However, now we will merely count the number of matching files.
Then we construct a FutureTask object from the MatchCounter and use it to start a thread.
Of course, the call to get blocks until the result is actually available.
Inside the call method, we use the same mechanism recursively.
Each call to get blocks until the result is available.
Of course, the threads run in parallel, so there is a good chance that the results will all be available at about the same time.
The second method throws a TimeoutException if it was unsuccessful.
If the task has already started and the mayInterrupt parameter is true, it is interrupted.
Constructing a new thread is somewhat expensive because it involves.
If your program creates a large number of short-lived threads, it should use a thread pool instead.
A thread pool contains a number of idle threads that are ready to run.
You give a Runnable to the pool, and one of the threads calls the run method.
When the run method exits, the thread doesn’t die but stays around to serve the next request.
Another reason to use a thread pool is to throttle the number of concurrent.
Creating a huge number of threads can greatly degrade performance and even crash the virtual machine.
If you have an algorithm that creates lots of threads, you should use a “fixed” thread pool that bounds the total number of concurrent threads.
The Executors class has a number of static factory methods for constructing thread pools; see Table 14.2 for a summary.
Let us look at the first three methods in Table 14.2 (we will discuss the.
The newFixedThreadPool method constructs a thread pool with a fixed size.
If more tasks are submitted than there are idle threads, the unserved tasks are placed on a queue.
These three methods return an object of the ThreadPoolExecutor class that implements the ExecutorService interface.
You can submit a Runnable or Callable to an ExecutorService with one of the following methods:
The pool will run the submitted task at its earliest convenience.
When you call submit, you get back a Future object that you can use to query the state of the.
The second version of submit also submits a Runnable, and the get method of the Future returns the given result object upon completion.
The third version submits a Callable, and the returned Future gets the result of the computation when it is ready.
When you are done with a thread pool, call shutdown.
An executor that is shut down accepts no new tasks.
When all tasks are finished, the threads in the pool die.
The pool then cancels all tasks that have not yet begun and attempts to interrupt the running threads.
Here, in summary, is what you do to use a thread pool: Executors class.
If you want to be able to cancel a task or if you submit Callable objects, hang on to the returned Future objects.
Call shutdown when you no longer want to submit any tasks.
For example, the preceding example program produced a large number of short-lived threads, one per directory.
The program in Listing 14.12 uses a thread pool to launch the tasks instead.
For informational purposes, this program prints out the largest pool size during execution.
For that reason, we had to cast the pool object to the ThreadPoolExecutor class.
You can schedule a Runnable or Callable to run once, after an initial delay.
You have seen how to use an executor service as a thread pool to increase the.
Sometimes, an executor is used for a more tactical reason, simply to control a group of related tasks.
For example, you can cancel all tasks in an executor with the shutdownNow method.
The invokeAny method submits all objects in a collection of Callable objects and returns the result of a completed task.
You don’t know which task that is— presumably, it was the one that finished most quickly.
Use this method for a search problem in which you are willing to accept any solution.
For example, suppose that you need to factor a large integer—a computation that is required for breaking the RSA cipher.
You could submit a number of tasks, each attempting a factorization with numbers in a different range.
As soon as one of these tasks has an answer, your computation can stop.
The invokeAll method submits all objects in a collection of Callable objects, blocks until all of them complete, and returns a list of Future objects that represent the solutions to all tasks.
You can process the results of the computation when they are available, like this:
A disadvantage of this approach is that you may wait needlessly if the first task happens to take a long time.
It would make more sense to obtain the results in the order in which they are available.
The service manages a blocking queue of Future objects, containing the results of the.
Thus, a more efficient organization for the preceding computation is the following:
The second method throws a TimeoutException if a timeout occurs.
The second method throws a TimeoutException if a timeout occurs.
Future<T> take() removes the next completed result, blocking if no completed results are available.
Fork-join framework Some applications use a large number of threads that are.
An example would be a web server that uses one thread per connection.
Other applications use one thread per processor core, in order to.
The fork-join framework, which appeared in Java SE 7, is designed to support the latter.
Suppose you have a processing task that naturally decomposes into subtasks, like this:
To enhance an image, you can transform the top half and the bottom half.
If you have enough idle processors, those operations can run in parallel.
You will need to do a bit of extra work along the strip that separates the two halves, but that’s a technical detail.)
Suppose we want to count how many elements of an array fulfill a particular property.
We cut the array in half, compute the counts of each half, and add them up.
To put the recursive computation in a form that is usable by the framework, supply a class that extends RecursiveTask<T> (if the computation produces a result of type T) or RecursiveAction (if it doesn’t produce a result)
Override the compute method to generate and invoke subtasks, and to combine their results.
Here, the invokeAll method receives a number of tasks and blocks until all of them have completed.
Here, we apply join to each subtask and return the sum.
Note There is also a get method for getting the current result, but it is less.
Behind the scenes, the fork-join framework uses an effective heuristic for.
Each worker thread has a deque (double-ended queue) for tasks.
A worker thread pushes subtasks onto the head of its own deque.
Only one thread accesses the head, so no locking is required.) When a worker thread is idle, it “steals” a task from the tail of another deque.
Since the large subtasks are at the tail, such stealing is rare.
If you have a set of collaborating threads that follow one of these behavior patterns, you should simply reuse the appropriate library class instead of trying to come up with a handcrafted collection of locks and conditions.
To proceed past the semaphore, a thread requests a permit by calling acquire.
The semaphore simply keeps a count.) Since only a fixed number of permits is available, a semaphore limits the number of threads that are allowed to pass.
Moreover, a permit doesn’t have to be released by the thread that acquires it.
Any thread can release any number of permits, potentially increasing the number of permits beyond the initial count.
Semaphores were invented by Edsger Dijkstra in 1968, for use as a synchronization primitive.
Dijkstra showed that semaphores can be efficiently implemented and that they are powerful enough to solve many common thread synchronization problems.
In just about any operating systems textbook, you will find implementations of bounded queues using semaphores.
Usually, semaphores do not map directly to common application situations.
A CountDownLatch lets a set of threads wait until a count has reached zero.
Once the count has reached 0, you cannot increment it again.
A useful special case is a latch with a count of 1
Threads are held at the gate until another thread sets the count to 0
Imagine, for example, a set of threads that need some initial data to do their work.
The worker threads are started and wait at the gate.
When it is ready, it calls countDown, and all worker threads proceed.
You can then use a second latch to check when all worker threads are done.
Each worker thread counts down that latch just before it terminates.
Another thread that harvests the work results waits on the latch, and proceeds as soon as all workers have terminated.
When all parts are ready, the results need to be combined.
When a thread is done with its part, we let it run against the barrier.
Once all threads have reached the barrier, the barrier gives way and the threads can proceed.
First, construct a barrier, giving the number of participating threads:
If any of the threads waiting for the barrier leaves the barrier, then the barrier breaks.
Threads that are already waiting have their await call terminated immediately.
You can supply an optional barrier action that is executed when all threads have reached the barrier:
The action can harvest the results of the individual threads.
The barrier is called cyclic because it can be reused after all waiting threads.
In this regard, it differs from a CountDownLatch, which can only be used once.
The Phaser class adds more flexibility, allowing you to vary the number of participating threads between phases.
An Exchanger is used when two threads are working on two instances of the.
Typically, one thread fills the buffer, and the other consumes its contents.
A synchronous queue is a mechanism that pairs up producer and consumer.
When a thread calls put on a SynchronousQueue, it blocks until another thread calls take, and vice versa.
Unlike the case with an Exchanger, data are only transferred in one direction, from the producer to the consumer.
Even though the SynchronousQueue class implements the BlockingQueue interface, it is not conceptually a queue.
As we mentioned in the introduction to this chapter, one of the reasons to use.
When your program needs to do something time-consuming, you should fire up another worker thread instead of blocking the user interface.
However, you have to be careful what you do in a worker thread because, perhaps surprisingly, Swing is not thread-safe.
If you try to manipulate user interface elements from multiple threads, your user interface can become corrupted.
To see the problem, run the upcoming test program in Listing 14.14
When you click the Bad button, a new thread is started whose run method tortures a combo box, randomly adding and removing values.
What is going on? When an element is inserted into the combo box, the combo box fires an event to update the display.
Then, the display code springs into action, reading the current size of the combo box and preparing to display the values.
But the worker thread keeps going—occasionally resulting in a reduction of the count of the values in the combo box.
This situation could have been avoided if programmers could lock the combo box object while displaying it.
However, the designers of Swing decided not to expend any effort to make Swing thread-safe, for two reasons.
First, synchronization takes time, and nobody wanted to slow down Swing any further.
More importantly, the Swing team checked out the experience other teams had with thread-safe user interface toolkits.
Programmers using thread-safe toolkits turned out to be confused by the demands for synchronization and often created deadlock-prone programs.
When you use threads together with Swing, you have to follow two simple.
If an action takes a long time, do it in a separate worker thread and never in the event dispatch thread.
Do not touch Swing components in any thread other than the event dispatch thread.
The reason for the first rule is easy to understand.
If you take a long time in the event dispatch thread, the application seems “dead” because it cannot respond to any events.
In particular, the event dispatch thread should never make input/output calls, which might block indefinitely, and it should never call sleep.
If you need to wait for a specific amount of time, use timer events.)
The second rule is often called the single-thread rule for Swing programming.
These two rules seem to be in conflict with each other.
Suppose you fire up a separate thread to run a time-consuming task.
You would usually want to update the user interface to indicate progress while your thread is working.
When your task is finished, you’d want to update the GUI again.
For example, if you want to update a progress bar or a label text, you can’t simply set its value from your thread.
To solve this problem, you can use, in any thread, two utility methods to add arbitrary actions to the event queue.
For example, suppose you want to periodically update a label in a thread to indicate progress.
Instead, use the invokeLater and invokeAndWait methods of the EventQueue class to have that call executed in the event dispatching thread.
Place the Swing code into the run method of a class that implements the Runnable interface.
Then, create an object of that class and pass it to the static invokeLater or invokeAndWait method.
For example, here is how to update a label text:
The invokeLater method returns immediately when the event is posted to the event queue.
The invokeAndWait method waits until the run method has actually been executed.
For updating a progress label, the invokeLater method is more appropriate.
Users would rather have the worker thread make more progress than have the most precise progress indicator.
Both methods execute the run method in the event dispatch thread.
Listing 14.14 demonstrates how to use the invokeLater method to safely modify the contents of a combo box.
If you click on the Good button, a thread inserts and removes numbers.
However, the actual modification takes place in the event dispatching thread.
When a user issues a command for which processing takes a long time, you.
The SwingWorker class reduces the tedium of implementing background tasks.
The program in Listing 14.15 has commands for loading a text file and for canceling the file loading process.
You should try the program with a long file, such as the full text of The Count of Monte Cristo, supplied in the gutenberg directory of the book’s companion code.
While the file is being read, the Open menu item is disabled and the Cancel item is enabled (see Figure 14.9)
After each line is read, a line counter in the status bar is updated.
After the reading process is complete, the Open menu item is reenabled, the Cancel item is disabled, and the status line text is set to Done.
This example shows the typical UI activities of a background task: • After each work unit, update the UI to show progress.
After the work is finished, make a final change to the UI.
The SwingWorker class makes it easy to implement such a task.
The publish method causes a process method to execute in the event dispatch thread to deal with the progress data.
When the work is complete, the done method is called in the event dispatch thread so that you can finish updating the UI.
Whenever you want to do some work in the worker thread, construct a new worker.
Each worker object is meant to be used only once.) Then call the execute method.
You will typically call execute on the event dispatch thread, but that is not a requirement.
This result can be obtained by the get method of the Future interface.
Since the get method blocks until the result is available, you don’t want to call it immediately after calling execute.
It is a good idea to call it only when you know that the work has been completed.
Both the intermediate progress data and the final result can have arbitrary types.
To cancel the work in progress, use the cancel method of the Future interface.
As already mentioned, the worker thread’s call to publish will cause calls to process on the event dispatch thread.
For efficiency, the results of several calls to publish may be batched up in a single call to process.
The process method receives a List<V> containing all intermediate results.
Let us put this mechanism to work for reading in a text file.
Appending lines from a long text file (such as all lines in The Count of Monte Cristo) takes considerable time.
To show the user that progress is being made, we want to display the number of lines read in a status line.
Thus, the progress data consist of the current line number and the current line of text.
The final result is the text that has been read into a StringBuilder.
In the doInBackground method, we read a file, a line at a time.
After each line, we call publish to publish the line number and the text of the current line.
We also sleep for a millisecond after every line so that you can test cancellation without getting stressed out, but you wouldn’t want to slow down your own programs by sleeping.
If you comment out this line, you will find that The Count of Monte Cristo loads quite quickly, with only a few batched user interface updates.
Note You can make this program behave quite smoothly by updating the text area from the worker thread, but this is not possible for most Swing components.
We show you the general approach in which all component updates occur in the event dispatch thread.
In the process method, we ignore all line numbers but the last one, and we concatenate all lines for a single update of the text area.
In the done method, the text area is updated with the complete text, and the Cancel menu item is disabled.
Note how the worker is started in the event listener for the Open menu item.
This simple technique allows you to execute time-consuming tasks while.
Every Java application starts with a main method that runs in the main thread.
It schedules the construction of the user interface in the event dispatch thread and then exits.
After the user interface construction, the event dispatch thread processes event notifications, such as calls to actionPerformed or paintComponent.
Other threads, such as the thread that posts events into the event queue, are running behind the scenes, but those threads are invisible to the application programmer.
You can safely add and remove event listeners in any thread.
Of course, the listener methods will be invoked in the event dispatch thread.
Note We used the repaint method many times in this book, but the revalidate method is less common.
Its purpose is to force a layout of a component after the contents have changed.
The traditional AWT has a validate method to force the layout of a component.
Any thread was allowed to construct components, set their properties, and add them into containers, as long as none of these components had been realized.
A component is realized if it can receive paint or validation events.
This is the case after the setVisible(true) or pack (!) methods have been invoked on the component, or after the component has been added to a container that has been realized.
It allowed you to create the GUI in the main method and then call setVisible(true) on the top-level frame of the application.
There was no bothersome scheduling of a Runnable on the event dispatch thread.
Unfortunately, some component implementors did not pay attention to the subtleties of the original single-thread rule.
They launched activities on the event dispatch thread without ever bothering to check whether the component was realized.
For example, if you call setSelectionStart or setSelectionEnd on a JTextComponent, a caret movement is scheduled in the event dispatch thread, even if the component is not visible.
It might well have been possible to detect and fix these problems, but the Swing designers took the easy way out.
They decreed that it is never safe to access components from any thread other than the event dispatch thread.
Of course, there are plenty of programs that are not so careful and live by the old version of the single-thread rule, initializing the user interface on the main thread.
Those programs incur the slight risk that some of the user interface initialization may cause actions on the event dispatch thread that conflict with actions on the main thread.
As we said in Chapter 7, you don’t want to be one of the unlucky few who run into trouble and waste time debugging an intermittent threading bug.
This volume covered the fundamentals of the Java programming language and the parts of the standard library that you need for most programming projects.
We hope that you enjoyed your tour through the Java fundamentals and that you found useful information along the way.
