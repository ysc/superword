Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions.
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
For questions about sales outside the United States, please contact international@pearsoned.com.
Cataloging-in-Publication Data is on file with the Library of Congress.
This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise.
To Greg Doench, my editor for two decades, whose patience, kindness,
This book is written in the “impatient” style that I ﬁrst tried out in a book called Scala for the Impatient.
In that book, I wanted to quickly cut to the chase without lecturing the reader about the superiority of one paradigm over another.
I presented information in small chunks organized to help you quickly retrieve it when needed.
The approach was a big success in the Scala community, and I am employing it again in this book.
With Java 8, the Java programming language and library receive a major refresh.
The recipient can choose to execute your computation when appropriate and as often as appropriate.
The library is then able to reorder the computation—for example, to take advantage of parallelism.
Or, if you just want to have the ﬁrst hundred matches, it can stop the computation without you having to maintain a counter.
The brand-new stream API of Java 8 puts this idea to work.
In the ﬁrst chapter, you learn all about the syntax of lambda expressions, and Chapter 2 gives a complete overview of streams.
In Chapter 3, I provide you with tips on how to effectively design your own libraries with lambdas.
Having waited for far too many years, programmers are ﬁnally able to use a well-designed date/time library.
Each version of Java brings enhancements in the concurrency API, and Java 8 is no exception.
In Chapter 6, you learn about improvements in atomic counters, concurrent hash maps, parallel array operations, and composable futures.
In Chapter 7, you will see how to execute JavaScript on the Java Virtual Machine, and how to interoperate with Java code.
My thanks go, as always, to my editor Greg Doench, who had the idea of a short book that brings experienced programmers up to speed with Java 8
Dmitry Kirsanov and Alina Kirsanova once again turned an XHTML manuscript into an attractive book with amazing speed and attention to detail.
I am grateful to the reviewers who spotted many embarrassing errors and gave excellent suggestions for improvement.
I hope that you enjoy reading this concise introduction to the new features of Java 8, and that it will make you a more successful Java programmer.
If you ﬁnd errors or have suggestions for improvement, please visit http://horstmann.com/ java8 and leave a comment.
On that page, you will also ﬁnd a link to an archive ﬁle containing all code examples from the book.
Long before there was object-oriented programming, there were functional programming languages such as Lisp and Scheme, but their beneﬁts were not much appreciated outside academic circles.
Recently, functional programming has risen in importance because it is well suited for concurrent and event-driven (or “reactive”) programming.
Instead, the winning strategy is to blend object-oriented and functional programming.
This makes sense even if you are not interested in concurrency.
For example, collection libraries can be given powerful APIs if the language has a convenient syntax for function expressions.
The principal enhancement in Java 8 is the addition of functional programming constructs to its object-oriented roots.
The next chapter shows you how to put that syntax to use with Java collections, and in Chapter 3 you will learn how to build your own functional libraries.
A lambda expression is a block of code with parameters.
Use a lambda expression whenever you want a block of code executed at a later point in time.
Lambda expressions can access effectively ﬁnal variables from the enclosing scope.
Method and constructor references refer to methods or constructors without invoking them.
You can now add default and static methods to interfaces that provide concrete implementations.
You must resolve any conﬂicts between default methods from multiple interfaces.
Before getting into the syntax (or even the curious name), let’s step back and see where you have used similar code blocks in Java all along.
When you want to do work in a separate thread, you put the work into the run method of a Runnable, like this:
Then, when you want to execute this code, you construct an instance of the Worker class.
You can then submit the instance to a thread pool, or, to keep it simple, start a new thread:
The key point is that the run method contains code that you want to execute in a separate thread.
If you want to sort strings by length instead of the default dictionary order, you can pass a Comparator object to the sort method:
The sort method keeps calling the compare method, rearranging the elements if they are out of order, until the array is sorted.
You give the sort method a snippet of code needed to compare elements, and that code is integrated into the rest of the sorting logic, which you’d probably not care to reimplement.
Note that you shouldn’t compute x - y to compare x and y since that computation can overﬂow for large operands of opposite sign.
As another example for deferred execution, consider a button callback.
You put the callback action into a method of a class implementing the listener interface, construct an instance, and register the instance with the button.
NOTE: Since Java 8 positions JavaFX as the successor to the Swing GUI toolkit, I use JavaFX in these examples.
See Chapter 4 for more information on JavaFX.) Of course, the details don’t matter.
In every user interface toolkit, be it Swing, JavaFX, or Android, you give a button some code that you want to run when the button is clicked.
A block of code was passed to someone—a thread pool, a sort method, or a button.
Up to now, giving someone a block of code hasn’t been easy in Java.
Java is an object-oriented language, so you had to construct an object belonging to a class that has a method with the desired code.
In other languages, it is possible to work with blocks of code directly.
The Java designers have resisted adding this feature for a long time.
A language can become an unmaintainable mess if it includes every feature that yields marginally more concise code.
However, in those other languages it isn’t just easier to spawn a thread or to register a button click handler; large swaths of their APIs are simpler, more consistent, and more powerful.
In Java, one could have written similar APIs that take objects of classes implementing a particular function, but such APIs would be unpleasant to use.
For some time now, the question was not whether to augment Java for functional programming, but how to do it.
It took several years of experimentation before a design emerged that is a good ﬁt for Java.
In the next section, you will see how you can work with blocks of code in Java 8
We pass code that checks whether one string is shorter than another.
Java is a strongly typed language, and we must specify that as well:
Such an expression is simply a block of code, together with the speciﬁcation of any variables that must be passed to the code.
Why the name? Many years ago, before there were any computers, the logician Alonzo Church wanted to formalize what it means for a mathematical function to be effectively computable.
Curiously, there are functions that are known to exist, but nobody knows how to compute their values.) He used the Greek letter lambda (λ) to mark parameters.
Had he known about the Java API, he would have written.
But in the end, he switched to the lowercase version.
Ever since, an expression with parameter variables has been called a lambda expression.
You have just seen one form of lambda expressions in Java: parameters, the -> arrow, and an expression.
If the code carries out a computation that doesn’t ﬁt in a single expression, write it exactly like you would have written a method: enclosed in {} and with explicit return statements.
If a lambda expression has no parameters, you still supply empty parentheses, just as with a parameterless method:
If the parameter types of a lambda expression can be inferred, you can omit them.
Here, the compiler can deduce that first and second must be strings because the lambda expression is assigned to a string comparator.
We will have a closer look at this assignment in the next section.)
If a method has a single parameter with inferred type, you can even omit the parentheses:
NOTE: You can add annotations or the final modiﬁer to lambda parameters in the same way as for method parameters:
You never specify the result type of a lambda expression.
NOTE: It is illegal for a lambda expression to return a value in some branches.
As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as Runnable or Comparator.
You can supply a lambda expression whenever an object of an interface with a single abstract method is expected.
NOTE: You may wonder why a functional interface must have a single abstract method.
Aren’t all methods in an interface abstract? Actually, it has always been possible for an interface to redeclare methods from the Object class such as toString or clone, and these declarations do not make the methods abstract.
Some interfaces in the Java API redeclare Object methods in order to attach javadoc comments.
To demonstrate the conversion to a functional interface, consider the Arrays.sort method.
Its second parameter requires an instance of Comparator, an interface with a single method.
Behind the scenes, the Arrays.sort method receives an object of some class that implements Comparator<String>
Invoking the compare method on that object executes the body of the lambda expression.
The management of these objects and classes is completely implementation dependent, and it can be much more efﬁcient than using traditional inner classes.
It is best to think of a lambda expression as a function, not an object, and to accept that it can be passed to a functional interface.
This conversion to interfaces is what makes lambda expressions so compelling.
That’s a lot easier to read than the alternative with inner classes.
In fact, conversion to a functional interface is the only thing that you can do with a lambda expression in Java.
In other programming languages that support function literals, you can declare function types such as (String, String) -> int, declare variables of those types, and use the variables to save function expressions.
However, the Java designers decided to stick with the familiar concept of interfaces instead of adding function types to the language.
NOTE: You can’t even assign a lambda expression to a variable of type Object—Object is not a functional interface.
The Java API deﬁnes a number of very generic functional interfaces in the java.util.function package.
You can save our string comparison lambda in a variable of that type:
If you have used a functional programming language before, you may ﬁnd this curious.
An interface such as Comparator has a speciﬁc purpose, not just a method with given parameter and return types.
When you want to do something with lambda expressions, you still want to keep the purpose of the expression in mind, and have a speciﬁc functional interface for it.
The interfaces in java.util.function are used in several Java 8 APIs, and you will likely see them elsewhere in the future.
But keep in mind that you can equally well convert a lambda expression into a functional interface that is a part of whatever API you use today.
NOTE: You can tag any functional interface with the @FunctionalInterface annotation.
The compiler checks that the annotated entity is an interface with a single abstract method.
And the javadoc page includes a statement that your interface is a functional interface.
Any interface with a single abstract method is, by deﬁnition, a functional interface.
Finally, note that checked exceptions matter when a lambda is converted to an instance of a functional interface.
Since the Runnable.run cannot throw any exception, this assignment is illegal.
You can catch the exception in the body of the lambda expression.
Or assign the lambda to an interface whose single abstract method can throw the exception.
For example, the call method of the Callable interface can throw any exception.
Therefore, you can assign the lambda to a Callable<Void> (if you add a statement return null)
Sometimes, there is already a method that carries out exactly the action that you’d like to pass on to some other code.
For example, suppose you simply want to print the event object whenever a button is clicked.
It would be nicer if you could just pass the println method to the setOnAction method.
The expression System.out::println is a method reference that is equivalent to the lambda expression x -> System.out.println(x)
As another example, suppose you want to sort strings regardless of letter case.
As you can see from these examples, the :: operator separates the method name from the name of an object or class.
In the ﬁrst two cases, the method reference is equivalent to a lambda expression that supplies the parameters of the method.
As already mentioned, System.out::println is equivalent to x -> System.out.println(x)
Similarly, Math::pow is equivalent to (x, y) -> Math.pow(x, y)
In the third case, the ﬁrst parameter becomes the target of the method.
For example, String::compareToIgnoreCase is the same as (x, y) -> x.compareToIgnoreCase(y)
NOTE: When there are multiple overloaded methods with the same name, the compiler will try to ﬁnd from the context which one you mean.
For example, there are two versions of the Math.max method, one for integers and one for double values.
Which one gets picked depends on the method parameters of the functional interface to which Math::max is converted.
Just like lambda expressions, method references don’t live in isolation.They are always turned into instances of functional interfaces.
You can capture the this parameter in a method reference.
For example, this::equals is the same as x -> this.equals(x)
When the thread starts, its Runnable is invoked, and super::greet is executed, calling the greet method of the superclass.
NOTE: In an inner class, you can capture the this reference of an enclosing class as EnclosingClass.this::method or EnclosingClass.super::method.
Constructor references are just like method references, except that the name of the method is new.
For example, Button::new is a reference to a Button constructor.
Then you can turn it into an array of buttons, by calling the constructor on each of the strings, with the following invocation:
We will discuss the details of the stream, map, and collect methods in Chapter 2
For now, what’s important is that the map method calls the Button(String) constructor for each list element.
There are multiple Button constructors, but the compiler picks the one with a String parameter because it infers from the context that the constructor is called with a string.
For example, int[]::new is a constructor reference with one parameter: the length of the array.
Array constructor references are useful to overcome a limitation of Java.
It is not possible to construct an array of a generic type T.
For example, suppose we want to have an array of buttons.
The Stream interface has a toArray method that returns an Object array:
The toArray method invokes this constructor to obtain an array of the correct type.
Often, you want to be able to access variables from an enclosing method or class in a lambda expression.
Now look at the variables count and text inside the lambda expression.
Note that these variables are not deﬁned in the lambda expression.
If you think about it, something nonobvious is going on here.
The code of the lambda expression may run long after the call to repeatMessage has returned and the parameter variables are gone.
To understand what is happening, we need to reﬁne our understanding of a lambda expression.
Values for the free variables, that is, the variables that are not parameters and not deﬁned inside the code.
In our example, the lambda expression has two free variables, text and count.
The data structure representing the lambda expression must store the values for these variables, in our case, "Hello" and 1000
We say that these values have been captured by the lambda expression.
For example, one can translate a lambda expression into an object with a single method, so that the values of the free variables are copied into instance variables of that object.)
NOTE: The technical term for a block of code together with the values of the free variables is a closure.
If someone gloats that their language has closures, rest assured that Java has them as well.
As you have seen, a lambda expression can capture the value of a variable in the enclosing scope.
In Java, to ensure that the captured value is well-deﬁned, there is an important restriction.
In a lambda expression, you can only reference variables whose value doesn’t change.
Consider a sequence of concurrent tasks, each updating a shared counter.
If this code were legal, it would be very, very bad.
The increment matches++ is not atomic, and there is no way of knowing what would happen if multiple threads execute that increment concurrently.
NOTE: Inner classes can also capture values from an enclosing scope.
Before Java 8, inner classes were only allowed to access final local variables.
This rule has now been relaxed to match that for lambda expressions.
An inner class can access any effectively ﬁnal local variable—that is, any variable whose value does not change.
Don’t count on the compiler to catch all concurrent access errors.
If matches is an instance or static variable of an enclosing class, then no error is reported, even though the result is just as undeﬁned.
Also, it’s perfectly legal to mutate a shared object, even though it is unsound.
An effectively ﬁnal variable is a variable that is never assigned a new value after it has been initialized.) In our.
However, the object is mutated, and that is not threadsafe.
There are safe mechanisms for counting and collecting values concurrently.
In Chapter 2, you will see how to use streams to collect values with certain properties.
In other situations, you may want to use threadsafe counters and collections.
See Chapter 6 for more information on this important topic.
NOTE: As with inner classes, there is an escape hatch that lets a lambda expression update a counter in an enclosing local scope.
For a button callback, that doesn’t matter, but in general, you should think twice before using this trick.You will see how to implement a threadsafe shared counter in Chapter 6
The body of a lambda expression has the same scope as a nested block.
It is illegal to declare a parameter or a local variable in the lambda that has the same name as a local variable.
Inside a method, you can’t have two local variables with the same name, and therefore, you can’t introduce such variables in a lambda expression either.
When you use the this keyword in a lambda expression, you refer to the this parameter of the method that creates the lambda.
There is nothing special about the use of this in a lambda expression.
The scope of the lambda expression is nested inside the doWork method, and this has the same meaning anywhere in that method.
Many programming languages integrate function expressions with their collections library.
This often leads to code that is shorter and easier to understand than the loop equivalent.
The library designers can supply a forEach method that applies a function to each element.
That’s ﬁne if the collections library has been designed from the ground up.
But the Java collections library has been designed many years ago, and there is a problem.
If the Collection interface gets new methods, such as forEach, then every program that deﬁnes its own class implementing Collection will break until it, too, implements that method.
The Java designers decided to solve this problem once and for all by allowing interface methods with concrete implementations (called default methods)
In this section, we’ll look into default methods in detail.
NOTE: In Java 8, the forEach method has been added to the Iterable interface, a superinterface of Collection, using the mechanism that I will describe in this section.
The interface has two methods: getId, which is an abstract method, and the default method getName.
A concrete class that implements the Person interface must, of course, provide an implementation of getId, but it can choose to keep the implementation of getName or to override it.
Default methods put an end to the classic pattern of providing an interface and an abstract class that implements most or all of its methods, such as Collection/AbstractCollection or WindowListener/WindowAdapter.
Now you can just implement the methods in the interface.
If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored.
If a superinterface provides a default method, and another interface supplies a method with the same name and parameter types (default or not), then you must resolve the conﬂict by overriding that method.
What happens if you form a class that implements both of them?
The class inherits two inconsistent getName methods provided by the Person and Named interfaces.
Rather than choosing one over the other, the Java compiler reports an error and leaves it up to the programmer to resolve the ambiguity.
In that method, you can choose one of the two conﬂicting methods, like this:
Now assume that the Named interface does not provide a default implementation for getName:
Can the Student class inherit the default method from the Person interface? This might be reasonable, but the Java designers decided in favor of uniformity.
If at least one interface provides an implementation, the compiler reports an error, and the programmer must resolve the ambiguity.
NOTE: Of course, if neither interface provides a default for a shared method, then we are in the pre-Java 8 situation, and there is no conﬂict.An implementing class has two choices: implement the method, or leave it unimplemented.
Now consider a class that extends a superclass and implements an interface, inheriting the same method from both.
For example, suppose that Person is a class and Student is deﬁned as.
In that case, only the superclass method matters, and any default method from the interface is simply ignored.
In our example, Student inherits the getName method from Person, and it doesn’t make any difference whether the Named interface provides a default for getName or not.
If you add default methods to an interface, it has no effect on code that worked before there were default methods.
CAUTION: You can never make a default method that redeﬁnes one of the methods in the Object class.
For example, you can’t deﬁne a default method for toString or equals, even though that might be attractive for interfaces such as List.
As of Java 8, you are allowed to add static methods to interfaces.
There was never a technical reason why this should be outlawed.
It simply seemed to be against the spirit of interfaces as abstract speciﬁcations.
Up to now, it has been common to place static methods in companion classes.
You ﬁnd pairs of interfaces and utility classes such as Collection/Collections or Path/Paths in the standard library.
You can construct a path from a sequence of strings, such as Paths.get("jdk1.8.0", "jre", "bin")
In Java 8, one could have added this method to the Path interface:
When you look at the Collections class, you will ﬁnd two kinds of methods.
For a factory method that doesn’t work since you don’t have an object on which to invoke the method.
It is unlikely that the Java collections library will be refactored in this way, but when you implement your own interfaces, there is no longer a reason to provide a separate companion class for utility methods.
In Java 8, static methods have been added to quite a few interfaces.
This is a ﬁtting way of closing this chapter because it demonstrates the power of working with functions.
The compare method turns a function (the key extractor) into a more complex function (the key-based comparator)
Using the listFiles(FileFilter) and isDirectory methods of the java.io.File class, write a method that returns all subdirectories of a given directory.
Using the list(FilenameFilter) method of the java.io.File class, write a method that returns all ﬁles in a given directory with a given extension.
Given an array of File objects, sort it so that the directories come before the ﬁles, and within each group, elements are sorted by path name.
Take a ﬁle from one of your projects that contains a number of ActionListener, Runnable, or the like.
Runnable? Write a method uncheck that catches all checked exceptions and turns them into unchecked exceptions.
Hint: Deﬁne an interface RunnableEx whose run method may throw any exceptions.
Write a static method andThen that takes as parameters two Runnable instances and returns a Runnable that runs the ﬁrst, then the second.
In the main method, pass two lambda expressions into a call to andThen, and run the returned instance.
What happens when a lambda expression captures values in an enhanced for loop such as this one?
Suppose you have a class that implements two interfaces I and J, each of or static method of I and an abstract, default, or static method of J? Repeat where a class extends a superclass S and implements an interface I, each.
In the past, you were told that it’s bad form to add methods to an interface because it would break existing code.
Now you are told that it’s okay to add new methods, provided you also supply a default implementation.
How safe is that? Describe a scenario where the new stream method of the Collection interface causes legacy code to fail compilation.
For example, if you want to compute the average of the values of a certain method, you specify that you want to call the method on each element and get the average of the values.
You leave it to the stream library to parallelize the operation, using multiple threads for computing sums and counts of each segment and combining the results.
Iterators imply a speciﬁc traversal strategy and prohibit efﬁcient concurrent execution.
You can create streams from collections, arrays, generators, or iterators.
Use filter to select elements and map to transform elements.
Other operations for transforming streams include limit, distinct, and sorted.
To obtain a result from a stream, use a reduction operator such as count, max, min, findFirst, or findAny.
The Optional type is intended as a safe alternative to working with null values.
To use it safely, take advantage of the ifPresent and orElse methods.
You can collect stream results in collections, arrays, strings, or maps.
The groupingBy and partitioningBy methods of the Collectors class allow you to split the contents of a stream into groups, and to obtain a result for each group.
There are specialized streams for the primitive types int, long, and double.
When you work with parallel streams, be sure to avoid side effects, and consider giving up ordering constraints.
You need to be familiar with a small number of functional interfaces in order to use the stream library.
When you process a collection, you usually iterate over its elements and do some work with each of them.
For example, suppose we want to count all long words in a book.
The stream method yields a stream for the words list.
The filter method returns another stream that contains only the words of length greater than twelve.
A stream seems superﬁcially similar to a collection, allowing you to transform and retrieve data.
They may be stored in an underlying collection or generated on demand.
This means they are not executed until their result is needed.
For example, if you only ask for the ﬁrst ﬁve long words instead of counting them all, then the filter method will stop ﬁltering after the ﬁfth match.
Many people ﬁnd stream expressions easier to read than the loop equivalents.
Simply changing stream into paralleStream allows the stream library to do the ﬁltering and counting in parallel.
In our stream example, we describe what needs to be done: get the long words and count them.
We don’t specify in which order, or in which thread, this should happen.
In contrast, the loop at the beginning of this section speciﬁes exactly how the computation should work, and thereby forgoes any chances of optimization.
When you work with streams, you set up a pipeline of operations in three stages.
You specify intermediate operations for transforming the initial stream into others, in one or more steps.
This operation forces the execution of the lazy operations that precede it.
In our example, the stream was created with the stream or parallelStream method.
The filter method transformed it, and count was the terminal operation.
NOTE: Stream operations are not executed on the elements in the order in which they are invoked on the streams.
In the next section, you will see how to create a stream.
You have already seen that you can turn any collection into a stream with the stream method that Java 8 added to the Collection interface.
If you have an array, use the static Stream.of method instead.
The of method has a varargs parameter, so you can construct a stream from any number of arguments:
Use Arrays.stream(array, from, to) to make stream from a part of an array.
To make a stream with no elements, use the static Stream.empty method:
The Stream interface has two static methods for making inﬁnite streams.
Whenever a stream value is needed, that function is called to produce a value.
The ﬁrst element in the sequence is the seed BigInteger.ZERO.
The second element is f(seed), or 1 (as a big integer)
The next element is f(f(seed)), or 2, and so on.
NOTE: A number of methods that yield streams have been added to the API with the Java 8 release.
For example, the Pattern class now has a method splitAsStream that splits a CharSequence by a regular expression.You can use the following statement to split a string into words:
The static Files.lines method returns a Stream of all lines in a ﬁle.
When the close method is called on the stream, the underlying ﬁle is also closed.To make sure that this happens, it is best to use the Java 7 try-with-resources statement:
The stream, and the underlying ﬁle with it, will be closed when the try block exits normally or through an exception.
A stream transformation reads data from a stream and puts the transformed data into another stream.
You have already seen the filter transformation that yields a new stream with all elements that match a certain condition.
Here, we transform a stream of strings into another stream containing only long words:
The argument of filter is a Predicate<T>—that is, a function from T to boolean.
Often, you want to transform the values in a stream in some way.
Use the map method and pass the function that carries out the transformation.
For example, you can transform all words to lowercase like this:
The resulting stream contains the ﬁrst character of each word.
When you use map, a function is applied to each element, and the return values are collected in a new stream.
Now suppose that you have a function that returns not just one value but a stream of values, such as this one:
Suppose you map this method on a stream of strings:
NOTE: You may ﬁnd a flatMap method in classes other than streams.
Then you can compose them, that is, ﬁrst apply f and then g, by using flatMap.
This is a key idea in the theory of monads.
But don’t worry—you can use flatMap without knowing anything about monads.
The call stream.limit(n) returns a new stream that ends after n elements (or when the original stream ends if it is shorter)
This method is particularly useful for cutting inﬁnite streams down to size.
This is handy in our book reading example where, due to the way the split method works, the ﬁrst element is an unwanted empty string.
You can concatenate two streams with the static concat method of the Stream class:
Of course, the ﬁrst stream should not be inﬁnite—otherwise the second wouldn’t ever get a chance.
TIP: The peek method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved.
When an element is actually accessed, a message is printed.
This way you can verify that the inﬁnite stream returned by iterate is processed lazily.
When an element is retrieved from a ﬁltered or mapped stream, the answer does not depend on the previous elements.
For example, the distinct method returns a stream that yields elements from the original stream, in the same order, except that duplicates are suppressed.
The stream must obviously remember the elements that it has already seen.
The sorted method must see the entire stream and sort it before it can give out any elements—after all, the smallest one might be the last one.
One works for streams of Comparable elements, and another accepts a Comparator.
Here, we sort strings so that the longest ones come ﬁrst:
Of course, you can sort a collection without using streams.
The sorted method is useful when the sorting process is a part of a stream pipeline.
NOTE: The Collections.sort method sorts a collection in place, whereas Stream.sorted returns a new sorted stream.
Now that you have seen how to create and transform streams, we will ﬁnally get to the most important point—getting answers from the stream data.
The methods that we cover in this section are called reductions.
They reduce the stream to a value that can be used in your program.
After a terminal operation has been applied, the stream ceases to be usable.
You have already seen a simple reduction: the count method that returns the number of elements of the stream.
Other simple reductions are max and min that return the largest or smallest value.
In the olden days, it was common to return null in such a situation.
But that can lead to null pointer exceptions when an unusual situation arises in an incompletely tested program.
In Java 8, the Optional type is the preferred way of indicating a missing return value.
We discuss the Optional type in detail in the next section.
Here is how you can get the maximum of a stream:
The findFirst returns the ﬁrst value in a nonempty collection.
For example, here we ﬁnd the ﬁrst word that starts with the letter Q, if it exists:
If you are okay with any match, not just the ﬁrst one, then use the findAny method.
This is effective when you parallelize the stream since the ﬁrst match in any of the examined segments will complete the computation.
If you just want to know there is a match, use anyMatch.
That method takes a predicate argument, so you won’t need to use filter.
There are also methods allMatch and noneMatch that return true if all or no elements match a predicate.
These methods always examine the entire stream, but they still beneﬁt from being run in parallel.
An Optional<T> object is either a wrapper for an object of type T or for no object.
It is intended as a safer alternative than a reference of type T that refers to an object or null.
But it is only safer if you use it right.
The get method gets the wrapped element if it exists, or throws a NoSuchElementException if it doesn’t.
As you saw in the preceding section, the isPresent method reports whether an Optional<T> object has a value.
In the next section, you will see how you should really work with Optional values.
The key to using Optional effectively is to use a method that either consumes the correct value or produces an alternative.
There is a second form of the ifPresent method that accepts a function.
If the optional value exists, it is passed to that function.
For example, if you want to add the value to a set if it is present, call.
When calling this version of ifPresent, no value is returned.
If you want to process the result, use map instead:
Now added has one of three values: true or false wrapped into an Optional, if optionalValue was present, or an empty optional otherwise.
Simply imagine an optional value as a stream of size zero or one.
The result again has size zero or one, and in the latter case, the function has been applied.
You have just seen how to gracefully consume an optional value when it is present.
The other strategy for working with optional values is to produce an alternative if no value is present.
Often, there is a default that you want to use when there was no match, perhaps the empty string:
Or, if you want to throw another exception if there is no value,
So far, we have discussed how to consume an Optional object that someone else created.
If you write a method that creates an Optional object, there are several static methods for that purpose.
The ofNullable method is intended as a bridge from the use of null values to optional values.
If they were normal methods, you could compose has type Optional<T>,has not T.
Clearly, you can repeat that process if you have more methods or lambdas that yield Optional values.
You can then build a pipeline of steps that succeeds only when all parts do, simply by chaining calls to flatMap.
For example, consider the safe inverse method of the preceding section.
Then you can compute the square root of the inverse as.
The Optional.flatMap method works in the same way if you consider an optional value to be a stream of size zero or one.
If you want to compute a sum, or combine the elements of a stream to a result in another way, you can use one of the reduce methods.
The simplest form takes a binary function and keeps applying it, starting with the ﬁrst two elements.
It’s easy to explain this if the function is the sum:
The method returns an Optional because there is no valid result if the stream is empty.
There are many associative operations that might be useful in practice, such as sum and product, string concatenation, maximum and minimum, set union and intersection.
An example of an operation that is not associative is subtraction.
The identity value is returned if the stream is empty, and you no longer need to deal with the Optional class.
Now suppose you have a stream of objects and want to form the sum of some property, such as all lengths in a stream of strings.
It requires a function (T, T) -> T, with the same types for the arguments and the result.
The stream elements have type String, and the accumulated result is an integer.
There is a form of reduce that can deal with this situation.
But when the computation is parallelized, there will be multiple computations of this kind, and you need to combine their results.
NOTE: In practice, you probably won’t use the reduce method a lot.
It is usually easier to map to a stream of numbers and use one of its methods to compute sum, max, or min.
When you are done with a stream, you often just want to look at the results instead of reducing them to a value.
You can call the iterator method, which yields an old-fashioned iterator that you can use to visit the elements.
Or you can call toArray and get an array of the stream elements.
Since it is not possible to create a generic array at runtime, the expression pass in the array constructor:
Now suppose you want to collect the results in a HashSet.
If the collection is parallelized, you can’t put the elements directly into a single HashSet because a HashSet object is not threadsafe.
Each segment needs to start out with its own empty hash set, and reduce only lets you supply one identity value.
A supplier to make new instances of the target object, for example, a constructor for a hash set.
It could be a StringBuilder or an object that tracks a count and a sum.
Here is how the collect method works for a hash set:
In practice, you don’t have to do that because there is a convenient Collector interface for these three functions, and a Collectors class with factory methods for common collectors.
To collect a stream into a list or set, you can simply call.
If you want to control which kind of set you get, use the following call instead:
Suppose you want to collect all strings in a stream by concatenating them.
If you want a delimiter between elements, pass it to the joining method:
If your stream contains objects other than strings, you need to ﬁrst convert them to strings, like this:
If you want to reduce the stream results to a sum, average, maximum, or minimum, then use one of the methods summarizing(Int|Long|Double)
These methods take a function that maps the stream objects to a number and yield a result of type (Int|Long|Double)SummaryStatistics, with methods for obtaining the sum, average, maximum, and minumum.
NOTE: So far, you have seen how to reduce or collect stream values.
But perhaps you just want to print them or put them in a database.
The function that you pass is applied to each element.
On a parallel stream, it’s your responsibility to ensure that the function can be executed concurrently.
On a parallel stream, the elements can be traversed in arbitrary order.
If you want to execute them in stream order, call forEachOrdered instead.
Of course, you might then give up most or all of the beneﬁts of parallelism.
The forEach and forEachOrdered methods are terminal operations.You cannot use the stream again after calling them.
Suppose you have a Stream<Person> and want to collect the elements into a map so that you can later look up people by their ID.
The Collectors.toMap method has two function arguments that produce the map keys and values.
In the common case that the values should be the actual elements, use Function.
If there is more than one element with the same key, the collector will throw an IllegalStateException.
You can override that behavior by supplying a third function argument that determines the value for the key, given the existing and the new value.
Your function could return the existing value, the new value, or a combination of them.
Here, we construct a map that contains, for each language in the available locales, as key its name in your default locale (such as "German"), and as value its localized name (such as "Deutsch")
We don’t care that the same language might occur twice—for example, German in Germany and in Switzerland, and we just keep the ﬁrst entry.
However, suppose we want to know all languages in a given country.
At ﬁrst, we store a singleton set for each language.
Whenever a new language is found for a given country, we form the union of the existing and the new set.
You will see a simpler way of obtaining this map in the next section.
If you want a TreeMap, then you supply the constructor as the fourth argument.
Here is one of the examples from the beginning of the section, now yielding a TreeMap:
NOTE: For each of the toMap methods, there is an equivalent toConcurrentMap method that yields a concurrent map.
A single concurrent map is used in the parallel collection process.
When used with a parallel stream, a shared map is more efﬁcient than merging maps, but of course, you give up ordering.
In the preceding section, you saw how to collect all languages in a given country.
You had to generate a singleton set for each map value, and then specify how to merge the existing and new values.
Forming groups of values with the same characteristic is very common, and the groupingBy method supports it directly.
Let’s look at the problem of grouping locales by country.
The function Locale::getCountry is the classiﬁer function of the grouping.
You can now look up all locales for a given country code, for example.
NOTE: A quick refresher on locales: Each locale has a language code (such as en for English) and a country code (such as US for the United States)
For example, ga_IE is Gaelic in Ireland, and, as the preceding example shows, my JVM knows three locales in Switzerland.
When the classiﬁer function is a predicate function (that is, a function returning a boolean value), the stream elements are partitioned into two lists: those where the function returns true and the complement.
In this case, it is more efﬁcient to use partitioningBy instead of groupingBy.
For example, here we split all locales into those that use English, and all others:
NOTE: If you call the groupingByConcurrent method, you get a concurrent map that, when used with a parallel stream, is concurrently populated.
The groupingBy method yields a map whose values are lists.
NOTE: In this example, as well as the remaining examples of this chapter, I assume a static import of java.util.stream.Collectors.* to make the expressions easier to read.
Several other collectors are provided for downstream processing of grouped elements:
Within each state, we produce the names of the cities and reduce by maximum length.
The mapping method also yields a nicer solution to a problem from the preceding section, to gather a set of all languages in a country.
In the preceding section, I used toMap instead of groupingBy.
In this form, you don’t need to worry about combining the individual sets.
Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.
Finally, the reducing methods apply a general reduction to downstream elements.
There are three forms: reducing(binaryOperator), reducing(identity, binaryOperator), and reducing(identity, mapper, binaryOperator)
Note that this is different from the forms of Stream::reduce, where the method without an identity parameter yields an Optional result.) In the third form, the mapper function is applied and its values are reduced.
Here is an example that gets a comma-separated string of all city names in each state.
We map each city to its name and then concatenate them.
In this case, you can achieve the same result more naturally as.
You should only use them in connection with groupingBy or partitioningBy to process the “downstream” map values.
Otherwise, simply apply methods such as map, reduce, count, max, or min directly on streams.
So far, we have collected integers in a Stream<Integer>, even though it is clearly inefﬁcient to wrap each integer into a wrapper object.
The same is true for the other primitive types double, float, long, short, char, byte, and boolean.
The stream library has specialized types IntStream, LongStream, and DoubleStream that store primitive values directly, without using wrappers.
If you want to store short, char, byte, and boolean, use an IntStream, and for float, use a DoubleStream.
The library designers didn’t think it was worth adding another ﬁve stream types.
To create an IntStream, you can call the IntStream.of and Arrays.stream methods:
As with object streams, you can also use the static generate and iterate methods.
In addition, IntStream and LongStream have static methods range and rangeClosed that generate integer ranges with step size one:
The CharSequence interface has methods codePoints and chars that yield an IntStream of the Unicode codes of the characters or of the code units in the UTF-16 encoding.
If you don’t know what code units are, you probably shouldn’t use the chars method.
When you have a stream of objects, you can transform it to a primitive type stream with the mapToInt, mapToLong, or mapToDouble methods.
For example, if you have a stream of strings and want to process their lengths as integers, you might as well do it in an IntStream:
To convert a primitive type stream to an object stream, use the boxed method:
Generally, the methods on primitive type streams are analogous to those on object streams.
Methods that yield an optional result return an OptionalInt, OptionalLong, or OptionalDouble.
These classes are analogous to the Optional class, but they have methods getAsInt, getAsLong, and getAsDouble instead of the get method.
There are methods sum, average, max, and min that return the sum, average, maximum, and minimum.
The summaryStatistics method yields an object of type IntSummaryStatistics, LongSummaryStatistics, or DoubleSummaryStatistics that can simultaneously report the sum, average, maximum, and minimum of the stream.
NOTE: The Random class has methods ints, longs, and doubles that return primitive type streams of random numbers.
The process is mostly automatic, but you need to follow a few rules.
By default, stream operations create sequential streams, except for a parallel one.
As long as the stream is in parallel mode when the terminal method executes, all lazy intermediate stream operations will be parallelized.
When stream operations run in parallel, the intent is that the same result is returned as if they had run serially.
It is important that the operations are stateless and can be executed in an arbitrary order.
Suppose you want to count all short words in a stream of strings:
The function passed to forEach runs concurrently in multiple threads, updating a shared array.
If you run this program multiple times, you are quite likely to get a different sequence of counts in each run, each of them wrong.
It is your responsibility to ensure that any functions that you pass to parallel stream operations are threadsafe.
In our example, you could use an array of AtomicInteger objects for the counters (see Exercise 12)
Or you could simply use the facilities of the streams library and group strings by length (see Exercise 13)
By default, streams that arise from ordered collections (arrays and lists), from ranges, generators, and iterators, or from calling Stream.sorted, are ordered.
Results are accumulated in the order of the original elements, and are entirely predictable.
If you run the same operations twice, you will get exactly the same results.
For example, when computing stream.map(fun), the stream can be partitioned into n segments, each of which is concurrently processed.
Some operations can be more effectively parallelized when the ordering requirement is dropped.
By calling the Stream.unordered method, you indicate that you are not interested in ordering.
On an ordered stream, distinct retains the ﬁrst of all equal elements.
That impedes parallelization—the thread processing a segment can’t know which elements to discard until the preceding segment has been processed.
If it is acceptable to retain any of the unique elements, all segments can be processed concurrently (using a shared set to track duplicates)
You can also speed up the limit method by dropping ordering.
If you just want any n elements from a stream and you don’t care which ones you get, call.
For that reason, the Collectors.groupingByConcurrent method uses a shared concurrent map.
Clearly, to beneﬁt from parallelism, the order of the map values will not be the same as the stream order.
Even on an ordered stream, that collector has a “characteristic” of being unordered, so that it can be used efﬁciently without having to make the stream unordered.
CAUTION: It is very important that you don’t modify the collection that is backing a stream while carrying out a stream operation (even if the modiﬁcation is threadsafe)
Remember that streams don’t collect their own data—the data is always in a separate collection.
If you were to modify that collection, the outcome of the stream operations would be undeﬁned.
To be exact, since intermediate stream operations are lazy, it is possible to mutate the collection up to the point when the terminal operation executes.
In this chapter, you have seen many operations whose argument is a function.
In the javadoc of the Stream class, the filter method is declared as follows:
To understand the documentation, you have to know what a Predicate is.
It is an interface with one nondefault method returning a boolean value:
In practice, one usually passes a lambda expression or method reference, so the name of the method doesn’t really matter.
When reading the documentation of Stream.filter, just remember that a Predicate is a function returning a boolean.
For example, you may want to use Person::isAlive to ﬁlter a Stream<Employee>
That only works because of the wildcard in the parameter of the filter method.
Table 2–1 summarizes the functional interfaces that occur as parameters of the Stream and Collectors methods.
You will see additional functional interfaces in the next chapter.
A function with argument of type int, long, or double.
Make that many separate threads, each working on a segment of the list, and total up the results as they come in.
You don’t want the threads to update a single counter.
Verify that asking for the ﬁrst ﬁve long words does not call the ﬁlter method once the ﬁfth long word has been found.
Measure the difference when counting long words with a parallelStream instead of a stream.
Call System.currentTimeMillis before and after the call, and print the difference.
Switch to a larger document (such as War and Peace) if you have a fast computer.
Using Stream.iterate, make an inﬁnite stream of random numbers—not by calling Math.random but by directly implementing a linear congruential generator.
Why isn’t that such a good idea? Go ahead and write it anyway.
Show how to do this with the three forms of reduce.
Write a call to reduce that can be used to compute the average of a Stream<Double>
It should be possible to concurrently collect stream results in a single ArrayList, instead of merging multiple array lists, provided it has been constructed with.
Use the atomic getAndIncrement method to safely increment each counter.
Repeat the preceding exercise, but ﬁlter out the short strings and use the collect method with Collectors.groupingBy and Collectors.counting.
In this chapter, you will learn how to create your own libraries that make use of lambda expressions and functional interfaces.
The main reason for using a lambda expression is to defer the execution of the code until an appropriate time.
When a lambda expression is executed, make sure to provide any required data as inputs.
Choose one of the existing functional interfaces if you can.
It is often useful to write methods that return an instance of a functional interface.
When you work with transformations, consider how you can compose them.
To compose transformations lazily, you need to keep a list of all pending transformations and apply them in the end.
If you need to apply a lambda many times, you often have a chance to split up the work into subtasks that execute concurrently.
Think what should happen when you work with a lambda expression that throws an exception.
When working with generic types that can be transformed by functions, consider supplying map and flatMap.
After all, if you wanted to execute some code right now, you’d do that, without wrapping it inside a lambda.
There are many reasons for executing code later, such as.
Running the code at the right point in an algorithm (for example, the comparison operation in sorting)
Running the code when something happens (a button was clicked, data has arrived, and so on)
It is a good idea to think through what you want to achieve when you set out programming with lambdas.
What happens if the log level is set to suppress INFO messages? The message string is computed and passed to the info method, which then decides to throw it away.
Wouldn’t it be nicer if the string concatenation only happened when necessary?
Running code only when necessary is a use case for lambdas.
The standard idiom is to wrap the code in a no-arg lambda:
To accept the lambda, we need to pick (or, in rare cases, provide) a functional interface.
We use the isLoggable method of the Logger class to decide whether INFO messages should be logged.
If so, we invoke the lambda by calling its abstract method, which happens to be called get.
NOTE: Deferring logging messages is such a good idea that the Java 8 library designers beat me to it.
The info method, as well as the other logging methods, now have variants that accept a Supplier<String>.You can directly call potentially useful reﬁnement.
When you ask your user to supply a comparator, it is pretty obvious that the comparator has two arguments—the values to be compared.
Why an IntConsumer and not a Runnable? We tell the action in which iteration it occurs, which might be useful information.
The action needs to capture that input in a parameter.
The event object carries information that the action may need.
In general, you want to design your algorithm so that it passes any required information as arguments.
For example, when editing an image, it makes sense to have the user supply a function that computes the color for a pixel.
Such a function might need to know not just the current color, but also where the pixel is in the image, or what the neighboring pixels are.
However, if these arguments are rarely needed, consider supplying a second version that doesn’t force users into accepting unwanted arguments:
In Java, you instead declare the intent of the function, using a functional interface such as Comparator<String>
In the theory of programming languages this is called nominal typing.
There are a number of generic function types for that purpose (see Table 3–1), and it’s a very good idea to use one of them when you can.
For example, suppose you write a method to process ﬁles that match a certain criterion.
The only reason not to do so would be if you already have many useful methods producing FileFilter instances.
NOTE: Most of the standard functional interfaces have nonabstract methods for producing or combining functions.
For example, Predicate.isEqual(a) is the same as a::equals, provided a is not null.
And there are default methods and, or, negate for combining predicates.
We want to transform images, applying a Color -> Color function to each pixel.
For example, the brightened image in Figure 3–1 is obtained by calling.
There is a standard functional interface for this purpose: UnaryOperator<Color>
That is a good choice, and there is no need to come up with a ColorTransformer interface.
NOTE: This method uses the Color and Image classes from JavaFX, not from java.awt.
Sometimes, you need to supply your own functional interface because there is nothing in the standard library that works for you.
Suppose you want to modify colors in an image, allowing users to specify a function (int, int, Color) -> Color that computes a new color depending on the (x, y) location in the image.
NOTE: I called the abstract method apply because that is used for the majority of standard functional interfaces.
Sticking with the standard name simpliﬁes the life of the implementor.
Just like you can pass numbers to methods and have methods that produce numbers, you can have arguments and return values that are functions.
This sounds abstract, but it is very useful in practice.
Java is not quite a functional language because it uses functional interfaces, but the principle is the same.
In this section, we consider methods whose return type is a functional interface.
We can make a method that returns the appropriate UnaryOperator<Color>, with the brightness set:
The brighten method returns a function (or, technically, an instance of a functional interface)
That function can be passed to another method (here, transform) that expects such an interface.
In general, don’t be shy to write methods that produce functions.
This is useful to customize the functions that you pass to methods with functional interfaces.
For example, consider the Arrays.sort method with a Comparator argument.
NOTE: As you will see in Chapter 8, the Comparator class has several methods that yield or modify comparators.
If you have two such transformations, then doing one after the other is also a transformation.
Consider image manipulation: Let’s ﬁrst brighten an image, then turn it to grayscale (see Figure 3–2)
Just run the program in the companion code to see the effect.
For large images, that requires a considerable amount of storage.
If we could compose the image operations and then apply the composite operation to each pixel, that would be better.
In this case, the image operations are instances of UnaryOperator<Color>
That type has a method compose that, for rather depressing reasons that are explored in Exercise 10, is not useful for us.
Now the composed transformation is directly applied to each pixel, and there is no need for an intermediate image.
Generally, when you build a library where users can carry out one effect after another, it is a good idea to give library users the ability to compose these effects.
In the preceding section, you saw how users of an image transformation method can precompose operations to avoid intermediate images.
But why should they have to do that? Another approach is for the library to accumulate all operations and then fuse them.
If you do lazy processing, your API needs to distinguish between intermediate operations, which accumulate the tasks to be done, and terminal operations which deliver the result.
In the image processing example, we can make transform lazy, but then it needs to return another object that is not an Image.
A LatentImage can simply store the original image and a sequence of image operations.
To avoid duplicate transform methods, you can follow the approach of the stream.
Since we can’t add a method to the Image class, we can provide a LatentImage constructor or a static factory method.
We can provide a toImage method that applies all operations and returns the result:
CAUTION: In real life, implementing lazy operations is quite a bit harder.
Usually you have a mixture of operations, and not all of them can be applied lazily.
When expressing operations as functional interfaces, the caller gives up control over the processing details.
As long as the operations are applied so that the correct result is achieved, the caller has nothing to complain about.
For example, in image processing we can split the image into multiple strips and process each strip separately.
Here is a simple way of carrying out an image transformation in parallel.
This code operates on Color[][] arrays instead of Image objects because the JavaFX PixelWriter is not threadsafe.
Supporting image operations that combine multiple pixels would be a major challenge.
In general, when you are given an object of a functional interface and you need to invoke it many times, ask yourself whether you can take advantage of concurrency.
When you write a method that accepts lambdas, you need to spend some thought on handling and reporting exceptions that may occur when the lambda expression is executed.
When an exception is thrown in a lambda expression, it is propagated to the caller.
There is nothing special about executing lambda expressions, of course.
They are simply method calls on some object that implements a functional interface.
Often it is appropriate to let the expression bubble up to the caller.
However, the doInOrderAsync returns right away and does the work in a separate thread, so it is not possible to have the method rethrow the exception.
In this situation, it is a good idea to supply a handler:
Now suppose that first produces a result that is consumed by second.
It is often inconvenient that methods in functional interfaces don’t allow checked exceptions.
A an equivalent for a Consumer or a Function, you have to create it yourself.
You sometimes see suggestions to “ﬁx” this problem with a generic wrapper, like this:
You would need to implement a variation of unchecked for each functional interface.
You have seen a number of examples where we wrote generic mechanisms, such as the unchecked method of the preceding section.
There are just a couple of issues to keep in mind.
One of the unhappy consequences of type erasure is that you cannot construct arrays.
In the past, the solution was to provide a second method that accepts an array.
That array was either ﬁlled or used to create a new one via reﬂection.
With lambdas, you have a new option, namely to pass the constructor.
When you implement such a method, the constructor expression is an IntFunction<T[]>, since the size of the array is passed to the constructor.
In this regard, lambdas help you overcome a limitation of generic types.
Unfortunately, in another common situtation lambdas suffer from a different limitation.
To understand the problem, recall the concept of type variance.
Note that staff and tenants are references to the same list.
We say that the type parameter T of List<T> is invariant.
If List was immutable, as it is in a functional programming language, then the problem would disappear, and one could have a covariant list.
That is what is done in languages such as Scala.
However, when generics were invented, Java had very few immutable generic classes, and the language designers instead embraced a different concept: use-site variance, or “wildcards.”
It is okay to write employees into a List<Person>, so you can pass such a list.
In general, reading is covariant (subtypes are okay) and writing is contravariant (supertypes are okay)
It gives each service the choice which variance, if any, is appropriate.
A function type is always contravariant in its arguments and covariant in its return value.
They will only call it with employees, whereas your function can handle any person.
They will expect the function to return a person, and you give them something even better.
In Java, when you declare a generic functional interface, you can’t specify that function arguments are always contravariant and return types always covariant.
The general rule is that you use super for argument types, extends for return types.
If it is willing to consume any object, surely it can consume strings.
Since T is the argument and return type of BinaryOperator, the type does not vary.
In effect, the contravariance and covariance cancel each other out.
For example, consider the doInOrderAsync method of the preceding section.
When you work with generic types, and with functions that yield values from these types, it is useful to supply methods that let you compose these functions—that is, carry out one after another.
In this section, you will see a design pattern for providing such compositions.
How this works exactly depends on the nature of the generic type G.
For example, applying a function f to a List with elements e1,
Applying f to a Future<T> simply means to apply it whenever it is available.
The CompletableFuture class that we will discuss in Chapter 6 has an operation that does just what map should do, but it is called thenApply.
For example, consider getting the web page for a URL.
Now suppose you have a Future<URL>, a URL that will arrive sometime.
Clearly it makes sense to map the function to that Future.
Wait for the URL to arrive, then feed it to the function and wait for the string to arrive.
You want to “ﬂatten” the set of sets so that you get the set of all possible values of both functions.
NOTE: These operations are important in the theory of monads, but you don’t need to know the theory to understand map and flatMap.
The concept of mapping a function is both straightforward and useful, and the point of this section is to make you aware of it.
Don’t evaluate the condition if the logger won’t log the message.
When you use a ReentrantLock, you are required to lock and unlock with the idiom.
Java 1.4 added assertions to the language, with an assert keyword.
We want to put a frame around an image, like this:
Then call it with an appropriate lambda expression to put a 10 pixel gray frame replacing the pixels on the border of an image.
Write a method that generates a Comparator<String> that can be normal or reversed, case-sensitive or case-insensitive, space-sensitive or space-insensitive, or any combination thereof.
Generalize Exercise 5 by writing a static method that yields a ColorTransformer that adds a frame of arbitrary thickness and color to an image.
For example, a lexicographicComparator("lastname", "firstname") takes two objects and, using reﬂection, gets the values of the lastname ﬁeld.
If they are different, return the difference, otherwise move on to the firstname ﬁeld.
Look carefully at the return type of the compose method of UnaryOperator<T>
Why is it not appropriate for the transform method? What does that say about.
Implement static methods that can compose two ColorTransformer objects, and a static method that turns a UnaryOperator<Color> into a ColorTransformer that ignores the x- and y-coordinates.
Then use these methods to add a gray frame to a brightened image.
Convolution ﬁlters such as blur or edge detection compute a pixel from neighboring pixels.
To blur an image, replace each color value by the average of itself and its eight neighbors.
Enhance the lazy image processing to deal with these operations.
Force computation of the previous stage when one of these operators is evaluated.
To deal with lazy evaluation on a per-pixel basis, change the transformers so that they are passed a PixelReader object from which they can read other pixels in the image.
For example, (x, y, reader) -> reader.get(width - x, y) is a mirroring operation.
The convolution ﬁlters from the preceding exercises can be easily implemented in terms of such a reader.
The straightforward operations you can provide an adapter from UnaryOperation<Color>
A PixelReader is at a particular level in the pipeline of operations.
Keep a cache of recently read pixels at each level in the pipeline.
If a reader is asked for a pixel, it looks in reader that asks the previous transform.
Implement a doInParallelAsync(Runnable first, Runnable second, Consumer<Throwable>) method that executes first and second in parallel, calling the handler if either method throws an exception.
Note that you will need to ﬁnd or provide a functional interface whose abstract method throws arbitrary exceptions.
Return an object of an anonymous class that implements all methods of the Future interface.
Deﬁne a map operation for a class Pair<T> that represents a pair of objects of type T.
JavaFX is now bundled with all supported versions of Oracle’s Java platform.
In this chapter, you will learn the basics of JavaFX development.
If you develop rich client user interface platforms, you will see how to transition from Swing to JavaFX.
If you don’t, skim over the chapter anyway so you can understand the sample applications we use elsewhere when it is convenient to illustrate a concept with a graphical program.
A scene graph is made up of nodes which may contain other nodes.
A scene is displayed on a stage (a top-level window, the surface of an applet, or the full screen)
Some controls (such as buttons) emit events, but most JavaFX events come from property changes.
When you bind a property to another, it is updated when the other one changes.
JavaFX uses layout panes that work similar to layout managers in Swing.
You can use CSS to change the visual appearance of your application.
JavaFX provides some advanced controls out of the box, such as charts, an embedded WebKit browser, and a media player.
When Java was born, the Internet was in its infancy and personal computers were on every desktop.
Java 1.0 included the AWT, a toolkit for graphical user interfaces, that had the distinction of being cross-platform.
The idea was to serve up the fat clients over the nascent Web, eliminating the cost of managing and updating the applications on every desktop.
The AWT had a noble idea: provide a common programming interface for the native buttons, sliders, text ﬁelds, and so on of various operating systems.
The central idea behind Swing was not to use the native widgets, but to paint its own.
That way, the user interface would look and feel the same on every platform.
Or, if users preferred, they could ask for the native look and feel of their platform, and the Swing widgets would be painted to match the native ones.
Of course, all that painting was slow, and users complained.
After a while, computers got faster, and users complained that Swing was ugly—indeed, it had fallen behind the native widgets that had been spruced up with animations and fancy effects.
More ominously, Flash was increasingly used to create user interfaces with even ﬂashier effects that didn’t use the native controls at all.
In 2007, Sun Microsystems introduced a new technology, called JavaFX, as a competitor to Flash.
It ran on the Java VM but had its own programming language, called JavaFX Script.
The language was optimized for programming animations and fancy effects.
Programmers complained about the need to learn a new language, and they stayed away in droves.
Of course, Flash is now a bad memory, and most user interfaces live in a browser or a mobile device.
JavaFX is what Oracle wants us to use for those applications.
Why didn’t Oracle just put the good parts of JavaFX into Swing? Swing would have to be redesigned from the ground up to run efﬁciently on modern graphics hardware.
Oracle decided that it wasn’t worth the trouble and declared that Swing will not be further developed.
In this chapter, we go over the basics of writing user interfaces in JavaFX, focusing on boring business applications with buttons, sliders, and text ﬁelds, not the ﬂashy effects that were the original motivation behind JavaFX.
In Swing, the equivalent control was called JLabel to distinguish it from the AWT Label.
This Font constructor makes a font object representing the default font at 100 points.
In JavaFX, you put everything you want to show onto a scene.
There, you can decorate and animate your “actors”—that is, your controls and shapes.
In our program, we won’t do any decorating or animating, but we still need the scene.
That is a top-level window if the program runs on a desktop, or a rectangular area if it runs as an applet.
The stage is passed as a parameter to the start method that you must override in a subclass of the Application class.
NOTE: As you see from this example, no main method is required to launch a JavaFX application.
In previous versions of JavaFX, you were required to include a main method of the form.
As they carry out these actions, the UI reacts and updates itself.
As in Swing, you add an event handler to a button so you can be notiﬁed when it is clicked.
In this case, it sets the text color to red.
However, you shouldn’t listen to the low-level events that the slider emits to indicate those changes.
Instead, the slider has a JavaFX property called value, and the property emits events when it changes.
We will discuss properties in detail in the next section, but here is how you can listen to the property’s events and adjust the font size of the message:
For example, if you want to change a part of the user interface as a user enters text into a text ﬁeld, add a listener to the text property.
A property is an attribute of a class that you can read or write.
Commonly, the property is backed by a ﬁeld, and the property getter and setter simply read and write that ﬁeld.
But the getter and setter can also take other actions, such as reading values from a database or sending out change notiﬁcations.
In many programming languages, there is convenient syntax for invoking property getters and setters.
Typically, using the property on the right-hand side of an assignments calls the getter, and using it on the left-hand side calls the setter.
In many languages (but not Java), this calls the property getter.
But it has supported properties by convention since Java 1.1
The JavaBeans speciﬁcation states that a property should be inferred from a getter/setter pair.
For example, a class with methods String Introspector and BeanInfo classes in the java.beans package let you enumerate all properties of a class.
The JavaBeans speciﬁcation also deﬁnes bound properties, where objects emit property change events when the setters are invoked.
JavaFX does not make use of this part of the speciﬁcation.
For example, a JavaFX text property has a method Property<String> from old-fashioned JavaBeans.
In JavaFX, the property object, not the bean, sends out notiﬁcations.
Implementing bound JavaBeans properties required boilerplate code to add, remove, and ﬁre listeners; in JavaFX it’s much simpler because there are library classes that do all that work.
Let’s see how we can implement a property text in a class Greeting.
It has methods for getting and setting the wrapped value and for managing listeners.
As you can see, implementing a JavaFX property requires some boilerplate code, and there is unfortunately no way in Java to generate the code automatically.
But at least you won’t have to worry about managing listeners.
It is not a requirement to declare property getters and setters as final, but the JavaFX designers recommend it.
NOTE: With this pattern, a property object is needed for each property, whether anyone listens to it or not.
Exercise 2 explores a useful optimization for the pattern, creating the property objects lazily.
All these are abstract classes with concrete subclasses SimpleIntegerProperty, SimpleObjectProperty<T>, and so on.
NOTE: The property classes have methods getValue and setValue in addition to the get and set methods.
In the StringProperty class, get is identical to getValue, and set to setValue.
For example, in an IntegerProperty, getValue returns an Integer, and get returns an int.
Generally, use get and set unless you write generic code that needs to work with properties of any type.
There are two kinds of listeners that can be attached to a property.
A ChangeListener is notiﬁed when the property value has changed, and an InvalidationListener is called when the property value may have changed.
As you will see in the next section, some properties are computed from others, and the computation is only done when necessary.
The ChangeListener callback tells you the old and new value, which means it has to compute the new value.
The InvalidationListener doesn’t compute the new value, but that means you might get a callback when the value hasn’t actually changed.
It doesn’t matter much whether you get the new value as a callback parameter or from the property.
And usually, it is not worth worrying about computed properties that happen to stay unchanged even though one of their inputs changed.
In the preceding section, I used an InvalidationListener because it made the code simpler.
CAUTION: It is a bit tricky to use the ChangeListener interface for numeric properties.
Therefore, the type for oldValue and newValue is Number and not Double, so you have to manually unbox:
The raison d’être for JavaFX properties is the notion of binding: automatically updating one property when another one changes.
When the user edits the top address, the bottom one is updated as well.
This is achieved by binding one property to the other:
Under the hood, a change listener is added to the text property of shipping that sets the text property of billing.
If either of the properties changes, the other is updated.
The binding mechanism solves a common problem in user interface programming.
For example, consider a date ﬁeld and a calendar picker.
When the user picks a date from the calendar, the date ﬁeld should be automatically updated, as should be the date property of the model.
Of course, in many situations, one property depends on another, but the relationship is more complex.
That is, its centerX property should be one half of the width property of the scene.
To achieve this, we need to produce a computed property.
Figure 4–4 The center of this circle is bound to half the width and height of the scene.
All that remains is to bind that computed property to the circle’s centerX property:
We want to disable the Smaller and Larger buttons when the gauge is too small or large (Figure 4–5)
Table 4–1 lists all operators that the Bindings class provides.
One or both of the arguments implement the Observable interface or one of its subinterfaces.
The Observable interface provides methods for adding and removing an InvalidationListener.
The ObservableValue interface adds ChangeListener management and a getValue method.
Its subinterfaces provide methods to get the value in the appropriate type.
For example, the get method of ObservableStringValue returns a String and the get method of ObservableIntegerValue returns an int.
Figure 4–5 When the gauge reaches either end, a button is disabled.
A Binding knows about all properties on which it depends.
In practice, you don’t need to worry about all of these interfaces.
You combine properties and you get something that you can bind to another property.
Two of ObservableNumberValue, int, long, float, double or two of ObservableStringValue, String.
If any of the objects is an ObservableValue that changes, the concatenation changes too.
An optional locale, a MessageFormat string, and a sequence of objects that are formatted.
If any of the objects is an ObservableValue that changes, the formatted string changes too.
An ObservableList and an index, or an ObservableMap and a key.
An Object or ObservableValue and a sequence of public property names, yielding the property obj.p1.p2
The conditional value is recomputed whenever an observable value changes.
Building up a computed property with the methods of the Bindings class can get quite baroque.
There is another approach for producing computed bindings that you may ﬁnd easier.
Simply put the expression that you want to have computed into a lambda, and supply a list of dependent properties.
When any of the properties changes, the lambda is recomputed.
Exercise 5 suggests a slightly more elegant way of lazily evaluating bindings with lambda expressions.
NOTE: In the JavaFX Script language, the compiler analyzed binding expressions and automatically ﬁgured out the dependent properties.You just to the gauge.width property.
Of course, in Java, the programmer needs to supply this information.
When a graphical user interface contains multiple controls, they need to be arranged on the screen in a functional and attractive way.
One way to obtain a layout is with a design tool.
The tool’s user, often a graphics designer, drags images of the controls onto a design view and arranges, resizes, and conﬁgures them.
However, this approach can be problematic when the sizes of the elements change, for example, because labels have different lengths in international versions of a program.
Alternatively, the layout can be achieved programmatically, by writing code in a setup method that adds the user interface controls to speciﬁc positions.
That is what was done in Swing, using layout manager objects.
Another approach is to specify the layout in a declarative language.
For example, web pages are laid out with HTML and CSS.
When you understand the concepts of this section, you will ﬁnd it straightforward to use.
However, instead of layout managers that are added to arbitrary panels, one uses panes—containers with a layout policy.
NOTE: With the Swing BorderLayout, buttons were expanded to ﬁll each region of the layout.
In JavaFX, a button does not expand past its natural size.
Now suppose you want more than one button in the South area.
Of course, there is a VBox for laying out controls vertically.
Without it, the label and the buttons would touch the window border.
In our example, we use ten pixels for the box spacing and padding.
This is not really appropriate nowadays, when pixel densities can vay widely.
One way to overcome this is to compute dimensions in rem, as you would do in CSS3
There is only so much you can achieve with horizontal and vertical boxes.
Think of a GridPane as an equivalent of an HTML table.
You can set the horizontal and vertical alignment of all cells.
Figure 4–9 A GridPane can arrange the controls for this login dialog.
The buttons are in an HBox that spans two rows.
When you add a child to a GridPane, specify its column and row index (in that order; think x- and y-coordinates)
If a child spans multiple columns or rows, specify the spans after the positions.
For example, the button panel spans two columns and one row:
If you want a child to span all remaining rows or columns, you can use GridPane.REMAINING.
To set the horizontal alignment of a child, use the static setHalignment method, and pass the child reference and a constant LEFT, CENTER, or RIGHT from the HPos enumeration.
Similarly, for vertical alignment, call setValignment and use TOP, CENTER, or BOTTOM from the VPos enumeration.
NOTE: These static calls look rather inelegant in Java code, but they make sense in the FXML markup language—see the next section.
CAUTION: Do not center the HBox with the buttons inside the grid.
That box has expanded to the full horizontal size, and centering will not change its position.
You will also want to provide some spacing around the rows and columns and some padding around the table:
TIP: For debugging, it can be useful to see the cell boundaries (see Figure 4–10)
If you want to see the borders of an individual child (for example, to see whether it has grown to ﬁll the entire cell), set its border.
Figure 4–10 Use visible grid lines when debugging a GridPane.
These layout panes should sufﬁce for the majority of applications.
Lays out children in a tabular grid, similar to the Swing GridBagLayout.GridPane.
Lays out children in a grid, giving them all the same size, similar to the Swing GridLayout.
Flows children in rows, making new rows when there isn’t sufﬁcient space, similar to the Swing FlowLayout.
Children can be positioned in absolute positions, or relative to pane’s boundaries.
Can be useful for decorating components, such as stacking a button over a colored rectangle.
NOTE: In this section, we built up user interfaces by manually nesting panes and controls.
That’s amazingly verbose, and it’s not even the full story—one still needed to specify the grid constraints.
Builders have been deprecated in JavaFX 8, not because they are so verbose, but because of an implementation issue.
To save code, builders have an inheritance tree that parallels the inheritance of the corresponding nodes.
What should PaneBuilder.children return? If it only returns a PaneBuilder, then the user has to be very careful to ﬁrst conﬁgure the subclass properties, then the superclass properties.
The JavaFX designers tried to solve this problem with generics.
If you like builders, you can use Scala or Groovy and their JavaFX bindings (https://code.google.com/p/scalafx, http://groovyfx.org)
The markup language that JavaFX uses to describe layouts is called FXML.
I discuss it in some detail because the concepts are interesting beyond the needs of JavaFX, and the implementation is fairly general.
Here is the FXML markup for the login dialog of the preceding section:
First off, the nesting of the GridPane, the labels and text ﬁelds, the HBox and its button children reﬂects the nesting that we built up with Java code in the preceding section.
When an attribute starts with a class name and a static method, that method is invoked.
NOTE: Generally, an FXML element is constructed with its default constructor and then customized by calling property setters or static methods, in the spirit of the JavaBeans speciﬁcation.
There are a few exceptions that we will consider later.
When a property value is too complex to express as a string, one uses nested elements instead of attributes.
The padding property has type Insets, and the Insets object is constructed with an.
You can write FXML ﬁles by hand, or you can use the SceneBuilder program that I mentioned in the preceding section.
Once you have such a ﬁle, load it like this:
The user interface is displayed, but the program cannot access the values that the user provides.
One way of establishing a connection between the controls and the program is to use id attributes, as you would in JavaScript.
In the controller’s initialize method, you wire up the binders and event handlers.
Any class can be the controller, even the FX application itself.
For example, here is a controller for our login dialog:
In the FXML ﬁle, provide the names of the controller’s instance variables to the corresponding control elements in the FXML ﬁle, using the fx:id (not id) attribute:
In the root element, you also need to declare the controller class, using the fx:controller attribute:
NOTE: If your controller doesn’t have a default constructor (perhaps, because it is being initialized with a reference to a business service), you can set it programmatically:
CAUTION: If you set the controller programmatically, really use the code from the preceding note.
The following code will compile, but it will invoke the static FXMLLoader.load method, ignoring the constructed loader:
When the FXML ﬁle is loaded, the scene graph is constructed, and references to the named control objects are injected into the annotated ﬁelds of the controller object.
It is even possible do much of the initialization in the FXML ﬁle.
You can deﬁne simple bindings, and you can set annotated controller methods as event listeners.
It seems better to separate the visual design from the program behavior, so that a user interface designer can produce the design and a programmer can implement the behavior.
NOTE: It is also possible to add scripts in JavaScript or another scripting language to an FXML ﬁle.
JavaFX lets you change the visual appearance of the user interface with CSS, which is usually more convenient than supplying FXML attributes or calling Java methods.
You can load a CSS style sheet programmatically and have it applied to a scene graph:
In the style sheet, you can reference any controls that have an ID.
For example, here is how you can control the appearance of a GridPane.
Unfortunately, you can’t use the familiar CSS attributes but need to know FX-speciﬁc attributes that start with -fx-
The attribute names are formed by changing the property names to lowercase and using hyphens instead of camel case.
You can ﬁnd all supported attributes in the JavaFX CSS reference at http://docs.oracle.com/ javafx/2/api/javafx/scene/doc-ﬁles/cssref.html.
Using CSS is nicer than cluttering up the code with layout minutiae.
Of course CSS can be used both for good and for evil (see Figure 4–11), and I hope you will resist the temptation to apply gratuitous background textures to your login dialogs.
Instead of styling by individual IDs, you can use style classes.
Every JavaFX control and shape class belongs to a CSS class whose name is the decapitalized Java class name.
Here is how you can change the font for all labels to Comic Sans:
Then you can specify most styling in CSS, and use FXML only for layout.
Unfortunately, you can’t completely remove all styling from the FXML.
For example, there is currently no way to specify grid cell alignment in CSS.
NOTE: You can also apply a CSS style programmatically, such as.
That can be handy for debugging, but in general, it seems better to use an external stylesheet.
When JavaFX was born, special effects were all the rage, and JavaFX makes it easy to produce shadows, blurs, and movement.
I thought you’d enjoy some useful tips on how to bring these animations to the world of business applications.
Figure 4–12 shows an application where the Yes button increases in size while the No button fades into the background and the Maybe button rotates.
JavaFX deﬁnes a number of transitions that, over a period of time, vary a property of a node.
Here is how you grow a node by 50% in both x and y directions over three seconds:
The node can be any node in a scene graph, such as a circle in an animation of soap bubbles or the ever more enticing Yes button in our example.
As set up, the transition will end when its goal is met.
Now the node will get bigger, then smaller, then bigger again, and so on.
Here is how the No button fades into the background:
The following code animates the rotation of the Maybe button:
You can compose transitions with the ParallelTransition and SequentialTransition combinators, performing them in parallel or one after the other.
If you need to animate multiple nodes, you can place them into a Group node and animate that.
When you need to create this kind of behavior, the JavaFX classes are a joy to work with.
If you need a drop shadow for a spiffy caption, make a DropShadow effect and set it as the effect property of a node.
To set a glow or a blur effect is just as simple:
Admittedly, the glow effect looks a bit cheesy and the blur effect doesn’t seem to have many applications in the world of business, but it is impressive how easy it is to produce these effects.
Of course, JavaFX has combo boxes, tab panes, trees, and tables, just like Swing does, as well as a few user interface controls that Swing never got, such as a date picker and an accordion.
It would take an entire book to describe these in detail.
In this section, I want to dispel any remaining Swing nostalgia by showing you three fancy controls that are far beyond what Swing had to offer.
Figure 4–14 shows one of many charts that you can make with JavaFX, out of the box, without having to install any third-party libraries.
Altogether, there are half a dozen chart types that you can use and customize.
In Swing, you could show HTML in a JEditorPane, but the rendering was poor for most real-world HTML.
In fact, it is so hard that most browsers are built on top of the open source WebKit engine.
A WebView displays an embedded native WebKit window (see Figure 4–15)
The browser is live—you can click on links in the usual way.
However, if you want to display status line or popup messages from JavaScript, you need to install notiﬁcation handlers and implement your own status line and popups.
NOTE: WebView does not support any plugins, so you cannot use it to show Flash animations or PDF documents.
A Java Media Framework was available as an optional download, but it did not get much love from the developers.
Of course, implementing audio and video playback is even harder than writing a browser.
Therefore, JavaFX leverages an existing toolkit, the open source GStreamer framework.
To play a video, construct a Media object from an URL string, construct a MediaPlayer to play it, and a MediaView to show the player:
You can add your own (see http://docs.oracle.com/javafx/ 2/media/playercontrol.htm, but it would have been nice to supply a default set of controls.
NOTE: Ever so often, GStreamer can’t handle a particular video ﬁle.The error handler in the code sample displays GStreamer messages so that you can diagnose playback problems.
That brings us to the end of this quick tour through JavaFX.
It has a few rough edges, mostly due to a hurried transformation from the original scripting language.
But it is certainly no harder to use than Swing, and it has many more useful and attractive controls than Swing ever had.
Write a program with a text ﬁeld and a label.
As with the Hello, JavaFX program, the label should have the string Hello, FX in a 100 point font.
Update the label as the user edits the text ﬁeld.
Consider a class with many JavaFX properties, such as a chart or table.
Chances are that in a particular application, most properties never have listeners attached to them.
It is therefore wasteful to have a property object per property.
Show how the property can be set up on demand, ﬁrst using a regular ﬁeld for storing the property value, and then using a property object.
Consider a class with many JavaFX properties, most of which are never changed from a default.
Show how the property can be set up on demand, for the ﬁrst time.
Find out how to set the border of a control without using CSS.
Since there is no JavaFX-speciﬁc knowledge in parsing FXML ﬁles, come up with an example where you load an object that has nothing to do with JavaFX, with some nested objects, and set the properties in FXML syntax.
Animate a circle, representing a planet, so it travels along an elliptical orbit.
Using the web viewer, implement a browser with a URL bar and a back.
So why is it so hard to deal with time? The problem is humans.
Its API wasn’t stellar, its instances were mutable, and it didn’t deal with issues such as leap seconds.
The third time is a charm, and the java.time API that is introduced in Java 8 has remedied the ﬂaws of the past and should serve us for quite some time.
In this chapter, you will learn what makes time computations so vexing, and how the new Date and Time API solves these issues.
An Instant is a point on the time line (similar to a Date)
In Java time, each day has exactly 86,400 seconds (i.e., no leap seconds)
TemporalAdjuster methods handle common calendar computations, such as ﬁnding the ﬁrst Tuesday of a month.
ZonedDateTime is a point in time in a given time zone (similar to GregorianCalendar)
Use a Period, not a Duration, when advancing zoned time, in order to account for daylight savings time changes.
Historically, the fundamental time unit, the second, was derived from Earth’s full revolution, so it seems just a question of astronomical measurements to precisely deﬁne a second.
Unfortunately, Earth wobbles slightly, and a more precise deﬁnition was needed.
Since then, a network of atomic clocks keeps the ofﬁcial time.
Ever so often, the ofﬁcial time keepers synchronize the absolute time with the rotation of Earth.
In theory, a second might need to be removed once in a while, but that has not yet happened.) There is talk of changing the system again.
This works because the local time on a computer isn’t all that precise, and computers are used to synchronizing themselves with an external time service.
The Java Date and Time API speciﬁcation requires that Java uses a time scale that.
That gives Java the ﬂexibility to adjust to future changes in the ofﬁcial time.
In Java, an Instant represents a point on the time line.
This is the same convention used in the Unix/POSIX time.
Starting from that origin, time is measured in 86,400 seconds per day, forwards and backwards, in nanosecond precision.
The Instant values go back as far as a billion years (Instant.MIN)
That’s not quite enough to express the age of the universe (around 13.5 billion years), but it should be enough for all practical purposes.
After all, a billion years ago, the earth was covered in ice and populated by microsocopic ancestors of today’s plants and animals.
To ﬁnd out the difference between two instants, use the static method Duration.between.
For example, here is how you can measure the running time of an algorithm:
A Duration is the amount of time between two instants.
You can get the length of a Duration in conventional units by calling toNanos, toMillis, toSeconds, toMinutes, toHours, or toDays.
Durations require more than a long value for their internal storage.
The number of seconds is stored in a long, and the number of nanoseconds in an additional int.
If you want to make computations in nanosecond accuracy, and you actually need the entire range of a Duration, then you can use one of the methods in Table 5–1
Otherwise, you can just call toNanos and do your calculations with long values.
NOTE: It takes almost 300 years of nanoseconds to overﬂow a long.
Adds a duration to, or subtracts a duration from, this Instant or Duration.
Adds a number of the given time units to this Instant or Duration.
Subtracts a number of the given time units from this Instant or Duration.
Returns a duration that is obtained by multiplying or dividing this Duration by a given long, or by –1
For example, if you want to check whether an algorithm is at least ten times faster than another, you can compute.
NOTE: The Instant and Duration classes are immutable, and all methods, such as multipliedBy or minus, return a new instance.
Now let us turn from absolute time to human time.
There are two kinds of human time in the new Java API, local date/time and zoned time.
Local date/time has a date and/or time of day, but no associated time zone information.
Since that date has neither a time of day nor time zone information, it does not correspond to a precise instant of time.
There are many calculations where time zones are not required, and in some cases they can even be a hindrance.
For that reason, the API designers recommend that you do not use zoned time unless you really want to represent absolute time instances.
Birthdays, holidays, schedule times, and so on are usually best represented as local dates or times.
A LocalDate is a date, with a year, month, and day of the month.
To construct one, you can use the now or of static methods:
Unlike the irregular conventions in Unix and java.util.Date, where months are zero-based and years are counted from 1900, you supply the usual numbers for the month of year.
Table 5–2 shows the most useful methods for working with LocalDate objects.
These static methods construct a LocalDate, either from the current time or from a given year, month, and day.
Adds a number of days, weeks, months, or years to this LocalDate.
Subtracts a number of days, weeks, months, or years from this LocalDate.
Returns a new LocalDate with the day of month, day of year, month, or year changed to the given value.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the Period, or the number of the given ChronoUnits, between two dates.
The algorithm is applied for all past years, even though that is historically inaccurate.
For example, Programmer’s Day is the 256th day of the year.
Recall that the difference between two time instants is a Duration.
The equivalent for local dates is a Period, which expresses a number of elapsed years, months, or days.
You can call birthday.plus(Period.ofYears(1)), to get the birthday next year.
But birthday.plus(Duration.ofDays(365)) won’t produce the correct result in a leap year.
The until method yields the difference between two local dates.
That is actually not terribly useful because the number of days per month varies.
CAUTION: Some methods in Table 5–2 could potentially create nonexistent dates.
Instead of throwing an exception, these methods return the last valid day of the month.
The getDayOfWeek yields the weekday, as a value of the DayOfWeek enumeration.
The DayOfWeek enumeration has convenience methods plus and minus to compute weekdays modulo 7
NOTE: The weekend days actually come at the end of the week.
In addition to LocalDate, there are also classes MonthDay, YearMonth, and Year to describe partial dates.
For example, December 25 (with the year unspeciﬁed) can be represented as a MonthDay.
You pass the result of an adjustment method to the with method.
For example, the ﬁrst Tuesday of a month can be computed like this:
As always, the with method returns a new LocalDate object without modifying the original.
You can also roll your own adjuster by implementing the TemporalAdjuster interface.
Note that the parameter of the lambda expression has type Temporal, and it must be cast to LocalDate.
You can avoid this cast with the ofDateAdjuster method that expects a lambda of type UnaryOperator<LocalDate>
Next or previous date that falls on the given weekday.
Next or previous date that falls on the given weekday, starting from the given date.
A LocalTime represents a time of day, such as 15:30:00
You can create an instance with the now or of methods:
The plus and minus operations wrap around a 24-hour day.
These static methods construct a LocalTime, either from the current time, or from the given hours, minutes, and optionally, seconds and nanoseconds.
Adds a number of hours, minutes, seconds, or nanoseconds to this LocalTime.
Subtracts a number of hours, minutes, seconds, or nanoseconds from this LocalTime.
Returns a new LocalTime with the hour, minute, second, or nanosecond changed to the given value.
Gets the hour, minute, second, or nanosecond of this LocalTime.
Returns the number of seconds or nanoseconds between midnight and this LocalTime.
There is a LocalDateTime class, representing a date and time.
That class is suitable for storing points in time in a ﬁxed time zone, for example, for a schedule of classes or events.
However, if you need to make calculations that span the daylight savings time, or if you need to deal with users in different time zones, you should use the ZonedDateTime class that we discuss next.
Time zones, perhaps because they are an entirely human creation, are even messier than the complications caused by the earth’s irregular rotation.
This is actually done in China, which spans four conventional time zones.
Elsewhere, we have time zones with irregular and shifting boundaries, and, to make matters worse, the daylight savings time.
As capricious as the time zones may appear to the enlightened, they are a fact of life.
When you implement a calendar application, it needs to work for people who ﬂy from one country to another.
When you have a conference call at 10:00 in New York, but happen to be in Berlin, you expect to be alerted at the correct local time.
The Internet Assigned Numbers Authority (IANA) keeps a database of all known time zones around the world (https://www.iana.org/time-zones), which is updated several times per year.
The bulk of the updates deals with the changing rules for daylight savings time.
Each time zone has an ID, such as America/New_York or Europe/Berlin.
At the time of this writing, there were almost 600 IDs.
Given a time zone ID, the static method ZoneId.of(id) yields a ZoneId object.
You can use that object to turn a LocalDateTime object into a ZonedDateTime object by calling local.atZone(zoneId), or you can construct a ZonedDateTime by calling the static method ZonedDateTime.of(year, month, day, hour, minute, second, nano, zoneId)
Conversely, if you have an instant in time, call instant.atZone(ZoneId.of("UTC")) to.
Many of the methods of ZonedDateTime are the same as those of LocalDateTime (see Table 5–5)
Most are straightforward, but daylight savings time introduces some complications.
When daylight savings time starts, clocks advance by an hour.
Conversely, when daylight time ends, clocks are set back by an hour, and there are two instants with the same local time! When you construct a time within that span, you get the earlier of the two.
An hour later, the time has the same hours and minutes, but the zone offset has changed.
You also need to pay attention when adjusting a date across daylight savings time boundaries.
For example, if you set a meeting for next week, don’t add a duration of seven days:
These static methods construct a ZonedDateTime from the current time, or from a year, month, day, hour, minute, second, nanosecond (or a LocalDate and LocalTime), and ZoneId, or from an Instant and ZoneId.
Adds a number of temporal units to this ZonedDateTime.plusDays, plusWeeks, plusMonths, plusYears, plusHours, plusMinutes, plusSeconds, plusNanos.
Returns a new ZonedDateTime, with one temporal unit changed to the given value.
Returns a new ZonedDateTime in the given time zone, either representing the same instant or the same local time.
Gets the day of the week, returning a value of the DayOfWeek enumeration.
Gets the hour, minute, second, or nanosecond of this ZonedDateTime.
Yields the local date or local time, or the corresponding instant.
CAUTION: There is also an OffsetDateTime class that represents times with an offset from UTC, but without time zone rules.
That class is intended for specialized applications that speciﬁcally require the absence of those rules, such as certain network protocols.
The DateTimeFormatter class provides three kinds of formatters to print a date/time value:
To use one of the standard formatters, simply call its format method:
To present dates and times to human readers, use a locale-speciﬁc formatter.
The static methods ofLocalizedDate, ofLocalizedTime, and ofLocalizedDateTime create such a formatter.
To change to a different locale, simply use the withLocale method.
NOTE: The java.time.format.DateTimeFormatter class is intended as a replacement for java.util.DateFormat.
Finally, you can roll your own date format by specifying a pattern.
Each letter denotes a different time ﬁeld, and the number of times the letter is repeated selects a particular format, according to rules that are arcane and seem to have organically grown over time.
To parse a date/time value from a string, use one of the static parse methods.
The ﬁrst call uses the standard ISO_LOCAL_DATE formatter, the second one a custom formatter.
As a brand-new creation, the Java Date and Time API will have to interoperate with existing classes, in particularicular, the ubiquitous java.util.Date, java.util.
In Java 8, that class has two added methods: the toInstant method that converts a Date to an Instant, and the static from method that converts in the other direction.
Similarly, ZonedDateTime is a close analog to java.util.GregorianCalendar, and that class has gained conversion methods in Java 8
The toZonedDateTime method converts a GregorianCalendar to a ZonedDateTime, and the static from method does the opposite conversion.
Another set of conversions is available for the date and time classes in the java.sql java.text.Format.
Implement a method next that takes a Predicate<LocalDate> and returns an adjuster yielding the next date fulﬁlling the predicate.
Write an equivalent of the Unix cal program that displays a calendar for a month.
Write a program that prints how many days you have been alive.
Obtain the offsets of today’s date in all supported time zones for the current time instant, turning ZoneId.getAvailableIds into a stream and using stream operations.
Again using stream operations, ﬁnd all time zones whose offsets aren’t full hours.
When does it arrive? Write a program that can handle calculations like this.
How long is the ﬂight? Write a program that can handle calculations like this.
Read a set of appointments in different time zones and alert the user which ones are due within the next hour in local time.
Early Java releases had minimal support for concurrency, and programmers busily created code with deadlocks and race conditions.
The robust java.util.concurrent and thread pools, allowing many application programmers to write concurrent programs without using locks or starting threads.
Unfortunately, java.util.concurrent is a mix of useful utilities for the application programmer and power tools for library authors, without much effort to separate the two.
In this chapter, we focus squarely on the needs of the application programmer.
Updating atomic variables has become simpler with the updateAndGet/ accumulateAndGet methods.
Updating entries in a ConcurrentHashMap has become simpler with the compute and merge methods.
ConcurrentHashMap now has bulk operations search, reduce, forEach, with variants operating on keys, values, keys and values, and entries.
A set view lets you use a ConcurrentHashMap as a Set.
The Arrays class has methods for parallel sorting, ﬁlling, and preﬁx operations.
Since Java 5, the java.util.concurrent.atomic package provided classes for lock-free mutation of variables.
For example, you can safely generate a sequence of numbers like this:
The incrementAndGet method atomically increments the AtomicLong and returns the post-increment value.
That is, the operations of getting the value, adding 1, setting it, and producing the new value cannot be interrupted.
It is guaranteed that the correct value is computed and returned, even if multiple threads access the same instance concurrently.
There are methods for atomically setting, adding, and subtracting values, but if you want to make a more complex update, you have to use the compareAndSet method.
For example, suppose you want to keep track of the largest value that is observed by different threads.
Instead, compute the new value and use compareAndSet in a loop:
If another thread is also updating largest, it is possible that it has beat this thread to it.
Then compareAndSet will return false without setting the new value.
In that case, the loop tries again, reading the updated value and trying to change it.
Eventually, it will succeed replacing the existing value with the new one.
This sounds tedious, but the compareAndSet method maps to a processor operation that is faster than using a lock.
In Java 8, you don’t have to write the loop boilerplate any more.
Instead, you provide a lambda expression for updating the variable, and the update is done for you.
The accumulateAndGet method takes a binary operator that is used to combine the atomic value and the supplied argument.
There are also methods getAndUpdate and getAndAccumulate that return the old value.
When you have a very large number of threads accessing the same atomic values, performance suffers because the optimistic updates require too many retries.
Java 8 provides classes LongAdder and LongAccumulator to solve this problem.
A LongAdder is composed of multiple variables whose collective sum is the current value.
Multiple threads can update different summands, and new summands are automatically provided when the number of threads increases.
This is efﬁcient in the common situation where the value of the sum is not needed until after all work has been done.
If you anticipate high contention, you should simply use a LongAdder instead of an AtomicLong.
Call increment to increment a counter or add to add a quantity, and sum to retrieve the total.
NOTE: Of course, the increment method does not return the old value.
Doing that would undo the efﬁciency gain of splitting the sum into multiple summands.
The LongAccumulator generalizes this idea to an arbitrary accumulation operation.
In the constructor, you provide the operation, as well as its neutral element.
Each variable is initialized with the neutral element (0 in our example)
When accumulate is called with value v, then one of them is atomically updated as.
If you choose a different operation, you can compute maximum or minimum (see Exercise 4)
That means that the ﬁnal result must be independent of the order in which the intermediate values were combined.
There are also DoubleAdder and DoubleAccumulator that work in the same way, except with double values.
NOTE: Another addition to Java 8 is the StampedLock class that can be used to implement optimistic reads.
I don’t recommend that application programmers use locks, but here is how it is done.You ﬁrst call tryOptimisticRead, upon which you get a “stamp.” Read your values and check whether the stamp is still valid (i.e., no other thread has obtained a write lock)
If not, get a read lock (which blocks any writers)
A ConcurrentHashMap is, of course, threadsafe—multiple threads can add and remove elements without damaging the internal structure.
Moreover, it is quite efﬁcient, allowing multiple threads to update different parts of the table concurrently without blocking each other.
NOTE: Some applications use humongous concurrent hash maps, so large that the size method is insufﬁcient because it returns an int.
NOTE: A hash map keeps all entries with the same hash code in the same “bucket.” Some applications use poor hash functions, and as a result all entries end up in a small number of buckets, severely degrading performance.
Even generally reasonable hash functions, such as that of the String class, can be problematic.
For example, an attacker can slow down a program by crafting a large number of strings that hash to the same value.
As of Java 8, the concurrent hash map organizes the buckets as trees, not lists, when the key type implements Comparable, guaranteeing O(log(n)) performance.
The original version of ConcurrentHashMap only had a few methods for atomic updates, which made for somewhat awkward programming.
Suppose we want to count how often certain features are observed.
As a simple example, suppose multiple threads encounter words, and we want to count their frequencies.
Another thread might be updating the exact same count at the same time.
NOTE: Some programmers are surprised that a supposedly threadsafe data structure permits operations that are not threadsafe.
If multiple threads modify a plain HashMap, they can destroy the internal structure (an array of linked lists)
Some of the links may go missing, or even go in circles, rendering the data structure unusable.
In the example above, the code for get and put will never corrupt the data structure.
But, since the sequence of operations is not atomic, the result is not predictable.
One remedy is to use the replace operation, replacing a known old value with a new one, just as you have seen in the preceding section:
The ﬁrst statement ensures that there is a LongAdder present that we can increment atomically.
Since putIfAbsent returns the mapped value (either the existing one or the newly put one), you can combine the two statements:
Java 8 provides methods that make atomic updates more convenient.
The compute method is called with a key and a function to compute the new value.
That function receives the key and the associated value, or null if there is none, and it computes the new value.
For example, here is how we can update a map of integer counters:
There are many methods that use a null value as an indication that a given key is not present in the map.
There are also variants computeIfPresent and computeIfAbsent that only compute a new value when there is already an old one, or when there isn’t yet one.
That is almost like the call to putIfAbsent that you saw before, but the LongAdder constructor is only called when a new counter is actually needed.
You often need to do something special when a key is added for the ﬁrst time.
It has a parameter for the initial value that is used when the key is not yet present.
Otherwise, the function that you supplied is called, combining the existing value and the initial value.
See Exercise 5 for another compelling application of the merge method.
NOTE: If the function that is passed to compute or merge returns null, the existing entry is removed from the map.
CAUTION: When you use compute or merge, keep in mind that the function that you supply should not do a lot of work.
While that function runs, some other updates to the map may be blocked.
Of course, that function should also not update other parts of the map.
Java 8 provides bulk operations on concurrent hash maps that can safely execute even while other threads operate on the map.
The bulk operations traverse the map and operate on the elements they ﬁnd as they go along.
No effort is made to freeze a snapshot of the map in time.
Unless you happen to know that the map is not being modiﬁed while a bulk operation runs, you should treat its result as an approximation of the map’s state.
Then the search terminates and the function’s result is returned.
With each of the operations, you need to specify a parallelism threshold.
If the map contains more elements than the threshold, the bulk operation is parallelized.
If you want the bulk operation to run in a single thread, use a threshold of Long.MAX_VALUE.
If you want the maximum number of threads to be made available for the bulk operation, use a threshold of 1
For example, suppose we want to ﬁnd the ﬁrst word that occurs more than 1,000 times.
Then result is set to the ﬁrst match, or to null if the search function returns null for all inputs.
The ﬁrst one simply applies a consumer function for each map entry, for example.
The second variant takes an additional transformer function, which is applied ﬁrst, and its result is passed to the consumer:
Whenever the transformer returns null, the value is silently skipped.
For example, here we only print the entries with large values:
The reduce operations combine their inputs with an accumulation function.
For example, here is how you can compute the sum of all values.
As with forEach, you can also supply a transformer function.
The transformer can act as a ﬁlter, by returning null to exclude unwanted inputs.
NOTE: If the map is empty, or all entries have been ﬁltered out, the reduce operation returns null.
If there is only one element, its transformation is returned, and the accumulator is not applied.
There are specializations for int, long, and double outputs with sufﬁx ToInt, ToLong, and ToDouble.
You need to transform the input to a primitive value and specify a default value and an accumulator function.
The default value is returned when the map is empty.
CAUTION: These specializations act differently from the object versions where there is only one element to be considered.
Instead of returning the transformed element, it is accumulated with the default.Therefore, the default must be the neutral element of the accumulator.
Suppose you want a large, threadsafe set instead of a map.
There is no ConcurrentHashSet class, and you know better than trying to create your own.
Of course, you can use a ConcurrentHashMap with bogus values, but then you get a map, not a set, and you can’t apply operations of the Set interface.
All map values are Boolean.TRUE, but you don’t actually care since you just use it as a set.)
Of course, if you have an existing map, the keySet method yields the set of keys.
If you remove the set’s elements, the keys (and their values) are removed from the map.
But it doesn’t make sense to add elements to the key set, because there would be no corresponding values to add.
Java 8 adds a second keySet method to ConcurrentHashMap, with a default value, to be used when adding elements to the set:
If "Java" wasn’t already present in words, it now has a value of one.
The Arrays class now has a number of parallelized operations.
The static Arrays.parallelSort method can sort an array of primitive values or objects.
With all methods, you can supply the bounds of a range, such as.
NOTE: At ﬁrst glance, it seems a bit odd that these methods have parallel in their name, since the user shouldn’t care how the sorting happens.
However, the API designers wanted to make it clear that the sorting is parallelized.
That way, users are on notice to avoid comparators with side effect.
The parallelSetAll method ﬁlls an array with values that are computed from a function.
The function receives the element index and computes the value at that location.
There are versions for all primitive type arrays and for object arrays.
Finally, there is a parallelPrefix method that replaces each array element with the accumulation of the preﬁx for a given associative operation.
Clearly, one can make this computation in parallel in separate regions of the array.
In the next step, update the indicated elements by multiplying them with elements that are one or two positions below:
This is a win over the straightforward linear computation if sufﬁcient processors are available.
On special-purpose hardware, this algorithm is commonly used, and users of such hardware are quite ingenious in adapting it to a variety of problems.
The java.util.concurrent library provides a Future<T> interface to denote a value of type T that will be available at some point in the future.
In the following sections, you will see how completable futures make it possible to compose asynchronous operations.
The method reads a web page in a separate thread, which is going to take a while.
Now suppose we want to extract all URLs from the page in order to build a web crawler.
How can we apply that method to the future object? Unfortunately, there is only one way.
First, call the get method on the future to get its value when it becomes available.
We are really no better off than with a method.
Now in fairness, there has been some support for futures in java.util.concurrent, but an essential piece was missing.
Let’s change the readPage method so that it returns a CompletableFuture<String>
Unlike a plain Future, a CompleteableFuture has a method thenApply to which you can pass the post-processing function.
When the ﬁrst future has completed, its result is fed to the getLinks method, and the return value of that method becomes the ﬁnal result.
This composability is the key aspect of the CompletableFuture class.
Composing future actions solves a serious problem in programming asynchronous applications.
The traditional approach for dealing with nonblocking calls is to use event handlers.
The programmer registers a handler for the next action after completion.
Of course, if the next action is also asynchronous, then the next action after that is in a different event handler.
It gets worse when one has to add error handling.
Trying to implement such a control ﬂow in a set of event handlers, or to understand it once it has been implemented, is challenging.
With completable futures, you just specify what you want to have done, and in which order.
It won’t all happen right away, of course, but what is important is that all the code is in one place.
In Chapter 2, you saw how a stream pipeline starts with stream creation, then goes through one or more transformations, and ﬁnishes with a terminal operation.
Start out by generating a CompletableFuture, usually with the static method supplyAsync.
That method requires a Supplier<T>, that is, a function with no parameters yielding a T.
In our example, we can start out the pipeline with.
There is also a static runAsync method that takes a Runnable, yielding a CompletableFuture<Void>
This is useful if you simply want to schedule one action after another, without passing data between them.
One of them runs the provided action on the common ForkJoinPool.
The other has a parameter of type java.util.concurrent.Executor, and it uses the given executor to run the action.
Next, you can call thenApply or thenApplyAsync to run another action, either in the same thread or another.
With either method, you supply a function and you get a CompletableFuture<U>, where U is the return type of the function.
For example, here is a two-stage pipeline for reading and processing the web page:
Eventually, you’ll be done, and you will need to save the results somewhere.
The thenAccept method takes a Consumer—that is, a function with return type void.
The last step in the pipeline simply deposits the result where it belongs.
NOTE: You don’t explicitly start the computation.The static supplyAsync method starts it automatically, and the other methods cause it to be continued.
There is a large number of methods for working with completable futures.
Let us ﬁrst look at those that deal with a single future (see Table 6–1)
For each method shown, there are also two Async variants that I don’t show.
As noted in the preceding section, one of them uses the common ForkJoinPool, and the other has an Executor parameter.
That sounds rather abstract, but it can be quite natural.
Consider the action of reading a web page from a given URL.
Invoke the function on the result and execute the returned future.
Now, suppose we have another method that gets the URL from user input, perhaps from a dialog that won’t reveal the answer until the user has clicked the OK button.
The third method in Table 6–1 focuses on a different aspect that I have ignored so far: failure.
When an exception is thrown in a CompletableFuture, it is captured and wrapped in an unchecked ExecutionException when the get method is called.
In order to handle an exception, use the handle method.
The supplied function is called with the result (or null if none) and the exception (or null if none), and it gets to make sense of the situation.
The remaining methods have void result and are usually used at the end of a processing pipeline.
Now let us turn to methods that combine multiple futures (see Table 6–2)
The next three methods run two CompletableFuture<T> actions in parallel.
As soon as one of them ﬁnishes, its result is passed on, and the other result is ignored.
Finally, the static allOf and anyOf methods take a variable number of completable futures and yield a CompletableFuture<Void> that completes when all of them, or any one of them, completes.
Execute both and combine the results with the given function.
When a result is available from one or the other, pass it to the given function.
Complete with void result after any of the given futures completes.
NOTE: Technically speaking, the methods in this section accept parameters of type CompletionStage, not CompletableFuture.
That is an interface type with almost forty abstract methods, currently implemented only by CompletableFuture.
Most programmers wouldn’t casually implement that interface, so I don’t dwell on the distinction.
Use a LongAccumulator to compute the maximum or minimum of the accumulated elements.
Write an application in which multiple threads read all words from a collection of ﬁles.
You can use the parallelPrefix method to parallelize the computation of Fibonacci numbers.
We use the fact that the nth Fibonacci number is the top make an array of matrices, and use parallelPrefix to multiply them.
Test with a function that reads a java.net.PasswordAuthentication from the console, and a function that simulates a validity check by sleeping for a second and then checking that the password is "secret"
It is called Rhino because a wellregarded JavaScript book has the image of a rhinoceros on its cover.
Oracle’s engineers realized that they could build a much more efﬁcient JavaScript interpreter using the new JVM instructions designed for dynamic languages.
You get extra karma for pronouncing it nas-horn, not na-shorn.) Nashorn is very fast, and it lets you integrate Java with JavaScript on a highly performant virtual machine.
It is also incredibly compliant with the ECMAScript standard for JavaScript.
If you are thinking of giving your users the ability to script your application, or if you are intrigued by the ease of use of reactive programming environments such as node.js, check out Nashorn in Java 8
Not only do you get the beneﬁts of a reasonably well-designed scripting language (i.e., JavaScript), but you have the full power of the JVM behind it.
Nashorn is the successor to the Rhino JavaScript interpreter, with greater performance and ﬁdelity to the JavaScript standard.
Nashorn is a pleasant environment for experimenting with the Java API.
You can run JavaScript through the jjs interpreter, or from Java via the scripting API.
Use the predeﬁned JavaScript objects for the most common packages, or the Java.type function to access any package.
Beware of intricacies in the conversion of strings and numbers between JavaScript and Java.
JavaScript offers a convenient syntax for working with Java lists and maps, as well as JavaBeans properties.
You can convert JavaScript functions to Java interfaces in a way that is very similar to using lambda expressions.
You can extend Java classes and implement Java interfaces in JavaScript, but there are limitations.
Nashorn has good support for writing shell scripts in JavaScript.
You can write JavaFX programs in JavaScript, but the integration is not as good as it might be.
You get what’s called a “read-eval-print” loop, or REPL, in the world of Lisp, Scala, and so on.
NOTE: As a reminder, in JavaScript, strings can be delimited by '...' or "..."
In this chapter, I will use single quotes for JavaScript strings to give you a visual clue that the code is JavaScript, not Java.
Now, when you type contents, you see the contents of the web page.
I wasn’t quite sure whether I could read the entire contents by setting the delimiter to $, but I tried it out and it worked.
And I didn’t have to write public static void main.
I didn’t have to make a project in my IDE.
The REPL is the easiest way to explore an API.
It is a bit odd that one drives Java from JavaScript, but it is also convenient.
Note how I didn’t have to deﬁne the types for the input and contents variables.
TIP: There are two annoyances that keep the JavaScript REPL from being as refreshing as its equivalent in Scala.
The Scala REPL has command completion.When you press the Tab key, you get a list of possible completions of the current expression.
Admittedly, that is a difﬁcult trick to pull off for dynamically typed languages such as JavaScript.A more fundamental omission is command-line recall.
Pressing the ↑ key should get you the previous command.
If it doesn’t, try installing rlwrap and run rlwrap jjs.
Start Emacs and hit M-x (i.e., Alt+x or Esc x) shell Enter, then type jjs.
Use M-p and M-n to recall the previous or next line, and the left and right arrow keys to move within a line.
Edit a command, then press Enter to see it executed.
In the preceding section, you saw one use case for Nashorn scripting: to experiment with Java APIs from the jjs REPL.
Another use case is to allow users of your programs to run scripts.
For example, all Microsoft Ofﬁce applications can be scripted with a language called VB Script that is a descendant of the Basic language.
Quite a few people write such scripts, and this capability leads to a form of vendor lock.
It is difﬁcult to adopt an alternate ofﬁce suite that won’t run those scripts.
If you want to lock in the users of your Java desktop or server app, you can provide the same capabilities.
Running a Nashorn script from Java uses the script engine mechanism that has been introduced in Java 6
You can use that mechanism to execute scripts in any.
There are also script engines for languages that run outside the JVM, such as PHP or Scheme.
To run a script, you need to get a ScriptEngine object.
If the engine is registered, you can simply get it by name.
To make a Java object available to your scripts, use the put method of the ScriptEngine interface.
For example, you can make a JavaFX stage visible, so that you can populate it using JavaScript code:
Instead of putting variables into the global scope, you can collect them in an object of type Bindings and pass that object to the eval method:
This is useful if a set of bindings should not persist for future calls to the eval method.
In the preceding section, you saw how the script engine can make Java objects accessible to JavaScript.
Nashorn supports a convenient property syntax for getters and setters.
You can even use the JavaScript bracket notation to access properties:
Note that the argument of the [] operator is a string.
In this context, that isn’t useful, but you can call stage[str] with a string variable and thereby access arbitrary properties.
NOTE: In JavaScript, semicolons at the end of a line are optional.
Many JavaScript programmers put them in anyway, but in this chapter, I omit them so that you can easily distinguish between Java and JavaScript code snippets.
There can be only one method with a given name, and it can have any number of parameters of any type.
Nashorn attempts to pick the correct Java method, following the number and types of the parameters.
In almost all cases, there is only one Java method that matches the supplied parameters.
If there is not, you can manually pick the correct method with the following rather strange syntax:
Here, we specify the remove(Object) method that removes the Integer object 1 from the list.
There is also a remove(int) method that removes the object at position 1.)
When you want to construct objects in JavaScript (as opposed to having them handed to you from the script engine), you need to know how to access Java.
There are global objects java, javax, javafx, com, org, and edu that yield package and class objects via the dot notation.
If you need to access a package that does not start with one of the above identiﬁers, you can ﬁnd it in the Package object, such as Package.ch.cern.
This is a bit faster than java.net.URL, and you get better error checking.
If you make a spelling error such as java.net.Url, Nashorn will think it is a package.) But if you want speed and good error handling, you probably shouldn’t be using a scripting language in the ﬁrst place, so I will stick with the shorter form.
NOTE: The Nashorn documentation suggests that class objects should be deﬁned at the top of a script ﬁle, just like you place imports at the top of a Java ﬁle:
Once you have a class object, you can call static methods:
To construct an object, pass the class object to the JavaScript new operator.
If you aren’t concerned about efﬁciency, you can also call.
CAUTION: If you use Java.type with new, you need an extra set of parentheses:
If you need to specify an inner class, you can do so with the dot notation:
Alternatively, if you use Java.type, use a $, like the JVM does:
In this case, the JavaScript string is converted to a Java string.
In general, a JavaScript string is converted to a Java string whenever it is passed to a Java method.
Also note that any JavaScript object is converted to a string when it is passed to a Java method with a String parameter.
The Paths.get method wants a String, and it gets one, even though it makes no sense in this situation.
It follows the general JavaScript behavior to turn anything into a string when a string is expected.
It is features such as this one that make programming in a dynamically typed language an exciting adventure.
Its Number type is the same as the Java double type.
When a number is passed to Java code that expects an int or long, any fractional part is silently removed.
For efﬁciency, Nashorn keeps computations as integers when possible, but that difference is generally transparent.
The value of price happens to be an integer, and it is assigned to an Object since the format method has an Object...
That causes the format method to fail, since the f format is intended for ﬂoating-point numbers.
In this case, you can force conversion to java.lang.Double by calling the Number function:
To construct a Java array, ﬁrst make a class object:
Then call the new operator and supply the length of the array:
To iterate through all values of the names array, use.
This is the equivalent of the enhanced for loop in Java.
If you need the index values, use the following loop instead:
CAUTION: Even though this loop looks just like the enhanced for loop in Java, it visits the index values.
When you supply a JavaScript array where a Java array is expected, Nashorn will carry out the conversion.
Given a JavaScript array, use the Java.to method to obtain the equivalent Java array:
Conversely, use Java.from to turn a Java array into a JavaScript array:
You can use the bracket operator with any Java List to invoke the get and set methods:
To visit all elements in the map, you can use the JavaScript for each loops:
If you want to process keys and values together, simply iterate over the entry set:
NOTE: The for each loop works for any Java class that implements the Iterable interface.
Syntactically, such an anonymous function is very similar to a Java lambda expression.
Instead of an arrow after the parameter list, you have the keyword function.
You can use an anonymous function as a functional interface argument of a Java method, just like you could use a lambda expression in Java.
Nashorn supports shorthand for functions whose body is a single expression.
For such functions, you can omit the braces and the return keyword:
Again, note the similarity with a Java lambda expression (a, b) -> Integer.
To extend a Java class, or to implement a Java interface, use the Java.extend function.
Supply the class object of the superclass or interface and a JavaScript object with the methods that you want to override or implement.
For example, here is an iterator that produces an inﬁnite sequence of random numbers.
For each method, we provide an implementation as an anonymous JavaScript function:
NOTE: When calling Java.extend, you can specify any number of superinterfaces as well as a superclass.
Place all class objects before the object with the implemented methods.
Another Nashorn syntax extension lets you deﬁne anonymous subclasses of interfaces or abstract classes.
When new JavaClassObject is followed by a JavaScript object, an object of the extended class is returned.
If the supertype is abstract and has only one abstract method, you don’t even have to give the method name.
Instead, pass the function as if it was a constructor parameter:
CAUTION: When extending a concrete class, you cannot use that constructor a Thread constructor, in this case the constructor Thread(Runnable)
The call to new returns an object of class Thread, not of a subclass of Thread.
If you want instance variables in your subclass, add them to the JavaScript object.
For example, here is an iterator that produces ten random numbers:
Note that the JavaScript methods next and hasNext refer to the instance variable as this.count.
It is possible to invoke a superclass method when overriding a method, but it is quite ﬁnicky.
The call Java.super(obj) yields an object on which you can invoke the superclass method of the class to which obj belongs, but you must have that object available.
When you call arr.add('Fred'), a message is printed before the value is added to the array list.
Note that the call Java.super(arr) requires the arr variable, which is being set to the value returned by new.
Calling Java.super(this) does not work—that only gets the JavaScript object that deﬁnes the method, not the Java proxy.
The Java.super mechanism is only useful for deﬁning individual objects, not subclasses.
NOTE: Instead of calling Java.super(arr).add(x), you can also use the syntax arr.super$add(x)
When a Java method throws an exception, you can catch it in JavaScript in the usual way:
Note that there is only one catch clause, unlike in Java where you can catch expressions by type.
That, too, is in the spirit of dynamic languages where all type inquiry happens at runtime.
If you need to automate a repetitive task on your computer, chances are that you have put the commands in a shell script, a script that replays a set of OS-level commands.
I have a directory ~/bin ﬁlled with dozens of shell scripts: to upload ﬁles to my web site, my blog, my photo storage, and to my publisher’s FTP.
For me, these are bash scripts, but in the olden days when I used Windows they were batch ﬁles.
So what is wrong with that? The problem comes once you have a need for branches and loops.
For some reason, most implementors of command shells are terrible at programming language design.
The way variables, branches, loops, and functions are implemented in bash is simply awful, and the batch language in Windows is even worse.
I have a few bash scripts that started out modest but have over time accreted so much cruft that they are unmanageable.
Why not just write these scripts in Java? Java is quite verbose.
If you call external commands via Runtime.exec, you need to manage standard input/output/error streams.
The Nashorn designers want you to consider JavaScript as an alternative.
The syntax is comparatively lightweight, and Nashorn offers some conveniences that are speciﬁcally geared towards shell programmers.
Now you can execute shell commands by including them in backquotes, for example.
By convention, an exit code of zero means success, and non-zero codes describe error conditions.)
You can also capture the standard output by assigning the result of the backquoted command to a variable:
If you want to supply standard input for a command, use.
For example, this command passes the output of ls -al to grep -v class:
Expressions inside ${...} are evaluated within doubly quoted and backquoted strings.
Sets message to a string such as The current time is 2013-10-12T21:48:58.545Z.
As with the bash shell, string interpolation does not work inside singly quoted strings.
These inline documents are useful when a command reads multiple lines from standard input and the script author doesn’t want to put the input in a separate ﬁle.
As an example, here is how you can feed commands to the GlassFish administration tool:
Note that the name and location of the application are interpolated.
String interpolation and here documents are only available in scripting mode.
Since it is possible to include multiple script ﬁles on the jjs command line, you need to separate the script ﬁles and arguments with a --:
If you have only one script ﬁle, you can instead run.
Then you can make the script ﬁle executable and simply run it as path/script.js.
When a script starts with a shebang, scripting mode is automatically activated.
In the script ﬁle, you receive the command-line arguments in the arguments array:
With jjs (but not with jrunscript), you can use $ARG instead of arguments.
If you use that variable with string interpolation, you need two dollar signs:
In your script, you can obtain the shell’s environment variables through the ENV object:
In scripting mode, you can prompt the user for input with the readLine function:
Simply put the instructions that you would normally put into the start method of the Application subclass into the script.
You don’t even have to call show on the Stage object—that is done for you.
All the boilerplate is gone, and you have the convenient property notation, that is,
NOTE: If you need to override the init or stop lifecycle methods of the Application class in addition to start, include the methods that you need in your script, at the top level.
With the -fx option, you then get a subclass of Application with the script methods.
As you have seen in Chapter 4, most FX events are handled through listeners to FX properties.
Recall that an FX property has two listener interfaces, InvalidationListener and ChangeListener, both added with the addListener method.
In Java, you can call addListener with a lambda expression, and the compiler is able to ﬁgure out from the parameter types which of the two listeners to add.
Suppose we have a slider to control the font size.
We’d like to add a listener that updates the size when the slider value changes:
Nashorn doesn’t know whether you want to add an InvalidationListener or a ChangeListener, and it doesn’t know that you don’t actually care.
That’s more heavyweight than the Java equivalent—not something one wants to see in a lightweight scripting language.
Compatibility with scripting languages was perhaps not their major concern, particularly since they had just abandoned another scripting language.
And there is another sad aspect about the JavaFX support in Nashorn.
Recall how in the olden days of JavaFX Script, it was easy to describe the layout of a scene like this:
Run some experiments in jjs: construct objects, call methods, and observe the returned values.
Did you ﬁnd it easier than writing test programs in Java?
First read the words, then ﬁlter the long words, and so on.
How does this interactive approach compare to your usual workﬂow?
Construct a nonliteral JavaScript string by extracting a substring from another string, and invoke the getClass method.
What class do you get? Then pass the object to java.lang.String.class.cast.
Write a JavaScript function that is a factory for such objects, so that one can generate any number of logging array lists.
Write a JavaScript function pipe that takes a sequence of shell commands and pipes the output of one to the input of the next, returning the ﬁnal output.
The solution of the preceding exercise is not quite as good as a Unix pipe because the second command only starts when the ﬁrst one has ﬁnished.
Write a script that prints the values of all environment variables.
Write a script nextYear.js that obtains the age of the user and then prints Next year, you will be ..., adding 1 to the input.
The age can be speciﬁed on the command line or the AGE environment variable.
Write a JavaFX program in JavaScript that reads data from a source of your choice and renders a pie chart.
But there are also numerous smaller changes throughout the library that are quite useful.
In this chapter, you will ﬁnd what is new for strings, numbers, math, collections, ﬁles, annotations, regular expressions, and JDBC.
Use Math.floorMod(x, n) instead of x % n if x might be negative.
There are new mutators in Collection (removeIf) and List (replaceAll, sort)
Files.list lazily lists the entries of a directory, and Files.walk traverses them recursively.
Annotations can now be repeated and applied to type uses.
Convenient support for null parameter checks can be found in the Objects class.
A common task is to combine several strings, separating them with a delimiter such as ", " or "/"
Think of join as the opposite of the String.split instance method.
This is the only method added to the String class in Java 8
Ever since Java 5, each of the seven numeric primitive type wrappers (i.e., not Boolean) had a static SIZE ﬁeld that gives the size of the type in bits.
You will be glad to know that there is now a BYTES ﬁeld that reports the size in bytes, for those who cannot divide by eight.
All eight primitive type wrappers now have static hashCode methods that return the same hash code as the instance method, but without the need for boxing.
The ﬁve types Short, Integer, Long, Float, and Double now have static methods sum, max, and min, which can be useful as reduction functions in stream operations.
The Boolean class has static methods logicalAnd, logicalOr, and logicalXor for the same purpose.
In general, with unsigned numbers, you lose the negative values and get twice the range of positive values.
The Byte and Short classes have methods toUnsignedInt, and Byte, Short, and Integer have methods toUnsignedLong.
The Integer and Long classes have methods compareUnsigned, divideUnsigned, and remainderUnsigned to work with unsigned values.
You don’t need special methods for addition, subtraction, and multiplication.
The + and - operators do the right thing already for unsigned values.
Integer multiplication would overﬂow with unsigned integers larger than Integer.MAX_VALUE, so you should call toUnsignedLong and multiply them as long values.
NOTE: In order to work with unsigned numbers, you need to have a clear understanding of base-two arithmetic and the binary representation of negative numbers.
In C and C++, mixing signed and unsigned types is a common cause of subtle errors.
Java has wisely decided to stay away from this area, and has managed to live with only signed numbers for many years.
The primary reason to use unsigned numbers is if you work with ﬁle formats or network protocols that require them.
The call Double.isFinite(x) returns true if x is not inﬁnity, negative inﬁnity, or a NaN (not a number)
In the past, you had to call the instance methods isInfinite and isNaN to get the same result.
Finally, the BigInteger class has instance methods (long|int|short|byte)ValueExact that return the value as a long, int, short, or byte, throwing an ArithmeticException if the value is not within the target range.
The Math class provides several methods for “exact” arithmetic that throw an exception when a result overﬂows.
The provided methods are (add|subtract|multiply|increment|decrement|negate)Exact, with int and long parameters.
The toIntExact method converts a long to the equivalent int.
The floorMod and floorDiv methods aim to solve a long-standing problem with integer remainders.
Why? When the ﬁrst computers were built, someone had to make rules for how integer division and remainder should work for negative operands.
But, rather than open a math textbook, those pioneers came up with rules that seemed reasonable but are actually inconvenient.
You compute the position of the hour hand of a clock.
But what if adjustment is negative? Then you might get a negative number.
NOTE: Unfortunately, floorMod gives negative results for negative divisors, but that situation doesn’t often occur in practice.
The nextDown method, deﬁned for both double and float parameters, gives the next smaller ﬂoating-point number for a given number.
For example, if you promise to produce a number < b, but you happen to have computed exactly b, then you can return Math.nextDown(b)
NOTE: All methods described in this section also exist in the StrictMath class.
The big change for the collections library is, of course, support for streams which you have seen in Chapter 2
You may wonder why the Stream interface has so many methods that accept lambda expressions but just one such method, removeIf, was added to the Collection interface.
If you review the Stream methods, you will ﬁnd that most of them return a single value or a stream of transformed values that are not present in the original stream.
The removeIf method can be thought of as the opposite of filter, removing rather than producing all matches and carrying out the removal in place.
The distinct method would be costly to provide on arbitrary collections.
The List interface has a replaceAll method, which is an in-place equivalent of map, and a sort method that is obviously useful.
The Map interface has a number of methods that are particularly important for maps accessed concurrently.
The Iterator interface has a forEachRemaining method that exhausts the iterator by feeding the remaining iterator elements to a function.
Finally, the BitSet class has a method that yields all members of the set as a stream of int values.
The Comparator interface has a number of useful new methods, taking advantage of the fact that interfaces can now have concrete methods.
The function is applied to the objects to be compared, and the comparison is then made on the returned keys.
For example, suppose you have an array of Person objects.
You can chain comparators with the thenComparing method for breaking ties.
If two people have the same last name, then the second comparator is used.
You can specify a comparator to be used for the keys that the comparing and thenComparing methods extract.
For example, here we sort people by the length of their names:
Moreover, both the comparing and thenComparing methods have variants that avoid boxing of int, long, or double values.
An easier way of producing the preceding operation would be.
If your key function can return null, you will like the nullsFirst and nullsLast adapters.
These static methods take an existing comparator and modify it so that it doesn’t throw an exception when encountering null values but ranks them as smaller or larger than regular values.
For example, suppose getMiddleName returns a null when a person has no middle name.
The nullsFirst method needs a comparator—in this case, one that compares two strings.
The naturalOrder method makes a comparator for any class implementing java.util.Comparator.*, to make the expression more legible.
The static reverseOrder method gives the reverse of the natural order.
Now the Collections class supports these classes as it does other collections, with methods (unmodifiable|synchronized|checked|empty)Navigable(Set|Map)
A checkedQueue wrapper, that has apparently been overlooked all these years, has also been added.
As a reminder, the checked wrappers have a Class parameter and throw a ClassCastException when you insert an element of the wrong type.
Suppose you declare a Queue<Path>, and somewhere in your code there is a ClassCastException trying to cast a String to a Path.
This could have happened because you passed the queue to a method void getMoreWork(Queue q) with no type parameter.
Because the generic type was suppressed, the compiler could not detect that.) Much later, you took out that String, thinking it was a Path, and the error manifested itself.
If you temporarily replace the queue with a CheckedQueue(new LinkedList<Path>, Path.class), then every insertion is checked at runtime, and you can locate the faulty insertion code.
Java 8 brings a small number of convenience methods that use streams for reading lines from ﬁles and for visiting directory entries.
Also, there is ﬁnally an ofﬁcial way of performing Base64 encoding and decoding.
To read the lines of a ﬁle lazily, use the Files.lines method.
It yields a stream of strings, one per line of input:
As soon as the ﬁrst line containing password is found, no further lines are read from the underlying ﬁle.
NOTE: Unlike the FileReader class, which was a portability nightmare since it opened ﬁles in the local character encoding, the Files.lines method defaults to UTF-8.You can specify other encodings by supplying a Charset argument.
The streams that you have seen in Chapter 2 didn’t need to close any resources.
But the Files.lines method produces a stream whose close method closes the ﬁle.
The easiest way to make sure the ﬁle is indeed closed is to use a Java 7 try-with-resources block:
When a stream spawns another, the close methods are chained.
When filteredLines is closed, it closes the underlying stream, which closes the underlying ﬁle.
NOTE: If you want to be notiﬁed when the stream is closed, you can attach an onClose handler.
Here is how you can verify that closing filteredLines actually closes the underlying stream:
If an IOException occurs as the stream fetches the lines, that exception is wrapped into an UncheckedIOException which is thrown out of the stream operation.
This subterfuge is necessary because stream operations are not declared to throw any checked exceptions.)
If you want to read lines from a source other than a ﬁle, use the BufferedReader.lines method instead:
With this method, closing the resulting stream does not close the reader.
For that reason, you must place the BufferedReader object, and not the stream object, into the header of the try statement.
NOTE: Almost ten years ago, Java 5 introduced the Scanner class to replace the cumbersome BufferedReader.
It is unfortunate that the Java 8 API designers decided to add the lines method to BufferedReader but not to Scanner.
The static Files.list method returns a Stream<Path> that reads the entries of a directory.
The directory is read lazily, making it possible to efﬁciently process directories with huge numbers of entries.
Since reading a directory involves a system resource that needs to be closed, you should use a try block:
NOTE: Under the hood, the stream uses a DirectoryStream, a construct introduced in Java 7 for efﬁcient traversal of huge directories.
That interface has nothing to do with Java 8 streams; it extends Iterable so that it can be used in an enhanced for loop.
To process all descendants of a directory, use the Files.walk method instead.
You can limit the depth of the tree that you want to visit by calling Files.walk(pathToRoot, depth)
Both walk methods have a varargs parameter of type FileVisitOption..., but there is currently only one option you can supply: FOLLOW_LINKS to follow symbolic links.
NOTE: If you ﬁlter the paths returned by walk and your ﬁlter criterion involves the ﬁle attributes stored with a directory, such as size, creation time, or type (ﬁle, directory, symbolic link), then use the find method instead of walk.
Call that method with a predicate function that accepts a path and a BasicFileAttributes object.The only advantage is efﬁciency.
Since the directory is being read anyway, the attributes are readily available.
The Base64 encoding encodes a sequence of bytes into a (longer) sequence of printable ASCII characters.
It is used for binary data in email messages and “basic” HTTP authentication.
That class has methods to encode an array of bytes or a NIO ByteBuffer.
Alternatively, you can “wrap” an output stream, so that all data sent to it is automatically encoded.
Annotations are tags inserted into the source code that some tools can process.
In Java SE, annotations are used for simple purposes, such as marking deprecated features or suppressing warnings.
Annotations have a much more important role in Java EE where they are used to conﬁgure just about any aspect of an application, replacing painful boilerplate code and XML customization that was the bane of older Java EE versions.
Java 8 has two enhancements to annotation processing: repeated annotations and type use annotations.
Moreover, reﬂection has been enhanced to report method parameter names.
This has the potential to simplify annotations on method parameters.
When annotations were ﬁrst created, they were envisioned to mark methods and ﬁelds for processing, for example,
In this context, it made no sense to apply the same annotation twice.
Of course, different annotations on the same element are ﬁne and quite common:
Soon, more and more uses for annotations emerged, leading to situations where one would have liked to repeat the same annotation.
For example, to denote a composite key in a database, you need to specify multiple columns:
Since that wasn’t possible, the annotations were packed into a container annotation, like this:
That’s pretty ugly, and it is no longer necessary in Java 8
As an annotation user, that is all you need to know.
If your framework provider has enabled repeated annotations, you can just use them.
For a framework implementor, the story is not quite as simple.
To solve this problem, the inventor of a repeatable annotation must.
For example, for a simple unit testing framework, we might deﬁne a repeatable.
When annotation processing code calls element.getAnnotation(TestCase.class) on the element representing the factorial method, null is returned.
This is because the element is actually annotated with the container annotation TestCases.
When implementing an annotation processor for your repeatable annotation, you will ﬁnd it simpler to use the getAnnotationsByType method.
NOTE: What I just described relates to processing runtime annotations with the reﬂection API.
If you process source-level annotations, you use the javax.lang.model and javax.annotation.processing APIs.
Prior to Java 8, an annotation was applied to a declaration.
A declaration is a part of code that introduces a new name.
Here are a couple of examples, with the declared name in bold:
This can be useful in combination with tools that check for common programming errors.
One common error is throwing a NullPointerException because the programmer didn’t anticipate that a reference might be null.
Now suppose you annotated variables that you never want to be null as @NonNull.
Of course, the tool should detect any statement that might cause names to become null:
It sounds tedious to put such annotations everywhere, but in practice, some of the drudgery can be avoided by simple heuristics.
The null checker in the Checker Framework (http://types.cs.washington.edu/checker-framework) assumes that any nonlocal variables are implicitly @NonNull, but that local variables might be null unless the code shows otherwise.
If a method may return a null, it needs to be annotated as @Nullable.
That may not be any worse than documenting the nullness behavior.
In the preceding example, the names variable was declared as @NonNull.
But how can one express that the list elements should be non-null? Logically, that would be.
It is this kind of annotation that was not possible before Java 8 but has now become legal.
There are currently no standard annotations that are meaningful for type use.All examples in this section come from the Checker Framework or from the author’s imagination.
They have no effect on the behavior of a cast or an instanceof check.)
There are a few type positions that cannot be annotated:
You can supply a separate annotation, but it would apply to the name declaration.)
The practical use of these annotations hinges on the viability of the tools.
If you are interested in exploring the potential of extended type checking, a good place to start is the Checker Framework tutorial at http://types.cs.washington.edu/ checker-framework/tutorial.
In almost all cases, the parameter names are the same as the annotation arguments, or they can be made to be the same.
If the annotation processor could read the parameter names, then one could simply write.
This is possible in Java 8, with the new class java.lang.reflect.Parameter.
Unfortunately, for the necessary information to appear in the classﬁle, the source must be compiled as javac -parameters SourceFile.java.
Let’s hope annotation writers will enthusiastically embrace this mechanism, so there will be momentum to drop that compiler ﬂag in the future.
We end this chapter with miscellaneous minor changes that you might ﬁnd useful.
This section covers the new features of the Objects, Logger, and Locale classes, as well as changes to regular expressions and JDBC.
The Objects class has static predicate methods isNull and nonNull that can be useful for streams.
The log, logp, severe, warning, info, config, fine, finer, and finest methods of the java.util.Logger class now support lazily constructed messages.
The message string is formatted even when the logging level is such that it would never be used.
Now the lambda expression is only evaluated at the FINEST logging level, when the cost of the additional lambda invocation is presumably the least of one’s problems.
The requireNonNull of the Objects class (which is described in Chapter 9) also has a version that computes the message string lazily.
In the common case that directions is not null, this.directions is simply set to directions.
If directions is null, the lambda is invoked, and a NullPointerException is thrown whose message is the returned string.
In Java 8, you can use the names in the start, end, and group methods of Matcher:
The Pattern class has a splitAsStream method that splits a CharSequence along a regular expression:
The method asPredicate can be used to ﬁlter strings that match a regular expression:
A locale speciﬁes everything you need to know to present information to a user with local preferences concerning language, date formats, and so on.
It used to be that locales were simple, consisting of location, language, and (for a few oddball cases, such as the Norwegians who have two spelling systems) variants.
Nowadays, a locale is composed of up to ﬁve components.
A language, speciﬁed by two or three lowercase letters, such as en (English) or de (German or, in German, Deutsch)
A script, speciﬁed by four letters with an initial uppercase, such as Latn (Latin), Cyrl (Cyrillic), or Hant (traditional Chinese characters)
This is useful because some languages, such as Serbian, are written in Latin or Cyrillic, and some Chinese readers prefer the traditional over the simpliﬁed characters.
A country, speciﬁed by two uppercase letters or three digits, such as US (United States) or CH (Switzerland)
Nynorsk spelling of Norwegian is now expressed with a different language code, nn, instead of a variant NY of the language no.
Extensions describe local preferences for calendars (such as the Japanese calendar), numbers (Thai digits), and so on.
Such extensions start with u- and a two-letter code specifying whether the extension deals with the calendar (ca), numbers (nu), and so on.
For example, the extension u-nu-thai denotes the use of Thai numerals.
Other extensions are entirely arbitrary and start with x-, such as x-java.
You can still construct a locale the old-fashioned way, such as new Locale("en", "US"), but since Java 7 you can simply call Locale.forLanguageTag("en-US")
Java 8 adds methods for ﬁnding locales that match user needs.
A language range is a string that denotes the locale characteristics that a user desires, with * for wildcards.
For example, a German speaker in Switzerland might prefer anything in German, followed by anything in Switzerland.
This is expressed with two Locale.LanguageRange objects speciﬁed with strings "de" and "*-CH"
Given a list of weighted language ranges and a collection of locales, the filter method produces a list of matching locales, in descending order of match quality:
In this case, the best match is de, which isn’t very interesting.
But if locales contains a more restricted set of locales, such as those in which a document was available, then this mechanism can be useful.
The Date, Time, and Timestamp classes in the java.sql package have methods to convert from and to their java.time analogs LocalDate, LocalTime, and LocalDateTime.
The Statement class has a method executeLargeUpdate for executing an update whose row count exceeds Integer.MAX_VALUE.
For which integer n does Math.negateExact(n) throw an exception? (Hint: There is only one.)
Euclid’s algorithm (which is over two thousand years old) computes the gcd(b, rem(a, b)) otherwise, where rem is the remainder.
Clearly, the gcd should not be negative, even if a or b are (since its negation would then be a greater divisor)
Implement the algorithm with %, floorMod, and a rem function that produces the mathematical (non-negative) remainder.
Which of the three gives you the least hassle with negative values?
Generate a million predecessors, using a stream of course, and pick the minimum seed.
Hint: You will get a zero after 376050 calls to nextDouble.
At the beginning of Chapter 2, we counted long words in a list as expression, but without using streams.
Using only methods of the Comparator class, deﬁne a comparator for Point2D which is a total ordering (that is, the comparator only returns zero for equal objects)
Write a program that demonstrates the beneﬁts of the CheckedQueue class.
Write methods that turn a Scanner into a stream of words, lines, integers, or double values.
Using Files.walk, ﬁnd all Java ﬁles that contain the keywords transient and volatile.
Write a program that gets the contents of a password-protected web page.
Implement the TestCase annotation and a program that loads a class with such annotations and invokes the annotated methods, checking whether they yield the expected values.
Repeat the preceding exercise, but build a source-level annotation processor emitting a program that, when executed, runs the tests in its main method.
Demonstrate the use of the Objects.requireNonNull method and show how it leads to more useful error messages.
Using Files.lines and Pattern.asPredicate, write a program that acts like the grep utility, printing all lines that contain a match for a regular expression.
Use a regular expression with named capturing groups to parse a line containing a city, state, and zip code.
In this chapter, I will write about some of the library changes that haven’t been discussed so much and that I have found far more useful in daily work than switching on strings or binary literals.
I cover one language change that is very useful in daily work—the try-with-resources statement.
Use the try-with-resources statement with any object that implements AutoCloseable.
The try-with-resources statement rethrows the primary exception if closing a resource throws another exception.
You can catch unrelated exceptions with a single catch clause.
The exceptions for reﬂective operations now have a common superclass ReflectiveOperationException.
You can read and write all characters, or all lines, of a text ﬁle with a single command.
The Files class has static methods for copying, moving, and deleting ﬁles, and for creating ﬁles and directories.
When comparing numbers in a comparator, use the static compare method.
Applets and Java Web Start applications continue to be supported in corporate environments, but they may no longer be viable for home users.
Everyone’s favorite trivial change: "+1" can now be converted to an integer without throwing an exception.
Changes in ProcessBuilder make it simple to redirect standard input, output, and error streams.
I start this chapter with the Java 7 features for exception handling, since they have a major impact on writing reliable programs.
I brieﬂy review the try-with-resources statement before moving on to more subtle changes.
Java 7 provides a useful shortcut to the code pattern.
It is a subinterface of AutoCloseable, also with a single close method, but that method is declared to throw an IOException.
In its simplest variant, the try-with-resources statement has the form.
No matter how the block exits, both in and out are closed if they were constructed.
NOTE: A try-with-resources statement can itself have catch clauses and a finally clause.
In practice, it’s probably not a good idea to pile so much onto a single try statement.
Whenever you work with input or output, there is an awkward problem with closing the resource after an exception.
Suppose an IOException occurs and then, when closing the resource, the call to close throws another exception.
Which exception will actually be caught? In Java, an exception thrown in a finally clause discards the previous exception.
After all, the user is likely to be much more interested in the original exception.
When an exception is thrown in a close method of one of the AutoCloseable objects, the original exception gets rethrown, and the exceptions from calling close are caught and attached as “suppressed” exceptions.
This is a very useful mechanism that would be tedious to implement by hand (see Exercise 2)
When you catch the primary exception, you can retrieve those secondary exceptions by calling the getSuppressed method:
If you want to implement such a mechanism yourself in the (hopefully rare) situation when you can’t use the try-with-resources statement, call.
NOTE: The classes Throwable, Exception, RuntimeException, and Error have constructors with an option for disabling suppressed exceptions and for disabling stack traces.
When suppressed exceptions are disabled, calling addSuppressed has no effect, and getSuppressed returns a zero-length array.
When stack traces are disabled, calls to fillInStackTrace have no effect, and getStackTrace returns a zero-length array.
This can be useful for VM errors when memory is low, or for programming languages on the VM that use exceptions to break out of nested method calls.
CAUTION: Detecting secondary exceptions only works when it isn’t actively sabotaged.
In particular, if you use a Scanner, and if input fails, and then closing fails, the Scanner class catches the input exception, closes the resource and catches that exception, and then throws an entirely different exception, without linking the suppressed exceptions.
As of Java SE 7, you can catch multiple exception types in the same catch clause.
For example, suppose that the action for missing ﬁles and unknown hosts is the same.
This feature is only needed when catching exception types that are not subclasses of one another.
Catching multiple exceptions doesn’t just make your code look simpler but is also more efﬁcient.
The generated bytecodes contain a single block for the shared catch clause.
NOTE: When you catch multiple exceptions, the exception variable is implicitly ﬁnal.
In the past, when you called a reﬂective method, you had to catch multiple unrelated checked exceptions.
For example, suppose you construct a class and invoke its main method:
Of course, you can use the feature described in the preceding section and combine them in a single clause:
Plainly, it is bad design not to provide a common superclass for related exceptions.
A new superclass ReflectiveOperationException has been introduced so that you can catch all of these exceptions in a single handler:
The try-with-resources statement is my favorite feature in Java 7, but the ﬁle handling improvements are a close second.
Operations that used to be tedious, such as reading a ﬁle into a string, or copying a ﬁle to another, are now as easy as they should have been all along.
Before you can learn how to carry out these easy ﬁle operations, you have to learn about the Path interface that replaces the File class.
Next, you will see how to read and write ﬁles.
A Path is a sequence of directory names, optionally followed by a ﬁle name.
The ﬁrst component of a path may be a root component, such as / or C:\
A path that starts with a root component is absolute.
For example, here we construct an absolute and a relative path.
For the absolute path, we assume a computer running a Unix-like ﬁle system.
The static Paths.get method receives one or more strings, which it joins with the path separator of the default ﬁle system (/ for a Unix-like ﬁle system, \ for Windows)
It then parses the result, throwing an InvalidPathException if the result is not a valid path in the given ﬁle system.
You can also provide a string with separators to the Paths.get method:
NOTE: Just like a File object, a Path object does not have to correspond to a ﬁle that actually exists.
To create a ﬁle, ﬁrst make a path, then call a method to create the corresponding ﬁle.
The call p.resolve(q) returns a path according to these rules:
For example, suppose your application needs to ﬁnd its conﬁguration ﬁle relative to the home directory.
There is a convenience method resolveSibling that resolves against a path’s parent, yielding a sibling path.
The call p.relativize(r) yields the path q which, when resolved with p, yields r.
The toAbsolutePath method yields the absolute path of a given path.
The Path interface has many useful methods for taking paths apart and combining them with other paths.
This code sample shows some of the most useful ones:
NOTE: Occasionally, you may need to interoperate with legacy APIs that use the File class instead of the Path interface.
The Path interface has a toFile method, and the File class has a toPath method.
The Files class makes quick work of common ﬁle operations.
For example, you can easily read the entire contents of a ﬁle:
If you want to read the ﬁle as a string, call readAllBytes followed by.
But if you want the ﬁle as a sequence of lines, call.
NOTE: By default, all methods of the Files class that read or write characters use the UTF-8 encoding.
In the (hopefully unlikely) case that you need a different encoding, you can supply a Charset argument.
Contrast with the String constructor and getBytes method which use the platform default.
When you work with text ﬁles of moderate length, it is usually simplest to process the contents as a single string or list of strings.
If your ﬁles are large or binary, you can still use the familiar streams or readers/writers:
These convenience methods save you from having to deal with FileInputStream, FileOutputStream, BufferedReader, or BufferedWriter.
Occasionally, you may have an InputStream (for example, from a URL) and you want to save its contents to a ﬁle.
All but the last component in the path must already exist.
The call throws an exception if the ﬁle already exists.
If the ﬁle doesn’t exist, it is created before anyone else has a chance to do the same.
There are convenience methods for creating a temporary ﬁle or directory in a given or system-speciﬁc location.
Here, dir is a Path, and prefix/suffix are strings which may be null.
For example, the call Files.createTempFile(null, ".txt") might return a path such as /tmp/1234405522364837194.txt.
NOTE: To read ﬁles from a directory, use the Files.list and Files.walk methods described in Chapter 8
To copy a ﬁle from one location to another, simply call.
To move a ﬁle (that is, copy and delete the original), call.
You can also use this command to move an empty directory.
The copy or move will fail if the target exists.
If you want to overwrite an existing target, use the REPLACE_EXISTING option.
If you want to copy all ﬁle attributes, use the COPY_ATTRIBUTES option.
Then you are assured that either the move completed successfully, or the source continues to be present.
This method throws an exception if the ﬁle doesn’t exist, so instead you may want to use.
The deletion methods can also be used to remove an empty directory.
NOTE: There is no convenient method for removing or copying a nonempty directory.
See the API documentation of the FileVisitor interface for code outlines that achieve these tasks.
Java 7 introduces several methods that make it more convenient to deal with null values in the ubiquitous equals and hashCode, and with numeric comparisons in compareTo.
Suppose you have to implement the equals method for this class:
First, there is the drudgery of casting the parameter to a Person:
Instead of worrying that first or last might be null, just call.
The call Objects.equals(a, b) returns true if both a and b are null, false if only a is null, and a.equals(b) otherwise.
NOTE: In general, it is a good idea to call Objects.equals(a, b) when you would have called a.equals(b) before.
The Objects.hashCode method returns a code of 0 for a null argument, so you can implement the body of your hashCode method like this:
The varargs method Objects.hash, introduced in Java 7, lets you specify any sequence of values, and their hash codes get combined:
NOTE: Objects.hash simply calls Arrays.hash, which existed since Java 5
But it isn’t a varargs method, making it less convenient.
NOTE: There has always been a null-safe way of calling toString as String.valueOf(obj)
If you don’t like that, you can use Object.toString and supply the value to be used for null, for example Object.toString(obj, "")
When you compare integers in a comparator, it is tempting to return the difference between them since you are allowed to return any negative or positive number—only the sign matters.
If x is large and other.x is negative, the difference can overﬂow.
In the past, some people used new Integer(x).compareTo(other.x), but that creates two boxed integers.
The static compare method has also been added to Long, Short, Byte, and Boolean.
If you need to compare two char values, you can safely subtract them because the result will not overﬂow.
The same is true for short or byte, of course.)
NOTE: The static compare method existed for Double and Float since Java 1.2
The designers of Java knew perfectly well that executing remote code is a security risk, so they designed a “sandbox” model that stopped any damaging instructions in their tracks.
Soon thereafter, academic researchers found some implementation ﬂaws that were promptly ﬁxed, and other academic researchers groused in general over the fact that the Java security model was rather complex and there was little assurance that its darker corners are safe from assault.
At the time, I didn’t take that very seriously because the vast majority of Java applet consumers used Microsoft Windows, which was far less secure and far more complex.
Applets were limited to visual effects and network connections to the originating host, which many application writers found limiting.
They wanted local device access for storage, printing, and so on.
Unfortunately, Java Web Start was poorly understood, not integrated with applets, and not maintained with any vigor.
Instead, many application developers simply signed their web-delivered programs, which gave them full permission to do anything on the user’s machine.
Signing certiﬁcates from commercial entities are within reach of anyone willing to endure some cost and pain.
It was also possible to apply a meaningless selfsigned certiﬁcate, or have users agree to run an applet without a certiﬁcate.
Warnings were toned down from one release to the next until they became background noise.
Meanwhile, Microsoft, with an enormous engineering effort, got better at closing Windows loopholes, and it became worthwhile for hackers to look at obscure Java vulnerabilities instead.
When Oracle purchased Sun in 2010, they inherited a very limited infrastructure for dealing with such attacks and no reliable means of updating client virtual machines.
In this regard, the early researchers who warned of a large attack surface in the Java security model were entirely justiﬁed.
It took Oracle until 2013 to credibly respond to attacks.
Management of client VMs is still a work in progress.
As of today, Oracle signals that it is no longer focused on securing home users’ Java applets and Web Start applications (collectively called rich internet applications, or RIAs)
Oracle continues to close Java vulnerabilities, and develops tools that are suitable for corporate deployment, so that legacy RIAs can be deployed safely.
Home users are expected to migrate away from PCs to tablets and smartphones.
These devices don’t support a Java VM in the browser.
And business users are a plausible revenue target for maintaining legacy applications.
With successive Java 7 releases, Oracle has tightened the security rules.
As of January 2014, RIAs running outside the sandbox need to be signed by a commercial certiﬁcate authority.
As of January 2014, all JARs must have a manifest entry.
Since the manifest entry is inside the JAR ﬁle, it is signed and cannot be modiﬁed afterwards.
The Java client will not permit sandbox execution of an all-permission client, which prevents “drive-by” attacks where an applet runs without any user consent.
Of course, it is still possible to attack users who are habituated to agree to any security dialogs.
To make that harder, another, as yet optional, manifest entry has been added:
NOTE: It has always been possible to call applets from JavaScript—another dubious decision from the point of view of the security minded.
If you are using that feature in your application, you can minimize the repurposing risk by adding an entry Caller-Allowable-Codebase: https://www.mycompany.com to the manifest before signing.
Java held great promise as a universal execution platform for remote code.
If Java had offered a more compelling sandbox, if nonsandbox code had been more aggressively controlled, if there had.
But there is no use dwelling on what might have been.
At this point, Java is no longer a viable platform for widespread distribution of client applications over the Internet.
If you maintain an applet or Java Web Start application for home users, the message is clear: Move away from it.
If your application serves a specialized audience (for example, software development, image editing, or document processing), make your users install Java or bundle a JVM with your installer.
NOTE: If you decide to make your users install Java, you face another hurdle.
If you direct Windows users to the installer at http://java.com, they will receive the widely reviled toolbar for Ask.com by default (see Figure 9–1).You have a couple of alternatives.You could have your users install the JDK, directing them to www.oracle.com/technetwork/java/javase/downloads and providing them with instructions for traversing that ever-changing page.
Or you could bundle a JVM, which you are then obligated to update since no effective update mechanism is supplied by Oracle.
In a corporate environment, you can effectively secure Java RIAs, provided you have control over the applications and the client machines.
You will need to tightly manage the application packaging and be ready to update client VMs when security updates become available.
NOTE: To more tightly manage corporate RIAs, you can provide deployment rulesets on end-user machines.
As in the preceding chapter, this section describes a number of smaller features that you may ﬁnd interesting or useful.
This has now been ﬁxed for all the various methods that construct int, long, short, byte, and BigInteger values from strings.
In addition to parse(Int|Long|Short|Byte), there are decode methods that work with hexadecimal and octal inputs, and valueOf methods that yield wrapper objects.
In order to encourage the use of logging even in simple cases, the Logger class has a global logger instance.
It was meant to be as easy as possible to use, so that you.
Unfortunately, that instance variable has to be initialized somewhere, and if other logging happens in the static initialization code, it was possible to cause deadlocks.
Instead, you were supposed to call Logger.getLogger(Logger.GLOBAL_LOGGER_NAME), which wasn’t anyone’s idea of quick and easy logging.
The Objects class has methods requireNonNull for convenient null checks of parameters.
If directions is null, a NullPointerException is thrown, which doesn’t seem like a huge improvement at ﬁrst.
When you see a call to requireNonNull as the culprit, you know right away what you did wrong.
You can also supply a message string for the exception:
Prior to Java 5, the Runtime.exec method was the only way to execute an external command from within a Java application.
Java 5 added the ProcessBuilder class that gives more control over the generated operating system process.
In particular, with the ProcessBuilder, you can change the working directory.
Java 7 adds convenience methods to hook the standard input, output, and error streams of the process to ﬁles.
NOTE: Since Java 8, the Process class has a waitFor method with timeout:
Also new in Java 7 is the inheritIO method of ProcessBuilder.
It sets the standard input, output, and error streams of the process to those of the Java program.
Suppose you want to write a Java program that automates execution of JUnit tests.
To load the JUnitCore class, you need a class loader that reads the JUnit JAR ﬁles:
Before Java 7, code such as this could lead to resource leaks.
Java 7 simply adds a close method to close the classloader.
URLClassLoader now implements AutoCloseable, so you can use a try-with-resources statement:
CAUTION: Don’t use any classes after the classloader has been closed.
If you do, and those classes need to load other classes to do their work, they will fail.
A BitSet is a set of integers that is implemented as a sequence of bits.
The ith bit is set if the set contains the integer i.
NOTE: As of Java 8, BitSet has a method stream that yields an IntStream.
Be sure to close both objects, provided they have been properly constructed.
Improve on the preceding exercise by adding any exceptions thrown by there was one.
When you rethrow an exception that you caught in a multi-catch clause, how do you declare its type in the throws declaration of the ambient method? For example, consider.
In which other parts of the Java library did you encounter situations that would beneﬁt from multi-catch or, even better, common exception superclasses? (Hint: XML parsing.)
Write a program that reads all characters of a ﬁle and writes them out in reverse order.
Write a program that reads all lines of a ﬁle and writes them out in reverse order.
Write a program that reads the contents of a web page and saves it to a ﬁle.
Implement a compareTo method for the LabeledPoint class of the preceding exercise.
Using the ProcessBuilder class, write a program that calls grep -r to look for credit card numbers in all ﬁles in any subdirectory of the user’s home directory.
Suppose you want to offer it to users as a security scan.
Package it so that it will run on your JRE.
Java Web Start, 190–192 java, javax, javafx global objects (JavaScript),
Horstmann introduces Scala concepts and techniques in  blogsized  chunks that you can quickly master and apply.
To begin the registration process, simply go to informit.com/register to sign in or create an account.
Here you will gain access to quality and trusted content and.
Access to supplemental content, including bonus chapters, source code, or project files.
Benefits will be listed on your Account page under Registered Products.
InformIT is a brand of Pearson and the online presence for the world’s leading technology publishers.
It’s your source for reliable and qualified content and knowledge, providing access to the top brands, authors, and contributors from the tech community.
Learn about new releases and special promotions by subscribing to a wide variety of newsletters.
Read the latest author articles and sample chapters at informit.com/articles.
Access thousands of books and videos in the Safari Books Online digital library at safari.informit.com.
Visit informit.com/learn to discover all the ways you can access the hottest technology content.
Feed your brain Gain unlimited access to thousands of books and videos about technology,
See it, believe it Watch hundreds of expert-led instructional videos on today’s hottest topics.
WAIT, THERE’S MORE! Gain a competitive edge Be first to learn about the newest technologies and subjects with Rough Cuts.
Accelerate your project Copy and paste code, create smart searches that let you know when new.
If you have diﬃ culty registering on Safari or accessing the online edition, please e-mail customer-service@safaribooksonline.com.
Safari Books Online is a digital library providing searchable, on-demand access to thousands of technology, digital media, and professional development books and videos from leading publishers.
With one monthly or yearly subscription price, you get unlimited access to learning tools and information on topics including mobile app and software development, tips and tricks on using your favorite gadgets, networking, project management, graphic design, and much more.
