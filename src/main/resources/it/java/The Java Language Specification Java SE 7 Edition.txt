Oracle and Java are registered trademarks of Oracle and/or its affiliates.
The Specification provided herein is provided to you only under the Limited License Grant included herein as Appendix A.
Generics, annotations, autoboxing and unboxing, enum types, foreach loops, variable arity methods, and static imports are all new to the language as of Autumn 2004
The Java programming language has grown a great deal in these past four years.
Unfortunately, it is unrealistic to shrink a commercially successful programming language - only to grow it more and more.
The challenge of managing this growth under the constraints of compatibility and the conflicting demands of a wide variety of uses and users is non-trivial.
I can only hope that we have met this challenge successfully with this specification; time will tell.
This specification builds on the efforts of many people, both at Sun Microsystems and outside it.
The most crucial contribution is that of the people who actually turn the specification into real software.
Chief among these are the maintainers of javac, the reference compiler for the Java programming language.
Neal's dedication and productivity can honestly be described as heroic.
We literally could not have completed the task without him.
In addition, his insight and skill made a huge contribution to the design of the new language features across the board.
No one deserves more credit for this version of the Java programming language than he - but any blame for its deficiencies should be directed at myself and the members of the many JSR Expert Groups!
Another individual who deserves to be singled out is Joshua Bloch.
Josh participated in endless language design discussions, chaired several Expert Groups and was a key contributor to the Java platform.
It is fair to say that Josh and Neal care more about this book than I do myself! Many parts of the specification were developed by various Expert Groups in the framework of the Java Community Process.
Ann Sellers, Greg Doench, and John Fuller at Addison-Wesley were exceedingly patient and ensured that the book materialized, despite the many missed deadlines for this text.
As always, I thank my wife Weihong and my son Teva for their support and cooperation.
This success has brought a challenge: along with explosive growth in popularity, there has been explosive growth in the demands made on the language and its libraries.
To meet this challenge, the language has grown as well (fortunately, not explosively) and so have the libraries.
It integrates all the changes made to the Java programming language since the publication of the First Edition in 1996
In addition, this edition incorporates important clarifications and amendments involving method lookup and binary compatibility.
The Java programming language is likely to continue to evolve.
At this writing, there are ongoing initiatives through the Java Community Process to extend the language with generic types and assertions, refine the memory model, etc.
However, it would be inappropriate to delay the publication of the Second Edition until these efforts are concluded.
The specifications of the libraries are now far too large to fit into this volume, and they continue to evolve.
The library specifications can be found on the Web; this specification now concentrates solely on the Java programming language proper.
Tim Lindholm brought extraordinary dedication to his role as technical editor of the Java Series.
He also made invaluable technical contributions, especially on floating-point issues.
The book would likely not see the light of day without him.
Lisa Friendly, the Series editor, provided encouragement and advice for which I am very thankful.
David Bowen first suggested that I get involved in the specifications of the Java platform.
I am grateful to him for introducing me to this uncommonly rich area.
John Rose, the father of nested types in the Java programming language, has been unfailingly gracious and supportive of my attempts to specify them accurately.
Special thanks go to Roly Perera at Ergnosis and to Leonid Arbouzov and his colleagues on.
Their thorough reading of earlier drafts has greatly improved the accuracy of this specification.
They all worked hard to make sure the reference implementation conformed to the specification.
Tricia Jordan, my manager, has been a model of patience, consideration and understanding.
Thanks are also due to Larry Abrahams, director of Java 2 Standard Edition, for supporting this work.
Suzette Pelouch provided invaluable assistance with the index and, together with Doug Kramer and Atul Dambalkar, assisted with FrameMaker expertise; Mike Hendrickson and Julie Dinicola at Addison-Wesley were gracious, helpful and ultimately made this book a reality.
On a personal note, I thank my wife Weihong for her love and support.
Finally, I'd like to thank my coauthors, James Gosling, Bill Joy, and Guy Steele for inviting me to participate in this work.
After several years of experience with the language, and significant contributions by Ed Frank, Patrick Naughton, Jonathan Payne, and Chris Warth it was retargeted to the Internet, renamed, and substantially revised to be the language specified here.
The Java programming language is a general-purpose concurrent class-based object-oriented programming language, specifically designed to have as few implementation dependencies as possible.
It allows application developers to write a program once and then be able to run it everywhere on the Internet.
This book attempts a complete specification of the syntax and semantics of the language.
We intend that the behavior of every language construct is specified here, so that all implementations will accept the same programs.
Except for timing dependencies or other non-determinisms and given sufficient time and sufficient memory space, a program written in the Java programming language should compute the same result on all machines and in all implementations.
We believe that the Java programming language is a mature language, ready for widespread use.
Nevertheless, we expect some evolution of the language in the years to come.
We intend to manage this evolution in a way that is completely compatible with existing applications.
To do this, we intend to make relatively few new versions of the language.
Compilers and systems will be able to support the several versions simultaneously, with complete compatibility.
Much research and experimentation with the Java platform is already underway.
We encourage this work, and will continue to cooperate with external groups to explore improvements to the language and platform.
For example, we have already received several interesting proposals for parameterized types.
In technically difficult areas, near the state of the art, this kind of research collaboration is essential.
We acknowledge and thank the many people who have contributed to this book through their excellent feedback, assistance and encouragement:
We apologize if we have omitted anyone.) The feedback from all these reviewers was invaluable to us in improving the definition of the language as well as the form of the presentation in this book.
Any remaining errors in this book - we hope they are few - are our responsibility and not theirs.
We thank Francesca Freedman and Doug Kramer for assistance with matters of typography and layout.
We thank Dan Mills of Adobe Systems Incorporated for assistance in exploring possible choices of typefaces.
Many of our colleagues at Sun Microsystems have helped us in one way or another.
Lisa Friendly, our series editor, managed our relationship with Addison-Wesley.
Susan Stambaugh managed the distribution of many hundreds of copies of drafts to reviewers.
We are thankful for the tools and services we had at our disposal in writing this book: telephones, overnight delivery, desktop workstations, laser printers, photocopiers, text formatting and page layout software, fonts, electronic mail, the World Wide Web, and, of course, the Internet.
In their book The C Programming Language, Brian Kernighan and Dennis Ritchie said that they felt that the C language "wears well as one's experience with it grows." If you like C, we think you will like the Java programming language.
Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.
It supports the writing of Unicode characters on systems that support only ASCII.
The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a boolean type, and a Unicode character char type.
Reference types are the class types, the interface types, and the array types.
The reference types are implemented by dynamically created objects that are either instances of classes or arrays.
All objects (including arrays) support the methods of the class Object, which is the (single) root of the class hierarchy.
In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing)
Class and interface declarations may be generic, that is, they may be parameterized by other reference types.
Such declarations may then be invoked with specific type arguments.
A variable of a primitive type holds a value of that exact primitive type.
A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type.
A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface.
A variable of an array type can hold a null reference or a reference to an array.
A variable of class type Object can hold a null reference or a reference to any object, whether class instance or array.
Conversions change the compile-time type and, sometimes, the value of an expression.
These conversions include the boxing and unboxing conversions between primitive types and reference types.
Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed.
Chapter 6 describes declarations and names, and how to determine what names mean (denote)
The language does not require types or their members to be declared before they are used.
Declaration order is significant only for local variables, local classes, and the order of initializers of fields in a class or interface.
The Java programming language provides control over the scope of names and supports limitations on external access to members of packages, classes, and interfaces.
This helps in writing large programs by distinguishing the implementation of a type from its users and those who extend it.
Recommended naming conventions that make for more readable programs are described here.
Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula.
The members of a package are classes, interfaces, and subpackages.
Compilation units contain type declarations and can import types from other packages to give them short names.
Packages have names in a hierarchical name space, and the Internet domain name system can usually be used to form unique package names.
The members of classes are classes, interfaces, fields (variables) and methods.
Instance variables are dynamically created in objects that are instances of classes.
Instance methods are invoked on instances of classes; such instances become the current object this during their execution, supporting the object-oriented programming style.
Classes support single implementation inheritance, in which the implementation of each class is derived from that of a single superclass, and ultimately from the class Object.
Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.
Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled.
Objects can declare a finalize method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.
For simplicity, the language has neither declaration "headers" separate from the implementation of a class nor separate type and class hierarchies.
A special form of classes, enums, support the definition of small sets of values and their manipulation in a type safe manner.
Unlike enumerations in other languages, enums are objects and may have their own methods.
Chapter 9 describes interface types, which declare a set of abstract methods, member types, and constants.
Classes that are otherwise unrelated can implement the same interface type.
A variable of an interface type can contain a reference to any object that implements the interface.
Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way.
Arrays are dynamically created objects and may be assigned to variables of type Object.
The language supports arrays of arrays, rather than multidimensional arrays.
Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms.
There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors.
The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it.
This provides compile-time checking that exception handlers exist, and aids programming in the large.
Errors result from failures detected by the Java Virtual Machine, such as OutOfMemoryError.
Chapter 12 describes activities that occur during execution of a program.
A program is normally stored as binary files representing compiled classes and interfaces.
These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.
After initialization, class methods and class variables may be used.
Some classes may be instantiated to create new objects of the class type.
Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.
When an object is no longer referenced, it may be reclaimed by the garbage collector.
If an object declares a finalizer, the finalizer is executed before the object.
When a class is no longer needed, it may be unloaded.
Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled.
These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet.
Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.
The language has no goto statement, but includes labeled break and continue statements.
Unlike C, the Java programming language requires boolean (or Boolean) expressions in control-flow statements, and does not convert types to boolean implicitly (except through unboxing), in the hope of catching more errors at compile time.
A try statement can include catch and finally clauses to protect against non-local control transfers.
This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability.
Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.
Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use.
While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.
Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language.
The Java programming language specifies a memory model for sharedmemory multiprocessors that supports high-performance implementations.
Most of the example programs given in the text are ready to be executed and are similar in form to:
On a machine with the Oracle JDK installed, this class, stored in the file Test.java, can be compiled and executed by giving the commands:
As noted above, this specification often refers to classes of the Java SE platform API.
In particular, some classes have a special relationship with the Java programming language.
This specification constrains the behavior of such classes and interfaces, but does not provide a complete specification for them.
The reader is referred to the Java SE platform API documentation.
Consequently, this specification does not describe reflection in any detail.
Many linguistic constructs have analogs in the reflection API, but these are generally.
For example, when we list the ways in which an object can be created, we generally do not include the ways in which the reflection API can accomplish this.
Readers should be aware of these additional mechanisms even though they are not mentioned in the text.
Each production has an abstract symbol called a nonterminal as its left-hand side, and a sequence of one or more nonterminal and terminal symbols as its right-hand side.
For each grammar, the terminal symbols are drawn from a specified alphabet.
Starting from a sentence consisting of a single distinguished nonterminal, called the goal symbol, a given context-free grammar specifies a language, namely, the set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.
Chapter 18 also gives a syntactic grammar for the Java programming language, better suited to implementation than exposition.
Terminal symbols are shown in fixed width font in the productions of the lexical and syntactic grammars, and throughout this specification whenever the text is directly referring to such a terminal symbol.
These are to appear in a program exactly as written.
The definition of a nonterminal is introduced by the name of the nonterminal being defined followed by a colon.
One or more alternative right-hand sides for the nonterminal then follow on succeeding lines.
This definition of ArgumentList is recursive, that is to say, it is defined in terms of itself.
The result is that an ArgumentList may contain any positive number of arguments.
The subscripted suffix "opt", which may appear after a terminal or nonterminal, indicates an optional symbol.
The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it.
BasicForStatement: for ( ; ; ForUpdateopt ) Statement for ( ; Expression ; ForUpdateopt ) Statement for ( ForInit ; ; ForUpdateopt ) Statement for ( ForInit ; Expression ; ForUpdateopt ) Statement.
BasicForStatement: for ( ; ; ) Statement for ( ; ; ForUpdate ) Statement for ( ; Expression ; ) Statement for ( ; Expression ; ForUpdate ) Statement for ( ForInit ; ; ) Statement for ( ForInit ; ; ForUpdate ) Statement for ( ForInit ; Expression ; ) Statement for ( ForInit ; Expression ; ForUpdate ) Statement.
A very long right-hand side may be continued on a second line by substantially indenting this second line.
When the words "one of" follow the colon in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition.
When an alternative in a lexical production appears to be a token, it represents the sequence of characters that would make up such a token.
The right-hand side of a lexical production may specify that certain expansions are not permitted by using the phrase "but not" and then indicating the expansions to be excluded.
Finally, a few nonterminal symbols are described by a descriptive phrase in roman type in cases where it would be impractical to list all the alternatives.
The Java SE platform tracks the Unicode specification as it evolves.
The precise version of Unicode used by a given release is specified in the documentation of the class Character.
The Unicode standard was originally designed as a fixed-width 16-bit character encoding.
It has since been changed to allow for characters whose representation requires more than 16 bits.
Some APIs of the Java SE platform, primarily in the Character class, use 32-bit integers to represent code points as individual entities.
A raw Unicode character stream is translated into a sequence of tokens, using the following three lexical translation steps, which are applied in turn:
This translation step allows any program to be expressed using only ASCII characters.
The longest possible translation is used at each step, even if the result does not ultimately make a correct program while another lexical translation would.
The \, u, and hexadecimal digits here are all ASCII characters.
If an eligible \ is not followed by u, then it is treated as a RawInputCharacter and remains part of the escaped Unicode stream.
If an eligible \ is followed by u, or more than one u, and the last u is not followed by four hexadecimal digits, then a compile-time error occurs.
The character produced by a Unicode escape does not participate in further Unicode escapes.
The Java programming language specifies a standard way of transforming a program written in Unicode into ASCII that changes a program into a form that can be processed by ASCII-based tools.
This transformed version is equally acceptable to a Java compiler and represents the exact same program.
The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple u's are present to a sequence of Unicode characters with one fewer u, while simultaneously converting each escape sequence with a single u to the corresponding single Unicode character.
A Java compiler should use the \uxxxx notation as an output format to display Unicode characters when a suitable font is not available.
A Java compiler next divides the sequence of Unicode input characters into lines by recognizing line terminators.
LineTerminator: the ASCII LF character, also known as "newline" the ASCII CR character, also known as "return" the ASCII CR character followed by the ASCII LF character.
The two characters CR immediately followed by LF are counted as one line terminator, not two.
The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.
As a special concession for compatibility with certain operating systems, the ASCII SUB character (\u001a, or control-Z) is ignored if it is the last character in the escaped input stream.
Consider two tokens x and y in the resulting input stream.
If x precedes y, then we say that x is to the left of y and that y is to the right of x.
WhiteSpace: the ASCII SP character, also known as "space" the ASCII HT character, also known as "horizontal tab" the ASCII FF character, also known as "form feed" LineTerminator.
An end-of-line comment: all the text from the ASCII characters // to the end of the line is ignored (as in C++)
These productions imply all of the following properties: • Comments do not nest.
An identifier is an unlimited-length sequence of Java letters and Java digits, the first of which must be a Java letter.
JavaLetter: any Unicode character that is a Java letter (see below)
JavaLetterOrDigit: any Unicode character that is a Java letter-or-digit (see below)
The $ character should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems.
Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean.
This allows programmers to use identifiers in their programs that are written in their native languages.
Two identifiers are the same only if they are identical, that is, have the same Unicode character for each letter or digit.
Identifiers that have the same external appearance may yet be different.
Keyword: one of abstract   continue   for          new         switch assert     default    if           package     synchronized boolean    do         goto         private     this break      double     implements   protected   throw byte       else       import       public      throws case       enum       instanceof   return      transient catch      extends    int          short       try char       final      interface    static      void class      finally    long         strictfp    volatile const      float      native       super       while.
The keywords const and goto are reserved, even though they are not currently used.
This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.
The suffix L is preferred, because the letter l (ell) is often hard to distinguish from the digit 1 (one)
Underscores are allowed as separators between digits that denote the integer.
In a decimal or octal literal, the integer is denoted by all the digits in the literal before any type suffix.
Therefore, underscores may not appear before the first digit or after the last digit in the numeral.
The following hexadecimal, octal, and binary literals represent the decimal value -1:
It is a compile-time error if a hexadecimal, octal, or binary int literal does not fit in 32 bits.
The following hexadecimal, octal, and binary literals represent the decimal value -1L:
It is a compile-time error if a hexadecimal, octal, or binary long literal does not fit in 64 bits.
A floating-point literal has the following parts: a whole-number part, a decimal or hexadecimal point (represented by an ASCII period character), a fraction part, an exponent, and a type suffix.
For decimal floating-point literals, at least one digit (in either the whole number or the fraction part) and either a decimal point, an exponent, or a float type suffix are required.
The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer.
For hexadecimal floating-point literals, at least one digit is required (in either the whole number or the fraction part), and the exponent is mandatory, and the float type suffix is optional.
The exponent is indicated by the ASCII letter p or P followed by an optionally signed integer.
Underscores are allowed as separators between digits that denote the whole-number part, and between digits that denote the fraction part, and between digits that denote the exponent.
Sign: one of + FloatTypeSuffix: one of f F d D.
The details of proper input conversion from a Unicode string representation of a floatingpoint number to the internal IEEE 754 binary floating-point representation are described for the methods valueOf of class Float and class Double of the package java.lang.
The largest positive finite literal of type float is 3.4028235e38f.
The smallest positive finite non-zero literal of type float is 1.40e-45f.
The smallest positive finite non-zero literal of type double is 4.9e-324
It is a compile-time error if a non-zero floating-point literal is too large, so that on rounded conversion to its internal representation, it becomes an IEEE 754 infinity.
It is a compile-time error if a non-zero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero.
A compile-time error does not occur if a non-zero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a nonzero denormalized number.
Predefined constants representing Not-a-Number values are defined in the classes Float and Double as Float.NaN and Double.NaN.
The boolean type has two values, represented by the boolean literals true and false, formed from ASCII letters.
In the Java programming language, a character literal always represents exactly one character.
Literal strings within different classes in the same package represent references to the same String object.
Literal strings within different classes in different packages likewise represent references to the same String object.
Strings computed by concatenation at run time are newly created and therefore distinct.
The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
The null type has one value, the null reference, represented by the null literal null, which is formed from ASCII characters.
Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type.
The null reference is the only possible value of an expression of null type.
The null reference can always undergo a widening reference conversion to any reference type.
In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.
The boolean type has exactly two values: true and false.
The values of the integral types are integers in the following ranges:
The Java programming language provides a number of operators that act on integral values:
The first multiplication is performed in 32-bit precision, whereas the second multiplication is a long multiplication.
Each of the four value sets includes not only the finite nonzero values that are ascribed to it above, but also NaN values and the four values positive zero, negative zero, positive infinity, and negative infinity.
Each extended-exponent value set has a larger range of exponent values than the corresponding standard value set, but does not have more precision.
The elements of the float value set are exactly the values that can be represented using the single floating-point format defined in the IEEE 754 standard.
The elements of the double value set are exactly the values that can be represented using the double floating-point format defined in the IEEE 754 standard.
Except for NaN, floating-point values are ordered; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, positive and negative zero, positive finite nonzero values, and positive infinity.
While each hardware architecture returns a particular bit pattern for NaN when a new NaN is generated, a programmer can also create NaNs with different bit patterns to encode, for example, retrospective diagnostic information.
For the most part, the Java SE platform treats NaN values of a given type as though collapsed into a single canonical value, and hence this specification normally refers to an arbitrary NaN as though to a canonical value.
The interested reader is referred to the specifications for the Float and Double classes for more information.
In particular, x!=x is true if and only if x is NaN.
The Java programming language provides a number of operators that act on floating-point values:
Other useful constructors, methods, and constants are predefined in the classes Float, Double, and Math.
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.
Because of the occasional need to use a generic class or interface name without type arguments, type names are distinct from type declaration specifiers.
A type name is always qualified by means of another type name.
In some cases, this is necessary to access an inner class that is a member of a parameterized type.
Here is an example of where a type declaration specifier is distinct from a type name:
If we accessed Inner by qualifying it with a type name, as in:
The method toString returns a String representation of the object.
When two reference types are the same, they are sometimes said to be the same class or the same interface.
At run time, several reference types with the same binary name may be loaded simultaneously by different class loaders.
These types may or may not represent the same type declaration.
Even if two such types do represent the same type declaration, they are considered distinct.
It is a compile-time error if any of the types I1 ...
A type variable must not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface, or a compile-time error occurs.
The order of types in a bound is only significant in that the erasure of a type variable is determined by the first type in its bound, and that a class type or type variable may only appear in the first position.
The type variable T has the same members as the intersection type C & I, which in turn has the same members as the empty class CT, defined in the same scope with equivalent supertypes.
The members of an interface are always public, and therefore always inherited (unless overridden)
Hence mI is a member of CT and of T.
Among the members of C, all but mCPrivate are inherited by CT, and are therefore members of both CT and T.
If C had been declared in a different package than T, then the call to mCDefault would give rise to a compile-time error, as that member would not be accessible at the point where T is declared.
A parameterized type is written as a ClassType or InterfaceType that contains at least one type declaration specifier immediately followed by a type argument list <T1,...,Tn>
The type argument list denotes a particular invocation of the type parameters of the generic type indicated by the type declaration specifier.
Given a type declaration specifier immediately followed by a type argument list, let C be the final Identifier in the specifier.
It is a compile-time error if C is not the name of a generic class or interface, or if the number of type arguments in the type argument list differs from the number of type parameters of C.
Vector<int> is illegal, as primitive types cannot be type arguments.
Pair<String> is illegal, as there are not enough type arguments.
A parameterized type may be an invocation of a generic class or interface which is nested.
Two parameterized types are provably distinct if either of the following conditions hold: • They are invocations of distinct generic type declarations.
Wildcards are useful in situations where only partial knowledge about the type parameter is required.
In contrast, the use of an unbounded wildcard allows any kind of collection to be used as a parameter.
Here is an example where the element type of an array is parameterized by a wildcard:
Wildcards may be given explicit bounds, just like regular type variable declarations.
An upper bound is signified by the following syntax, where B is the bound:
Unlike ordinary type variables declared in a method signature, no type inference is required when using a wildcard.
Consequently, it is permissible to declare lower bounds on a wildcard, using the following syntax, where B is a lower bound:
Here, the method is declared within the interface Collection<E>, and is designed to add all the elements of its incoming argument to the collection upon which it is invoked.
A natural tendency would be to use Collection<E> as the type of c, but this is unnecessarily restrictive.
An alternative would be to declare the method itself to be generic:
This version is sufficiently flexible, but note that the type parameter is used only once in the signature.
This reflects the fact that the type parameter is not being used to express any kind of interdependency between the type(s) of the argument(s), the return type and/or throws type.
In the absence of such interdependency, generic methods are considered bad style, and wildcards are preferred.
Here, the referent can be inserted into any queue whose element type is a supertype of the type T of the referent; T is the lower bound for the wildcard.
Two type arguments are provably distinct if one of the following is true: • Neither argument is a type variable or wildcard, and the two arguments are not.
The relationship of wildcards to established type theory is an interesting one, which we briefly allude to here.
Historically, wildcards are a direct descendant of the work by Atsushi Igarashi and Mirko Viroli.
Let m be a member or constructor declaration in D, where D is a class extended by C or an interface implemented by C.
If any of the type arguments in the invocation of C are wildcards, then:
Let D be a (possibly generic) class or interface declaration in C.
Then the type of D in C<T1,...,Tn> is D where, if D is generic, all type arguments are unbounded wildcards.
Because some type information is erased during compilation, not all types are available at run time.
Types that are completely available at run time are known as reifiable types.
A type is reifiable if and only if one of the following holds: • It refers to a non-generic class or interface type declaration.
It is a parameterized type in which all type arguments are unbounded wildcards.
The decision not to make all generic types reifiable is one of the most crucial, and controversial design decisions involving the type system of the Java programming language.
Ultimately, the most important motivation for this decision is compatibility with existing code.
In a naive sense, the addition of new constructs such as generics has no implications for pre-existing code.
The Java programming language, per se, is compatible with earlier versions as long as every program written in the previous versions retains its meaning in the new version.
However, this notion, which may be termed language compatibility, is of purely theoretical interest.
Real programs (even trivial ones, such as "Hello World") are composed of several compilation units, some of which are provided by the Java SE platform (such as elements of java.lang or java.util)
In practice, then, the minimum requirement is platform compatibility - that any program written for the prior version of the Java SE platform continues to function unchanged in the new version.
One way to provide platform compatibility is to leave existing platform functionality unchanged, only adding new functionality.
For example, rather than modify the existing Collections hierarchy in java.util, one might introduce a new library utilizing generics.
The disadvantages of such a scheme is that it is extremely difficult for pre-existing clients of the Collection library to migrate to the new library.
Collections are used to exchange data between independently developed modules; if a vendor decides to switch to the new, generic, library, that vendor must also distribute two versions of their code, to be compatible.
Libraries that are dependent on other vendors code cannot be modified to use generics until the supplier's library is updated.
If two modules are mutually dependent, the changes must be made simultaneously.
Clearly, platform compatibility, as outlined above, does not provide a realistic path for adoption of a pervasive new feature such as generics.
Therefore, the design of the generic type system seeks to support migration compatibility.
Migration compatibiliy allows the evolution of existing code to take advantage of generics without imposing dependencies between independently developed software modules.
The price of migration compatibility is that a full and sound reification of the generic type system is not possible, at least while the migration is taking place.
More precisely, a raw type is defined to be one of: • The reference type that is formed by taking the name of a generic type declaration.
An array type whose element type is a raw type.
A non-static member type of a raw type R that is not inherited from a superclass or superinterface of R.
A non-generic class or interface type is not a raw type.
To see why a non-static type member of a raw type is considered raw, consider the following example:
The type of the member(s) of Inner depends on the type parameter of Outer.
If Outer is raw, Inner must be treated as raw as well, as there is no valid binding for T.
This rule applies only to type members that are not inherited.
Inherited type members that depend on type variables will be inherited as raw types as a consequence of the rule that the supertypes of a raw type are erased, described later in this section.
Another implication of the rules above is that a generic inner class of a raw type can itself only be used as a raw type:
It is not possible to access Inner as a partially raw type (a "rare" type):
This means that the ban on "rare" types extends to the case where the qualifying type is parameterized, but we attempt to use the inner class as a raw type:
In non-legacy code, we should use the generic types correctly and pass all the required type arguments.
The supertype of a class may be a raw type.
Member accesses for the class are treated as normal, and member accesses for the supertype are treated as for raw types.
In the constructor of the class, calls to super are treated as method calls on a raw type.
The use of raw types is allowed only as a concession to compatibility of legacy code.
The use of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged.
It is possible that future versions of the Java programming language will disallow the use of raw types.
To make sure that potential violations of the typing rules are always flagged, some accesses to members of a raw type will result in compile-time unchecked warnings.
The rules for compile-time unchecked warnings when accessing members or constructors of raw types are as follows:
At an assignment to a field: if the type of the left-hand operand is a raw type, then a compile-time unchecked warning occurs if erasure changes the field's type.
No compile-time unchecked warning occurs for a method call when the formal parameter types do not change under erasure (even if the result type and/or throws clause changes), for reading from a field, or for a class instance creation of a raw type.
The warnings from unchecked conversion cover the dual case, where a generified consumer uses a legacy library.
For example, a method of the library has the raw return type Vector, but the consumer assigns the result of the method invocation to a variable of type Vector<String>
This is unsafe, since the raw vector might have had a different element type than String, but is still permitted using unchecked conversion in order to enable interfacing with legacy code.
In contrast, the static member cng retains its full parameterized type even when accessed through a object of raw type.
Note that access to a static member through an instance is considered bad style and is to be discouraged.) The member myNumbers is inherited from the NonGeneric class (whose erasure is also NonGeneric) and so retains its full parameterized type.
Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with legacy code.
It is worth dwelling upon the distinction between intersection types and the bounds of type variables.
This intersection type is often trivial (i.e., consists of a single type)
However, capture conversion can lead to the creation of type variables whose bounds are more general (e.g., array types)
The type Object, if C is an interface type with no direct superinterfaces.
Types are used when they appear in declarations or in certain expressions.
In this example, types are used in declarations of the following:
A variable of a primitive type always holds a primitive value of that exact primitive type.
A variable of a class type T can hold a null reference or a reference to an instance of class T or of any class that is a subclass of T.
A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface.
Note that a variable is not guaranteed to always refer to a subtype of its declared type, but only to subclasses or subinterfaces of the declared type.
This is due to the possibility of heap pollution discussed below.
If T is a primitive type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of T"
If T is a reference type, then a variable of type "array of T" can hold a null reference or a reference to any array of type "array of S" such that type S is a subclass or subinterface of type T.
A variable of type Object[] can hold a reference to an array of any reference type.
A variable of type Object can hold a null reference or a reference to any object, whether it is an instance of a class or an array.
The problem cannot be identified at run time because type variables are not reified, and thus instances do not carry any information at run time regarding the type arguments used to create them.
In a simple example as given above, it may appear that it should be straightforward to identify the situation at compile time and give an error.
However, in the general (and typical) case, the value of the variable l may be the result of an invocation of a separately compiled method, or its value may depend upon arbitrary control flow.
The code above is therefore very atypical, and indeed very bad style.
Furthermore, the fact that Object[] is a supertype of all array types means that unsafe aliasing can occur which leads to heap pollution.
For example, the following code compiles because it is statically type-correct:
Finally, note that the stringLists array could be aliased through variables of types other than Object[], and heap pollution could still occur.
And if the Java SE platform defined, say, Sequence as a non-generic supertype of List<T>, then using Sequence as the type of array would also cause heap pollution.
The variable will always refer to an object that is an instance of a class that represents the parameterized type.
The value of ls in the example above is always an instance of a class that provides a representation of a List.
Assignment from an expression of a raw type to a variable of a parameterized type should only be used when combining legacy code which does not make use of parameterized types with more modern code that does.
If no operation that requires a compile-time unchecked warning to be issued takes place, and no unsafe aliasing occurs of array variables with non-reifiable element types, then heap pollution cannot occur.
Note that this does not imply that heap pollution only occurs if a compile-time unchecked warning actually occurred.
It is possible to run a program where some of the binaries were produced by a compiler for an older version of the Java programming language, or from sources that explicitly suppressed unchecked warnings.
Conversely, it is possible that despite executing code that could (and perhaps did) give rise to a compile-time unchecked warning, no heap pollution takes place.
Indeed, good programming practice requires that the programmer satisfy herself that despite any unchecked warning, the code is correct and heap pollution will not occur.
The array components effectively cease to exist when the array is no longer referenced.
In this program, the class Point declares a final class variable origin.
The origin variable holds a reference to an object that is an instance of class Point whose coordinates.
The value of the variable Point.origin can never change, so it always refers to the same Point object, the one created by its initializer.
However, an operation on this Point object might change its state - for example, modifying its useCount or even, misleadingly, its x or y coordinate.
Every variable in a program must have a value before its value is used: • Each class variable, instance variable, or array component is initialized with a.
Sometimes a variable or expression is said to have a "run-time type"
This refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not null.
The correspondence between compile-time types and run-time types is incomplete for two reasons:
At run time, classes and interfaces are loaded by the Java Virtual Machine using class loaders.
Each class loader defines its own set of classes and interfaces.
As a result, it is possible for two loaders to load an identical class or interface definition but produce distinct classes or interfaces at run time.
Consequently, code that compiled correctly may fail at link time if the class loaders that load it are inconsistent.
The local variable p of the method main of class Test has type Point and is initially assigned a reference to a new instance of class Point.
The local variable cp similarly has as its type ColoredPoint, and is initially assigned a reference to a new instance of class ColoredPoint.
The local variable c has as its type the interface type Colorable, so it can hold a reference to any object whose class implements Colorable; specifically, it can hold a reference to a ColoredPoint.
It is possible, however, to write an expression in a context where the type of the expression is not appropriate.
In some cases, this leads to an error at compile time.
In other cases, the context may be able to accept a type that is related to the type of the expression; as a convenience, rather than requiring the programmer to indicate a type conversion explicitly, the Java programming language performs an implicit conversion from the type of the expression to a type acceptable for its surrounding context.
A specific conversion from type S to type T allows an expression of type S to be treated at compile time as if it had type T instead.
In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type T.
A conversion from type Object to type Thread requires a run-time check to make sure that the run-time value is actually an instance of class Thread or one of its subclasses; if it is not, an exception is thrown.
A conversion from type Thread to type Object requires no run-time action; Thread is a subclass of Object, so any reference produced by an expression of type Thread is a valid reference value of type Object.
Depending on the actual run-time value, information may be lost.
In every conversion context, only certain specific conversions are permitted.
Specific type conversions in the Java programming language are divided into 13 categories.
A conversion from a type to that same type is permitted for any type.
This may seem trivial, but it has two practical consequences.
First, it is always permitted for an expression to have the desired type to begin with, thus allowing the simply stated rule that every expression is subject to conversion, if only a trivial identity conversion.
Second, it implies that it is permitted for a program to include redundant cast operators for the sake of clarity.
A narrowing conversion of a char to an integral type T likewise simply discards all but the n lowest order bits, where n is the number of bits used to represent type T.
In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though chars represent 16-bit unsigned integer values.
A narrowing conversion of a floating-point number to an integral type T takes two steps:
In the first step, the floating-point number is converted either to a long, if T is long, or to an int, if T is byte, short, char, or int, as follows:
Otherwise, if this integer value can be represented as an int, then the result of the first step is the int value V.
Otherwise, one of the following two cases must be true: a.
The value must be too small (a negative value of large magnitude.
The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type int or long.
In the second step: • If T is int or long, the result of the conversion is the result of the first step.
The results for char, int, and long are unsurprising, producing the minimum and maximum representable values of the type.
The results for byte and short lose information about the sign and magnitude of the numeric values and also lose precision.
The results can be understood by examining the low order bits of the minimum and maximum int.
The following conversion combines both widening and narrowing primitive conversions:
Six kinds of conversions are called the narrowing reference conversions: • From any reference type S to any reference type T, provided that S is a proper.
From any class type C to any non-parameterized interface type K, provided that C is not final and does not implement K.
From any interface type J to any non-parameterized class type C that is not final.
From any interface type J to any non-parameterized interface type K, provided.
Such conversions require a test at run time to find out whether the actual reference value is a legitimate value of the new type.
Boxing conversion converts expressions of primitive type to corresponding expressions of reference type.
Specifically, the following nine conversions are called the boxing conversions: • From type boolean to type Boolean.
If p is a value of type byte, then boxing conversion converts p into a reference r of class and type Byte, such that r.byteValue() == p.
If p is a value of type char, then boxing conversion converts p into a reference r of class and type Character, such that r.charValue() == p.
If p is a value of type short, then boxing conversion converts p into a reference r of class and type Short, such that r.shortValue() == p.
If p is a value of type int, then boxing conversion converts p into a reference r of class and type Integer, such that r.intValue() == p.
If p is a value of type long, then boxing conversion converts p into a reference r of class and type Long, such that r.longValue() == p.
Ideally, boxing a given primitive value p, would always yield an identical reference.
In practice, this may not be feasible using existing implementation techniques.
The final clause above requires that certain common values always be boxed into indistinguishable objects.
For other values, this formulation disallows any assumptions about the identity of the boxed values on the programmer's part.
This would allow (but not require) sharing of some or all of these references.
This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices.
A boxing conversion may result in an OutOfMemoryError if a new instance of one of the wrapper classes (Boolean, Byte, Character, Short, Integer, Long, Float, or Double) needs to be allocated and insufficient storage is available.
Unboxing conversion converts expressions of reference type to corresponding expressions of primitive type.
Specifically, the following eight conversions are called the unboxing conversions: • From type Boolean to type boolean.
At run time, unboxing conversion proceeds as follows: • If r is a reference of type Boolean, then unboxing conversion converts r into r.booleanValue()
If r is a reference of type Byte, then unboxing conversion converts r into r.byteValue()
If r is a reference of type Character, then unboxing conversion converts r into r.charValue()
If r is a reference of type Short, then unboxing conversion converts r into r.shortValue()
If r is a reference of type Integer, then unboxing conversion converts r into r.intValue()
If r is a reference of type Long, then unboxing conversion converts r into r.longValue()
If r is a reference of type Float, unboxing conversion converts r into r.floatValue()
If r is a reference of type Double, then unboxing conversion converts r into r.doubleValue()
Unchecked conversion is used to enable a smooth interoperation of legacy code, written before the introduction of generic types, with libraries that have undergone a conversion to use genericity (a process we call generification)
In such circumstances (most notably, clients of the Collections Framework in java.util), legacy code uses raw types (e.g.
Expressions of raw types are passed as arguments to library methods that use parameterized versions of those same types as the types of their corresponding formal parameters.
Such calls cannot be shown to be statically safe under the type system using generics.
Rejecting such calls would invalidate large bodies of existing code, and prevent them from using newer versions of the libraries.
This in turn, would discourage library vendors from taking advantage of genericity.
To prevent such an unwelcome turn of events, a raw type may be converted to an arbitrary invocation of the generic type declaration to which the raw type refers.
While the conversion is unsound, it is tolerated as a concession to practicality.
It is a compile-time error if, for any two classes (not interfaces) Vi and Vj, Vi is not a subclass of Vj or vice versa.
It works for any type of list, and so the use of the wildcard type List<?> as the type of the formal parameter is entirely appropriate.
The implementation needs to copy the list, extract elements from the copy, and insert them into the original.
To do this in a type-safe manner, we need to give a name, T, to the element type of the incoming list.
This requires us to pass the incoming argument list, of type List<?>, as an argument to rev()
It is not a subtype of List<T>, for any type T.
So, without some special dispensation, we can see that the call from reverse() to rev() would be disallowed.
If this were the case, the author of reverse() would be forced to write its signature as:
This is undesirable, as it exposes implementation information to the caller.
Worse, the designer of an API might reason that the signature using a wildcard is what the callers of the API require, and only later realize that a type safe implementation was precluded.
The call is harmless, because the incoming argument is doubtless a list of some type (albeit an unknown one)
If we can capture this unknown type in a type variable X, we can infer T to be X.
The specification of course must cope with complications, like non-trivial (and possibly recursively defined) upper or lower bounds, the presence of multiple arguments etc.
Mathematically sophisticated readers will want to relate capture conversion to established type theory.
Readers unfamiliar with type theory can skip this discussion - or else study a suitable text, such as Types and Programming Languages by Benjamin Pierce, and then revisit this section.
Here then is a brief summary of the relationship of capture conversion to established type theoretical notions.
Capture conversion corresponds loosely to an opening of a value of existential type.
A capture conversion of an expression e can be thought of as an open of e in a scope that comprises the top level expression that encloses e.
The classical open operation on existentials requires that the captured type variable must not escape the opened expression.
The open that corresponds to capture conversion is always on a scope sufficiently large that the captured type variable can never be visible outside that scope.
If T is byte, short, or int, then use new Integer(x)
This reference value is then converted to type String by string conversion.
Now only reference values need to be considered: • If the reference is null, it is converted to the string "null" (four ASCII characters n, u, l, l)
Otherwise, the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string "null" is used instead.
Value set conversion is the process of mapping a floating-point value from one value set to another without changing its type.
This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign)
This conversion may result in overflow (in which case the value is replaced by an infinity of the same sign) or underflow (in which case the value may lose precision because it is replaced by a denormalized number or zero of the same sign)
If the value is of type double and is not an element of the double value set, then the implementation must map the value to the nearest element of the double value set.
Whether in FP-strict code or code that is not FP-strict, value set conversion always leaves unchanged any value whose type is neither float nor double.
The first three elements of the chain are related by widening reference conversion, while the last entry is derived from its predecessor by unchecked conversion.
A narrowing primitive conversion may be used if the type of the variable is byte, short, or char, and the value of the constant expression is representable in the type of the variable.
Character and the value of the constant expression is representable in the type char.
The compile-time narrowing of constants means that code such as:
Without the narrowing, the fact that the integer literal 42 has type int would mean that a cast to byte would be required:
A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.
The only exceptions that an assignment conversion may cause are:
The following test program illustrates assignment conversions on reference values, but fails to compile, as described in its comments.
The value of veclong cannot be assigned to a Long variable, because Long is a class type other than Object.
The value of veclong cannot be assigned to vecshort, because they are arrays of primitive type, and short and long are not the same primitive type.
The value of cpvec can be assigned to pvec, because any reference that could be the value of an expression of type ColoredPoint can be the value of a variable of type Point.
If the type of the expression cannot be converted to the type of the parameter by a conversion permitted in a method invocation context, then a compile-time error occurs.
The only exceptions that an method invocation conversion may cause are: • A ClassCastException if, after the type conversions above have been applied,
An expression of a primitive type may undergo casting conversion to another primitive type, by an identity conversion (if the types are the same), or by a widening primitive conversion, or by a narrowing primitive conversion, or by a widening and narrowing primitive conversion.
An expression of a primitive type may undergo casting conversion to a reference type without error, by boxing conversion.
An expression of a reference type may undergo casting conversion to a primitive type without error, by unboxing conversion.
In the tables, a comma between symbols indicates that a casting conversion uses one conversion followed by another.
Given a compile-time reference type S (source) and a compile-time reference type T (target), a casting conversion exists from S to T if no compile-time errors occur due to the following rules.
Otherwise, the cast is always legal at compile time (because even if S does not implement T, a subclass of S might)
If T is a type variable, then this algorithm is applied recursively, using the upper bound of T in place of T.
If T is an array type, then S must be the class Object, or a compile-time error occurs.
Then there must exist a supertype X of T, such that X is an invocation of G, or a compile-time error occurs.
Furthermore, if S and X are provably distinct parameterized types then a compile-time error occurs.
If S is a type variable, then this algorithm is applied recursively, using the upper bound of S in place of S.
If T is a class type, then if T is not Object, then a compile-time error occurs (because Object is the only class type to which arrays can be assigned)
Here, the first compile-time error occurs because the class types Long and Point are unrelated (that is, they are not the same, and neither is a subclass of the other), so a cast between them will always fail.
The second compile-time error occurs because a variable of type EndPoint can never reference a value that implements the interface Colorable.
This is because EndPoint is a final type, and a variable of a final type always holds a value of the same run-time type as its compile-time type.
Therefore, the run-time type of variable e must be exactly the type EndPoint, and type EndPoint does not implement Colorable.
If T is an array type, then a run-time exception is thrown.
If T is an interface type, then R must be either the same interface as T or a subinterface of T, or a run-time exception is thrown.
If T is an array type, then a run-time exception is thrown.
If R is a class representing an array type RC[], that is, an array of components of type RC:
This case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type Object.
This program uses casts to compile, but it throws exceptions at run time, because the types are incompatible.
Numeric promotion is applied to the operands of an arithmetic operator.
Some operators apply unary numeric promotion to a single operand, which must produce a value of a numeric type: • If the operand is of compile-time type Byte, Short, Character, or Integer, it.
A long shift distance (right operand) does not promote the value being shifted (left operand) to long.
When an operator applies binary numeric promotion to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:
Otherwise, if either operand is of type float, the other is converted to float.
Otherwise, if either operand is of type long, the other is converted to long.
The example converts the ASCII character G to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character.
The 7 is the numeric value of this control character.
The class libraries of the Java SE platform attempt to use, whenever possible, names chosen according to the conventions presented below.
These conventions help to make code more readable and avoid certain kinds of name conflicts.
We recommend these conventions for use in all programs written in the Java programming language.
However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise.
So, for example, the sin and cos methods of the class java.lang.Math have mathematically conventional names, even though these method names flout the convention suggested here because they are short and are not verbs.
Developers should take steps to avoid the possibility of two published packages having the same name by choosing unique package names for packages that are widely distributed.
This allows packages to be easily and automatically installed and catalogued.
This section specifies a suggested convention for generating such unique package names.
Implementations of the Java SE platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.
You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as oracle.com.
You then reverse this name, component by component, to obtain, in this example, com.oracle, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names.
Such a convention might specify that certain package name components be division, department, project, machine, or login names.
The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, such as com, edu, gov, mil, net, or org, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166
The name of a package is not meant to imply where the package is stored on the Internet.
The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.
In some cases, the Internet domain name may not be a valid package name.
Here are some suggested conventions for dealing with these situations:
If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier java; package names that start with the identifier java are reserved for package of the Java SE platform.
Names of class types should be descriptive nouns or noun phrases, not overly long, in mixed case with the first letter of each word capitalized.
Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized.
Type variable names should be pithy (single character if possible) yet evocative, and should not include lower case letters.
This makes it easy to distinguish type parameters from ordinary classes and interfaces.
Container types should use the name E for their element type.
Maps should use K for the type of their keys and V for the type of their values.
The name X should be used for arbitrary exception types.
We use T for type, whenever there is not anything more specific about the type to distinguish it.
If there are multiple type parameters that denote arbitrary types, one should use letters that neighbor T in the alphabet, such as S.
In such cases, all the variables with the same prefix should be subscripted.
If a generic method appears inside a generic class, it is a good idea to avoid using the same names for the type parameters of the method and class, to avoid confusion.
When type parameters do not fall conveniently into one of the categories mentioned, names should be chosen to be as meaningful as possible within the confines of a single letter.
The names mentioned above (E, K, V, X, T) should not be used for type parameters that do not fall into the designated categories.
Method names should be verbs or verb phrases, in mixed case, with the first letter lowercase and the first letter of any subsequent words capitalized.
Methods to get and set an attribute that might be thought of as a variable V should be named getV and setV.
An example is the methods getPriority and setPriority of class Thread.
A method that returns the length of something should be named length, as in class String.
A method that tests a boolean condition V about an object should be named isV.
A method that converts its object to a particular format F should be named toF.
Examples are the method toString of class Object and the methods toLocaleString and toGMTString of class java.util.Date.
Whenever possible and appropriate, basing the names of methods in a new class on names in an existing class that is similar, especially a class from the Java SE platform API, will make it easier to use.
Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized.
Note that well-designed classes have very few public or protected fields, except for fields that are constants (static final fields)
Fields should have names that are nouns, noun phrases, or abbreviations for nouns.
The names of constants in interface types should be, and final variables of class types may conventionally be, a sequence of one or more words, acronyms, or abbreviations, all uppercase, with components separated by underscore "_" characters.
A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix.
Local variable and parameter names should be short, yet meaningful.
They are often short sequences of lowercase letters that are not words, such as:
Acronyms, that is the first letter of a series of words, as in cp for a variable holding a reference to a ColoredPoint.
Abbreviations, as in buf holding a pointer to a buffer of some kind.
Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes.
One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type.
Local variable or parameter names that consist of only two or three lowercase letters should not conflict with the initial country codes and domain names that are the first component of unique package names.
A name is used to refer to an entity declared in a program.
There are two forms of names: simple names and qualified names.
Not all identifiers in a program are a part of a name.
Rather, they are used in declarations to specify the names of the declared entities.
One might wonder why these kinds of expression use an identifier rather than a simple name, which is after all just an identifier.
The reason is that a simple expression name is defined in terms of the lexical environment; that is, a simple expression name must be in the scope of a variable declaration.
But field access, and method invocation qualified by a Primary, and qualified class instance creation all denote members whose names are not in the lexical environment.
By definition, such names are bound only in the context provided by the Primary of the field access expression, method invocation expression, or class instance creation expression.
Therefore, we denote such members with identifiers rather than simple names.
The identifier max could also have been used as the statement label; the label would not obscure the local variable max within the labeled statement.
The translation of a try-with-resources statement implies the rule above.
These rules imply that declarations of class and interface types need not appear before uses of the types.
In the following program, the use of PointList in class Point is valid, because the scope of the class declaration PointList includes both class Point and class PointList, as well as any other type declarations in other compilation units of package points.
This program causes a compile-time error because the initialization of x is within the scope of the declaration of x as a local variable, and the local variable x does not yet have a value and cannot be used.
In the following program, the initializer for three can correctly refer to the variable two declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable three declared earlier in the block.
For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and the formal parameter would no longer be visible - an undesirable outcome.
It is a compile-time error if the name of a formal parameter is redeclared as a local variable of the method or constructor; or as an exception parameter of a catch clause in a try statement in the body of the method or constructor; or as a resource in a try-with-resources statement in the body of the method or constructor.
It is a compile-time error if the name of a local variable v is redeclared as a local variable of the directly enclosing method, constructor, or initializer block within the scope of v; or as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block within the scope of v; or as a resource in a try-with-resources statement of the directly enclosing method, constructor or initializer block within the scope of v.
It is a compile-time error if the name of a local class C is redeclared as a local class of the directly enclosing method, constructor, or initializer block within the scope of C.
The translation of a try-with-resources statement implies the rule above.
A formal parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor.
A local variable of a method, constructor, or initializer may be shadowed anywhere inside a class declaration nested within the scope of the local variable.
A local class declaration may be shadowed anywhere inside a class declaration nested within the local class declaration's scope.
An exception parameter may be shadowed anywhere inside a class declaration nested within the Block of the catch clause.
Because a declaration of an identifier as a local variable of a method, constructor, or initializer block must not appear within the scope of a parameter or local variable of the same name, a compile-time error occurs for the following program:
This restriction helps to detect some otherwise very obscure bugs.
A similar restriction on shadowing of members by local variables was judged impractical, because the addition of a member in a superclass could cause subclasses to have to rename local variables.
Related considerations make restrictions on shadowing of local variables by members of nested classes, or on shadowing of local variables by local variables declared within nested classes unattractive as well.
On the other hand, local variables with the same name may be declared in two separate blocks or for statements, neither of which contains the other:
This program compiles without error and, when executed, produces the output:
Some declarations may be shadowed in part of their scope by another declaration of the same name, in which case a simple name cannot be used to refer to the declared entity.
A declaration d of a local variable or exception parameter named n shadows, throughout the scope of d, (a) the declarations of any other fields named n that are in scope at the point where d occurs, and (b) the declarations of any other variables named n that are in scope at the point where d occurs but are not declared in the innermost class in which d is declared.
A declaration d of a method named n shadows the declarations of any other methods named n that are in an enclosing scope at the point where d occurs throughout the scope of d.
The expression x in the invocation of print refers to (denotes) the value of the local variable x.
Here, the constructor takes parameters having the same names as the fields to be initialized.
This is simpler than having to invent different names for the parameters and is not too confusing in this stylized context.
In general, however, it is considered poor style to have local variables with the same names as fields.
If a package name is obscured by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter.
The Java programming language does not actually rely on case distinctions to determine whether a name is a package name or a type name.)
Names of fields, parameters, and local variables normally do not obscure type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.
If a field name is shadowed by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other code.
Constant names normally have no lowercase letters, so they will not normally obscure names of packages or types, nor will they normally shadow fields, whose names typically contain at least one lowercase letter.
Constant names cannot obscure method names, because they are distinguished syntactically.
The meaning of a name depends on the context in which it is used.
The determination of the meaning of a name requires three steps: • First, context causes a name syntactically to fall into one of.
Second, a name that is initially classified by its context as an AmbiguousName or as a PackageOrTypeName is then reclassified to be a PackageName, TypeName, or ExpressionName.
Third, the resulting category then dictates the final determination of the meaning of the name (or a compile-time error if the name has no meaning)
For example, types, methods, and fields may have the same name.
It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.
A name is syntactically classified as an ExpressionName in these contexts: • As the qualifying expression in a qualified superclass constructor invocation.
The effect of syntactic classification is to restrict certain kinds of entities to certain parts of expressions:
The name of a package may appear in an expression only as part of a qualified name for a class or interface type.
A later step determines whether or not a package of that name actually exists.
If the AmbiguousName is a qualified name, consisting of a name, a ".", and an Identifier, then the name to the left of the "." is first reclassified, for it is itself an AmbiguousName.
There is then a choice: • If the name to the left of the "." is reclassified as a PackageName, then:
If there is a package whose name is the name to the left of the "." and that package contains a declaration of a type whose name is the same as the Identifier, then this AmbiguousName is reclassified as a TypeName.
A later step determines whether or not a package of that name actually exists.
The simple name org is reclassified as a PackageName (since there is no variable or type named org in scope)
Next, assuming that there is no class or interface named rpgpoet in any compilation unit of package org (and we know that there is no such class or interface because package org has a subpackage named rpgpoet), the qualified name org.rpgpoet is reclassified as a PackageName.
The meaning of a name classified as a PackageName is determined as follows.
If the PackageOrTypeName, Q, occurs in the scope of a type named Q, then the PackageOrTypeName is reclassified as a TypeName.
The meaning of the PackageOrTypeName is the meaning of the reclassified name.
Given a qualified PackageOrTypeName of the form Q.Id, if the type or package denoted by Q has a member type named Id, then the qualified PackageOrTypeName name is reclassified as a TypeName.
The meaning of the qualified PackageOrTypeName is the meaning of the reclassified name.
The meaning of a name classified as a TypeName is determined as follows.
If a type name consists of a single Identifier, then the identifier must occur in the scope of exactly one visible declaration of a type with this name, or a compile-time error occurs.
If a type name is of the form Q.Id, then Q must be either a type name or a package name.
This program produced the following output the first time it was run:
In this example, the name java.util.Date must denote a type, so we first use the procedure recursively to determine if java.util is an accessible type or a package, which it is, and then look to see if the type Date is accessible in this package.
The meaning of a name classified as an ExpressionName is determined as follows.
If the declaration declares a final variable which is definitely assigned before the simple expression, the meaning of the name is the value of that variable.
Otherwise, the meaning of the expression name is the variable declared by the declaration.
That is, if the expression name appears "on the right hand side", its type is subject to capture conversion.
If the expression name is a variable that appears "on the left hand side", its type is not subject to capture conversion.
In this program, the names used as the left-hand-sides in the assignments to i, v, and f denote the local variable i, the field v, and the value of f (not the variable f, because f is a final variable)
The example therefore produces an error at compile time because the last assignment does not have a variable as its left-hand side.
If the erroneous assignment is removed, the modified code can be compiled and it will produce the output:
If an expression name is of the form Q.Id, then Q has already been classified as a package name, a type name, or an expression name.
If Q is a package name, then a compile-time error occurs.
Otherwise, if the single accessible member field is not a class variable (that is, it.
If Q is an expression name, let T be the type of the expression Q: • If T is not a reference type, a compile-time error occurs.
This program encounters two compile-time errors, because the int variable i has no members, and because nPoints is not a method of class Point.
Note that expression names may be qualified by type names, but not by types in general.
A consequence is that it is not possible to access a class variable through a parameterized type.
This does not restrict the Java programming language in any meaningful way.
Type parameters may not be used in the types of static variables, and so the type arguments of a parameterized type can never influence the type of a static variable.
Technically, the type name Foo above is a raw type, but this use of raw types is harmless, and does not give rise to warnings.
The meaning of a name classified as a MethodName is determined as follows.
A simple method name may appear as the element name in an element-value pair.
In that case, the Identifier in an ElementValuePair must be the simple name of one of the elements of the annotation type identified by TypeName in the containing annotation, or a compile-time error occurs.
In other words, the identifier in an element-value pair must also be a method name in the interface identified by TypeName.
The following program demonstrates the role of method visibility when determining which method to invoke.
A qualified method name can only appear in the context of a method invocation expression.
If a method name is of the form Q.Id, then Q has already been classified as a package name, a type name, or an expression name:
If Q is a package name, then a compile-time error occurs.
Otherwise, Q is a type name or an expression name.
Note that qualified names, field access expressions, method invocation expressions, and qualified class instance creation expressions are syntactically similar in that a "." token appears, preceded by some indication of a package, type, or expression having a type, and followed by an Identifier that names a member of the package or type.
If a class or interface type is declared public, then it may be accessed by.
An array type is accessible if and only if its element type is accessible.
A member (class, interface, field, or method) of a reference (class, interface,
Otherwise, we say there is default access, which is permitted only when the access occurs from within the package in which the type is declared.
The class type PointVec is not public and not part of the public interface of the package points, but rather can be used only by other classes in the package.
The class type Point is declared public and is available to other packages.
It is part of the public interface of the package points.
The methods move, getX, and getY of the class Point are declared public and so are available to any code that uses an object of type Point.
The fields x and y are declared protected and are accessible outside the package points only in subclasses of class Point, and only when they are fields of objects that are being implemented by the code that is accessing them.
These public members are accessible to any other package that has access to package points.
The fields x and y are not public and therefore are accessible only from within the package points.
The class Point is available outside the package points, while the class PointList is available for access only within the package.
Thus a compilation unit in another package can access points.Point, either by using its fully qualified name:
If none of the access modifiers public, protected, or private are specified, a class member or constructor is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package.
If a public class has a method or constructor with default access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.
Because move of Point is not overridden by move in PlusPoint, the method moveAlso in Point never calls the method move in PlusPoint.
Thus if you delete the super.move call from PlusPoint and execute the test program:
If move of Point were overridden by move in PlusPoint, then this program would recurse infinitely, until a StackOverflowError occurred.
They may not be accessed by qualified names, field access expressions, or method invocation expressions outside the body of the declaration of Point.
A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.
Let C be the class in which a protected member is declared.
Access is permitted only within the body of a subclass S of C.
In addition, if Id denotes an instance field or instance method, then: • If the access is by a qualified name Q.Id, where Q is an ExpressionName, then.
If the access is by a field access expression E.Id, where E is a Primary expression, or by a method invocation expression E.Id(
Let C be the class in which a protected constructor is declared and let S be the innermost class in whose declaration the use of the protected constructor occurs.
If the access is by a superclass constructor invocation super(
Otherwise, if the access is by a simple class instance creation expression of the form new C(
A protected constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) only from within the package in which it is defined.
A compile-time error occurs in the method delta here: it cannot access the protected members x and y of its parameter p, because while Point3d (the class in which the references to fields x and y occur) is a subclass of Point (the class in which x and y are declared), it is not involved in the implementation of a Point (the type of the parameter p)
A compile-time error also occurs in the method warp: it cannot access the protected member z of its parameter a, because while the class Point (the class in which the reference to field z occurs) is involved in the implementation of a Point3d (the type of the parameter a), it is not a subclass of Point3d (the class in which z is declared)
Every primitive type, named package, top level class, and top level interface has a fully qualified name: • The fully qualified name of a primitive type is the keyword for that primitive.
The fully qualified name of a named package that is not a subpackage of a named package is its simple name.
The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by ".", followed by the simple (member) name of the subpackage.
The fully qualified name of a top level class or top level interface that is declared in an unnamed package is the simple name of the class or interface.
The fully qualified name of a top level class or top level interface that is declared in a named package consists of the fully qualified name of the package, followed by ".", followed by the simple name of the class or interface.
Each member class, member interface, and array type may have a fully qualified name:
A member class or member interface M of another class or interface C has a fully qualified name if and only if C has a fully qualified name.
In that case, the fully qualified name of M consists of the fully qualified name of C, followed by ".", followed by the simple name of M.
An array type has a fully qualified name if and only if its element type has a fully qualified name.
In that case, the fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "[]"
A local class does not have a fully qualified name.
The fully qualified name of the type long is "long"
The fully qualified name of the package java.lang is "java.lang" because it is subpackage lang of package java.
The fully qualified name of the type "array of double" is "double[]"
Every primitive type, named package, top level class, and top level interface has a canonical name: • For every primitive type, named package, top level class, and top level interface,
Each member class, member interface, and array type may have a canonical name: • A member class or member interface M declared in another class C has a canonical.
In that case, the canonical name of M consists of the canonical name of C, followed by ".", followed by the simple name of M.
An array type has a canonical name if and only if its component type has a canonical name.
In that case, the canonical name of the array type consists of the canonical name of the component type of the array type followed by "[]"
The difference between a fully qualified name and a canonical name can be seen in code such as:
Each package has its own set of names for types, which helps to prevent name conflicts.
The package java has subpackages awt, applet, io, lang, net, and util, but no compilation units.
The package java.awt has a subpackage named image, as well as a number of compilation units containing declarations of class and interface types.
A package may not contain two members of the same name, or a compile-time error results.
Because the package java.awt has a subpackage image, it cannot (and does not) contain a declaration of a class or interface type named image.
It is however possible for members of different packages to have the same simple name.
For example, there is no special access relationship between a package named oliver and another package named oliver.twist, or between packages named evelyn.wood and evelyn.waugh.
That is, the code in a package named oliver.twist has no better access to the types declared within package oliver than code in any other package.
For example, a system that uses a database to store packages may not enforce a maximum of one public class or interface per compilation unit.
Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.
As an extremely simple example of storing packages in a file system, all the packages and source and binary code in a project might be stored in a single directory and its subdirectories.
Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name.
Each further level of subdirectory would represent a subpackage of the package represented by the containing directory, and so on.
Continuing the example, the directory java would contain, among others, the following subdirectories:
Still continuing the example, if we were to look inside the directory util, we might see the following files:
Under this simple organization of packages, an implementation of the Java SE platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components.
For example, if this simple organization were used on an operating system where the file name separator is /, the package name:
If the @ character is not a valid character in a file name for some given host file system, then some other character that is not valid in a identifier could be used instead.
All the compilation units of the predefined package java and its subpackages lang and io are always observable.
For all other packages, the host system determines which compilation units are observable.
Types declared in different compilation units can depend on each other, circularly.
A Java compiler must arrange to compile all such types at the same time.
A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.
At most one annotated package declaration is permitted for a given package.
The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation.
This file does not contain the source for a class called packagePACKAGES Package Declarations 7.4
While the file could technically contain the source code for one or more package-private (default-access) classes, it would be very bad form.
If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information.
A compilation unit that has no package declaration is part of an unnamed package.
Unnamed packages are provided by the Java SE platform principally for convenience when developing small or temporary applications or when just beginning development.
Note that an unnamed package cannot have subpackages, since the syntax of a package declaration always includes a reference to a named top level package.
An implementation of the Java SE platform must support at least one unnamed package; it may support more than one unnamed package but is not required to do so.
Which compilation units are in each unnamed package is determined by the host system.
In implementations of the Java SE platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the "current working directory"
The precise meaning of "current working directory" depends on the host system.
An import declaration makes types or members available by their simple names only within the compilation unit that actually contains the import declaration.
The scope of the type(s) or member(s) introduced by an import declaration specifically does not include the PackageName of a package declaration, other import declarations in the current compilation unit, or other compilation units in the same package.
A single-type-import declaration imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type-import declaration appears.
Note that an import statement cannot import a subpackage, only a type.
The declaration might be shadowed by a single-type-import declaration of a type whose simple name is Vector; by a type named Vector and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.
The declaration might be obscured by a declaration of a field, parameter, or local variable named Vector.
It would be unusual for any of these conditions to occur.)
Here, the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an interface in the same package.
A second compile-time error is the attempt to declare the name Vector both by a class type declaration and by a single-typeimport declaration.
This program defines two classes that use each other in the declarations of their class members.
Because the class types Point and PointColor have all the type declarations in package points, including all those in the current compilation unit, as their scope, this program compiles correctly.
In this code, the class Point is declared in a compilation unit with no package statement, and thus Point is its fully qualified name, whereas in the code:
The type is declared public (and therefore is potentially accessible from code.
This restriction implies that there must be at most one such type per compilation unit.
This restriction makes it easy for a Java compiler to find a named class within a package.
In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is public or is referred to by code in other compilation units.
Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.
There are two kinds of class declarations: normal class declarations and enum declarations.
ClassModifier: one of Annotation public protected private abstract static final strictfp.
It is a compile-time error if the same modifier appears more than once in a class declaration.
If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier.
Here, a class Point is declared that must be declared abstract, because it contains a declaration of an abstract method named alert.
The subclass of Point named ColoredPoint inherits the abstract method alert, so it must also be declared abstract.
On the other hand, the subclass of Point named SimplePoint provides an implementation of alert, so it need not be abstract.
However, a Point variable could correctly be initialized with a reference to any subclass of Point, and the class SimplePoint is not abstract, so the statement:
Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed.
The class Math is an example of a class that cannot be instantiated; its declaration looks like this:
This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes.
It is a compile-time error to refer to a type parameter of a generic class C anywhere in:
A class O is the zeroth lexically enclosing class of itself.
A class O is the n'th lexically enclosing class of a class C if it is the immediately enclosing class of the n-1'th lexically enclosing class of C.
Instance variables of class Outer are not available within the body of a static method.
However, local variables from the surrounding method may be referred to without error (provided they are marked final)
Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class.
An instance variable is always defined with respect to an instance.
In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class.
For example, the class Local above has an enclosing instance of class Outer.
The optional extends clause in a normal class declaration specifies the direct superclass of the current class.
The extends clause must not appear in the definition of the class Object, or a compile-time error occurs, because it is the primordial class and has no direct superclass.
The direct superclass of an enum type E is Enum<E>
A class is said to be a direct subclass of its direct superclass.
The direct superclass is the class from whose implementation the implementation of the current class is derived.
The class Object is the direct superclass of the class Point.
The class ColoredPoint is a direct subclass of class Point.
The class Point is the direct superclass of class ColoredPoint.
The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint.
The subclass relationship is the transitive closure of the direct subclass relationship.
Class C is said to be a superclass of class A whenever A is a subclass of C.
A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier of a superclass or superinterface name.
The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared.
An interface type I is a superinterface of class type C if any of the following is true:
The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint.
The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable.
This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable.
On the other hand, in a situation such as this:
Members of a class that are declared private are not inherited by subclasses of that class.
Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.
We use the phrase the type of a member to denote: • For a field, its type.
One error occurs because ColoredPoint has no constructor declared with two int parameters, as requested by the use in main.
This illustrates the fact that ColoredPoint does not inherit the constructors of its superclass Point.
Two more errors occur because the method reset of class Point is private, and therefore is not inherited by class ColoredPoint.
The method invocations in method clear of class ColoredPoint and in method main of class Test are therefore not correct.
Consider the example where the points package declares two compilation units:
The class Point3d inherits the fields x and y of class Point, because it is in the same package as Point.
A better way to write the third compilation unit would be:
If Point4d is written in this way, it will compile without errors.
Therefore, this test program, in another package, can be compiled successfully:
Here, the class variable totalMoves can be used only within the class Point; it is not inherited by the subclass Point3d.
A compile-time error occurs because method move of class Point3d tries to increment totalMoves.
Even though a class might not be declared public, instances of the class might be available at run time to code outside the package in which it is declared by means a public superclass or superinterface.
An instance of the class can be assigned to a variable of such a public type.
An invocation of a public method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the public superclass or superinterface.
In this situation, the method is necessarily declared public, even though it is declared in a class that is not public.)
The two-argument version of method move could then be invoked for that object, which is permissible because method move of Point3d is public (as it must be, for any method that overrides a public method must itself be public,
The fields x and y of that object could also be accessed from such a third package.
The declaration of the field z as public is not useless, however.
The variables of a class type are introduced by field declarations.
The Identifier in a FieldDeclarator may be used in a name to refer to the field.
More than one field may be declared in a single field declaration by using more than one declarator; the FieldModifiers and Type apply to all the declarators in the declaration.
The declared type of a field is denoted by the Type that appears in the field declaration, followed by any bracket pairs that follow the Identifier in the declarator.
It is a compile-time error for the body of a class declaration to declare two fields with the same name.
In this respect, hiding of fields is similar to hiding of methods.
If a field declaration hides the declaration of another field, the two fields need not have the same type.
This in itself is permitted, but a compile-time error occurs because of the use of the simple name v in method printV: it cannot be determined which v is intended.
The following variation uses the field access expression super.v to refer to the field named v declared in class SuperTest and uses the qualified name Frob.v to refer to the field named v declared in interface Frob:
Even if two distinct inherited fields have the same type, the same value, and are both final, any reference to either field by simple name is considered ambiguous and results in a compile-time error.
The point of this example is that the reference to RED is also considered ambiguous, because two distinct declarations are inherited.
The fact that the two fields named RED happen to have the same type and the same unchanging value does not affect this judgment.
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once.
It may be referred to by its simple name without ambiguity.
The simple names RED, GREEN, and BLUE may nevertheless be used without ambiguity within the class PaintedPoint to refer to the fields declared in interface Colorable.
FieldModifier: one of Annotation public protected private static final transient volatile.
It is a compile-time error if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers public, protected, and private.
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for FieldModifier.
If a field is declared static, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created.
Within the declaration of class Test, the simple name x refers to the field declared within class Test.
Code in class Test may refer to the field x of class Point as super.x (or, because x is static, as Point.x)
Code in class Test may still refer to that same field as super.x.
It must be noted, however, that while the field x of class Point is not inherited by class Test, it is nevertheless implemented by instances of class Test.
In other words, every instance of class Test contains two fields, one of type int and one of type double.
Both fields bear the name x, but within the declaration of class Test, the simple name x always refers to the field declared within class Test.
Code in instance methods of class Test may refer to the instance variable x of class Point as super.x.
Code that uses a field access expression to access field x will access the field named x in the class indicated by the type of reference expression.
If the declaration of x is deleted from class Test, as in the program:
Within instance methods in the declaration of class Test, the simple name x now refers to the field declared within class Point.
Code in class Test may still refer to that same field as super.x.
The expression sample.x still refers to the field x within type Test, but that field is now an.
Variables may be marked transient to indicate that they are not part of the persistent state of an object.
It is a compile-time error if a final variable is also declared volatile.
This prevents method one and method two from being executed concurrently, and furthermore guarantees that the shared values of i and j are both updated before method one returns.
Therefore method two never observes a value for j greater than that for i; indeed, it always observes the same value for i and j.
Another approach would be to declare i and j to be volatile:
This allows method one and method two to be executed concurrently, but guarantees that accesses to the shared values for i and j occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread.
Therefore, the shared value for j is never greater than that for i, because each update to i must be reflected in the shared value for i before the update to j occurs.
It is possible, however, that any given invocation of method two might observe a value for j that is much.
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.
Initialization expressions for instance variables may use the simple name of any static variable declared in or inherited by the class, even one whose declaration occurs textually later.
This program compiles without error; it initializes j to 1 when class Test is initialized, and initializes f to the current value of j every time an instance of class Test is created.
The declaration of a member needs to appear textually before it is used only if the member is an instance (respectively static) field of a class or interface C and all of the following conditions hold: • The usage occurs in an instance (respectively static) variable initializer of C or.
The usage is not on the left hand side of an assignment.
It is a compile-time error if any of the four requirements above are not met.
The restrictions above are designed to catch, at compile time, circular or otherwise malformed initializations.
Accesses by methods are not checked in this way, so:
A method declares executable code that can be invoked, passing a fixed number of values as arguments.
For compatibility with older versions of the Java SE platform, the declaration of a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the formal parameter list.
This is supported by the following obsolescent production, but should not be used in new code.
The formal parameters of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers.
Each parameter specifier consists of a type (optionally preceded by the final modifier and/or one or more annotations) and an identifier (optionally followed by brackets) that specifies the name of the parameter.
The last formal parameter of a method or constructor is special: it may be a variable arity parameter, indicated by an ellipsis following the type.
If the last formal parameter is a variable arity parameter, the method is a variable arity method.
If a method or constructor has no formal parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.
The declared type of a formal parameter is denoted by the Type that appears in its parameter specifier, followed by any bracket pairs that follow the Identifier in the declarator, except for a variable arity parameter, whose declared type is an array type whose component type is the Type that appears in its parameter specifier.
Two methods have the same signature if they have the same name and argument types.
After renaming each occurrence of a Bi in N's type to Ai, the bounds of corresponding type variables are the same, and the formal parameter types of M and N are the same.
This is an error even though one of the declarations is abstract.
The notion of subsignature is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other.
Specifically, it allows a method whose signature does not use generic types to override any generified version of that method.
This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library.
This would significantly inhibit the use of generics, since library writers would hesitate to migrate existing code.
MethodModifier: one of Annotation public protected private abstract static final synchronized native strictfp.
It is a compile-time error if a method declaration that contains the keyword native also contains strictfp.
If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier.
It would be impossible for a subclass to implement a private abstract method, because private methods are not inherited by subclasses; therefore such a method could never be used.
An abstract class can override an abstract method by providing another abstract method declaration.
An instance method that is not abstract can be overridden by an abstract method.
The overriding declaration of method get in class InfiniteBuffer states that method get in any subclass of InfiniteBuffer never throws a BufferEmpty exception, putatively because it generates the data in the buffer, and thus can never run out of data.
We can declare an abstract class Point that requires its subclasses to implement toString if they are to be complete, instantiable classes:
This abstract declaration of toString overrides the non-abstract toString method of class Object.
Class Object is the implicit direct superclass of class Point.) Adding the code:
Method toString of class Object can be made available to class ColoredPoint only if class Point explicitly makes it available through some other method, as in:
A method that is not declared static is called an instance method, and sometimes called a non-static method.
An instance method is always invoked with respect to an object, which becomes the current object to which the keywords this and super refer during execution of the method body.
At run time, a machine-code generator or optimizer can "inline" the body of a final method, replacing an invocation of the method with the code in its body.
The inlining process must preserve the semantics of the method invocation.
A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.
Inlining the method move of class Point in method main would transform the for loop to the form:
Such inlining cannot be done at compile time unless it can be guaranteed that Test and Point will always be recompiled together, so that whenever Point - and specifically its move method - changes, the code for Test.main will also be updated.
A method that is native is implemented in platform-dependent code, typically written in another programming language such as C.
The body of a native method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.
For example, the class RandomAccessFile of the package java.io might declare the following native methods:
This program defines a class which is designed for concurrent use.
Each instance of the class Box has an instance variable boxContents that can hold a reference to any object.
You can put an object in a Box by invoking put, which returns false if the box is already full.
You can get something out of a Box by invoking get, which returns a null reference if the box is empty.
If put and get were not synchronized, and two threads were executing methods for the same instance of Box at the same time, then the code could misbehave.
It might, for example, lose track of an object because two invocations to put occurred at the same time.
The result of a method declaration either declares the type of value that the method returns (the return type), or uses the keyword void to indicate that the method does not return a value.
Return types may vary among methods that override each other if the return types are reference types.
Essentially, for each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless its exception type or a supertype of its exception type is mentioned in a throws clause in the declaration of the method or constructor.
The requirement to declare checked exceptions allows a Java compiler to ensure that code for handling such error conditions has been included.
Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions in their bodies will normally cause compile-time errors if they lack proper exception types in their throws clauses.
The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.
A method body is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation.
It is a compile-time error if a method declaration is either abstract or native and has a block for its body.
It is a compile-time error if a method declaration is neither abstract nor native and has a semicolon for its body.
In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body"
Note that it is possible for a method to have a declared return type and yet contain no return statements.
If the method not inherited is declared in a class, or the method not inherited is declared in an interface and the new declaration is abstract, then the new declaration is said to override it.
If the method not inherited is abstract and the new declaration is not abstract, then the new declaration is said to implement it.
The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has a raw type, while the corresponding parameter in the other has a parameterized type.
It is a compile-time error if an instance method overrides a static method.
Here, the class SlowPoint overrides the declarations of method move of class Point with its own move method, which limits the distance that the point can move on each invocation of the method.
When the move method is invoked for an instance of class SlowPoint, the overriding definition in class SlowPoint will always be called, even if the reference to the SlowPoint object is taken from a variable whose type is Point.
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:
The class BufferOutput implements a very simple buffered version of an OutputStream, flushing the output when the buffer is full or flush is invoked.
The subclass LineBufferOutput declares only a constructor and a single method putchar, which overrides the method putchar of BufferOutput.
It inherits the methods putstr and flush from class BufferOutput.
In the putchar method of a LineBufferOutput object, if the character argument is a newline, then it invokes the flush method.
The critical point about overriding in this example is that the method putstr, which is declared in class BufferOutput, invokes the putchar method defined by the current object this, which is not necessarily the putchar method declared in class BufferOutput.
Thus, when putstr is invoked in main using the LineBufferOutput object lbo, the invocation of putchar in the body of the putstr method is an invocation of the putchar of the object lbo, the overriding declaration of putchar that checks for a newline.
This allows a subclass of BufferOutput to change the behavior of the putstr method without redefining it.
In this respect, hiding of methods is similar to hiding of fields.
A class (static) method that is hidden can be invoked by using a reference whose type is the class that actually contains the declaration of the method.
In this respect, hiding of static methods is different from overriding of instance methods.
This rule allows for covariant return types - refining the return type of a method when overriding it.
A method that overrides or hides another method, including methods that implement abstract methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.
More precisely, suppose that B is a class or interface, and A is a superclass or superinterface of B, and a method declaration n in B overrides or hides a method declaration m in A.
Then: • If n has a throws clause that mentions any checked exception types, then m must.
If the unerased throws clause of m does not contain a supertype of each exception type in the throws clause of n, a compile-time unchecked warning occurs.
These restrictions are necessary because generics are implemented via erasure.
The rule above implies that methods declared in the same class with the same name must have different erasures.
It also implies that a type declaration cannot implement or extend two distinct invocations of the same generic interface.
If the overridden or hidden method is protected, then the overriding or hiding.
If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be private; otherwise, a compile-time error occurs.
Note that a private method cannot be hidden or overridden in the technical sense of those terms.
This means that a subclass can declare a method with the same signature as a private method in one of its superclasses, and there is no requirement that the return type or throws clause of such a method bear any relationship to those of the private method in the superclass.
The following declarations are legal in the Java programming language from Java SE 5.0 onwards:
The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces.
Now, at some point the author of StringSorter decides to generify the code:
An unchecked warning would be given when compiling Overrider against the new definition of StringSorter because the return type of Overrider.toList is List, which is not a subtype of the return type of the overridden method, List<String>
This program uses the usual and conventional form for declaring a new exception type, in its declaration of the class BadPointException:
The program results in a compile-time error, because the override of method move in class CheckedPoint declares that it will throw a checked exception that the move in class Point has not declared.
If this were not considered an error, an invoker of the method move on a reference of type Point could find the contract between it and Point broken if this exception were thrown.
A different compile-time error now occurs, because the body of the method move cannot throw a checked exception, namely BadPointException, that does not appear in the throws clause for move.
A class cannot have two member methods with the same name and type erasure:
Two different methods of a class may not override methods with the same erasure:
This is also illegal, since D.id(String) is a member of D, D.id(Integer) is declared in D, and:
I.id(Integer) yet the two overridden methods have the same erasure.
Otherwise, there are two possible cases: • If one of the inherited methods is not abstract, then there are two subcases:
If all the inherited methods are abstract, then the class is necessarily an abstract class and is considered to inherit all the abstract methods.
The throws clauses do not cause errors in this case.)
There might be several paths by which the same method declaration might be inherited from an interface.
This fact causes no difficulty and never, of itself, results in a compile-time error.
This fact causes no difficulty and never of itself results in a compile-time error.
There is no required relationship between the return types or between the throws.
In this example, the members of the class RealPoint include the instance variable color inherited from the class Point, the float instance variables x and y declared in RealPoint, and the two move methods declared in RealPoint.
This following program is an extended variation of the preceding program:
Here, the class Point provides methods getX and getY that return the values of its fields x and y; the class RealPoint then overrides these methods by declaring methods with the same signature.
The result is two errors at compile time, one for each method, because the return types do not match; the methods in class Point return values of type int, but the wanna-be overriding methods in class RealPoint return values of type float.
Here, the overriding methods getX and getY in class RealPoint have the same return types as the methods of class Point that they override, so this code can be successfully compiled.
The first line of output illustrates the fact that an instance of RealPoint actually contains the two integer fields declared in class Point; it is just that their names are hidden from code that occurs within the declaration of class RealPoint (and those of any subclasses it might have)
When a reference to an instance of class RealPoint in a variable of type Point is used to access the field x, the integer field x declared in class Point is accessed.
The second line of output shows that the field access rp.x refers to the field x declared in class RealPoint.
This field is of type float, and this second line of output accordingly displays floating-point values.
Incidentally, this also illustrates the fact that the method name show is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.
The last two lines of output show that the method invocations p.getX() and rp.getX() each invoke the getX method declared in class RealPoint.
Indeed, there is no way to invoke the getX method of class Point for an instance of class RealPoint from outside the body of RealPoint, no matter what the type of the variable we may use to hold the reference to the object.
Thus, we see that fields and methods behave differently: hiding is different from overriding.
A class inherits from its direct superclass and direct superinterfaces all the non-private member types of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface.
It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once.
It may be referred to by its simple name without ambiguity.
The static keyword may modify the declaration of a member type C within the body of a non-inner class or interface T.
Its effect is to declare that C is not an inner class.
Just as a static method of T has no current instance of T in its body, C also has no current instance of T, nor does it have any lexically enclosing instances.
It is a compile-time error if a static class contains a usage of a non-static member of an enclosing class.
If no access modifier is specified for the constructor of a normal class, the constructor has default access.
If no access modifier is specified for the constructor of an enum type, the constructor is private.
If two or more (distinct) method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for MethodModifier.
Unlike methods, a constructor cannot be abstract, static, final, native, strictfp, or synchronized:
A constructor is not inherited, so there is no need to declare it final.
A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be static.
There is no practical need for a constructor to be synchronized, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work.
The lack of native constructors is an arbitrary language design choice that makes it easy for an implementation of the Java Virtual Machine to verify that superclass constructors are always properly invoked during object creation.
The type of a constructor consists of its signature and the exception types given by its throws clause.
It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving this.
Here, the first constructor of ColoredPoint invokes the second, providing an additional argument; the second constructor of ColoredPoint invokes the constructor of its superclass Point, passing along the coordinates.
Explicit constructor invocation statements can be divided into two kinds: • Alternate constructor invocations begin with the keyword this (possibly.
They are used to invoke an alternate constructor of the same class.
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use this or super in any expression; otherwise, a compiletime error occurs.
If a superclass constructor invocation statement is unqualified, and if S is an inner member class, then it is a compile-time error if S is not a member of a lexically enclosing class of C by declaration or inheritance.
Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.
Evaluation of a superclass constructor invocation statement is more complicated, as follows:
Let C be the class being instantiated, let S be the direct superclass of C, and let i be the instance being created.
The immediately enclosing instance of i with respect to S (if any) must be determined: • If S is not an inner class, or if the declaration of S occurs in a static context,
If the superclass constructor invocation is qualified, then the Primary.
Otherwise, the result of this evaluation is the immediately enclosing instance of i with respect to S.
Let n be an integer such that O is the n'th lexically enclosing class of C.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
After determining the immediately enclosing instance of i with respect to S (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.
Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of C and all instance initializers of C are executed.
If an instance initializer or instance variable initializer I textually precedes another instance initializer or instance variable initializer J, then I is executed before J.
Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically.
An alternate constructor invocation does not perform this additional implicit execution.)
If a class contains no constructor declarations, then a default constructor with no formal parameters and no throws clause is implicitly declared.
If the class being declared is the primordial class Object, then the default constructor has an empty body.
Otherwise, the default constructor simply invokes the superclass constructor with no arguments.
The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive.
Note, however, that this does not imply that the constructor is accessible whenever the class is accessible.
However, the constructor is protected relative to Inner, while Inner is protected relative to Outer.
So, Inner is accessible in SonOfOuter, since it is a subclass of Outer.
Inner's constructor is not accessible in SonOfOuter, because the class SonOfOuter is not a subclass of Inner! Hence, even though Inner is accessible, its default constructor is not.
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and by declaring all constructors to be private.
A public class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with public access, and by declaring no constructor that is public.
Here, the class ClassOnly cannot be instantiated, while in the following code:
An enum type is implicitly final unless it contains at least one enum constant that has a class body.
It is a compile-time error to explicitly declare an enum type to be final.
It is permissible to explicitly declare a nested enum type to be static.
The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.
Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants.
The body of an enum type may contain enum constants.
An enum constant defines an instance of the enum type.
The Identifier in a EnumConstant may be used in a name to refer to the enum constant.
Instance methods declared in these class bodies may be invoked outside the enclosing enum type only if they override accessible methods in the enclosing enum type.
It is a compile-time error for the class body of an enum constant to declare an abstract method.
Because there is only one instance of each enum constant, it is permissible to use the == operator in place of the equals method when comparing two object references if it is known that at least one of them refers to an enum constant.
The equals method in Enum is a final method that merely invokes super.equals on its argument and returns the result, thus performing an identity comparison.
Any constructor or member declarations within an enum declaration apply to the enum type exactly as if they had been present in the class body of a normal class declaration, unless explicitly stated otherwise.
It is a compile-time error if a constructor declaration of an enum type is public or protected.
If an enum type has no constructor declarations, then a private constructor that takes no parameters (to match the implicit empty argument list) is automatically provided.
It is a compile-time error for an enum declaration to declare a finalizer.
An instance of an enum type may never be finalized.
It is a compile-time error for an enum type E to have an abstract method m as a member unless E has one or more enum constants, and all of E's enum constants have class bodies that provide concrete implementations of m.
In addition to the members that an enum type E inherits from Enum<E>, for each declared enum constant with the name n, the enum type has an implicitly declared public static final field named n of type E.
These fields are considered to be declared in the same order as the corresponding enum constants, before any static fields explicitly declared in the enum type.
Each such field is initialized to the enum constant that corresponds to it.
The enum constant is said to be created when the corresponding field is initialized.
In addition, if E is the name of an enum type, then that type has the following implicitly declared static methods:
Returns an array containing the constants of this enum * type, in the order they're declared.
Returns the enum constant of this type with the specified * name.
The string must match exactly an identifier used to declare * an enum constant in this type.
Without this rule, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum types.
A circularity exists in any class with a "self-typed" static field.) Here is an example of the sort of code that would fail:
Note that the example can easily be refactored to work properly:
The refactored version is clearly correct, as static initialization occurs top to bottom.
Each enum constant arranges for a different value in the field value, passed in via a constructor.
The field represents the value, in cents, of an American coin.
Note that there are no restrictions on the type or number of parameters that may be declared by an enum type's constructor.
A switch statement is useful for simulating the addition of a method to an enum type from outside the type.
This example "adds" a color method to the Coin type, and prints a table of coins, their values, and their colors.
In the following program, a playing card class is built atop two simple enum types.
Note that each enum type would be as long as the entire example in the absence of the enum facility:
It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:
The above pattern is much safer than using a switch statement in the base type (Operation), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error)
This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods.
A nested interface is any interface whose declaration occurs within the body of another class or interface.
A top level interface is an interface that is not a nested interface.
We distinguish between two kinds of interfaces - normal interfaces and annotation types.
A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface.
It is not sufficient that the class happen to implement all the abstract methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.
The Identifier in an interface declaration specifies the name of the interface.
It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces.
InterfaceModifier: one of Annotation public protected private abstract static strictfp.
If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier.
This modifier is obsolete and should not be used in new programs.
If an extends clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces.
These other named interfaces are the direct superinterfaces of the interface being declared.
Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends.
The superinterface relationship is the transitive closure of the direct superinterface relationship.
An interface K is a superinterface of interface I if either of the following is true:
There exists an interface J such that K is a superinterface of J, and J is a.
Interface I is said to be a subinterface of interface K whenever K is a superinterface of I.
While every class is an extension of class Object, there is no single interface of which all interfaces are extensions.
An interface I directly depends on a type T if T is mentioned in the extends clause of I either as a superinterface or as a qualifier within a superinterface name.
The members of an interface are: • Those members declared in the interface.
If an interface has no direct superinterfaces, then the interface implicitly declares.
Every field declaration in the body of an interface is implicitly public, static, and final.
It is permitted to redundantly specify any or all of these modifiers for such fields.
If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for ConstantModifier.
It is a compile-time error if the same modifier appears more than once in a field declaration.
It is a compile-time error for the body of an interface declaration to declare two fields with the same name.
The declared type of a field is denoted by the Type that appears in the field declaration, followed by any bracket pairs that follow the Identifier in the declarator.
If the interface declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superinterfaces of the interface.
It is possible for an interface to inherit more than one field with the same name.
Such a situation does not in itself cause a compile-time error.
However, any attempt within the body of the interface to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.
There might be several paths by which the same field declaration might be inherited from an interface.
In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.
If two fields with the same name are inherited by an interface because, for example, two of its direct superinterfaces declare fields with that name, then a single ambiguous member results.
Any use of this ambiguous member will result in a compile-time error.
This is all right as long as the interface does not contain any reference by simple name to the field YELLOW.
Such a reference could occur within a variable initializer for a field.)
If a single field is inherited multiple times from the same interface because, for example, both this interface and one of this interface's direct superinterfaces extend the interface that declares the field, then only a single member results.
This situation does not in itself cause a compile-time error.
In the previous example, the fields RED, GREEN, and BLUE are inherited by interface LotsOfColors in more than one way, through interface RainbowColors and also through interface PrintColors, but the reference to field RED in interface LotsOfColors is not considered ambiguous because only one actual declaration of the field RED is involved.
This program causes two compile-time errors, because j is referred to in the initialization of f before j is declared, and because the initialization of k refers to k itself.
However, a method declared in an interface may be implemented by a method that is declared strictfp or native or synchronized in a class that implements the interface.
An interface inherits from its direct superinterfaces all methods of the superinterfaces that are not overridden by a declaration in the interface.
The throws clauses do not cause errors in this case.) There might be several paths by which the same method declaration is inherited from an interface.
This fact causes no difficulty and never, of itself, results in a compile-time error.
Here, the method named move is overloaded in interface RealPointInterface with three different signatures, two of them declared and one inherited.
Any non-abstract class that implements interface RealPointInterface must provide implementations of all three method signatures.
If an interface declares a member type with a certain name, then the declaration of that type is said to hide any and all accessible declarations of member types with the same name in superinterfaces of the interface.
An interface inherits from its direct superinterfaces all the non-private member types of the superinterfaces that are both accessible to code in the interface and not hidden by a declaration in the interface.
An interface may inherit two or more type declarations with the same name.
It is a compile-time error to attempt to refer to any ambiguously inherited class or interface by its simple name.
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once; it may be referred to by its simple name without ambiguity.
An annotation type declaration is a special kind of interface declaration.
To distinguish an annotation type declaration from an ordinary interface declaration, the keyword interface is preceded by an at-sign (@)
Note that the at-sign (@) and the keyword interface are two distinct tokens.
Technically it is possible to separate them with whitespace, but this is discouraged as a matter of style.
The Identifier in an annotation type declaration specifies the name of the annotation type.
It is a compile-time error if an annotation type has the same simple name as any of its enclosing classes or interfaces.
A consequence of the fact that an annotation type cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation type is never itself an annotation type.
Without this rule, we could not ensure that the elements were of the types representable in annotations, or that accessor methods for them would be available.
Unless explicitly modified herein, all of the rules that apply to ordinary interface declarations apply to annotation type declarations.
For example, annotation types share the same namespace as ordinary class and interface types; and annotation type declarations are legal wherever interface declarations are legal, and have the same scope and accessibility.
Each method declaration in an annotation type declaration defines an element of the annotation type.
An annotation type has no elements other than those defined by the methods it explicitly declares.
The following annotation type declaration defines an annotation type with several elements:
The following annotation type declaration defines an annotation type with no elements, termed a marker annotation type:
It is a compile-time error if the return type of a method declared in an annotation type is not one of the following: a primitive type, String, Class, any parameterized.
It is a compile-time error if an annotation type declaration T contains an element of type T, either directly or indirectly.
The convention is illustrated in the following annotation type declaration:
The following annotation type declaration defines a single-element annotation type whose sole element has an array type:
The following annotation type declaration shows a Class annotation whose value is restricted by a bounded wildcard:
Note that the grammar for annotation type declarations permits other element declarations besides method declarations.
For example, one might choose to declare a nested enum for use in conjunction with an annotation type:
Here is an example of a complex annotation type, that is, an annotation type that contains one or more elements whose types are also annotation types.
An annotation type element may have a default value specified for it.
This is done by following its (empty) parameter list with the keyword default and the default value of the element.
Several annotation types are predefined in the libraries of the Java SE platform.
This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications.
Only those semantics that require special behavior on the part of a Java compiler or Java Virtual Machine implementation are specified here.
Annotations may be present only in source code, or they may be present in the binary form of a class or interface.
An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE platform.
An annotation on a local variable declaration is never retained in the binary representation.
Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems.
The annotation type Override supports early detection of such problems.
This is perfectly legal, but class Foo inherits the equals implementation from Object, which can cause some very subtle bugs.
If a method declaration is annotated with the annotation @Override, but the method does not override or implement a method declared in a supertype, or is not overrideequivalent to a public method of Object, a compile-time error occurs.
The clause about overriding a public method is motivated by use of @Override in an interface.
However, consider an interface that attempts to use @Override on a clone method: (finalize could also be used in this example)
Because Object.clone is not public, there is no member called clone implicitly declared in Quux.
Therefore, the explicit declaration of clone in Quux is not deemed.
In contrast, a class declaration that declares clone is simply overriding Object.clone, so is able to use @Override:
Java compilers are increasingly capable of issuing helpful "lint-like" warnings.
To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.
The annotation type SuppressWarnings supports programmer control over warnings otherwise issued by a Java compiler.
It contains a single element that is an array of String.
Compiler vendors should document the warning names they support in conjunction with this annotation type.
Vendors are encouraged to cooperate to ensure that the same names work across multiple compilers.
A program element annotated @Deprecated is one that programmers are discouraged from using, typically because it is dangerous, or because a better alternative exists.
A Java compiler must produce a deprecation warning when a type, method, field, or constructor whose declaration is annotated with the annotation @Deprecated is used (i.e.
The use and declaration are both within the same outermost class.
Use of the @Deprecated annotation on a local variable declaration or on a parameter declaration has no effect.
The variable arity parameter has declared type T[], which is non-reifiable.
However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array.
Applying a SafeVarargs annotation to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.
It is a compile-time error if a fixed arity method or constructor declaration is annotated with the SafeVarargs annotation.
It is a compile-time error if a variable arity method declaration that is neither static nor final is annotated with the SafeVarargs annotation.
Since a SafeVarargs annotation is only applicable to static methods, final instance methods, and constructors, the annotation is not usable where method overriding occurs.
Annotation inheritance only works on classes (not methods, interfaces, or constructors), so a SafeVarargs-style annotation cannot be passed through instance methods in classes or through interfaces.
The purpose of an annotation is simply to associate information with the annotated program element.
Annotations must contain an element-value pair for every element of the corresponding annotation type, except for those elements with default values, or a compile-time error occurs.
Annotations are conventionally placed before all other modifiers, but this is not a requirement; they may be freely intermixed with other modifiers.
The others (marker annotation and single-element annotation) are merely shorthands.
A normal annotation is used to annotate a program element.
The TypeName names the annotation type corresponding to the annotation.
Note that the at-sign (@) is a token unto itself.
Technically it is possible to put whitespace between it and the TypeName, but this is discouraged as a matter of style.
Note that null is not a legal element value for any element type.
In other words, it is permissible to omit the curly braces when a single-element array is to be associated with an array-valued annotation type element.
Note that the array's element type cannot be an array type.
That is, nested array types are not permitted as element types.
While the annotation syntax would permit this, the annotation type declaration syntax would not.)
An annotation on an annotation type declaration is known as a meta-annotation.
An annotation type may be used to annotate its own declaration.
More generally, circularities in the transitive closure of the "annotates" relation are permitted.
For example, it is legal to annotate an annotation type declaration with another annotation type, and to annotate the latter type's declaration with the former type.
Here is an example of a normal annotation that takes advantage of default values.
The second form of annotation, marker annotation, is a shorthand designed for use with marker annotation types.
It is legal to use the marker annotation form for annotation types with elements, so long as all the elements have default values.
The third form of annotation, single-element annotation, is a shorthand designed for use with single-element annotation types.
It is legal to use single-element annotations for annotation types with multiple elements, so long as one element is named value, and all other elements have default values.
Here is an example of a single-element array-valued single-element annotation.
Here is an example with of a single-element annotation that contains a normal annotation.
Here is an example of a single-element annotation with a Class element whose value is restricted by the use of a bounded wildcard.
Here is an example of a single-element annotation using an enum type defined inside the annotation type.
All the components of an array have the same type, called the component type of the array.
If the component type of an array is T, then the type of the array itself is written T[]
The element type of an array may be any type, whether primitive or reference.
Arrays with an interface type as the element type are allowed.
An element of such an array may have as its value a null reference or an instance of any type that implements the interface.
Arrays with an abstract class type as the element type are allowed.
An element of such an array may have as its value a null reference or an instance of any subclass of the abstract class that is not itself abstract.
The following are examples of declarations of array variables that do create array objects:
The [] may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both.
Brackets are allowed in declarators as a nod to the tradition of C and C++
The general rules for variable declaration, however, permit brackets to appear on both the type and in declarators, so that the local variable declaration:
A ColoredPoint can be assigned to a Point; therefore, the value of cpa can be assigned to pa.
A reference to this array pa, for example, testing whether pa[1] is null, will not result in a run-time type error.
This is because the element of the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint can stand in for a Point, since Point is the superclass of ColoredPoint.
On the other hand, an assignment to the array pa can result in a run-time error.
At compile time, an assignment to an element of pa is checked to make sure that the value assigned is a Point.
But since pa holds a reference to an array of ColoredPoint, the assignment is valid only if the type of the value assigned at run time is, more specifically, a ColoredPoint.
If the component type is an array type, then the variable initializer specifying a component may itself be an array initializer; that is, array initializers may be nested.
In this case, execution of the nested array initializer constructs and initializes an array object by recursive application of the algorithm above, and assigns it to the component.
The members of an array type are all of the following: • The public final field length, which contains the number of components of.
The public method clone, which overrides the method of the same name in.
A clone of a multidimensional array is shallow, which is to say that it creates only a single new array.
All the members inherited from class Object; the only method of Object that is not inherited is its clone method.
An array thus has the same public fields and methods as the following class:
The fact that subarrays are shared when a multidimensional array is cloned is shown by this program:
Every array has an associated Class object, shared with all other arrays with the same component type.
The program uses the method getClass inherited from class Object, and the field length.
The result of the comparison of the Class objects in the first println.
In the Java programming language, unlike C, an array of char is not a String, and neither a String nor an array of char is terminated by '\u0000' (the NUL character)
A String object is immutable, that is, its contents never change, while an array of char has mutable elements.
The method toCharArray in class String returns an array of characters containing the same character sequence as a String.
The class StringBuffer implements useful methods on mutable arrays of characters.
An example of such a violation is an attempt to index outside the bounds of an array.
Some programming languages and their implementations react to such errors by peremptorily terminating the program; other programming languages allow an implementation to react in an arbitrary or unpredictable way.
Neither of these approaches is compatible with the design goals of the Java SE platform: to provide portability and robustness.
Instead, the Java programming language specifies that an exception will be thrown when semantic constraints are violated and will cause a non-local transfer of control from the point where the exception occurred to a point that can be specified by the programmer.
An exception is represented by an instance of the class Throwable (a direct subclass of Object) or one of its subclasses.
Throwable and all its subclasses are, collectively, the exception classes.
The classes Exception and Error are direct subclasses of Throwable.
Exception is the superclass of all the exceptions from which ordinary programs may wish to recover.
Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover.
Error and all its subclasses are, collectively, the error classes.
RuntimeException is the superclass of all the exceptions which may be thrown.
RuntimeException and all its subclasses are, collectively, the run-time exception classes.
The unchecked exception classes are the run-time exception classes and the error classes.
The checked exception classes are all exception classes other than the unchecked exception classes.
That is, the checked exception classes are all subclasses of Throwable other than RuntimeException and its subclasses and Error and its subclasses.
These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution.
Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception.
An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program.
An invocation of the (deprecated) stop method of class Thread or ThreadGroup.
The (deprecated) stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group.
They are asynchronous because they may occur at any point in the execution of the other thread or threads.
An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language.
In this case, the asynchronous exception that is thrown is an instance of a subclass of VirtualMethodError.
The Java SE platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown.
Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated.
The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language.
A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction.
Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception.
Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance.
Of the unchecked exception classes, error classes are exempted because they can occur at many points in the program and recovery from them is difficult or impossible.
Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
Of the unchecked exception classes, run-time exception classes are exempted because, in the judgment of the designers of the Java programming language, having to declare such exceptions would not aid significantly in establishing the correctness of programs.
Many of the operations and constructs of the Java programming language can result in exceptions at run time.
The information available to a Java compiler, and the level of analysis a compiler performs, are usually not sufficient to establish that such run-time exceptions cannot occur, even though this may be obvious to the programmer.
Requiring such exception classes to be declared would simply be an irritation to programmers.
The theorem-proving technology that is needed to establish such global properties of data structures is beyond the scope of this specification.
The expression is a qualified class instance creation expression and the qualifying expression can throw E; or.
Some expression of the argument list can throw E; or.
The class instance creation expression includes a ClassBody, and some instance initializer block or instance variable initializer expression in the ClassBody can throw E.
Some expression of the argument list can throw E; or.
For every other kind of expression, the expression can throw an exception class E iff one of its immediate subexpressions can throw E.
A throw statement whose thrown expression is a final or effectively final exception parameter of a catch clause C can throw an exception class E iff:
Some catch block of the try statement can throw E and either no finally block is present or the finally block can complete normally; or.
Some expression of the constructor invocation's parameter list can throw E; or.
Any other statement S can throw an exception class E iff an expression or statement immediately contained in S can throw E.
It is a compile-time error if an instance variable initializer or instance initializer of a named class can throw a checked exception class unless that exception class or one of its superclasses is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor.
A statement or expression is dynamically enclosed by a catch clause if it appears within the try block of the try statement of which the catch clause is a part, or if the caller of the statement or expression is dynamically enclosed by the catch clause.
If within a constructor or an instance initializer or the initializer for an instance.
Whether a particular catch clause can handle an exception is determined by comparing the class of the object that was thrown to the catchable exception classes of the catch clause.
The catch clause can handle the exception if one of its catchable exception classes is the class of the exception or a superclass of the class of the exception.
If optimized code has speculatively executed some of the expressions or statements which follow the point at which the exception occurs, such code must be prepared to hide this speculative execution from the user-visible state of the program.
If no catch clause that can handle an exception can be found, then the current thread (the thread that encountered the exception) is terminated.
If the current thread has an uncaught exception handler set, then that handler is executed.
Otherwise, the method uncaughtException is invoked for the ThreadGroup that is the parent of the current thread.
If the ThreadGroup and its parent ThreadGroups do not override uncaughtException, then the default handler's uncaughtException method is invoked.
If a try or catch block in a try-finally or try-catch-finally statement completes abruptly, then the finally clause is executed during propagation of the exception, even if no matching catch clause is ultimately found.
If a finally clause is executed because of abrupt completion of a try block and the finally clause itself completes abruptly, then the reason for the abrupt completion of the try block is discarded and the new reason for abrupt completion is propagated from there.
The main method of class Test invokes the thrower method four times, causing exceptions to be thrown three of the four times.
The try statement in method main catches each exception that the thrower throws.
Whether the invocation of thrower completes normally or abruptly, a message is printed describing what happened.
The Java Virtual Machine starts execution by invoking the method main of some specified class, passing it a single argument, which is an array of strings.
In the examples in this specification, this first class is typically called Test.
Here we present an overview of the process from the viewpoint of the Java programming language.
The manner in which the initial class is specified to the Java Virtual Machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully-qualified name of the class to be specified as a command-line argument and for following command-line arguments to be used as strings to be provided as the argument to the method main.
We now outline the steps the Java Virtual Machine may take to execute Test, as an example of the loading, linking, and initialization processes that are described further in later sections.
This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of "static" linkage that has been done for many years in simple implementations of the C language.
In these implementations, a compiled program is typically represented as an "a.out" file that contains a fully-linked version of the program, including completely resolved links to library routines used by the program.
Copies of these library routines are included in the "a.out" file.) An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the "laziest" form of resolution.
In this case, if Test had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.
If class Test has another class Super as its superclass, then Super must be initialized before Test.
This requires loading, verifying, and preparing Super if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from Super and so on, recursively.
Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.
Loading refers to the process of finding the binary form of a class or interface type with a particular name, perhaps by computing it on the fly, but more typically by retrieving a binary representation previously computed from source code by a Java compiler, and constructing, from that binary form, a Class object to represent the class or interface.
Here we present an overview of the process from the viewpoint of the Java programming language.
Given the same name, a good class loader should always return the same class object.
However, it could not undermine the security of the type system, because the Java Virtual Machine guards against this.
A basic principle of the design of the Java programming language is that the run-time type system cannot be subverted by code written in the Java programming language, not even by implementations of such otherwise sensitive system classes as ClassLoader and SecurityManager.
The loading process is implemented by the class ClassLoader and its subclasses.
In particular, a class loader may cache binary representations of classes and interfaces, prefetch them based on expected usage, or load a group of related classes together.
These activities may not be completely transparent to a running application if, for example, a newly compiled version of a class is not found because an older version is cached by a class loader.
It is the responsibility of a class loader, however, to reflect loading errors only at points in the program where they could have arisen without prefetching or group loading.
Because loading involves the allocation of new data structures, it may fail with an OutOfMemoryError.
Linking is the process of taking a binary form of a class or interface type and combining it into the run-time state of the Java Virtual Machine, so that it can be executed.
A class or interface type is always loaded before it is linked.
Three different activities are involved in linking: verification, preparation, and resolution of symbolic references.
Here we present an overview of the process from the viewpoint of the Java programming language.
This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the Java programming language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.
For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution)
This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.
Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.
Verification ensures that the binary representation of a class or interface is structurally correct.
For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction; that every method is provided with a structurally correct signature; and that every instruction obeys the type discipline of the Java Virtual Machine language.
If an error occurs during verification, then an instance of the following subclass of class LinkageError will be thrown at the point in the program that caused the class to be verified: • VerifyError: The binary definition for a class or interface failed to pass a set of.
Implementations of the Java Virtual Machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient.
One particularly useful data structure is a "method table" or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.
Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.
If an error occurs during resolution, then an error will be thrown.
Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables) declared in the class.
Initialization of an interface consists of executing the initializers for fields (constants) declared in the interface.
Before a class is initialized, its direct superclass must be initialized, but interfaces implemented by the class are not initialized.
Similarly, the superinterfaces of an interface are not initialized before the interface is initialized.
A class or interface type T will be initialized immediately before the first occurrence of any one of the following:
A static field declared by T is used and the field is not a constant variable.
The class One is never initialized, because it not used actively and therefore is never linked to.
The class Two is initialized only after its superclass Super has been initialized.
The reference to K.j is a reference to a field actually declared in interface J that is not a constant variable; this causes initialization of the fields of interface J, but not those of its superinterface I, nor those of interface K.
Despite the fact that the name K is used to refer to field j of interface J, interface K is not initialized.
Because the Java programming language is multithreaded, initialization of a class or interface requires careful synchronization, since some other thread may be trying to initialize the same class or interface at the same time.
There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface; for example, a variable initializer in class A might invoke a method of an unrelated class B, which might in turn invoke a method of class A.
The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure.
The procedure assumes that the Class object has already been verified and prepared, and that the Class object contains state that indicates one of four situations:
This Class object is verified and prepared but not initialized.
This Class object is being initialized by some particular thread T.
This Class object is fully initialized and ready for use.
This Class object is in an erroneous state, perhaps because initialization was.
For each class or interface C, there is a unique initialization lock LC.
The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.
If the Class object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization.
If the Class object for C indicates that C has already been initialized, then no further action is required.
If the Class object for C is in an erroneous state, then initialization is not possible.
Next, if C is a class rather than an interface, and its superclass SC has not yet been initialized, then recursively perform this entire procedure for SC.
If the initialization of SC completes abruptly because of a thrown exception, then acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete abruptly, throwing the same exception that resulted from initializing SC.
Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block.
If the execution of the initializers completes normally, then acquire LC, label the Class object for C as fully initialized, notify all waiting threads, release LC, and complete this procedure normally.
Otherwise, the initializers must have completed abruptly by throwing some exception E.
Acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete this procedure abruptly with reason E or its replacement as determined in the previous step.
An implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4/5) when it can determine that the initialization of the class has already completed, provided that, in terms of the memory model, all happens-before orderings that would exist if the lock were acquired, still exist when the optimization is performed.
Code generators need to preserve the points of possible initialization of a class or interface, inserting an invocation of the initialization procedure just described.
If this initialization procedure completes normally and the Class object is fully initialized and ready for use, then the invocation of the initialization procedure is no longer necessary and it may be eliminated from the code - for example, by patching it out or otherwise regenerating the code.
Compile-time analysis may, in some cases, be able to eliminate many of the checks that a type has been initialized from the generated code, if an initialization order for a group of related types can be determined.
Such analysis must, however, fully account for concurrency and for the fact that initialization code is unrestricted.
This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using this)
If this constructor is for a class other than Object, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using super)
Evaluate the arguments and process that superclass constructor invocation recursively using.
If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason.
Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class.
If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception.
If that execution completes abruptly, then this procedure completes abruptly for the same reason.
Unlike C++, the Java programming language does not specify altered rules for method dispatch during the creation of a new class instance.
If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized.
First, space is allocated for the new ColoredPoint, to hold the fields x, y, and color.
All these fields are then initialized to their default values (in this case, 0 for each field)
Next, the ColoredPoint constructor with no arguments is first invoked.
Since ColoredPoint declares no constructors, a default constructor of the form:
This constructor then invokes the Point constructor with no arguments.
The Point constructor does not begin with an invocation of a constructor, so the Java compiler.
Therefore, the constructor for Object which takes no arguments is invoked.
The class Object has no superclass, so the recursion terminates here.
Next, any instance initializers and instance variable initializers of Object are invoked.
Next, the body of the constructor of Object that takes no arguments is executed.
No such constructor is declared in Object, so the Java compiler supplies a default one, which in this special case is:
Next, all initializers for the instance variables of class Point are executed.
As it happens, the declarations of x and y do not provide any initialization expressions, so no action is required for this step of the example.
This shows that the invocation of printThree in the constructor for class Super does not invoke the definition of printThree in class Super, but rather invokes the overriding definition of printThree in class Test.
The later invocation of printThree in method main invokes the same definition of printThree, but by that point the initializer for instance variable three has been executed, and so the value 3 is printed.
The class Object has a protected method called finalize; this method can be overridden by other classes.
The particular definition of finalize that can be invoked for an object is called the finalizer of that object.
Before the storage for an object is reclaimed by the garbage collector, the Java Virtual Machine will invoke the finalizer of that object.
Finalizers provide a chance to free up resources that cannot be freed automatically by an automatic storage manager.
In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.
The Java programming language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused.
The Java programming language does not specify which thread will invoke the finalizer for any given object.
It is important to note that many finalizer threads may be active (this is sometimes needed on large shared memory multiprocessors), and that if a large connected data structure becomes garbage, all of the finalize methods for every object in that data structure could be invoked at the same time, each finalizer invocation running in a different thread.
The Java programming language imposes no ordering on finalize method calls.
Finalizers may be called in any order, or even concurrently.
Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads.
If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.
It is straightforward to implement a class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable.
Defining such a class is left as an exercise for the reader.
It is guaranteed that the thread that invokes the finalizer will not be holding any user-visible synchronization locks when the finalizer is invoked.
For efficiency, an implementation may keep track of classes that do not override the finalize method of class Object, or override it in a trivial way.
A finalizer may be invoked explicitly, just like any other method.
The package java.lang.ref describes weak references, which interact with garbage collection and finalization.
As with any API that has special interactions with the Java programming language, implementors must be cognizant of any requirements imposed by the java.lang.ref API.
This specification does not discuss weak references in any way.
A reachable object is any object that can be accessed in any potential continuing computation from any live thread.
An unfinalized object has never had its finalizer automatically invoked.
A finalizable object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer.
An object o is not finalizable until its constructor has invoked the constructor for Object on o and that invocation has completed successfully (that is, without throwing an exception)
Every pre-finalization write to a field of an object must be visible to the finalization of that object.
Furthermore, none of the pre-finalization reads of fields of that object may see writes that occur after finalization of that object is initiated.
Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable.
For example, a Java compiler or code generator may choose to set a variable or parameter that will no longer be used to null to cause the storage for such an object to be potentially reclaimable sooner.
Another example of this occurs if the values in an object's fields are stored in registers.
The program may then access the registers instead of the object, and never access the object again.
Note that this sort of optimization is only allowed if references are on the stack, not stored in the heap.
The finalizer guardian forces super.finalize to be called if a subclass overrides finalize and does not explicitly call super.finalize.
If these optimizations are allowed for references that are stored on the heap, then a Java compiler can detect that the finalizerGuardian field is never read, null it out, collect the object immediately, and call the finalizer early.
This runs counter to the intent: the programmer probably wanted to call the Foo finalizer when the Foo instance became unreachable.
This sort of transformation is therefore not legal: the inner class object should be reachable for as long as the outer class object is reachable.
Transformations of this sort may result in invocations of the finalize method occurring earlier than might be otherwise expected.
In order to allow the user to prevent this, we.
If an object's finalizer can result in synchronization on that object, then that object must be alive and considered reachable whenever a lock is held on it.
Note that this does not prevent synchronization elimination: synchronization only keeps an object alive if a finalizer might synchronize on it.
Since the finalizer occurs in another thread, in many cases the synchronization could not be removed anyway.
The only objects that are considered definitely reachable at a point di are those that can be shown to be reachable by the application of these rules: • An object B is definitely reachable at di from static fields if there exists a write.
If an object C is definitely reachable from an object B, and object B is definitely reachable from an object A, then C is definitely reachable from A.
If an object X is marked as unreachable at di, then:
All reads that come-after di that see a reference to X must see writes to elements of objects that were unreachable at di, or see writes that came-after di.
Class unloading is an optimization that helps reduce memory use.
Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading.
Consequently, whether a class or interface has been unloaded or not should be transparent to a program.
However, if a class or interface C was unloaded while its defining loader was potentially reachable, then C might be reloaded.
Even if the class was not referenced by any other currently loaded class, it might be.
When D is loaded by C's defining loader, its execution might cause reloading of C.
Reloading may not be transparent if, for example, the class has static variables (whose state would be lost), static initializers (which may have side effects), or native methods (which may retain static state)
Furthermore, the hash value of the Class object is dependent on its identity.
Therefore it is, in general, impossible to reload a class or interface in a completely transparent manner.
Since we can never guarantee that unloading a class or interface whose loader is potentially reachable will not cause reloading, and reloading is never transparent, but unloading must be transparent, it follows that one must not unload a class or interface while its loader is potentially reachable.
A similar line of reasoning can be used to deduce that classes and interfaces loaded by the bootstrap loader can never be unloaded.
One must also argue why it is safe to unload a class C if its defining class loader can be reclaimed.
If the defining loader can be reclaimed, then there can never be any live references to it (this includes references that are not live, but might be resurrected by finalizers)
This, in turn, can only be true if there are can never be any live references to any of the classes defined by that loader, including C, either from their instances or from code.
Class unloading is an optimization that is only significant for applications that load large numbers of classes and that stop using most of those classes after some time.
A prime example of such an application is a web browser, but there are others.
A characteristic of such applications is that they manage classes through explicit use of class loaders.
As a result, the policy outlined above works well for them.
Strictly speaking, it is not essential that the issue of class unloading be discussed by this specification, as class unloading is merely an optimization.
However, the issue is very subtle, and so it is mentioned here by way of clarification.
A program terminates all its activity and exits when one of two things happens: • All the threads that are not daemon threads terminate.
Some thread invokes the exit method of class Runtime or class System, and the exit operation is not forbidden by the security manager.
Particular implementations may also store the source and binary of types in a versioning database and implement a ClassLoader that uses integrity mechanisms of the database to prevent linkage errors by providing binary-compatible versions of types to clients.
Developers of packages and classes that are to be widely distributed face a different set of problems.
In the Internet, which is our favorite example of a widely distributed system, it is often impractical or impossible to automatically recompile the pre-existing binaries that directly or indirectly depend on a type that is to be changed.
Instead, this specification defines a set of changes that developers are permitted to make to a package or to a class or interface type while preserving (not breaking) compatibility with pre-existing binaries.
Within the framework of Release-to-Release Binary Compatibility in SOM (Forman, Conner, Danforth, and Raper, Proceedings of OOPSLA '95), Java programming language binaries are binary compatible under all relevant transformations that the authors identify (with some caveats with respect to the addition of instance variables)
Using their scheme, here is a list of some important binary compatible changes that the Java programming language supports: • Reimplementing existing methods, constructors, and initializers to improve.
Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock.
Adding new fields, methods, or constructors to an existing class or interface.
When an entire package is updated, deleting default (package-only) access fields, methods, or constructors of classes and interfaces in the package.
Reordering the fields, methods, or constructors in an existing type declaration.
Reordering the list of direct superinterfaces of a class or interface.
Inserting new class or interface types in the type hierarchy.
Programs must be compiled either into the class file format specified by The Java Virtual Machine Specification, Java SE 7 Edition, or into a representation that can be mapped into that format by a class loader written in the Java programming language.
A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility.
A reference to another class or interface type must be symbolic, using the binary name of the type.
Otherwise, the compile-time type of Primary is the qualifying type of the reference.
If the expression is of the form super.f then the superclass of C is the qualifying type of the reference.
If the expression is of the form X.super.f then the superclass of X is the qualifying type of the reference.
If the reference is of the form X.f, where X denotes a class or interface, then the class or interface denoted by X is the qualifying type of the reference.
If the expression is referenced by a simple name, then if f is a member of the current class or interface, C, then let T be C.
Otherwise, let T be the innermost lexically enclosing class of which f is a member.
In either case, T is the qualifying type of the reference.
If D is Object then the qualifying type of the expression is Object.
Otherwise, the compile-time type of Primary is the qualifying type of the method invocation.
If the expression is of the form super.m then the superclass of C is the qualifying type of the method invocation.
If the expression is of the form X.super.m then the superclass of X is the qualifying type of the method invocation.
If the reference is of the form X.m, where X denotes a class or interface, then the class or interface denoted by X is the qualifying type of the method invocation.
If the method is referenced by a simple name, then if m is a member of the current class or interface, C, then let T be C.
Otherwise, let T be the innermost lexically enclosing class of which m is a member.
In either case, T is the qualifying type of the method invocation.
If the expression is of the form new D(...) or X.new D(...), then the qualifying type of the invocation is D.
If the expression is of the form this(...), then the qualifying type of the expression is C.
Any constructs introduced by a Java compiler that do not have a corresponding construct in the source code must be marked as synthetic, except for default constructors, the class initialization method, and the values and valueOf methods of the Enum class.
A binary representation for a class or interface must also contain all of the following:
A symbolic reference to the erasure of each direct superinterface, if any.
If it is a class, then the erased signature of each constructor, as described above.
For each method declared in the class or interface (excluding, for an interface,
Every class that contains a nested class must contain symbolic references to all of its member classes, and to all local and anonymous classes that appear in its methods, constructors, and static or instance initializers.
The following sections discuss changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries.
Under the translation requirements given above, the Java Virtual Machine and its class file format support these changes.
Any other valid binary format, such as a compressed or encrypted representation that is mapped back into class files by a class loader under the above requirements, will necessarily support these changes as well.
A change to a type is binary compatible with (equivalently, does not break binary compatibility with) pre-existing binaries if pre-existing binaries that previously linked without error will continue to link without error.
Binaries are compiled to rely on the accessible members and constructors of other classes and interfaces.
To preserve binary compatibility, a class or interface should treat its accessible members and constructors, their existence and behavior, as a contract with its users.
A new top level class or interface type may be added to a package without breaking compatibility with pre-existing binaries, provided the new type does not reuse a name previously given to an unrelated type.
If a new type reuses a name previously given to an unrelated type, then a conflict may result, since binaries for both types could not be loaded by the same class loader.
Changes in top level class and interface types that are not public and that are not a superclass or superinterface, respectively, of a public type, affect only types within the package in which they are declared.
Such types may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together.
This section describes the effects of changes to the declaration of a class and its members and constructors on pre-existing binaries.
Changing a class that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries.
If a class that was not declared final is changed to be declared final, then a VerifyError is thrown if a binary of a pre-existing subclass of this class is loaded,
Changing a class that is declared final to no longer be declared final does not break compatibility with pre-existing binaries.
Changing a class that is not declared public to be declared public does not break compatibility with pre-existing binaries.
If a class that was declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the class type; such a change is not recommended for widely distributed classes.
Changes to the class hierarchy that could result in such a circularity when newly compiled binaries are loaded with pre-existing binaries are not recommended for widely distributed classes.
Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.
If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then linkage errors may result if pre-existing binaries are loaded with the binary of the modified class.
Suppose that a new version of class Super is then compiled:
This version of class Super is not a subclass of Hyper.
If we then run the existing binaries of Hyper and Test with the new version of Super, then a VerifyError is thrown at link time.
The verifier objects because the result of new Super() cannot be passed as an argument in place of a formal parameter of type Hyper, because Super is not a subclass of Hyper.
It is instructive to consider what might happen without the verification step: the program might run and print:
This demonstrates that without the verifier, the Java type system could be defeated by linking inconsistent binary files, even though each was produced by a correct Java compiler.
The lesson is that an implementation that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid implementation.
This is analogous to other situations where a class transformation that is binary compatible for a client might not be source compatible for the same client.
Adding or removing a type parameter of a class does not, in itself, have any implications for binary compatibility.
If such a type parameter is used in the type of a field or method, that may have the normal implications of changing the aforementioned type.
No incompatibility with pre-existing binaries is caused by adding an instance (respectively static) member that has the same name and accessibility (for fields), or same name and accessibility and signature and return type (for methods), as an instance (respectively static) member of a superclass or subclass.
No error occurs even if the set of classes being linked would encounter a compile-time error.
Deleting a class member or constructor that is not declared private may cause a linkage error if the member or constructor is used by a pre-existing binary.
Suppose that a new version of class Super is produced:
Then, recompiling Super and executing this new binary with the original binaries for Test and Hyper produces the output:
The super keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class.
The expression super.Identifier is resolved, at compile time, to a method m in the superclass S.
If the method m is an instance method, then the method which is invoked at run time is the method with the same signature as m that is a member of the direct superclass of the class containing the expression involving super.
Suppose that a new version of class Super is produced:
Then, if Super and Hyper are recompiled but not Test, then running the new binaries with the existing binary of Test produces the output:
Changing the declared access of a member or constructor to permit less access may break compatibility with pre-existing binaries, causing a linkage error to be thrown when these binaries are resolved.
Less access is permitted if the access modifier is changed from default access to private access; from protected access to default.
Changing a member or constructor to permit less access is therefore not recommended for widely distributed classes.
Perhaps surprisingly, the binary format is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access.
If the method print in class Point is changed to be public, and then only the Point class is recompiled, and then executed with the previously existing binary for Test, then no linkage error occurs.
This happens even though it is improper, at compile time, for a public method to be overridden by a protected method (as shown by the fact that the class Test could not be recompiled using this new Point class unless print in Test were changed to be public.)
Allowing superclasses to change protected methods to be public without breaking binaries of pre-existing subclasses helps make binaries less fragile.
The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities.
Widely distributed programs should not expose any fields to their clients.
Apart from the binary compatibility issues discussed below, this is generally good software engineering practice.
Adding a field to a class may break compatibility with pre-existing binaries that are not recompiled.
Assume a reference to a field f with qualifying type T.
Assume further that f is in fact an instance (respectively static) field declared in a superclass of T, S, and that the type of f is X.
If a new field of type X with the same name as f is added to a subclass of S that is a superclass of T or T itself, then a linkage error may occur.
Such a linkage error will occur only if, in addition to the above, either one of the following conditions hold: • The new field is less accessible than the old one.
In particular, no linkage error will occur in the case where a class could no longer be recompiled because a field access previously referenced a field of a superclass with an incompatible type.
The previously compiled class with such a reference will continue to reference the field declared in a superclass.
Then, recompiling Hyper and Super, and executing the resulting new binaries with the old binary of Test produces the output:
The field h of Hyper is output by the original binary of Test.
While this may seem surprising at first, it serves to reduce the number of incompatibilities that occur at run time.
In an ideal world, all source files that needed recompilation would be recompiled whenever any one of them changed, eliminating such surprises.
But such a mass recompilation is often impractical or impossible, especially in the Internet.
And, as was previously noted, such recompilation would sometimes require further changes to the source code.)
Suppose that a new version of class Super is then compiled:
If the resulting binary is used with the existing binaries for Hyper and Test, then the output is still:
Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a NoSuchFieldError will be thrown when such a.
If a field that was not declared final is changed to be declared final, then it can break compatibility with pre-existing binaries that attempt to assign new values to the field.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in a IllegalAccessError.
Suppose that a new version of class Flags is produced:
If Flags is recompiled but not Test, then running the new binary with the existing binary of Test produces the output:
This behavior would not change if Flags were changed to be an interface, as in the modified example:
The best way to avoid problems with "inconstant constants" in widely-distributed code is to declare as compile-time constants only values which truly are unlikely ever to change.
Other than for true mathematical constants, we recommend that source code make very sparing use of class variables that are declared static and final.
If the read-only nature of final is required, a better choice is to declare a private static variable and a suitable accessor method to get its value.
We also recommend, as a general rule, that only truly constant values be declared in interfaces.
We note, but do not recommend, that if a field of primitive type of an interface may change, its value may be expressed idiomatically as in:
Such changes are not recommended in code that has been widely distributed.
Adding or deleting a transient modifier of a field does not break compatibility with pre-existing binaries.
Adding a method or constructor declaration to a class will not break compatibility with any pre-existing binaries, even in the case where a type could no longer be.
The previously compiled class with such a reference will continue to reference the method or constructor declared in a superclass.
Adding or removing a type parameter of a method or constructor does not, in itself, have any implications for binary compatibility.
If such a type parameter is used in the type of the method or constructor, that may have the normal implications of changing the aforementioned type.
Renaming a type parameter of a method or constructor has no effect with respect to pre-existing binaries.
If the type parameter is used as the type of any formal parameter of a method, but not as the return type, the effect is as if that method were removed, and replaced with a new method that is identical except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their type.
If the type parameter is used as a return type of a method, but not as the type of any formal parameter of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter.
If the type parameter is used as a return type of a method and as the type of one or more formal parameters of the method, the effect is as if that method were removed, and replaced with a new method that is identical except for the return type, which is now the new erasure of the type parameter, and except for the types of the aforementioned formal parameters, which now have the new erasure of the type parameter as their types.
Changing any other bound has no effect on binary compatibility.
Changing a method that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing binaries.
Suppose that a new version of class Super is produced:
Changing a method that is declared final to no longer be declared final does not break compatibility with pre-existing binaries.
Changing an instance method that is not declared final to be declared final may break compatibility with existing binaries that depend on the ability to override the method.
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test results in a VerifyError because the class Test improperly tries to override the instance method out.
Changing a class (static) method that is not declared final to be declared final does not break compatibility with existing binaries, because the method could not have been overridden.
Adding or deleting a native modifier of a method does not break compatibility with pre-existing binaries.
The impact of changes to types on pre-existing native methods that are not recompiled is beyond the scope of this specification and should be provided with.
Implementations are encouraged, but not required, to implement native methods in a way that limits such impact.
Such changes are not recommended in code that has been widely distributed.
Adding or deleting a synchronized modifier of a method does not break compatibility with pre-existing binaries.
Changes to the throws clause of methods or constructors do not break compatibility with pre-existing binaries; these clauses are checked only at compile time.
Changes to the body of a method or constructor do not break compatibility with pre-existing binaries.
The keyword final on a method does not mean that the method can be safely inlined; it means only that the method cannot be overridden.
It is still possible that a new version of that method will be provided at link-time.
Furthermore, the structure of the original program must be preserved for purposes of reflection.
Therefore, we note that a Java compiler cannot expand a method inline at compile time.
In general we suggest that implementations use late-bound (run-time) code generation and optimization.
Adding new methods or constructors that overload existing methods or constructors does not break compatibility with pre-existing binaries.
The signature to be used for each invocation was determined when these existing binaries were compiled;
Suppose that a new version of class Super is produced:
If Super is recompiled but not Test, then running the new binary with the existing binary of Test still produces the output:
However, if Test is then recompiled, using this new Super, the output is then:
If an instance method is added to a subclass and it overrides a method in a superclass, then the subclass method will be found by method invocations in preexisting binaries, and these binaries are not impacted.
If a class method is added to a class, then this method will not be found unless the qualifying type of the reference is the subclass type.
Adding or reordering constants in an enum type will not break compatibility with pre-existing binaries.
If a pre-existing binary attempts to access an enum constant that no longer exists, the client will fail at run time with a NoSuchFieldError.
Therefore such a change is not recommended for widely distributed enums.
In all other respects, the binary compatibility rules for enums are identical to those for classes.
This section describes the impact of changes to the declaration of an interface and its members on pre-existing binaries.
Changing an interface that is not declared public to be declared public does not break compatibility with pre-existing binaries.
If an interface that is declared public is changed to not be declared public, then an IllegalAccessError is thrown if a pre-existing binary is linked that needs but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.
Adding a method to an interface does not break compatibility with pre-existing binaries.
A field added to a superinterface of C may hide a field inherited from a superclass of C.
If the original reference was an assignment, an IllegalAccessError will result.
Deleting a member from an interface may cause linkage errors in pre-existing binaries.
Suppose that a new version of interface I is compiled:
If I is recompiled but not Test, then running the new binary with the existing binary for Test will result in a NoSuchMethodError.
The effects of changes to the type parameters of an interface are the same as those of analogous changes to the type parameters of a class.
Adding or removing an element from an annotation type is analogous to adding or removing a method.
There are important considerations governing other changes to annotation types, but these have no effect on the linkage of binaries by the Java Virtual Machine.
Rather, such changes affect the behavior of reflective APIs that manipulate annotations.
The documentation of these APIs specifies their behavior when various changes are made to the underlying annotation types.
Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.
Every statement has a normal mode of execution in which certain computational steps are carried out.
The following sections describe the normal mode of execution for each kind of statement.
If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally.
However, certain events may prevent a statement from completing normally:
If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly.
An abrupt completion always has an associated reason, which is one of the following:
A throw with a given value, including exceptions thrown by the Java Virtual Machine.
Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.
A block is a sequence of statements, local class declarations, and local variable declaration statements within braces.
A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right)
If all of these block statements complete normally, then the block completes normally.
If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.
Here is an example that illustrates several aspects of the rules given above:
The first statement of method foo creates an instance of the member class Global.Cyclic rather than an instance of the local class Cyclic, because the local class declaration is not yet in scope.
The fact that the scope of a local class encompasses its own declaration (not only its body) means that the definition of the local class Cyclic is indeed cyclic because it extends itself rather than Global.Cyclic.
Consequently, the declaration of the local class Cyclic will be rejected at compile time.
Since local class names cannot be redeclared within the same method (or constructor or initializer, as the case may be), the second and third declarations of Local result in compiletime errors.
However, Local can be redeclared in the context of another, more deeply nested, class such as AnotherLocal.
The fourth and last declaration of Local is legal, since it occurs outside the scope of any prior declaration of Local.
A local variable declaration statement declares one or more local variable names.
Every time it is executed, the declarators are processed in order from left to right.
If a declarator has an initialization expression, the expression is evaluated and its value is assigned to the variable.
Each initialization (except the first) is executed only if evaluation of the preceding initialization expression completes normally.
Execution of the local variable declaration completes normally only if evaluation of the last initialization expression completes normally.
If the local variable declaration contains no initialization expressions, then executing it always completes normally.
There are many kinds of statements in the Java programming language.
Most correspond to statements in the C and C++ languages, but some are unique.
As in C and C++, the if statement of the Java programming language suffers from the so-called "dangling else problem," illustrated by this misleadingly formatted example:
The problem is that both the outer if statement and the inner if statement might conceivably own the else clause.
In this example, one might surmise that the programmer intended the else clause to belong to the outer if statement.
The Java programming language, like C and C++ and many programming languages before them, arbitrarily decrees that an else clause belongs to the innermost if to which it might possibly belong.
Statements are thus grammatically divided into two categories: those that might end in an if statement that has no else clause (a "short if statement") and those that definitely do not.
Only statements that definitely do not end in a short if statement may appear as an immediate substatement before the keyword else in an if statement that does have an else clause.
The execution behavior of a statement with the "no short if" restriction is identical to the execution behavior of the same kind of statement without the "no short if" restriction; the distinction is drawn purely to resolve the syntactic difficulty.
Certain kinds of expressions may be used as statements by following them with semicolons.
An expression statement is executed by evaluating the expression; if the expression has a value, the value is discarded.
Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.
Unlike C and C++, the Java programming language allows only certain forms of expressions to be used as expression statements.
The if statement allows conditional execution of a statement or a conditional choice of two statements, executing one or the other but not both.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
Otherwise, execution continues by making a choice based on the resulting value: • If the value is true, then the contained Statement is executed; the if-then.
If the value is false, no further action is taken and the if-then statement completes normally.
If the value is false, then the second contained Statement (the one after the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally.
An assertion is an assert statement containing a boolean expression.
If the assertion is enabled, execution of the assertion causes evaluation of the boolean expression and an error is reported if the expression evaluates to false.
If the assertion is disabled, execution of the assertion has no effect whatsoever.
Whether or not a top level class enables assertions is determined no later than the earliest of the initialization of the top level class and the initialization of any class nested in the top level class, and cannot be changed after it has been determined.
An assert statement that is executed before its class has completed initialization is enabled.
This rule is motivated by a case that demands special treatment.
Recall that the assertion status of a class is set no later than the time it is initialized.
It is possible, though generally not desirable, to execute methods or constructors prior to initialization.
This can happen when a class hierarchy contains a circularity in its static initialization, as in the following example:
Because of the rule above, if the program above is executed without enabling assertions, it must print:
Otherwise, execution continues by making a choice based on the value of Expression1:
If the value is true, no further action is taken and the assert statement completes normally.
If the evaluation completes abruptly for some reason, the assert statement completes abruptly for the same reason.
For example, after unmarshalling all of the arguments from a data buffer, a programmer might assert that the number of bytes of data remaining in the buffer is zero.
By verifying that the boolean expression is indeed true, the system corroborates the programmer's knowledge of the program and increases one's confidence that the program is free of bugs.
Typically, assertion-checking is enabled during program development and testing, and disabled for deployment, to improve performance.
Because assertions may be disabled, programs must not assume that the expressions contained in assertions will be evaluated.
Thus, these boolean expressions should generally be free of side effects.
Evaluating such a boolean expression should not affect any state that is visible after the evaluation is complete.
It is not illegal for a boolean expression contained in an assertion to have a side effect, but it is generally inappropriate, as it could cause program behavior to vary depending on whether assertions were enabled or disabled.
Along similar lines, assertions should not be used for argument-checking in public methods.
Argument-checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.
Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate.
It is intended that AssertionError never be caught, but it is possible to do so, thus the rules for try statements should treat assertions appearing in a try block similarly to the current treatment of throw statements.
The switch statement transfers control to one of several statements depending on the value of an expression.
At most one default label may be associated with the same switch statement.
The prohibition against using null as a switch label prevents one from writing code that can never be executed.
If the switch expression is of a reference type, that is, String or a boxed primitive type or an enum type, then a run-time error will occur if the expression evaluates to null at run time.
In the judgment of the designers of the Java programming language, this is a better outcome than silently skipping the entire switch statement or choosing to execute the statements (if any) after the default label (if any)
A Java compiler is encouraged (but not required) to provide a warning if a switch on an enum-valued expression lacks a default label and lacks case labels for one or more of the enum type's constants.
Such a statement will silently do nothing if the expression evaluates to one of the missing constants.)
In C and C++ the body of a switch statement can be a statement and statements with case labels do not have to be immediately contained by that statement.
A trick known as Duff's device can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:
Fortunately, this trick does not seem to be widely known or used.
Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.
Otherwise, execution continues by comparing the value of the Expression with each case constant, and there is a choice: • If one of the case constants is equal to the value of the expression, then we say.
If all these statements complete normally, or if there are no statements after the matching case label, then the entire switch statement completes normally.
If no case matches but there is a default label, then all statements after the matching default label in the switch block, if any, are executed in sequence.
If all these statements complete normally, or if there are no statements after the default label, then the entire switch statement completes normally.
If no case matches and there is no default label, then no further action is taken and the switch statement completes normally.
If any statement immediately contained by the Block body of the switch statement completes abruptly, it is handled as follows: • If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly for any other reason, the switch.
As in C and C++, execution of statements in a switch block "falls through labels."
If code is not to fall through case to case in this manner, then break statements should be used, as in this example:
The while statement executes an Expression and a Statement repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
Otherwise, execution continues by making a choice based on the resulting value: • If the value is true, then the contained Statement is executed.
If the (possibly unboxed) value of the Expression is false, no further action is taken and the while statement completes normally.
If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.
Abrupt completion of the contained Statement is handled in the following manner: • If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly because of a continue with no.
If execution of the Statement completes abruptly because of a continue with.
If execution of the Statement completes abruptly for any other reason, the while.
The do statement executes a Statement and an Expression repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
A do statement is executed by first executing the Statement.
Then there is a choice: • If execution of the Statement completes normally, then the Expression is.
Executing a do statement always executes the contained Statement at least once.
Abrupt completion of the contained Statement is handled in the following manner: • If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly for any other reason, the do.
The following code is one possible implementation of the toHexString method of class Integer:
Because at least one digit must be generated, the do statement is an appropriate control structure.
The basic for statement executes some initialization code, then executes an Expression, a Statement, and some update code repeatedly until the value of the Expression is false.
The Expression must have type boolean or Boolean, or a compile-time error occurs.
If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForInit statement expressions to the right of the one that completed abruptly are not evaluated.
If the ForInit part is not present, no action is taken.
Next, a for iteration step is performed, as follows: • If the Expression is present, it is evaluated.
Otherwise, there is then a choice based on the presence or absence of the Expression and the resulting value if the Expression is present; see next bullet.
If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForUpdate statement expressions to the right of the one that completed abruptly are not evaluated.
If the ForUpdate part is not present, no action is taken.
If the Expression is present and the value resulting from its evaluation (including any possible unboxing) is false, no further action is taken and the for statement completes normally.
If the (possibly unboxed) value of the Expression is false the first time it is evaluated, then the Statement is not executed.
If the Expression is not present, then the only way a for statement can complete normally is by use of a break statement.
Abrupt completion of the contained Statement is handled in the following manner: • If execution of the Statement completes abruptly because of a break with no.
If execution of the Statement completes abruptly because of a continue with no.
If the ForUpdate part is not present, no action is taken.
If execution of the Statement completes abruptly because of a continue with.
First, if the ForUpdate part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded.
If the ForUpdate is not present, no action is taken.
If execution of the Statement completes abruptly for any other reason, the for.
If the type of Expression is a subtype of Iterable, then the translation is as follows.
The enhanced for statement is equivalent to a basic for statement of the form:
Lm be the (possibly empty) sequence of labels immediately preceding the enhanced for statement.
The enhanced for statement is equivalent to a basic for statement of the form:
The following program, which calculates the sum of an integer array, shows how enhanced for works for arrays:
The following program combines the enhanced for statement with auto-unboxing to translate a histogram into a frequency table:
A break statement transfers control out of an enclosing statement.
A break statement with no label attempts to transfer control to the innermost enclosing switch, while, do, or for statement of the immediately enclosing method or initializer; this statement, which is called the break target, then immediately completes normally.
To be precise, a break statement with no label always completes abruptly, the reason being a break with no label.
If no switch, while, do, or for statement in the immediately enclosing method, constructor, or initializer contains the break statement, a compile-time error occurs.
It can be seen, then, that a break statement always completes abruptly.
In the following example, a mathematical graph is represented by an array of arrays.
A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself.
In this example it is assumed that there are no redundant edges; that is, for any two nodes P and Q, where Q may be the same as P, there is at most one edge from P to Q.
The task of the method loseEdges, given integers i and j, is to construct a new graph by copying a given graph but omitting the edge from node i to node j, if any, and the edge from node j to node i, if any:
Note the use of two statement labels, edgelist and search, and the use of break statements.
This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node i to node j, and the test for an edge from node j to node i.
A continue statement may occur only in a while, do, or for statement; statements of these three kinds are called iteration statements.
Control passes to the loopcontinuation point of an iteration statement.
A continue statement with no label attempts to transfer control to the innermost enclosing while, do, or for statement of the immediately enclosing method, constructor, or initializer; this statement, which is called the continue target, then immediately ends the current iteration and begins a new one.
To be precise, such a continue statement always completes abruptly, the reason being a continue with no label.
If no while, do, or for statement of the immediately enclosing method, constructor, or initializer contains the continue statement, a compile-time error occurs.
To be precise, a continue statement with label Identifier always completes abruptly, the reason being a continue with label Identifier.
The continue target must be a while, do, or for statement, or a compile-time error occurs.
A continue statement must refer to a label within the immediately enclosing method, constructor, or initializer.
If no labeled statement with Identifier as its label in the immediately enclosing method, constructor, or initializer contains the continue statement, a compile-time error occurs.
It can be seen, then, that a continue statement always completes abruptly.
Which to use, if either, is largely a matter of programming style.
The Expression must denote a variable or value of some type T, or a compile-time error occurs.
It can be seen, then, that a return statement always completes abruptly.
At least one of the following three conditions must be true, or a compile-time error occurs:
If evaluation of the Expression completes abruptly for some reason, then the throw completes abruptly for that reason.
If evaluation of the Expression completes normally, producing a non-null value V, then the throw statement completes abruptly, the reason being a throw with value V.
The throw statement then completes abruptly, the reason being a throw with value V'
It can be seen, then, that a throw statement always completes abruptly.
The type of Expression must be a reference type, or a compile-time error occurs.
A synchronized statement is executed by first evaluating the Expression.
Then: • If evaluation of the Expression completes abruptly for some reason, then the synchronized statement completes abruptly for the same reason.
Acquiring the lock associated with an object does not in itself prevent other threads from accessing fields of the object or invoking un-synchronized methods on the object.
Other threads can also use synchronized methods or the synchronized statement in a conventional manner to achieve mutual exclusion.
Note that this program would deadlock if a single thread were not permitted to lock a monitor more than once.
If a value is thrown and the try statement has one or more catch clauses that can catch it, then control will be transferred to the first such catch clause.
If the try statement has a finally clause, then another block of code is executed, no matter whether the try block completes normally or abruptly, and no matter whether a catch clause is first given control.
The Block immediately after the keyword try is called the try block of the try statement.
The Block immediately after the keyword finally is called the finally block of the try statement.
An exception parameter may denote its type as either a single class type or a union of two or more class types (called alternatives)
The alternatives of a union are syntactically separated by |
A catch clause whose exception parameter is denoted as a single class type is called a uni-catch clause.
A catch clause whose exception parameter is denoted as a union of types is called a multi-catch clause.
Each class type used in the denotation of the type of an exception parameter must be the class Throwable or a subclass of Throwable, or a compile-time error occurs.
It is a compile-time error if a type variable is used in the denotation of the type of an exception parameter.
An implicitly final exception parameter is final by virtue of its declaration, while an effectively final exception parameter is (as it were) final by virtue of how it is used.
An exception parameter of a multi-catch clause is implicitly final, so will never occur as the left-hand operand of an assignment operator, but it is not considered effectively final.
If an exception parameter is effectively final (in a uni-catch clause) or implicitly final (in a multi-catch clause), then adding an explicit final modifier to its declaration will not introduce any compile-time errors.
However, if the exception parameter of a uni-catch clause is explicitly declared final, then removing the final modifier may introduce compile-time errors.
This is because the exception parameter, while still effectively final, can no longer be referenced by, for example, local classes.
On the other hand, if there are no compile-time errors, it is possible to further change the program so that the exception parameter is re-assigned and no longer effectively final.
A multi-catch clause can be thought of as a sequence of uni-catch clauses.
A Java compiler is neither required nor recommended to compile a multi-catch clause by duplicating code in this manner, since it is possible to represent the multi-catch clause in a class file without duplication.
A try statement without a finally block is executed by first executing the try block.
Then there is a choice: • If execution of the try block completes normally, then no further action is taken.
If execution of the try block completes abruptly for any other reason, then the try statement completes abruptly for the same reason.
Here, the exception BlewIt is thrown by the method blowUp.
The try-catch statement in the body of main has two catch clauses.
The run-time type of the exception is BlewIt which is not assignable to a variable of type RuntimeException, but is assignable to a variable of type BlewIt, so the output of the example is:
A try statement with a finally block is executed by first executing the try block.
This causes the finally clause to execute, after which the thread executing main, which is the only thread of the test program, terminates because of an uncaught exception, which typically results in printing the exception name and a simple backtrace.
The problem with mandating a backtrace is that an exception can be created at one point in the program and thrown at a later one.
It is prohibitively expensive to store a stack trace in an exception unless it is actually thrown (in which case the trace may be generated while unwinding the stack)
Hence we do not mandate a back trace in every exception.
A try-with-resources statement is parameterized with variables (known as resources) that are initialized before execution of the try block and closed automatically, in the reverse order from which they were initialized, after execution of the try block.
If a resource fails to initialize (that is, its initializer expression throws an exception), then all resources initialized so far by the try-with-resources statement are closed.
If all resources initialize successfully, the try block executes as normal and then all non-null resources of the try-withresources statement are closed.
Resources are closed in the reverse order from that in which they were initialized.
A resource is closed only if it initialized to a non-null value.
An exception from the closing of one resource does not prevent the closing of other resources.
Such an exception is suppressed if an exception was thrown previously by an initializer, the try block, or the closing of a resource.
After n such translations, there are n nested try-catch-finally statements, and the overall translation is complete.
A try-with-resources statement with no catch clauses or finally clause is called a basic try-with-resources statement.
Reachability and definite assignment rules for the basic try-with-resources statement are implicitly specified by the translation above.
In a basic try-with-resources statement that manages a single resource: • If the initialization of the resource completes abruptly because of a throw of a.
If the initialization of the resource completes normally, and the try block completes normally, and the automatic closing of the resource completes abruptly because of a throw of a value V, then the try-with-resources statement completes abruptly because of a throw of the value V.
In a basic try-with-resources statement that manages multiple resources: • If the initialization of a resource completes abruptly because of a throw of a.
A try-with-resources statement with at least one catch clause and/or a finally clause is called an extended try-with-resources statement.
This allows a catch clause of an extended try-with-resources statement to catch an exception due to the automatic initialization or closing of any resource.
Furthermore, all resources will have been closed (or attempted to be closed) by the time the finally block is executed, in keeping with the intent of the finally keyword.
It is a compile-time error if a statement cannot be executed because it is unreachable.
This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself.
Except for the special treatment of while, do, and for statements whose condition expression has the constant value true, the values of expressions are not taken into account in the flow analysis.
To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if." A reachable break statement exits a statement if, within the break target, either there are no try statements whose try blocks contain the break statement, or there are try statements whose try blocks contain the break statement and all finally clauses of those try statements can complete normally.
A continue statement continues a do statement if, within the do statement, either there are no try statements whose try blocks contain the continue statement, or there are try statements whose try blocks contain the continue statement and all finally clauses of those try statements can complete normally.
The block that is the body of a constructor, method, instance initializer, or static initializer is reachable.
An empty block that is not a switch block can complete normally iff it is reachable.
A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally.
The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.
Every other statement S in a non-empty block that is not a switch block is reachable iff the statement preceding S can complete normally.
A local class declaration statement can complete normally iff it is reachable.
A local variable declaration statement can complete normally iff it is reachable.
An empty statement can complete normally iff it is reachable.
A labeled statement can complete normally if at least one of the following is true:
An expression statement can complete normally iff it is reachable.
An if-then statement can complete normally iff it is reachable.
The then-statement is reachable iff the if-then statement is reachable.
An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally.
The then-statement is reachable iff the if-then-else statement is reachable.
The else-statement is reachable iff the if-then-else statement is reachable.
This handling of an if statement, whether or not it has an else part, is rather unusual.
The rationale is given at the end of this section.
An assert statement can complete normally iff it is reachable.
A switch statement can complete normally iff at least one of the following is.
A switch block is reachable iff its switch statement is reachable.
A statement in a switch block is reachable iff its switch statement is reachable.
The do statement contains a reachable continue statement with a label L, and the do statement has label L, and the continue statement continues that do statement, and the condition expression is not a constant expression with value true.
There is a reachable break statement that exits the do statement.
The contained statement is reachable iff the do statement is reachable.
An enhanced for statement can complete normally iff it is reachable.
A break, continue, return, or throw statement cannot complete normally.
A synchronized statement can complete normally iff the contained statement can complete normally.
The contained statement is reachable iff the synchronized statement is reachable.
The try block is reachable iff the try statement is reachable.
A catch block C is reachable iff both of the following are true:
Either the type of C's parameter is an unchecked exception type or Throwable; or some expression or throw statement in the try block is reachable and can throw a checked exception whose type is assignable to the parameter of the catch clause C.
An expression is reachable iff the innermost statement containing it is reachable.
The Block of a catch block is reachable iff the catch block is reachable.
If a finally block is present, it is reachable iff the try statement is reachable.
One might expect the if statement to be handled in the following manner:
An if-then statement can complete normally iff at least one of the following is true:
The if-then statement is reachable and the condition expression is not a constant expression whose value is true.
The then-statement is reachable iff the if-then statement is reachable and the condition expression is not a constant expression whose value is false.
An if-then-else statement can complete normally iff the then-statement can complete normally or the else-statement can complete normally.
The then-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is false.
The else-statement is reachable iff the if-then-else statement is reachable and the condition expression is not a constant expression whose value is true.
This approach would be consistent with the treatment of other control structures.
However, in order to allow the if statement to be used conveniently for "conditional compilation" purposes, the actual rules differ.
As an example, the following statement results in a compile-time error:
The rationale for this differing treatment is to allow programmers to define "flag variables" such as:
The idea is that it should be possible to change the value of DEBUG from false to true or from true to false and then compile the code correctly with no other changes to the program text.
This chapter specifies the meanings of expressions and the rules for their evaluation.
When an expression in a program is evaluated (executed), the result denotes one of three things:
The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in an annotation, or in the code for a method.
It follows that an expression is not FP-strict if and only if it is not a compiletime constant expression and it does not appear within any declaration that has the strictfp modifier.
Within an FP-strict expression, all intermediate values must be elements of the float value set or the double value set, implying that the results of all FPstrict expressions must be those predicted by IEEE 754 arithmetic on operands represented using single and double formats.
Within an expression that is not FP-strict, some leeway is granted for an implementation to use an extended exponent range to represent intermediate results; the net effect, roughly speaking, is that a calculation might produce "the correct answer" in situations where exclusive use of the float value set or double value set might result in overflow or underflow.
If the type of an expression is a primitive type, then the value of the expression is of that same primitive type.
If the type of an expression is a reference type, then the class of the referenced object, or even whether the value is a reference to an object rather than null, is not necessarily known at compile time.
There are a few places in the Java programming language where the actual class of a referenced object affects program execution in a manner that cannot be deduced from the type of the expression.
Situations where the class of an object is not statically known may lead to run-time type errors.
A run-time type error can occur only in these situations:
Every expression has a normal mode of evaluation in which certain computational steps are carried out.
The following sections describe the normal mode of evaluation for each kind of expression.
If all the steps are carried out without an exception being thrown, the expression is said to complete normally.
If, however, evaluation of an expression throws an exception, then the expression is said to complete abruptly.
An abrupt completion always has an associated reason, which is always a throw with a given value.
A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly.
A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly.
Various linkage and virtual machine errors may also occur during the evaluation of an expression.
By their nature, such errors are difficult to predict and difficult to handle.
If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly.
If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.
The Java programming language guarantees that the operands of operators appear to be evaluated in a specific evaluation order, namely, from left to right.
It is recommended that code not rely crucially on this specification.
Code is usually clearer when each expression contains at most one side effect, as its outermost operation, and when code does not depend on exactly which exception arises as a consequence of the left-toright evaluation of expressions.
In the following program, the * operator has a left-hand operand that contains an assignment to a variable and a right-hand operand that contains a reference to the same variable.
The value produced by the reference will reflect the fact that the assignment occurred first.
It is not permitted for either assignment (compound for a, simple for b) to produce the result 6
That is, the left-hand operand forgetIt() of the operator / throws an exception before the right-hand operand is evaluated and its embedded assignment of 2 to j occurs.
The Java programming language respects the order of evaluation indicated explicitly by parentheses and implicitly by operator precedence.
In the case of floating-point calculations, this rule applies also for infinity and nota-number (NaN) values.
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative.
In contrast, integer addition and multiplication are provably associative in the Java programming language.
In a method or constructor invocation or class instance creation expression, argument expressions may appear within the parentheses, separated by commas.
Each argument expression appears to be fully evaluated before any part of any argument expression to its right.
If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.
Primary expressions include most of the simplest kinds of expressions, from which all others are constructed: literals, class literals, field accesses, method invocations, and array accesses.
A parenthesized expression is also treated syntactically as a primary expression.
The keyword this may be used only in the body of an instance method, instance initializer, or constructor, or in the initializer of an instance variable of a class.
Here, the class IntVector implements a method equals, which compares two vectors.
If the other vector is the same vector object as the one for which the equals method was invoked, then the check can skip the length and value comparisons.
The equals method implements this check by comparing the reference to the other object to this.
The value of an expression of the form ClassName.this is the n'th lexically enclosing instance of this.
It is a compile-time error if the current class is not an inner class of class C or C itself.
A parenthesized expression is a primary expression whose type is the type of the contained expression and whose value at run time is the value of the contained expression.
If the contained expression denotes a variable then the parenthesized expression also denotes that variable.
A class instance creation expression is used to create new objects that are instances of classes.
This rule is introduced because inference of a generic class's type arguments may influence the constraints on a generic constructor's type arguments.
A qualified class instance creation expression enables the creation of instances of inner member classes and their anonymous subclasses.
We say that a class is instantiated when an instance of the class is created by a class instance creation expression.
Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created.
If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class.
Then: • If the class instance creation expression is an unqualified class instance creation.
Otherwise, the class instance creation expression is a qualified class instance.
If a class instance creation expression does not declare an anonymous class, then:
The class being instantiated is the class denoted by the TypeDeclSpecifier.
Otherwise, the class instance creation expression is a qualified class instance.
The type of the class instance creation expression is the class type being instantiated, as defined above.
If C occurs in a static context, then i has no immediately enclosing instance.
Otherwise, if the class instance creation expression occurs in a static context,
The immediately enclosing instance of i is the n'th lexically enclosing instance of this.
Otherwise, the class instance creation expression is a qualified class instance creation expression.
The immediately enclosing instance of i is the object that is the value of the Primary expression.
If S occurs within a static context, then i has no immediately enclosing instance with respect to S.
Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.
Otherwise, the immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
The immediately enclosing instance of i with respect to S is the n'th lexically enclosing instance of this.
Otherwise, the class instance creation expression is a qualified class instance creation expression.
The immediately enclosing instance of i with respect to S is the object that is the value of the Primary expression.
To create an instance of C, i, a constructor of C is chosen at compile time by the following rules.
First, the actual arguments to the constructor invocation are determined: • If C is an anonymous class, and the direct superclass of C, S, is an inner class, then:
If S is a local class and S occurs in a static context, then the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
Otherwise, the immediately enclosing instance of i with respect to S is the first argument to the constructor, followed by the arguments in the argument list of the class instance creation expression, if any, in the order they appear in the expression.
Otherwise the arguments in the argument list, if any, are the arguments to the constructor, in the order they appear in the expression.
Otherwise, the class instance creation expression does not use "<>" to elide class type arguments.
At run time, evaluation of a class instance creation expression is as follows.
First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated.
If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.
The value of a class instance creation expression is a reference to the newly created object of the specified class.
Every time the expression is evaluated, a fresh object is created.
If evaluation of a class instance creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown.
Instead, a Java compiler must automatically provide an anonymous constructor for the anonymous class.
The form of the anonymous constructor of an anonymous class C with direct superclass S is as follows:
In all cases, the throws clause of an anonymous constructor must list all the checked exceptions thrown by the explicit superclass constructor invocation statement contained within the anonymous constructor, and all checked exceptions thrown by any instance initializers or instance variable initializers of the anonymous class.
Note that it is possible for the signature of the anonymous constructor to refer to an inaccessible type (for example, if such a type occurred in the signature of the superclass constructor cs)
This does not, in itself, cause any errors at either compile-time or run-time.
The rules above imply that the element type in an array creation expression cannot be a parameterized type, other than an unbounded wildcard.
At run time, evaluation of an array creation expression behaves as follows: • If there are no dimension expressions, then there must be an array initializer.
If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an OutOfMemoryError.
Otherwise, if n DimExpr expressions appear, then array creation effectively executes a set of nested loops of depth n-1 to create the implied arrays of arrays.
A multidimensional array need not have arrays of the same length at each level.
In an array creation expression with one or more dimension expressions, each dimension expression is fully evaluated before any part of any dimension expression to its right.
If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated.
This example leaves the fifth dimension, which would be arrays containing the actual array elements (references to Age objects), initialized only to null references.
These arrays can be filled in later by other code, such as:
If evaluation of an array creation expression finds there is insufficient memory to perform the creation operation, then an OutOfMemoryError is thrown.
If the array creation expression does not have an array initializer, then this check occurs only after evaluation of all dimension expressions has completed normally.
A field access expression may access a field of an object or array, a reference to which is the value of either an expression or the special keyword super.
If the identifier does not name an accessible member field in type T, then the.
Otherwise, the identifier names a single accessible member field in type T, and.
At run time, the result of the field access expression is computed as follows: (assuming that the program is correct with respect to definite assignment analysis, i.e.
The Primary expression is evaluated, and the result is discarded.
If evaluation of the Primary expression completes abruptly, the field access expression completes abruptly for the same reason.
If the field is a non-blank final field, then the result is the value of the specified class variable in the class or interface that is the type of the Primary expression.
If the field is not final, or is a blank final and the field access occurs in a constructor, then the result is a variable, namely, the specified class variable in the class that is the type of the Primary expression.
If the field is a non-blank final, then the result is the value of the named member field in type T found in the object referenced by the value of the Primary.
If the field is not final, or is a blank final and the field access occurs in a constructor, then the result is a variable, namely the named member field in type T found in the object referenced by the value of the Primary.
Note that only the type of the Primary expression, not the class of the actual object referred to at run time, is used in determining which field to use.
The last line shows that, indeed, the field that is accessed does not depend on the runtime class of the referenced object; even if s holds a reference to an object of class T, the expression s.x refers to the x field of class S, because the type of the expression s is S.
Objects of class T contain two fields named x, one for class T and one for its superclass S.
This lack of dynamic lookup for field accesses allows programs to be run efficiently with straightforward implementations.
The power of late binding and overriding is available, but only when instance methods are used.
Consider the same example using instance methods to access the fields:
The last line shows that, indeed, the method that is accessed does depend on the runtime class of the referenced object; when s holds a reference to an object of class T, the expression s.z() refers to the z method of class T, despite the fact that the type of the expression s is S.
Method z of class T overrides method z of class S.
The following program demonstrates that a null reference may be used to access a class (static) variable without causing an exception:
That "Mount " is printed demonstrates that the Primary expression is indeed fully evaluated at run time, despite the fact that only its type, not its value, is used to determine which field to access (because the field mountain is static)
The form super.Identifier refers to the field named Identifier of the current object, but with the current object viewed as an instance of the superclass of the current class.
The forms using the keyword super are valid only in an instance method, instance initializer, or constructor, or in the initializer of an instance variable of a class.
It is a compile-time error if the forms using the keyword super appear in the declaration of class Object, since Object has no superclass.
If a field access expression super.name appears within class C, and the immediate superclass of C is class S, then super.name is treated exactly as if it had been the expression this.name in the body of class S.
Thus it can access the field name that is visible in class S, even if that field is hidden by a declaration of a field name in class C.
If a field access expression T.super.name appears within class C, and the immediate superclass of the class denoted by T is a class whose fully qualified name is S, then T.super.name is treated exactly as if it had been the expression this.name in the body of class S.
Thus it can access the field name that is visible in class S, even if that field is hidden by a declaration of a field name in class T.
It is a compile-time error if the current class is not an inner class of class T or T itself.
Within class T3, the expression super.x is treated as if it were:
Note that super.x is not specified in terms of a cast, due to difficulties around access to protected members of the superclass.
A method invocation expression is used to invoke a class or instance method.
Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading.
Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.
The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to check for definitions of methods of that name.
There are several cases to consider, depending on the form that precedes the left parenthesis, as follows.
If the form is MethodName, then there are three subcases:
If it is a qualified name of the form TypeName.
Identifier, then the name of the method is the Identifier and the class to search is the one named by the TypeName.
If TypeName is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only static methods and interfaces have no static methods.
In all other cases, the qualified name has the form FieldName.
The name of the method is the Identifier and the class or interface to search is the declared type T of the field named by the FieldName, if T is a class or interface type, or the upper bound of T if T is a type variable.
The class or interface to be searched is T if T is a class or interface type, or the upper bound of T if T is a type variable.
It is a compile-time error if T is not a reference type.
Let T be the type declaration immediately enclosing the method invocation.
It is a compile-time error if T is the class Object or T is an interface.
It is a compile-time error if C is not a lexically enclosing class of the current class.
It is a compile-time error if C is the class Object.
Let T be the type declaration immediately enclosing the method invocation.
It is a compile-time error if T is the class Object or T is an interface.
If TypeName is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only static methods and interfaces have no static methods.
The second step searches the type determined in the previous step for member methods.
This step uses the name of the method and the types of the argument expressions to locate methods that are both accessible and applicable, that is, declarations that can be correctly invoked on the given arguments.
There may be more than one such method, in which case the most specific one is chosen.
The descriptor (signature plus return type) of the most specific method is one used at run time to perform the method dispatch.
If no applicable method is found during this phase then processing continues to the second phase.
This ensures that a method is never chosen through variable arity method invocation if it is applicable through fixed arity method invocation.
For the method invocation two(1) within class Doubler, there are two accessible methods named two, but only the second one is applicable, and so that is the one invoked at run time.
For the method invocation Doubler.two(3), the class Doubler, not class Test, is searched for methods named two; the only applicable method is not accessible, and so this method invocation causes a compile-time error.
Here, a compile-time error occurs for the second invocation of setColor, because no applicable method can be found at compile time.
The type of the literal 37 is int, and int cannot be converted to byte by method invocation conversion.
Assignment conversion, which is used in the initialization of the variable color, performs an implicit conversion of the constant from type int to byte, which is permitted because the value 37 is small enough to be represented in type byte; but such a conversion is not allowed for method invocation conversion.
If the method setColor had, however, been declared to take an int instead of a byte, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from byte to int.
However, a narrowing cast would then be required in the body of setColor:
The problem is that there are two declarations of test that are applicable and accessible, and neither is more specific than the other.
Here, the most specific declaration of method test is the one taking a parameter of type ColoredPoint.
Because the result type of the method is int, a compile-time error occurs because an int cannot be converted to a String by assignment conversion.
This example shows that the result types of methods do not participate in resolving overloaded methods,
The most specific method is chosen at compile time; its descriptor determines what method is actually executed at run time.
If a new method is added to a class, then source code that was compiled with the old definition of the class might not use the new method, even if a recompilation would cause this method to be chosen.
So, for example, consider two compilation units, one for class Point:
The programmer who coded class Test has expected to see the word green, because the actual argument, a ColoredPoint, has a color field, and color would seem to be a "relevant field"
Of course, the documentation for the package points ought to have been much more precise!)
Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of adopt has a signature that indicates a method of one parameter, and the parameter is of type Point.
This signature becomes part of the binary representation of class Test produced by the Java compiler and is used by the method invocation at run time.
Suppose the programmer reported this software error and the maintainer of the points package decided, after due deliberation, to correct it by adding a method to class ColoredPoint:
If the programmer then runs the old binary file for Test with the new binary file for ColoredPoint, the output is still:
If the source code for Test is recompiled, the Java compiler will then discover that there are now two applicable adopt methods, and that the signature for the more specific one is "one parameter, whose type is ColoredPoint; void"; running the program will then produce the desired output:
With forethought about such problems, the maintainer of the points package could fix the ColoredPoint class to work with both newly compiled and old code, by adding defensive code to the old adopt method for the sake of old code that still invokes it on ColoredPoint arguments:
The name of the member is identical to the name of the method in the method invocation.
Whether a member method is accessible at a method invocation depends on the access modifier (public, none, protected, or private) in the member's declaration and on where the method invocation appears.
If the member is a variable arity method with arity n, the arity of the method invocation is greater or equal to n-1
If the member is a fixed arity method with arity n, the arity of the method invocation is equal to n.
If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.
This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments.
In such a case, the type arguments will simply be ignored.
This rule stems from issues of compatibility and principles of substitutability.
Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one.
However, the overriding (nongeneric) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments.
Otherwise the subtype would not be substitutable for its generified supertype.
If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.
Up be the explicit type arguments given in the method invocation.
Up be the explicit type arguments given in the method invocation.
Up be the explicit type arguments given in the method invocation.
If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the runEXPRESSIONS Method Invocation Expressions 15.12
The Java programming language uses the rule that the most specific method is chosen.
The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.
One variable arity member method named m is more specific than another variable arity member method of the same name if either:
The above conditions are the only circumstances under which one method may be more specific than another.
A method is said to be maximally specific for a method invocation if it is accessible and applicable and there is no other method that is applicable and accessible that is strictly more specific.
Otherwise, we say that the method invocation is ambiguous, and a compile-time error occurs.
The result type of the chosen method is determined as follows: • If the chosen method is declared with a return type of void, then the result is void.
The exception types of the throws clause of the chosen method are determined as follows:
Otherwise, the type of the throws clause is the type given in the method declaration.
Therefore, it is useful to give an informal overview of the process before delving into the detailed specification.
Generally, the constraints require that the statically known types of the actual arguments are acceptable given the declared formal parameter types.
Given these initial constraints, one may derive a set of supertype and/or equality constraints on the type parameters of the method or constructor.
Next, one must try and find a solution that satisfies the constraints on the type parameters.
As a first approximation, if a type parameter is constrained by an equality constraint, then that constraint gives its solution.
Bear in mind that the constraint may equate one type parameter with another, and only when the entire set of constraints on all type variables is resolved will we have a solution.
A supertype constraint T :> X implies that the solution is one of supertypes of X.
Given several such constraints on T, we can intersect the sets of supertypes implied by each of the constraints, since the type parameter must be a member of all of them.
We can then choose the most specific type that is in the intersection.
Computing the intersection is more complicated than one might first realize.
However, a more sophisticated analysis yields a set containing List<?>
Similarly, if a type parameter T is constrained to be a supertype of two unrelated interfaces I and J, we might infer T must be Object, or we might obtain a tighter bound of I & J.
These issues are discussed in more detail later in this section.
The letter A is only used to denote the type of an actual argument, and F is only used to denote the type of a formal parameter.
Type parameters are represented using the letters S and T • Arguments to parameterized types are represented using the letters X and Y.
Generic type declarations are represented using the letters G and H.
It is worth noting that a constraint of the form A = F is never part of the initial constraints.
We need to remember which participant in the relation includes a type to be inferred.
It may be that the initial constraints are unsatisfiable; we say that inference is overconstrained.
In that case, we do not necessarily derive unsatisfiable constraints on the type parameters.
Instead, we may infer type arguments for the invocation, but once we substitute the type arguments for the type parameters, the applicability test may fail because the actual argument types are not acceptable given the substituted formal parameter types.
An alternative strategy would be to have type inference itself fail in such cases.
A Java compiler may choose to do so, provided the effect is equivalent to that specified here.
If F does not involve a type parameter Tj then no constraint is implied on Tj.
Otherwise, F involves a type parameter Tj, and there are four cases to consider.
If A is the type of null, no constraint is implied on Tj.
Otherwise, if the constraint has the form A << F:
If A is a primitive type, then A is converted to a reference type U via boxing conversion and this algorithm is applied recursively to the constraint U << F.
This follows from the covariant subtype relation among array types.
Since array subtyping is covariant, it must be the case that V << U.
For simplicity, assume that G takes a single type argument.
If the method invocation being examined is to be applicable, it must be the case that A is a subtype of some invocation of G.
Now, since U is a type expression (and therefore, U is not a wildcard type argument), it must be the case that U = V, by the non-variance of ordinary parameterized type invocations.
The formulation above merely generalizes this reasoning to generics with an arbitrary number of type arguments.
Again, let's keep things as simple as possible, and consider only the case where G has a single type argument.
As above, it must be the case that A is a subtype of some invocation of G.
The first variation is described (generalized to multiple arguments) by the sub-bullet directly above.
The rules of subtyping for wildcards imply that V << U.
Then this algorithm is applied recursively to the constraint V << U.
The rules of subtyping for wildcards again imply that V << U.
It may be that U will eventually be inferred to be Object, in which case the call may indeed be valid.
Therefore, we simply refrain from placing any constraint on U.
As usual, we consider only the case where G has a single type argument.
As above, it must be the case that A is a subtype of some invocation of G.
The first variation is described (generalized to multiple arguments) by the sub-bullet directly above.
The rules of subtyping for wildcards imply that V >> U.
Then this algorithm is applied recursively to the constraint V >> U.
The rules of subtyping for lowerbounded wildcards again imply that V >> U.
It may be that U will eventually be inferred to the null type, in which case the call may indeed be valid.
Therefore, we simply refrain from placing any constraint on U.
Otherwise, if the constraint has the form A = F:
Otherwise, if the constraint has the form A >> F:
This follows from the covariant subtype relation among array types.
Since array subtyping is covariant, it must be the case that V >> U.
A must be a supertype of the generic type G.
However, since A is not a parameterized type, it cannot depend upon the type argument U in any way.
It is a supertype of G<X> for every X that is a valid type argument to G.
No meaningful constraint on U can be derived from A.
Our goal here is to simplify the relationship between A and F.
We aim to recursively invoke the algorithm on a simpler case, where the type argument is known to be an invocation of the same generic type declaration as the formal.
Let's consider the case where both H and G have only a single type argument.
If we replace F by V in the constraint, we will have accomplished the goal of relating two invocations of the same generic (as it happens, H)
We will then be able to relate the type arguments of both invocations of H and extract the relevant constraints from them.
Since W is a type expression (and not a wildcard type argument), it must be the case that W = U, by the invariance of parameterized types.
It must be the case that W >> U, by the subtyping rules for wildcard types.
It must be the case that W << U, by the subtyping rules for wildcard types.
A must be a supertype of the generic type G.
However, since A is not a parameterized type, it cannot depend upon U in any way.
No meaningful constraint on U can be derived from A.
Then this algorithm is applied recursively to the constraint A >> V.
Our goal here is once more to simplify the relationship between A and F, and recursively invoke the algorithm on a simpler case, where the type argument is known to be an invocation of the same generic type as the formal.
Assume both H and G have only a single type argument.
However, substituting ? extends U for S is not generally valid.
By the subtyping rules for wildcards it must be the case that W >> U.
A must be a supertype of the generic type G.
However, since A is not a parameterized type, it cannot depend upon U in any way.
No meaningful constraint on U can be derived from A.
If A is an invocation of a generic type declaration H, where H is either G or superclass or superinterface of G, then:
It must be the case that W << U, by the subtyping rules for wildcard types.
This concludes the process of determining constraints on the type parameters of a method.
Note that this process does not impose any constraints on the type parameters based on their declared bounds.
Once type arguments are inferred, they will be tested against the declared bounds of the type parameters as part of applicability testing.
Note also that type inference does not affect soundness in any way.
If the types inferred are nonsensical, the invocation will yield a type error.
The type inference algorithm should be viewed as a heuristic, designed to perform well in practice.
If it fails to infer the desired result, explicit type paramneters may be used instead.
Then all remaining constraints involving Tj are rewritten such that Tj is replaced with U.
There are necessarily no further equality constraints involving Tj, and processing continues with the next type parameter, if any.
Otherwise, if U is Tj, then this constraint carries no information and may be discarded.
Then, for each remaining type variable Tj, the constraints Tj :> U are considered.
Uk), computed as follows: For a type U, we write ST(U) for the set of supertypes of U, and define the erased supertype set of U:
Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates.
The next step will be to recover type arguments for the inferred types themselves.
This is done by means of the least containing invocation (lci) operation defined below.
The first line defines lci() on a set, such as Inv(List), as an operation on a list of the elements of the set.
The next line defines the operation on such lists, as a pairwise reduction on the elements of the list.
The third line is the definition of lci() on pairs of parameterized types, which in turn relies on the notion of least containing type argument (lcta)
This will be our candidate invocation of G in the bound we infer for Tj.
The possibility of an infinite type stems from the recursive calls to lub()
Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.
If any of the method's type arguments were not inferred from the types of the actual arguments, they are now inferred as follows.
If the method result occurs in a context where it will be subject to assignment.
Otherwise, the unresolved type arguments are inferred by invoking the procedure described in this section under the assumption that the method result was assigned to a variable of type Object.
Otherwise, let C be the innermost enclosing class of which the compile-time declaration is a member.
If the invocation is not directly enclosed by C or an inner class of C, then a compile-time error occurs.
If the method invocation has, before the left parenthesis, a MethodName of the form TypeName.
Identifier, or if the method invocation, before the left parenthesis, has the form TypeName.
The reason is that a method invocation of this form does not specify a reference to an object that can serve as this within the instance method.
If the method invocation has, before the left parenthesis, the form super.
If the method invocation occurs in a static context, a compile-time error occurs.
If the method invocation has, before the left parenthesis, the form ClassName.
If the method invocation occurs in a static context, a compile-time error occurs.
If the invocation is not directly enclosed by C or an inner class of C, then a compile-time error occurs.
The reason is that such a method invocation produces no value and so must be used only in a situation where a value is not needed.
If the compile-time declaration for the method invocation is not a signature polymorphic method, then the types of its parameters are the types of its formal parameters, and the result type is its chosen result type.
Otherwise, if the compile-time declaration for the method invocation is a signature polymorphic method, then:
The types of its parameters are the static types of the actual argument expressions.
Otherwise, the return type is the method's declared return type, Object.
The following compile-time information is then associated with the method invocation for use at run time:
Otherwise, if the compile-time declaration is in an interface, then the invocation mode is interface.
If the compile-time declaration for the method invocation is not void, then the type of the method invocation expression is the result type specified in the compile-time declaration.
Third, the accessibility of the method to be invoked is checked.
Fourth, the actual code for the method to be executed is located.
Fifth, a new activation frame is created, synchronization is performed if necessary, and control is transferred to the method code.
If the MethodName is a qualified name of the form TypeName.
If the second production for MethodInvocation, which includes a Primary, is involved, then there are two subcases: • If the invocation mode is static, then there is no target reference.
Otherwise, the expression Primary is evaluated and the result is used as the target reference.
In either case, if the evaluation of the Primary expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
If the third production for MethodInvocation, which includes the keyword super, is involved, then the target reference is the value of this.
When a target reference is computed and then discarded because the invocation mode is static, the reference is not examined to see whether it is null:
Therefore, a reference to the string "one" is remembered as the target reference before the local variable s is changed to refer to the string "two"
As a result, the startsWith method is invoked for target object "one" with argument "two", so the result of the invocation is false, as the string "one" does not start with "two"
It follows that the test program does not print "oops"
The argument expressions (possibly rewritten as described above) are now evaluated to yield argument values.
Each argument value corresponds to exactly one of the method's n formal parameters.
The argument expressions, if any, are evaluated in order, from left to right.
If the evaluation of any argument expression completes abruptly, then no part of any.
If the invocation mode is interface, then the implementation must also check that the target reference type still implements the specified interface.
The implementation must also ensure, during linkage, that the type T and the method m are accessible: • For the type T:
If m is protected, then m is accessible if and only if either T is in the same package as C, or C is T or a subclass of T.
If m has default (package) access, then m is accessible if and only if T is in the same package as C.
If m is private, then m is accessible if and only if C is T, or C encloses T, or T encloses C, or T and C are both enclosed by a third class.
This is true even if the target object is an array instance.
Note that for invocation mode interface, R necessarily implements T; for invocation mode virtual, R is necessarily either T or a subclass of T.)
The dynamic method lookup uses the following procedure to search class S, and then the superclasses of class S, as necessary, for method m.
Let X be the compile-time type of the target reference of the method invocation.
If class S contains a declaration for a non-abstract method named m with the same descriptor (same number of parameters, the same parameter types,
If the invocation mode is virtual, and the declaration in S overrides.
Otherwise, if S has a superclass, this same lookup procedure is performed recursively using the direct superclass of S in place of S; the method to be invoked is the result of the recursive invocation of this lookup procedure.
The above procedure (if it terminates without error) will find a non-abstract, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled.
However, if this is not the case, then various errors may occur.
We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.
Here, the subclass ColoredPoint extends the clear abstraction defined by its superclass Point.
It does so by overriding the clear method with its own method, which invokes the clear method of its superclass, using the form super.clear()
This method is then invoked whenever the target object for an invocation of clear is a ColoredPoint.
Even the method move in Point invokes the clear method of class ColoredPoint when the class of this is ColoredPoint, as shown by the output of this test program:
Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to clear in the body of Point.move (which is really syntactic shorthand for this.clear) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by this) rather than a method chosen "early" (at compile time, based only on the type of this)
This provides the programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.
An overridden instance method of a superclass may be accessed by using the keyword super to access the members of the immediate superclass, bypassing any overriding declaration in the class that contains the method invocation.
A cast does not change the class of an object; it only checks that the class is compatible with the specified type.
A method m in some class S has been identified as the one to be invoked.
Now a new activation frame is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and.
If there is not sufficient memory available to create such an activation frame, a StackOverflowError is thrown.
The erasure of the actual method being invoked, D.id(), differs in its signature from that of the compile-time method declaration, C.id()
The former takes an argument of type String while the latter takes an argument of type Object.
The invocation fails with a ClassCastException before the body of the method is executed.
In the above example, the following bridge method would be created in class D:
This is the method that would actually be invoked by the Java Virtual Machine in response to the call c.id(new Object()) shown above, and it will execute the cast and fail, as required.
An array access expression refers to a variable that is a component of an array.
An array access expression contains two subexpressions, the array reference expression (before the left bracket) and the index expression (within the brackets)
The result of an array access expression is a variable of type T, namely the variable within the array selected by the value of the index expression.
This resulting variable, which is a component of the array, is never considered final, even if the array reference expression denoted a final variable.
An array access expression is evaluated using the following procedure: • First, the array reference expression is evaluated.
If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
Otherwise, the value of the array reference expression indeed refers to an array.
Otherwise, the result of the array access is the variable of type T, within the array, selected by the value of the index expression.
In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated.
This array referenced by the original value of a is then subscripted by a value that is element 3 of another array (possibly the same array) that was referenced by b and is now also referenced by a.
If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated.
A postfix expression followed by a ++ operator is a postfix increment expression.
A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a postfix increment operator.
A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a postfix decrement operator.
A variable that is declared final cannot be incremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a prefix increment operator.
A variable that is declared final cannot be decremented because when an access of such a final variable is used as an expression, the result is a value, not a variable.
Thus, it cannot be used as the operand of a prefix decrement operator.
At run time, the value of the unary plus expression is the promoted value of the operand.
The type of the operand expression of the unary ! operator must be boolean or Boolean, or a compile-time error occurs.
The type of the unary logical complement expression is boolean.
A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is boolean; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type.
The parentheses and the type they contain are sometimes called the cast operator.
Otherwise, at run time, the operand value is converted (if necessary) by casting conversion to the type specified by the cast operator.
A ClassCastException is thrown if a cast is found at run time to be impermissible.
The type of a multiplicative expression is the promoted type of its operands.
If the promoted type is int or long, then integer arithmetic is performed.
If the promoted type is float or double, then floating-point arithmetic is performed.
The binary * operator performs multiplication, producing the product of its operands.
Multiplication is a commutative operation if the operand expressions have no side effects.
Integer multiplication is associative when the operands are all of the same type.
If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format.
As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.
The result of a floating-point multiplication is determined by the rules of IEEE 754 arithmetic:
If the result is not NaN, the sign of the result is positive if both operands have.
Multiplication of an infinity by a zero results in NaN.
Multiplication of an infinity by a finite value results in a signed infinity.
In the remaining cases, where neither an infinity nor NaN is involved, the exact.
If the type of the multiplication expression is float, then the float value set must be chosen.
If the type of the multiplication expression is double, then the double value set must be chosen.
Next, a value must be chosen from the chosen value set to represent the product.
If the magnitude of the product is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator * never throws a run-time exception.
If the result is not NaN, the sign of the result is positive if both operands have.
Division of an infinity by an infinity results in NaN.
Division of an infinity by a finite value results in a signed infinity.
Division of a finite value by an infinity results in a signed zero.
Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero.
Division of a nonzero finite value by a zero results in a signed infinity.
If the type of the division expression is float, then the float value set must be chosen.
If the type of the division expression is double, then the double value set must be chosen.
Next, a value must be chosen from the chosen value set to represent the quotient.
If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator / never throws a runtime exception.
The binary % operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor.
The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator.
Instead, the Java programming language defines % on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function fmod.
If the result is not NaN, the sign of the result equals the sign of the dividend.
If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
If the dividend is finite and the divisor is an infinity, the result equals the.
If the dividend is a zero and the divisor is finite, the result equals the dividend.
In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved,
Evaluation of a floating-point remainder operator % never throws a run-time exception, even if the right-hand operand is zero.
The operators + and - are called the additive operators.
The additive operators have the same precedence and are syntactically leftassociative (they group left-to-right)
If the type of either operand of a + operator is String, then the operation is string concatenation.
An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object.
To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.
For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.
The + operator is syntactically left-associative, no matter whether it is determined by type analysis to represent string concatenation or numeric addition.
In some cases care is required to get the desired result.
Popular values for stuff include "pop" and "beer"; the most popular value for n is 100
Here is the output that results from running the program:
In the code, note the careful conditional generation of the singular "bottle" when appropriate rather than the plural "bottles"; note also how the string concatenation operator was used to break the long constant string:
The type of an additive expression on numeric operands is the promoted type of its operands.
If this promoted type is int or long, then integer arithmetic is performed.
If this promoted type is float or double, then floating-point arithmetic is performed.
Addition is a commutative operation if the operand expressions have no side effects.
Integer addition is associative when the operands are all of the same type.
If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format.
If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.
The sum of two infinities of opposite sign is NaN.
The sum of two infinities of the same sign is the infinity of that sign.
The sum of an infinity and a finite value is equal to the infinite operand.
The sum of two zeros of opposite sign is positive zero.
The sum of two zeros of the same sign is the zero of that sign.
The sum of a zero and a nonzero finite value is equal to the nonzero operand.
The sum of two nonzero finite values of the same magnitude and opposite sign.
If the type of the addition expression is float, then the float value set must be chosen.
If the type of the addition expression is double, then the double value set must be chosen.
Next, a value must be chosen from the chosen value set to represent the sum.
If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign.
The binary - operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend.
For both integer and floating-point subtraction, it is always the case that a-b produces the same result as a+(-b)
Note that, for integer values, subtraction from zero is the same as negation.
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.
The left-hand operand of a shift operator is the value to be shifted; the right-hand operand specifies the shift distance.
The value of n >>> s is n right-shifted s bit positions with zero-extension, where:
If n is positive, then the result is the same as that of n >> s.
If the promoted type of the operands is int or long, then signed integer comparison is performed.
If the promoted type is float or double, then floating-point comparison is performed.
Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.
All values other than NaN are ordered, with negative infinity less than all finite.
Note, however, that the methods Math.min and Math.max treat negative zero as being strictly smaller than positive zero.
The value produced by the <= operator is true if the value of the left-hand.
The value produced by the > operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.
The value produced by the >= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.
The cast (Point)e is incorrect because no instance of Element or any of its possible subclasses (none are shown here) could possibly be an instance of any subclass of Point.
The instanceof expression is incorrect for exactly the same reason.
If, on the other hand, the class Point were a subclass of Element (an admittedly strange notion in this example):
The cast (Point)e would never raise an exception because it would not be executed if the value of e could not correctly be cast to type Point.
The result type of a==b is always boolean, and c must therefore be of type boolean or a compile-time error occurs.
Thus, a==b==c does not test to see whether a, b, and c are all equal.
The equality operators are commutative if the operand expressions have no side effects.
The equality operators are analogous to the relational operators except for their lower precedence.
If the promoted type of the operands is int or long, then an integer equality test is performed.
If the promoted type is float or double, then a floating-point equality test is performed.
Comparison is carried out accurately on floating-point values, no matter what value sets their representing values were drawn from.
Indeed, the test x!=x is true if and only if the value of x is NaN.
The methods Float.isNaN and Double.isNaN may also be used to test whether a value is NaN.
Otherwise, two distinct floating-point values are considered unequal by the equality operators.
In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
The value produced by the != operator is true if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is false.
If the operands of an equality operator are both of type boolean, or if one operand is of type boolean and the other is of type Boolean, then the operation is boolean equality.
Each of these operators is syntactically left-associative (each groups left-to-right)
Each operator is commutative if the operand expressions have no side effects.
The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type boolean.
For ^, the result value is true if the operand values are different; otherwise, the result is false.
For |, the result value is false if both operand values are false; otherwise, the result is true.
The conditional-and operator is fully associative with respect to both side effects and result value.
Each operand of the conditional-and operator must be of type boolean or Boolean, or a compile-time error occurs.
The conditional-or operator is fully associative with respect to both side effects and result value.
Each operand of the conditional-or operator must be of type boolean or Boolean, or a compile-time error occurs.
The conditional operator ? : uses the boolean value of one expression to decide which of two other expressions should be evaluated.
The first expression must be of type boolean or Boolean, or a compile-time error occurs.
It is a compile-time error for either the second or the third operand expression to be an invocation of a void method.
The type of a conditional expression is determined as follows: • If the second and third operands have the same type (which may be the null type),
If one of the second and third operands is of primitive type T, and the type of the.
If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
At run time, the first operand expression of the conditional expression is evaluated first.
The resulting boolean value is then used to choose either the second or the third operand expression: • If the value of the first operand is true, then the second operand expression is.
If the value of the first operand is false, then the third operand expression is chosen.
There are 12 assignment operators; all are syntactically right-associative (they group right-to-left)
The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs.
Otherwise, the variable denoted by e.f is assigned the value of the right hand operand as computed above.
First, the array reference subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the righthand operand are not evaluated and no assignment occurs.
Otherwise, the index subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the value of the array reference subexpression indeed refers to an array.
If the value of the index subexpression is less than zero, or greater.
Otherwise, the reference value of the right-hand operand is stored into the selected array component.
Otherwise, three steps are required: • First, the left-hand operand is evaluated to produce a variable.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
The most interesting case of the lot is thirteenth from the end:
The code is typecorrect at compile time: the assignment has a left-hand side of type Object[] and a righthand side of type Object.
At run time, the first actual argument to method testFour is a reference to an instance of "array of Thread" and the third actual argument is a reference to an instance of class StringBuffer.
At run time, the expression is evaluated in one of two ways.
If the left-hand operand expression is not an array access expression, then: • First, the left-hand operand is evaluated to produce a variable.
Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator.
If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the righthand operand are not evaluated and no assignment occurs.
Otherwise, the index subexpression of the left-hand operand array access expression is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
Otherwise, the value of the array reference subexpression indeed refers to an array.
Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression.
The value of this component is saved and then the right-hand operand is evaluated.
If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.
The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator.
If T is a reference type, then it must be String.
Because class String is a final class, S must also be String.
Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily +=)
If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
Otherwise, the String result of the binary operation is stored into the array component.
The most interesting cases of the lot are eleventh and twelfth from the end:
They are the cases where a right-hand side that throws an exception actually gets to throw the exception; moreover, they are the only such cases in the lot.
An identical analysis applies to the case that uses a[0]
Unlike C and C++, the Java programming language has no comma operator.
A compile-time constant expression is an expression denoting a value of primitive type or a String that does not complete abruptly and is composed using only the following:
A Java compiler recognizes that k is definitely assigned before its access (as an argument of a method invocation) in the code:
Similarly, a Java compiler will recognize that in the code:
A Java compiler must produce a compile-time error for the code:
As another example, a Java compiler will accept the code:
Here, when true and when false refer to the value of the expression.
For example, the local variable k is definitely assigned a value after evaluation of the expression:
The phrase "V is definitely assigned after X" (where V is a local variable and X is a statement or expression) means "V is definitely assigned after X if X completes normally"
If X completes abruptly, the assignment need not have occurred, and the rules stated here take this into account.
A peculiar consequence of this definition is that "V is definitely assigned after break;" is always true! Because a break statement never completes normally, it is vacuously true that V has been assigned a value if the break statement completes normally.
The statement "V is definitely unassigned after X" (where V is a variable and X is a statement or expression) means "V is definitely unassigned after X if X completes normally"
An even more peculiar consequence of this definition is that "V is definitely unassigned after break;" is always true! Because a break statement never completes normally, it is vacuously true that V has not been assigned a value if the break statement completes normally.
For that matter, it is also vacuously true that the moon is made of green cheese if the break statement completes normally.)
In all, there are four possibilities for a variable V after a statement or expression has been executed: • V is definitely assigned and is not definitely unassigned.
The flow analysis rules prove that an assignment to V has occurred.) • V is definitely unassigned and is not definitely assigned.
The flow analysis rules prove that an assignment to V has not occurred.) • V is not definitely assigned and is not definitely unassigned.
The rules cannot prove whether or not an assignment to V has occurred.) • V is definitely assigned and is definitely unassigned.
It is impossible for the statement or expression to complete normally.) To shorten the rules, the customary abbreviation "iff" is used to mean "if and only if"
Throughout the rest of this chapter, we will, unless explicitly stated otherwise, write V to represent a local variable or a blank final field (for rules of definite assignment) or a blank final variable (for rules of definite unassignment)
Likewise, we will use a, b, c, and e to represent expressions, and S and T to represent statements.
We will use the phrase "a is V" to mean that a is either the simple name of the variable V, or V's simple name qualified by this (ignoring parentheses)
We will use the phrase "a is not V" to mean the negation of "a is V"
A revised rule would be: "V is definitely unassigned before e iff it is definitely unassigned before the while statement and definitely unassigned after S"
However, when we formulate the rule for S, we find: "V is definitely unassigned before S iff it is definitely unassigned after e when true"
In effect, V is definitely unassigned before the loop condition e only if it is unassigned after the loop as a whole!
We break this vicious circle using a hypothetical analysis of the loop condition and body.
For example, if we assume that V is definitely unassigned before e (regardless of whether V.
Assuming V is definitely unassigned before e, V is definitely unassigned after e.
Variations on the above analysis are used to define well founded definite unassignment rules for all loop statements in the Java programming language.
Note that if a is V and V is not definitely assigned before a compound assignment such as a &= b, then a compile-time error will necessarily occur.
The first rule for definite assignment stated above includes the disjunct "a is V" even for compound assignment expressions, not just simple assignments, so that V will be considered to have been definitely assigned at.
Including the disjunct "a is V" does not affect the binary decision as to whether a program is acceptable or will result in a compile-time error, but it affects how many different points in the code may be regarded as erroneous, and so in practice it can improve the quality of error reporting.
A similar remark applies to the inclusion of the conjunct "a is not V" in the first rule for definite unassignment stated above.
This case applies to literals, names, this (both qualified and unqualified), unqualified class instance creation expressions with no arguments, initialized array creation expressions whose initializers contain no expressions, unqualified superclass field access expressions, named method invocations with no arguments, and unqualified superclass method invocations with no arguments.
For any immediate subexpression y of an expression x, V is [un]assigned before y iff one of the following situations is true:
A local variable V is definitely unassigned (and moreover is not definitely assigned) before the block that is the body of the constructor, method, instance initializer or static initializer that declares V.
Let C be a class declared within the scope of V.
Then V is definitely assigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C iff V is definitely assigned before the declaration of C.
Note that there are no rules that would allow us to conclude that V is definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C.
We can informally conclude that V is not definitely unassigned before the block that is the body of any constructor, method, instance initializer, or static initializer declared in C, but there is no need for such a rule to be stated explicitly.
We say that V is definitely unassigned everywhere in a block B iff: • V is definitely unassigned before B.
The assignment occurs in dead code, and V is vacuously definitely assigned.
In this case, the assignment will not actually take place, and we can assume that V is not being assigned by the assignment expression.
In this case the current assignment will cause a compile-time error.
So, we can conclude that if the conditions are met by a program that causes no compile time error, then any assignments to V in B will not actually take place at run time.
Either there is a default label in the switch block or V is [un]assigned after the switch expression.
Either a condition expression is not present or V is [un]assigned after the condition expression when false.
Assuming V is definitely unassigned before the condition part of the for statement, V is definitely unassigned after the contained statement.
Assuming V is definitely unassigned before the contained statement, V is definitely unassigned before every continue statement for which the for statement is the continue target.
Because a break, continue, return, or throw statement never completes normally, it vacuously satisfies this notion.
If a try statement does have a finally block, then these rules also apply: • V is definitely assigned after the try statement iff at least one of the following.
Let C be a class, and let V be a blank final member field of C.
Then: • V is definitely assigned (and moreover, not definitely unassigned) before the.
Let C be a class declared within the scope of V.
Then: • V is definitely assigned before a member type declaration of C iff V is definitely.
Let C be a class, and let V be a blank static final member field of C, declared in C.
Let C be a class, and let V be a blank static final member field of C, declared in a superclass of C.
Let C be a class declared within the scope of V.
Note that there are no rules that would allow us to conclude that V is definitely unassigned before an instance variable initializer.
We can informally conclude that V is not definitely unassigned before any instance variable initializer of C, but there is no need for such a rule to be stated explicitly.
Let C be a class, and let V be a blank final non-static member field of C, declared in C.
Let C be a class, and let V be a blank final member field of C, declared in a superclass of C.
These threads independently execute code that operates on values and objects residing in a shared main memory.
Threads may be supported by having many hardware processors, by time-slicing a single hardware processor, or by timeslicing many hardware processors.
The only way for a user to create a thread is to create an object of this class; each thread is associated with such an object.
A thread will start when the start() method is invoked on the corresponding Thread object.
The behavior of threads, particularly when not correctly synchronized, can be confusing and counterintuitive.
This chapter describes the semantics of multithreaded programs; it includes rules for which values may be seen by a read of shared memory that is updated by multiple threads.
As the specification is similar to the memory models for different hardware architectures, these semantics are known as the Java programming language memory model.
When no confusion can arise, we will simply refer to these rules as "the memory model"
These semantics do not prescribe how a multithreaded program should be executed.
Rather, they describe the behaviors that multithreaded programs are allowed to exhibit.
Any execution strategy that generates only allowed behaviors is an acceptable execution strategy.
The Java programming language provides multiple mechanisms for communicating between threads.
The most basic of these methods is synchronization, which is implemented using monitors.
Each object in Java is associated with a monitor, which a thread can lock or unlock.
Only one thread at a time may hold a lock on a monitor.
Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor.
A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation.
Every object, in addition to having an associated monitor, has an associated wait set.
When an object is first created, its wait set is empty.
Elementary actions that add threads to and remove threads from wait sets are atomic.
Wait sets are manipulated solely through the methods Object.wait, Object.notify, and Object.notifyAll.
Wait set manipulations can also be affected by the interruption status of a thread, and by the Thread class's methods dealing with interruption.
Additionally, the Thread class's methods for sleeping and joining other threads have properties derived from those of wait and notification actions.
Wait actions occur upon invocation of wait(), or the timed forms wait(long millisecs) and wait(long millisecs, int nanosecs)
A call of wait(long millisecs) with a parameter of zero, or a call of wait(long millisecs, int nanosecs) with two zero parameters, is equivalent to an invocation of wait()
Let thread t be the thread executing the wait method on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
Thread t is added to the wait set of object m, and performs n unlock actions on m.
Thread t does not execute any further instructions until it has been removed from m's wait set.
The thread may be removed from the wait set due to any one of the following actions, and will resume sometime afterward:
A notify action being performed on m in which t is selected for removal from the wait set.
Implementations are permitted, although not encouraged, to perform "spurious wake-ups", that is, to remove threads from wait sets and thus enable resumption without explicit instructions to do so.
Notice that this provision necessitates the Java coding practice of using wait only within loops that terminate only when some logical condition that the thread is waiting for holds.
Each thread must determine an order over the events that could cause it to be removed from a wait set.
That order does not have to be consistent with other orderings, but the thread must behave as though those events occurred in that order.
For example, if a thread t is in the wait set for m, and then both an interrupt of t and a notification of m occur, there must be an order over these events.
If the notification is deemed to have occurred first, then t will eventually return normally from wait with an interrupt still pending.
If thread t was removed from m's wait set in step 2 due to an interrupt,
Notification actions occur upon invocation of methods notify and notifyAll.
Let thread t be the thread executing either of these methods on object m, and let n be the number of lock actions by t on m that have not been matched by unlock actions.
This is the case where thread t does not already possess the lock for target m.
If n is greater than zero and this is a notify action, then if m's wait set is not.
There is no guarantee about which thread in the wait set is selected.
This removal from the wait set enables u's resumption in a wait action.
Notice, however, that u's lock actions upon resumption cannot succeed until some time after t fully unlocks the monitor for m.
If n is greater than zero and this is a notifyAll action, then all threads are removed from m's wait set, and thus resume.
Notice, however, that only one of them at a time will lock the monitor required during the resumption of wait.
Let t be the thread invoking u.interrupt, for some thread u, where t and u may be the same.
This action causes u's interruption status to be set to true.
Additionally, if there exists some object m whose wait set contains u, then u is removed from m's wait set.
The above specifications allow us to determine several properties having to do with the interaction of waits, notification, and interruption.
If a thread is both notified and interrupted while waiting, it may either: • return normally from wait, while still having a pending interrupt (in other words,
The thread may not reset its interrupt status and return normally from the call to wait.
Assume that a set s of threads is in the wait set of an object m, and another thread performs a notify on m.
Thread.sleep causes the currently executing thread to sleep (temporarily cease execution) for the specified duration, subject to the precision and accuracy of system timers and schedulers.
The thread does not lose ownership of any monitors, and resumption of execution will depend on scheduling and the availability of processors on which to execute the thread.
It is important to note that neither Thread.sleep nor Thread.yield have any synchronization semantics.
In particular, the compiler does not have to flush writes cached in registers out to shared memory before a call to Thread.sleep or Thread.yield, nor does the compiler have to reload values cached in registers after a call to Thread.sleep or Thread.yield.
For example, in the following (broken) code fragment, assume that this.done is a nonvolatile boolean field:
The compiler is free to read the field this.done just once, and reuse the cached value in each execution of the loop.
This would mean that the loop would never terminate, even if another thread changed the value of this.done.
A memory model describes, given a program and an execution trace of that program, whether the execution trace is a legal execution of the program.
The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.
An implementation is free to produce any code it likes, as long as all resulting executions of a program produce a result that can be predicted by the memory model.
This provides a great deal of freedom for the implementor to perform a myriad of code transformations, including the reordering of actions and removal of unnecessary synchronization.
The semantics of the Java programming language allow compilers and microprocessors to perform optimizations that can interact with incorrectly synchronized code in ways that can produce behaviors that seem paradoxical.
Here are some examples of how incorrectly synchronized programs may exhibit surprising behaviors.
Consider, for example, the example program traces shown in Table 17.1
However, compilers are allowed to reorder the instructions in either thread, when this does not affect the execution of that thread in isolation.
Surprising results caused by statement reordering - valid compiler transformation.
However, it should be noted that this code is improperly synchronized:
A Just-In-Time compiler in a Java Virtual Machine implementation may rearrange code, or the processor.
In addition, the memory hierarchy of the architecture on which a Java Virtual Machine implementation is run may make it appear as if code is being reordered.
In this chapter, we shall refer to anything that can reorder code as a compiler.
Another example of surprising results can be seen in Table 17.3
This program is also incorrectly synchronized; it writes to shared memory without enforcing any ordering between those writes.
The memory model determines what values can be read at every point in the program.
The actions of each thread in isolation must behave as governed by the semantics of that thread, with the exception that the values seen by each read are determined by the memory model.
When we refer to this, we say that the program obeys intra-thread semantics.
Intra-thread semantics are the semantics for singlethreaded programs, and allow the complete prediction of the behavior of a thread based on the values seen by read actions within the thread.
To determine if the actions of thread t in an execution are legal, we simply evaluate the implementation of thread t as it would be performed in a single-threaded context, as defined in the rest of this specification.
The memory model specified herein is not fundamentally based in the object-oriented nature of the Java programming language.
For conciseness and simplicity in our examples, we often exhibit code fragments without class or method definitions, or explicit dereferencing.
Most examples consist of two or more threads containing statements with access to local variables, shared global variables, or instance fields of an object.
Memory that can be shared between threads is called shared memory or heap memory.
An inter-thread action is an action performed by one thread that can be detected or directly influenced by another thread.
There are several kinds of inter-thread action that a program may perform:
An external action is an action that may be observable outside of an execution, and has a result based on an environment external to the execution.
Thread divergence actions are introduced to model how a thread may cause all other threads to stall and fail to make progress.
We do not need to concern ourselves with intra-thread actions (e.g., adding two local variables and storing the result in a third local variable)
As previously mentioned, all threads need to obey the correct intra-thread semantics for Java programs.
We will usually refere to inter-thread actions more succinctly as simply actions.
For lock actions, v is the monitor being locked; for unlock actions, v is the monitor being unlocked.
If the action is a (volatile or non-volatile) read, v is the variable being read.
If the action is a (volatile or non-volatile) write, v is the variable being written.
Among all the inter-thread actions performed by each thread t, the program order of t is a total order that reflects the order in which these actions would be performed according to the intra-thread semantics of t.
A set of actions is sequentially consistent if all actions occur in a total order (the execution order) that is consistent with program order, and furthermore, each read r of a variable v sees the value written by the write w to v such that: • w comes before r in the execution order, and • there is no other write w' such that w comes before w' and w' comes before r in.
Sequential consistency is a very strong guarantee that is made about visibility and ordering in an execution of a program.
Within a sequentially consistent execution, there is a total order over all individual actions (such as reads and writes) which is consistent with the order of the program, and each individual action is atomic and is immediately visible to every thread.
If a program has no data races, then all executions of the program will appear to be sequentially consistent.
Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.
If we were to use sequential consistency as our memory model, many of the compiler and processor optimizations that we have discussed would be illegal.
An unlock action on monitor m synchronizes-with all subsequent lock actions on m (where "subsequent" is defined according to the synchronization order)
An action that starts a thread synchronizes-with the first action in the thread it starts.
The write of the default value (zero, false, or null) to each variable synchronizes-with the first action in every thread.
Although it may seem a little strange to write a default value to a variable before the object containing the variable is allocated, conceptually every object is created at the start of the program with its default initialized values.
The source of a synchronizes-with edge is called a release, and the destination is called an acquire.
If one action happens-before another, then the first is visible to and ordered before the second.
If we have two actions x and y, we write hb(x, y) to indicate that x happens-before y.
If x and y are actions of the same thread and x comes before y in program order,
There is a happens-before edge from the end of a constructor of an object to the.
For example, the write of a default value to every field of an object constructed by a thread need not happen before the beginning of that thread, as long as no read ever observes that fact.
A call to start() on a thread happens-before any actions in the started thread.
All actions in a thread happen-before any other thread successfully returns from.
The default initialization of any object happens-before any other actions (other.
Therefore, a data race cannot cause incorrect behavior such as returning the wrong length for an array.
Programmers do not need to reason about reorderings to determine that their code contains data races.
Therefore they do not need to reason about reorderings when determining whether their code is correctly synchronized.
Once the determination that the code is correctly synchronized is made, the programmer does not need to worry that reorderings will affect his or her code.
A program must be correctly synchronized to avoid the kinds of counterintuitive behaviors that can be observed when code is reordered.
The use of correct synchronization does not ensure that the overall behavior of a program is correct.
However, its use does allow a programmer to reason about the possible behaviors of a program in a simple way; the behavior of a correctly synchronized program is much less dependent on possible reorderings.
Without correct synchronization, very strange, confusing and counterintuitive behaviors are possible.
We say that a read r of a variable v is allowed to observe a write w to v if, in the happens-before partial order of the execution trace: • r is not ordered before w (i.e., it is not the case that hb(r, w)), and • there is no intervening write w' to v (i.e.
Informally, a read r is allowed to see the result of a write w if there is no happensbefore ordering to prevent that read.
A set of actions A is happens-before consistent if for all reads r in A, where W(r) is the write action seen by r, it is not the case that either hb(r, W(r)) or that there exists a write w in A such that w.v = r.v and hb(W(r), w) and hb(w, r)
In a happens-before consistent set of actions, each read sees a write that it is allowed to see by the happens-before ordering.
Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread.
In this execution, the reads see writes that occur later in the execution order.
This may seem counterintuitive, but is allowed by happens-before consistency.
Allowing reads to see later writes can sometimes produce unacceptable behaviors.
Each read sees a write to the same variable in the execution.
All reads and writes of volatile variables are volatile actions.
For all reads r in A, we have W(r) in A and W(r).v = r.v.
The variable r.v is volatile if and only if r is a volatile read, and the variable w.v is volatile if and only if w is a volatile write.
The happens-before order is given by the transitive closure of synchronizeswith edges and program order.
It must be a valid partial order: reflexive, transitive and antisymmetric.
For each thread t, the actions performed by t in A are the same as would be generated by that thread in program-order in isolation, with each write w writing the value V(w), given that each read r sees the value V(W(r))
Values seen by each read are determined by the memory model.
The program order given must reflect the program order in which the actions would be performed according to the intra-thread semantics of P.
For all volatile reads r in A, it is not the case that either so(r, W(r)) or that there exists a write w in A such that w.v = r.v and so(W(r), w) and so(w, r)
We use f|d to denote the function given by restricting the domain of f to d.
We use p|d to represent the restriction of the partial order p to the elements in d.
For all x,y in d, p(x,y) if and only if p|d(x,y)
If either x or y are not in d, then it is not the case that p|d(x,y)
If all of the actions in A can be committed, then the execution satisfies the causality requirements of the Java programming language memory model.
To demonstrate that this is reasonable, for each Ci we need to demonstrate an execution E containing Ci that meets certain conditions.
All actions in Ci must share the same relative happensbefore order and synchronization order in both Ei and E.
Formally: The values written by the writes in Ci must be the same in both Ei and E.
Only the reads in Ci-1 need to see the same writes in Ei as in E.
If y is in Ci, x is an external action and hbi(x, y), then x in Ci.
Happens-before consistency is a necessary, but not sufficient, set of constraints.
Merely enforcing happens-before consistency would allow for unacceptable behaviors - those that violate the requirements we have established for programs.
For example, happens-before consistency allows values to appear "out of thin air"
This can be seen by a detailed examination of the trace in Table 17.6
This may seem surprising, since it does not perform any synchronization actions.
Remember, however, that a program is correctly synchronized if, when it is executed in a sequentially consistent manner, there are no data races.
If this code is executed in a sequentially consistent way, each action will occur in program order, and neither of the writes will occur.
Since no writes occur, there can be no data races: the program is correctly synchronized.
Since this program is correctly synchronized, the only behaviors we can allow are sequentially consistent behaviors.
However, there is an execution of this program that is happens-before consistent, but not sequentially consistent:
This result is happens-before consistent: there is no happens-before relationship that prevents it from occurring.
However, it is clearly not acceptable: there is no sequentially consistent execution that would result in this behavior.
The fact that we allow a read to see a write that comes later in the execution order can sometimes thus result in unacceptable behaviors.
Although allowing reads to see writes that come later in the execution order is sometimes undesirable, it is also sometimes necessary.
As we saw above, the trace in Table 17.5 requires some reads to see writes that occur later in the execution order.
Since the reads come first in each thread, the very first action in the execution order must be a read.
If that read cannot see a write that occurs later, then it cannot see any value other than the initial value for the variable it reads.
We refer to the issue of when reads can see future writes as causality, because of issues that arise in cases like the one found in Table 17.6
In that case, the reads cause the writes to occur, and the writes cause the reads to occur.
Our memory model therefore needs a consistent way of determining which reads can see writes early.
Examples such as the one found in Table 17.6 demonstrate that the specification must be careful when stating whether a read can see a write that occurs later in the execution (bearing in mind that if a read sees a write that occurs later in the execution, it represents the fact that the write is actually performed early)
The memory model takes as input a given execution, and a program, and determines whether that execution is a legal execution of the program.
It does this by gradually building a set of "committed" actions that reflect which actions were executed by the program.
Usually, the next action to be committed will reflect the next action that can be performed by a sequentially consistent execution.
However, to reflect reads that need to see later writes, we allow some actions to be committed earlier than other actions that happen-before them.
Obviously, some actions may be committed early and some may not.
If, for example, one of the writes in Table 17.6 were committed before the read of that variable, the read could see the write, and the "out-of-thin-air" result could occur.
Informally, we allow an action to be committed early if we know that the action can occur without assuming some data race occurs.
In Table 17.6, we cannot perform either write early, because the writes cannot occur unless the reads see the result of a data race.
For programs that always terminate in some bounded finite period of time, their behavior can be understood (informally) simply in terms of their allowable executions.
For programs that can fail to terminate in a bounded amount of time, more subtle issues arise.
The observable behavior of a program is defined by the finite sets of external actions that the program may perform.
A program that, for example, simply prints "Hello" forever is described by a set of behaviors that for any non-negative integer i, includes the behavior of printing "Hello" i times.
If behavior is described by a set of external actions including a hang action, it indicates a behavior where after the external actions are observed, the program can run for an unbounded amount of time without performing any additional external actions or terminating.
Programs can hang if all threads are blocked or if the program can perform an unbounded number of actions without performing any external actions.
A thread can be blocked in a variety of circumstances, such as when it is attempting to acquire a lock or perform an external action (such as a read) that depends on external data.
An execution may result in a thread being blocked indefinitely and the execution's not terminating.
In such cases, the actions generated by the blocked thread must consist of all actions generated by that thread up to and including the action that caused the thread to be blocked, and no actions that would be generated by the thread after that action.
To reason about observable behaviors, we need to talk about sets of observable actions.
If O is a set of observable actions for an execution E, then set O must be a subset of E's actions, A, and must contain only a finite number of actions, even if A contains an infinite number of actions.
Furthermore, if an action y is in O, and either hb(x, y) or so(x, y), then x is in O.
Note that a set of observable actions are not restricted to external actions.
Rather, only external actions that are in a set of observable actions are deemed to be observable external actions.
A behavior B is an allowable behavior of a program P if and only if B is a finite set of external actions and either: • There exists an execution E of P, and a set O of observable actions for E, and B.
Note that a behavior B does not describe the order in which the external actions in B are observed, but other (internal) constraints on how the external actions are generated and performed may impose such constraints.
Fields declared final are initialized once, but never changed under normal circumstances.
The detailed semantics of final fields are somewhat different from those of normal fields.
In particular, compilers have a great deal of freedom to move reads of final fields across synchronization barriers and calls to arbitrary or unknown methods.
Correspondingly, compilers are allowed to keep the value of a final field cached in a register and not reload it from memory in situations where a non-final field would have to be reloaded.
A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads.
This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code.
An object is considered to be completely initialized when its constructor finishes.
A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields.
The usage model for final fields is a simple one: Set the final fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished.
If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's final fields.
It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are.
The program below illustrates how final fields compare to normal fields.
The class FinalFieldExample has a final int field x and a non-final int field y.
One thread might execute the method writer and another might execute the method reader.
Because the writer method writes f after the object's constructor finishes, the reader method will be guaranteed to see the properly initialized value for f.x: it will read the value 3
However, f.y is not final; the reader method is therefore not guaranteed to see the value 4 for it.
One thread (which we shall refer to as thread 1) executes:
String objects are intended to be immutable and string operations do not perform synchronization.
While the String implementation does not have any data races, other code could have data races involving the use of String objects, and the memory model makes weak guarantees for programs that have data races.
A later operation on the String object might see the correct offset of 4, so that the String object is perceived as being "/usr"
Many security features of the Java programming language depend upon String objects being perceived as truly immutable, even if malicious code is using data races to pass String references between threads.
Let o be an object, and c be a constructor for o in which a final field f is written.
A freeze action on final field f of o takes place when c exits, either normally or abruptly.
Note that if one constructor invokes another constructor, and the invoked constructor sets a final field, the freeze for the final field takes place at the end of the invoked constructor.
For each execution, the behavior of reads is influenced by two additional partial orders, the dereference chain dereferences() and the memory chain mc(), which are considered to be part of the execution (and thus, fixed for any particular execution)
These partial orders must satisfy the following constraints (which need not have a unique solution): • Dereference Chain: If an action a is a read or write of a field or element of an.
For reads of final fields, the only writes that are deemed to come before the read of the final field are the ones derived through the final field semantics.
A read of a final field of an object within the thread that constructs that object is ordered with respect to the initialization of that field within the constructor by the.
If the read occurs after the field is set in the constructor, it sees the value the final field is assigned, otherwise it sees the default value.
Another problem is that the specification allows aggressive optimization of final fields.
Within a thread, it is permissible to reorder reads of a final field with those modifications of a final field that do not take place in the constructor.
In the d method, the compiler is allowed to reorder the reads of x and the call to g freely.
An implementation may provide a way to execute a block of code in a final-fieldsafe context.
If an object is constructed within a final-field-safe context, the reads of a final field of that object will not be reordered with modifications of that final field that occur within that final-field-safe context.
If a thread has seen an incorrectly published reference to an object that allows the thread to see the default value of a final field, and then, within a final-field-safe context, reads a properly published reference to the object, it will be guaranteed to see the correct value of the final field.
In the formalism, code executed within a final-field-safe context is treated as a separate thread (for the purposes of final field semantics only)
In an implementation, a compiler should not move an access to a final field into or out of a final-field-safe context (although it can be moved around the execution of such a context, so long as the object is not constructed within that context)
One place where use of a final-field-safe context would be appropriate is in an executor or thread pool.
By executing each Runnable in a separate final-field-safe context, the executor could guarantee that incorrect access by one Runnable to a object o will not remove final field guarantees for other Runnables handled by the same executor.
Normally, a field that is final and static may not be modified.
However, System.in, System.out, and System.err are static final fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut, and System.setErr.
We refer to these fields as being writeprotected to distinguish them from ordinary final fields.
The compiler needs to treat these fields differently from other final fields.
For example, a read of an ordinary final field is "immune" to synchronization: the barrier involved in a lock or volatile read does not have to affect what value is read from a final field.
Since the value of write-protected fields may be seen to change, synchronization events should have an effect on them.
Therefore, the semantics dictate that these fields be treated as normal fields that cannot be changed by user code, unless that user code is in the System class.
One consideration for implementations of the Java Virtual Machine is that every field and array element is considered distinct; updates to one field or element must not interact with reads or updates of any other field or element.
In particular, two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need synchronization to ensure sequential consistency.
Some processors do not provide the ability to write to a single byte.
It would be illegal to implement byte array updates on such a processor by simply reading an entire word, updating the appropriate byte, and then writing the entire word back to memory.
This problem is sometimes known as word tearing, and on processors that cannot easily update a single byte in isolation some other approach will be required.
The following program is a test case to detect word tearing:
This makes the point that bytes must not be overwritten by writes to adjacent bytes.
Writes and reads of volatile long and double values are always atomic.
Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible.
Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.
Modifier: Annotation public protected private static abstract final native synchronized transient volatile strictfp.
Oracle hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide, limited license (without the right to sublicense), under Oracle's applicable intellectual property rights to view, download, use and reproduce the Specification only for the purpose of internal evaluation.
This includes (i) developing applications intended to run on an implementation of the Specification, provided that such applications do not themselves implement any portion(s) of the Specification, and (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Specification.
In addition, the foregoing license is expressly conditioned on your not acting outside its scope.
Also, no right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder.
Java, and Java-related logos, marks and names are trademarks or registered trademarks of Oracle in the U.S.
You need not include limitations (a)-(c) from the previous paragraph or any other particular "pass through" requirements in any license You grant concerning the use of your Independent Implementation or products derived from it.
However, except with respect to Independent Implementations (and products derived from them) that satisfy limitations (a)-(c) from the previous paragraph, You may neither: (a) grant or otherwise pass through to your licensees any licenses under Oracle's applicable intellectual property rights; nor (b) authorize your licensees to make any claims concerning their implementation's compliance with the Specification in question.
With respect to any patent claims covered by the license granted under subparagraph 2 above that would be infringed by all technically feasible implementations of the Specification, such license is conditioned upon your offering on fair, reasonable and non-discriminatory terms, to any party seeking it from You, a perpetual, non-exclusive, non-transferable, worldwide license under Your patent rights which are or would be infringed by all technically feasible implementations of the Specification to develop, distribute and use a Compliant Implementation.
With respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2, whether or not their infringement can be avoided in a technically feasible manner when implementing the Specification, such license shall terminate with respect to such claims if You initiate a claim against Oracle that it has, in the course of performing its responsibilities as the Specification Lead, induced any other entity to infringe Your patent rights.
Also with respect to any patent claims owned by Oracle and covered by the license granted under subparagraph 2 above, where the infringement of such claims can be avoided in a technically feasible manner when implementing the Specification such license, with respect to such claims, shall terminate if You initiate a claim against Oracle that its making, having made, using, offering to sell, selling or importing a Compliant Implementation infringes Your patent rights.
For the purposes of this Agreement: "Independent Implementation" shall mean an implementation of the Specification that neither derives from any.
This Agreement will terminate immediately without notice from Oracle if you breach the Agreement or act outside the scope of the licenses granted above.
This document does not represent any commitment to release or implement any portion of the Specification in any product.
In addition, the Specification could include technical inaccuracies or typographical errors.
You will indemnify, hold harmless, and defend Oracle and its licensors from any claims arising or resulting from: (i) your use of the Specification; (ii) the use or distribution of your Java application, applet and/or implementation; and/or (iii)
Government: If this Specification is being acquired by or on behalf of the U.S.
Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R.
If you provide Oracle with any comments or suggestions concerning the Specification ("Feedback"), you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose.
Any action related to this Agreement will be governed by California law and controlling U.S.
Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.
Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.
This Agreement is the parties' entire agreement relating to its subject matter.
It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement.
No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
