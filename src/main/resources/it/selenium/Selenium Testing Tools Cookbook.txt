Over 90 recipes to build, maintain, and improve test automation with Selenium WebDriver.
No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the information presented.
However, the information contained in this book is sold without warranty, either express or implied.
Neither the author, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals.
However, Packt Publishing cannot guarantee the accuracy of this information.
Unmesh has architected functional test automation projects using industry standard, in-house and custom test automation frameworks along with leading commercial and open source test automation tools.
Presently he is working as Test Architect with a multinational company in Pune, India.
We would be remiss if we did not thank all of the people who helped make this book a reality.
This includes the wonderful people at Packt Publishing, in particular Usha Iyer – Acquisition Editor, who proposed that I write this book.
I'm grateful for all the help I got from the editorial staff at Packt Publishing in reviewing this book, particularly, Azharuddin Sheikh, Sonali Tharwani, Mayur Hule, Veronica Fernandes, Prashant Salvi, and especially Yashodhan Dere – Project Coordinator, who coordinated the progress of this book, by ensuring that I stayed on track.
This book has benefited a lot from a great team of technical reviewers.
I'd like to thank each of them for volunteering their time reviewing drafts of this book and providing valuable feedback – Dave Hunt who is Selenium contributor, for his insight into some key areas; Vamsi Chandra for making sure the code samples for all chapters work by executing each and every sample; and Tarun Kumar for his early feedback.
I would like to thank my wife Punam, for supporting me while I was writing this book and making sure I did things on time, and my friends and colleagues at work for supporting me for all these years.
Finally, a big thanks to Selenium Development and User Community for building this wonderful tool.
He has been involved in to improving the quality of the product by testing with various tools, using Automation and Manual, works of Software Development Life Cycle (SDLC), Software Testing Life Cycle (STLC), and Agile (scrum) testing methodology to deliver high standard/complex products to the client.
Unmesh Gundecha for this wonderful and exciting opportunity to reveal my thoughts in my own platform and to explore a bit beyond technologies.
I am also thankful to the team for supporting and communicating fully to achieve this success.
Dave Hunt lives in Kent, UK with his wife and young son.
He has always had a passion for turning mundane tasks into one-click solutions, and when he discovered Selenium back in 2005, his career in software testing and automation development was sealed.
He works from home for Mozilla Corporation, where he assists teams in creating automated tests for their projects – ranging from Mozilla's web properties to the Firefox web browser and Thunderbird e-mail client.
Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book library.
Here, you can access, read and search across Packt's entire library of books.
Why Subscribe? f Fully searchable across every book published by Packt.
I would like to dedicate this book to my parents, who have raised me to be the person I am today and to my loving wife Punam for giving me the support and.
Preface This book will help you in learning advanced techniques for testing web applications with Selenium WebDriver API and related tools.
In this book you will learn how to test web applications effectively and efficiently with Selenium WebDriver on desktops, mobile web browsers, and in a distributed environment.
This book covers design patterns such as data-driven testing, page objects, and object map for designing a highly maintainable and reliable test automation framework.
This book also covers techniques to extend Selenium for your specific needs.
There are more than 90 recipes that you can use to build or extend your existing test automation framework.
What this book covers Chapter 1, Locating Elements, introduces you to locator techniques supported by Selenium WebDriver, for locating elements on pages in your web applications.
Selenium WebDriver provides one of the advanced techniques for locating elements on web pages with multiple locator strategies such as XPath, CSS, and DOM.
We can also implement custom locator strategies for locating elements.
This chapter will also help you in getting started with Selenium WebDriver locator API.
We will explore API and investigate advanced user interactions for performing complex mouse and keyboard operations, working with various types of UI elements used in web applications.
Chapter 3, Controlling the Test Flow, demonstrates how to use Selenium WebDriver API for building a reliable test automation framework.
The tenants of good test automation are robustness, reliability, recovery from unexpected events, and unhandled execution.
This chapter covers recipes on handling synchronization with implicit and explicit waits, multiple windows, and pop-ups and alerts that are displayed during the test execution.
Chapter 4, Data-driven Testing, introduces the data-driven testing approach, a widely used methodology in test automation.
Selenium WebDriver does not have built-in features to support data driven testing.
However we can extend Selenium WebDriver API to support data-driven testing.
This chapter covers recipes to support data-driven testing using JUnit/Apache POI and JDBC technologies.
This chapter provides tips on building testing frameworks using Page Object model.
Chapter 6, Extending Selenium, demonstrates how to extend Selenium WebDriver API and add features for building a scalable test automation framework.
This chapter covers some of the important recipes in extending Selenium WebDriver for various practical scenarios such as supporting custom UI controls, capturing images of elements, and performing image-based verifications.
Chapter 7, Testing on Mobile Browsers, introduces you to testing mobile web applications with the Apple iOS and Android platform.
This chapter covers recipes for configuring and using Selenium WebDriver to test a mobile application on the iPhone and Android based devices/simulators.
Client-side performance can be measured in different ways with Selenium WebDriver.
We can use tools such as dynaTrace and HttpWatch, along with Selenium WebDriver to collect, measure, and monitor client-side performance of web applications.
This chapter explains how to test video and canvas elements and web storage API of HTML5
We will also set up Maven and ANT along with Selenium WebDriver and Jenkins for running tests in Continuous Integration.
This chapter also covers recipes for using tools such as AutoIt and Sikuli for testing non-web UI.
Distributed Testing with Selenium Grid, demonstrates how to set up a distributed test environment with Selenium Grid.
We will add nodes with various browser and operating system combinations.
We will run tests in parallel using TestNG, which helps in reducing the time of test execution and increases the test coverage.
What you need for this book You will need the following software to follow the recipes in this book:
Who this book is for This book is for software quality assurance/testing professionals, test managers, or software developers with prior experience in using Selenium and Java for testing web-based applications.
This book also provides examples for C#, Python, and Ruby users.
Conventions In this book, you will find a number of styles of text that distinguish between different kinds of information.
Here are some examples of these styles, and an explanation of their meaning.
Code words in text are shown as follows: "The WebElement class also supports find methods to find child elements."
When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:
Words that you see on the screen, in menus or dialog boxes for example, appear in the text like this: "Right-click to open the pop-up menu and select the Inspect element option."
Warnings or important notes appear in a box like this.
Let us know what you think about this book—what you liked or may have disliked.
Reader feedback is important for us to develop titles that you really get the most out of.
Customer support Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.packtpub.com.
If you purchased this book elsewhere, you can visit http://www.packtpub.com/support and register to have the files e-mailed directly to you.
Errata Although we have taken every care to ensure the accuracy of our content, mistakes do happen.
By doing so, you can save other readers from frustration and help us improve subsequent versions of this book.
If you find any errata, please report them by visiting http://www.packtpub.com/support, selecting your book, clicking on the errata submission form link, and entering the details of your errata.
Once your errata are verified, your submission will be accepted and the errata will be uploaded to our website, or added to any list of existing errata, under the Errata section of that title.
Piracy Piracy of copyright material on the Internet is an ongoing problem across all media.
At Packt, we take the protection of our copyright and licenses very seriously.
If you come across any illegal copies of our works, in any form, on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy.
We appreciate your help in protecting our authors, and our ability to bring you valuable content.
Introduction The success of automated GUI (Graphical User Interface) tests depends on identifying and locating GUI elements from the application under test and then performing operations and verifications on these elements to achieve the test flow.
This boils down to the test tool's ability to recognize various GUI elements effectively.
Selenium WebDriver provides one of the advanced techniques for locating elements on web pages.
Selenium's feature-rich API provides multiple locator strategies such as Name, ID, CSS selectors, XPath, and so on.
We can also implement custom locator strategies for locating elements.
In this chapter, we will explore more on how to use locator strategies by starting with ID, Name, and Class.
In any web development project, it is always a good practice to assign attributes such as Name, IDs, or Class to GUI elements.
This makes the application more testable and conforms to accessibility standards.
For such scenarios, we have to use advanced locator strategies such as CSS selector and XPath.
While CSS selector and XPath are popular among Selenium users, CSS selector is highly recommended over XPath due to its simplicity, speed, and performance.
Before we start exploring locators, we need to analyze the page and elements to understand how these are structured in the application, what properties or attributes are defined for the elements, how JavaScript or AJAX calls are made from the application, and so on.
Browsers render visual elements of the application for end users by hiding the HTML code and other resources.
When we want to automate interaction with the application using Selenium WebDriver, we need to look carefully at the background code written to render pages and elements in browsers.
We need to identify information such as attribute values and elements structure for locating elements and perform user actions using Selenium WebDriver API.
Here is an example of a BMI Calculator application page and HTML code written to render this page in a browser as displayed in the following screenshots:
You can view the code written for a page by right-clicking in the browser window and selecting the View Page Source option from the pop-up menu.
This will display the HTML code of the page in a separate window.
We need special tools that can display this information in a structured and easy to understand format.
In this recipe we will briefly explore few of these tools before we dive into locators.
In the following sections we will explore some of the tools which are in-built in browsers and plugins to analyze elements and page structure.
These tools will help us to understand how elements and their attributes are defined on a page, DOM structure, JavaScript calls, CSS Style attributes, and so on.
The newer versions of Firefox provide in-built ways to analyze the page and elements; however, we will use the Firebug add-in which has more powerful features.
To inspect an element from the page, move the mouse over the desired element and right-click to open the pop-up menu.
Select the Inspect Element with Firebug option as shown in the following screenshot:
This will display Firebug with HTML code in a tree format as shown in the following screenshot:
For this, select the desired element in the tree and right-click and select Copy XPath or Copy CSS Path option from the pop-up menu as shown in the following screenshot:
This will paste the possible XPath or CSS selector value on the clipboard.
Google Chrome provides an in-built feature to analyze pages and elements.
You can move the mouse over a desired element on the page and right-click to open the pop-up menu, then select Inspect element option.
This will open Developer Tools in the browser, which displays information similar to that of Firebug, as shown in the following screenshot:
Chrome Developer Tools also provide a feature where you can get XPath for an element by right-clicking on the desired element in the tree and selecting the Copy XPath option from the pop-up menu.
Similar to Google Chrome, Microsoft Internet Explorer also provides an in-built feature to analyze pages and elements.
The Developer Tools section will be displayed as shown in the following screenshot:
To inspect an element, click on the pointer ( ) icon and hover over the desired element on the page.
Developer Tools will highlight the element with a blue outline and display the HTML code in a tree as shown in the following screenshot:
These tools will help you in finding the locator details for elements.
These tools parse the code for a page and display the information in a hierarchal tree.
These tools also provide information on how styles have been applied, page resources, page DOM (Document Object Model), JavaScript code, and so on.
Some of these tools also provide the ability to run JavaScript code for debugging and testing.
In the following recipes we will explore various types of locators that are supported by Selenium WebDriver and these tools will help you in finding and deciding various locator strategies or methods provided by Selenium WebDriver API.
Locating elements in Selenium WebDriver is done by using the findElement() and findElements() methods provided by WebDriver and WebElement class.
The findElement() method returns a WebElement object based on a specified search criteria or throws up an exception if it does not find any element matching the search criteria.
The findElements() method returns a list of WebElements matching the search criteria.
If no elements are found, it returns an empty list.
Find methods take a locator or query object as an instance of By class as an argument.
Selenium WebDriver provides By class to support various locator strategies.
The following table lists various locator strategies supported by Selenium WebDriver:
In this recipe, we will use the findElement() method to locate elements.
Locating elements using id, name, or class attributes is the preferred way to find elements.
Let's try using these methods to locate elements as described in the following sections.
Using the id attribute is the most preferable way to locate elements on a page.
The W3C standard recommends that developers provide an id attribute for elements that are unique to each element.
Having a unique id attribute provides a very explicit and reliable way to locate elements on the page.
While processing the DOM, browsers use id as the preferred way to identify the elements and this provides the fastest locator strategy.
Let's now look at how to use id attributes for locating elements on a login form.
Downloading the example code You can download the example code files for all Packt books you have purchased from your account at http://www.packtpub.com.
If you purchased this book elsewhere, you can visit http://www.packtpub.
To locate the User Name and Password fields, we can use the id attribute in the following way:
Locating elements with the id attribute is the most preferred locator strategy, but you might find situations where you cannot use the id attribute due to the following reasons:
In this example, the login form elements use the name attribute instead of the id attribute:
We can use the name attribute to locate elements in the following way:
Unlike id, the name attribute may not be unique on a page.
You might find multiple elements with similar name attributes and in such a case, the first element on the page with the specified value will be selected, which may not be the element you are looking for.
When building a testable application, you should recommend that the developers add the id attribute for key elements as well as other unique attributes to enable the easy location of elements.
Apart from using the id and name attributes, you can also use the class attribute to locate elements.
The class attribute is provided to apply CSS to an element.
In this example, the login form elements use the class attribute instead of the id attribute:
We can use the class attribute to locate elements in the following way:
Selenium WebDriver API provides the findElement() method to locate the elements that are required in a test from the page under test.
When locating an element matching specified criteria, it looks through the DOM (Document Object Model) for matching elements and returns the first matching element to the test.
The WebElement class also supports find methods that find child elements.
For example, imagine that there are some duplicate elements on a page.
You can also a use a shortcut method in the following way:
See also f The Locating elements using findElements method recipe.
Selenium WebDriver provides the findElements() method, which enables the acquisition of a list of elements matching the specified search criteria.
This method is useful when we want to work with a group of similar elements.
For example, we can get all the links displayed on a page or get rows from a table, and so on.
In this recipe, we will get all the links and print their targets by using the findElements() method.
Let's create a test which will get all the links from a page and verify the count of links and print target for each link as follows:
The findElements() method returns all the elements matching with the locator specified as a list of WebElements.
In Java, we can use the List class to create an instance of list of WebElements.
The size() method of the List class will tell us how many elements are there in the list.
We can iterate using this list in the following way, getting a link and printing its target value:
See also f The Locating an element using the findElement method recipe.
Locating links Selenium WebDriver provides multiple ways to locate links.
You can locate a link either by its text or by partial text.
Locating links with partial text comes in handy when links have dynamic text.
In this recipe, we will see how to use these methods to locate the links on page.
Let's create a sample test to see how locating links work in Selenium WebDriver with the following options.
Selenium WebDriver's By class provides the linkText() method to locate links using the text displayed for the link.
In the following example, we will locate the GMail link:
Selenium WebDriver's By class also provides a method to locate links using partial text.
This method is useful where developers create links with dynamic text.
In this example, a link is provided to open inbox.
This link also displays the number of new e-mails which may change dynamically.
Here we can use the partialLinkText() method to locate the link using a fixed or known portion of the link text, in this case it would be inbox.
The linkText and partialLinkText locator methods query the driver for all the links that meet the specified text and returns the matching link(s)
You can also locate links using id, name, or class attributes if developers have provided these attributes.
Locating elements based on text can cause issues while testing applications in multiple locales.
Using parameterized text locator value could work in such applications.
See also f The Locating an element using the findElement method recipe.
Locating elements by tag name Selenium WebDriver's By class provides a tagName() method to find elements by their HTML tag name.
This comes in handy when you want to locate elements using their tag name.
For example, locating all <tr> tags in a table and so on.
In this recipe, we will briefly see how to use the tagName locator method.
Let's assume you have a single button element on a page.
You can locate this button by using its tag in the following way:
Take another example where we want to count how many rows are displayed in <table>
The tagName locator method queries the DOM and returns a list of matching elements for the specified tag name.
This method may not be reliable while locating individual elements and the page might have multiple instances of these elements.
See also f The Locating elements using findElements method recipe.
Locating elements using CSS selectors Cascading Style Sheets (CSS) is a style sheet language used for describing the presentation semantics (the look and formatting) of a document written in a markup language such as HTML or XML.
Major browsers implement CSS parsing engines for formatting or styling the pages using CSS syntax.
For more information on CSS and CSS selectors, visit http://en.wikipedia.
In CSS, pattern-matching rules determine which style should be applied to elements in the DOM.
These patterns, called selectors, may range from simple element names to rich contextual patterns.
If all conditions in the pattern are true for a certain element, the selector matches the element and the browser applies the defined style in CSS syntax.
Selenium WebDriver uses same principles of CSS selectors to locate elements in DOM.
This is a much faster and more reliable way to locate the elements when compared with XPaths.
In this recipe, we will explore some basic CSS selectors and then later on we will dive into advanced CSS selectors.
Let's explore some basic CSS selectors that can be used in Selenium WebDriver.
Selenium WebDriver's By class provides the cssSelector() method for locating elements using CSS selectors.
Here is an example where the Username Input field is located using the absolute path.
While providing absolute path, a space is given between the elements.
You can also use the previous selector in the following way by describing the direct parent to child relationships with > separator:
However, this strategy has limitations as it depends on the structure or hierarchy of the elements on a page.
If this changes, the locator will fail to find the element.
With relative path we can locate an element directly, irrespective of its location in the DOM.
For example, we can locate the Username Input field in the following way, assuming it is the first <input> element in the DOM:
The following CSS selectors use the Class and ID attributes to locate the elements using relative paths.
This is same as the className() and id() locator methods.
However, there is another strategy where we can use any other attribute of the element that is not covered in the By class.
While finding elements using the CSS selector, we can use the Class attribute to locate an element.
This can be done by specifying the type of HTML tag, then adding a dot followed by the value of the class attribute in the following way:
This will find the Login button's <input> tag whose Class attribute is login.
There is also a shortcut where you can put a.
However, this will return all the elements with class as login and the test may not return the correct element.
We can locate the element using the IDs assigned to elements.
This can be done by specifying the type of HTML tag, then entering a hash followed by the value of the Class attribute, as shown:
This will return the username <input> element using its id attribute.
There is also a shortcut where you can enter # and a class attribute value and ignore the HTML tag.
However, this will return all the elements with the id set as username and the test may not return the correct element.
Apart from the class and id attributes, CSS selectors also enable the location of elements using other attributes of the element.
In the following example, the Name attribute is used to locate an <input> element.
Using the name attribute to locate an element is similar to the name() locator method of the By class.
In the following example, the <img> element is located by using its alt attribute.
You might come across situations where one attribute may not be sufficient to locate an element and you need to combine additional attributes for a precise match.
In the following example, multiple attributes are used to locate the Login button's <input> element:
This strategy is a bit different from the earlier strategy where we want to locate elements based on only the specific attribute defined for them but not attribute values.
For example, we want to lookup all the <img> elements which have alt attribute specified.
A Boolean not()pseudo-class can also be used to locate elements not matching the specified criteria.
For example, to locate all the <img> elements that do not have the alt attribute, the following method can be used:
Performing partial match on attribute values CSS selector provides a way to locate elements matching partial attribute values.
This is very useful for testing applications where attribute values are dynamically assigned and change every time a page is requested.
For example, ASP.NET applications exhibit this kind of behavior, where IDs are generated dynamically.
The following table explains the use of CSS partial match syntax:
For example, if the ID of an element is ctrl_12, this will locate and return elements with ctrl at the beginning of the ID.
The majority of browsers support CSS parsing for applying styles to these elements.
Selenium WebDriver uses CSS parsing engine to locate the elements on a page.
This is also a more reliable and fast method when compared with XPath locators.
Using CSS selector, the test can locate elements in multiple ways using Class, ID, attribute values, and text contents as described in this recipe.
See also f The Locating elements using advanced CSS selectors recipe.
Locating elements using XPath XPath, the XML path language, is a query language for selecting nodes from an XML document.
All the major browsers support XPath as HTML pages are represented as XHTML documents in DOM.
The XPath language is based on a tree representation of the XML document and provides the ability to navigate around the tree, selecting nodes using a variety of criteria.
Selenium WebDriver supports XPath for locating elements using XPath expressions or queries.
Locating elements with XPath works very well with a lot of flexibility.
However, this is the least preferable locator strategy due its slow performance.
One of the important differences between XPath and CSS is, with XPath we can search elements backward or forward in the DOM hierarchy while CSS works only in a forward direction.
This means that with XPath we can locate a parent element using a child element.
In this recipe, we will explore some basic XPath queries to locate elements and then examine some advanced XPath queries.
Let's explore some basic XPath expressions that can be used in Selenium WebDriver.
Selenium WebDriver provides the xpath() method for locating elements using XPaths.
Similar to CSS absolute paths, XPath absolute paths refer to the very specific location of the element, considering its complete hierarchy in the DOM.
Here is an example where Username Input field is located using the absolute path.
While providing absolute path a space is given between the elements.
However, this strategy has limitations as it depends on the structure or hierarchy of the elements on a page.
If this changes, the locator will fail to get the element.
With relative path, we can locate an element directly irrespective of its location in the DOM.
For example, we can locate the Username Input field in the following way, assuming it is the first <input> element in the DOM:
In the previous example, the XPath query will return the first <input> element that it finds in the DOM.
There could be multiple elements matching the specified XPath query.
If the element is not the first element, we can also locate the element by using its index in DOM.
For example in our login form, we can locate the Password field which is the second <input> element on the page in the following way:
Similar to CSS, we can also locate elements using their attribute values in XPath.
In the following example, the Username field is located using the ID attribute:
Here is another example where the image is located using the alt attribute:
You might come across situations where one attribute may not be sufficient to locate an element and you need combined additional attributes for a precise match.
In the following example, multiple attributes are used to locate the <input> element for the Login button:
The same result can be achieved by using XPath and operator.
In the following example, either of the attributes is used to locate the elements using XPath or operator:
This strategy is a bit different from the earlier strategy where we want to locate elements based only on the specific attribute defined for them but not attribute values.
For example, we want to lookup all the <img> elements that have the alt attribute specified.
Similar to CSS selector, XPath also provides a way to locate elements matching partial attribute values using XPath functions.
This is very useful for testing applications where attributes values are dynamically assigned and change every time a page is requested.
For example, ASP.NET applications exhibit this kind of behavior where IDs are generated dynamically.
The following table explains the use of these XPath functions:
For example, if the ID of an element is ctrl_12, this will locate and return elements with ctrl at the beginning of the ID.
XPath matches the attribute for all the elements for a specified value and returns the element.
For example, in the following XPath query, 'userName' is specified.
XPath will check all the elements and their attributes to see if they have this value and return the matching element.
XPath axes help to locate elements based on the element's relationship with other elements in a document.
Here are some examples for some common XPath axes used to locate elements from a <table> element.
This can be applied to any other element structure from your application.
This will get the input element from the third column of the second row from the table.
This will get the second column from the second row immediately after the column that has Product 1 as the text value.
This will get the first column of third row from the table.
You can find more about XPath axis at http://www.w3schools.com/xpath/xpath_ axes.asp.
XPath is a powerful language for querying and processing DOM in browsers.
XPath is used to navigate through elements and attributes in a DOM.
XPath provides rules, function, and syntax to locate the elements.
The majority of browsers support XPath and Selenium WebDriver provides the ability to locate elements using the XPath language.
Using the xpath() method of the By class we can locate elements using XPath syntax.
XPath is little slower than the CSS selectors as XPath provides the ability to search elements bi-directionally.
You can search for the parent element if you know the child or you can locate a child element using its relationship with the parent and siblings.
Using XPath, a test can locate elements in multiple ways based on the structure of the document, attribute values, text contents and so on, as described in this recipe.
Locating elements using text While testing web applications, you will also encounter situations where developers don't assign any attributes to the elements and it becomes difficult to locate elements.
Using the CSS selectors or XPath, we can locate elements based on their text contents.
In this recipe, we will explore methods to locate elements using text values.
For locating elements by using their text contents, CSS selectors and XPath provide methods to find text within the elements.
If an element contains specific text, this will return the element back to the test.
For example, a test wants to locate the cell of a table using its contents in the following way:
It then checks all the <td> elements in DOM for the specified text.
The contains() pseudo-class may not work with browsers that don't natively support CSS selectors.
As an alternative for contains() pseudo-class, you can use the innerText attribute (does not work with Firefox) or textContent attribute (for Firefox) in the following ways:
You can also use jQuery selectors which support the contains() pseudo-class.
XPath provides the text() function which can be used to see if an element contains the specified text in the following way:
Here we are using the contains function along with the text() function.
The text() function returns the complete text from the element and the contains() function checks for the specific value that we have mentioned.
With XPath, elements can be located by exact text value in the following way:
This will locate the <td> element matching with exact text.
This approach comes in handy when elements don't have enough attributes or when no other strategies work when attempting to locate these elements.
For locating elements using their text, both CSS selector and XPath search through the DOM for elements that have the specified text value and return the matching element(s)
In this recipe, we will explore some advanced CSS selectors for locating elements.
In the Locating elements using CSS selectors recipe, we explored some basic CSS selectors.
Let's explore advanced CSS selectors such as adjacent sibling combinators and pseudoclasses as described in the following sections.
For example, to locate the Username Field in the login form, we can use the following selector.
Here, > is used denote the parent and child relationship.
Similarly the nth-child() method can be used in the following way:
Here, the second element in <form> is the Username field.
The following table shows some of the structural pseudo-classes used to locate child elements:
This will locate the last element under the form, that is, the Login button.
This will locate the second child element under the form, that is, the Username field.
With CSS selector, we can locate sibling elements using the + operator.
Here are few more adjacent sibling combinators for locating siblings:
Using the user action :focus pseudo-class, we can locate the element which has current input focus in the following way:
This will locate any element that currently has the input focus.
You can also locate elements using :hover and :active pseudo-classes.
Using UI state pseudo-classes, we can locate elements for various states such as control is enabled, disabled, and checked.
Pseudo-class Example Description :enabled input:enabled This will locate all the elements that are enabled.
Apart from the basic CSS selectors, you can also use various advanced CSS selector methods such as pseudo-classes or adjacent sibling combinators to locate the elements with Selenium WebDriver API.
Visit http://www.w3schools.com/cssref/css_selectors.asp for an exhaustive list of CSS selectors and their usage.
See also f The Locating elements using CSS selectors recipe.
Using jQuery selectors jQuery selectors is one of the important feature of the jQuery library.
These selectors use the familiar CSS Selector syntax to allow developers to quickly and easily identify page elements to operate upon with the jQuery library methods.
Similar to CSS selectors, these selectors allow us to locate and manipulate HTML elements as a single element or list of elements.
In this recipe, we will explore in brief how to use jQuery selectors with Selenium WebDriver.
Let's create a test which checks that specified checkboxes are selected when page is displayed, as follows:
Selenium WebDriver can be enhanced by jQuery selectors using the jQuery API.
However, we need to make sure that the page has jQuery API loaded before using these selectors.
The jQuery API provides the find() function through which we can search for elements.
We need to use the JavaScriptExecutor class to use jQuery's find() method.
In this example, we will locate all the selected checkboxes on a page by calling the find() method.
The find() method returns a WebElement or list of WebElements matching the selector criteria back to the test.
For more details and a list of available jQuery selectors, please visit http://api.jquery.com/category/selectors/
You can also use the CSS Selectors described in this chapter with the jQuery find()method.
For using jQuery selectors, the page under test should have jQuery library loaded.
If your application does not use jQuery, you can load the jQuery on the page by attaching jQuery library at runtime with the following utility methods:
This is done by adding a <script> element, which refers the Google CDN (Content Delivery Network) for jQuery library file, to the page.
You may change the version used in this example to the latest version of the jQuery library.
Locating table rows and cells While working with tables, we can locate the rows and cells effectively by using a set of the By class methods.
In this recipe, we will see how to locate rows and columns in table.
Let's create a simple test that will print data from a table, locating its rows and columns as follows:
In the sample test, the table can be located as a WebElement using its ID as follows:
To get all the rows from a table, the findElements() method is called on simpleTable and the tagName strategy is used to get all <tr> elements.
The test iterates through the row and columns to print the data in the following way:
This method comes in handy when you have a test that needs to verify data in a table.
There's more… We can also use CSS selectors or XPath for locating table rows and cells using index matching.
In the following example, CSS selector is used to locate the first cell of the second row in the table:
Similarly using XPath, it can be done in the following way:
See also f The Locating child elements in a table recipe.
Locating child elements in a table Working with simple tables is relatively easy.
However, you will come across complex tables where other than data, table cells have child elements for user interaction.
For example, in an e-commerce application when you open the shopping cart page, it looks a simple table but inside there are many complex elements.
Furthermore, these elements are dynamically created based on user actions and may have attribute values generated at runtime.
In this recipe, we will explore strategies to locate child elements within tables using CSS and XPath.
Here is sample table that lists users of a system and their details including what access rights are assigned to these users.
A test needs to select a given checkbox and see if the selected access is granted to the user.
If we look at the code for this table, each record or row has the following code:
The checkbox has dynamic IDs that we cannot correlate to a user.
However, we can deal with such issues by using CSS selectors or XPath.
In this example, we want to grant user Nash with admin access.
This can be done using CSS selectors in the following way:
Parent, child, and sibling in CSS or XPath axes become a great help in correlating users with roles and developing a generic locator strategy for this feature.
In simple terms, these strategies help to locate elements based on the element's relationship with other elements in a document.
Coming back to the problem, first we need to find a unique way to identify a user in the table.
For this, we will locate a cell which contains username.
We will locate this cell using its inner text in the following way:
Next, we need to find the cell which contains the child elements.
This is the second cell from the cell containing username.
In the next step, we need to locate the label with the correct option.
The next sibling of this label will be the checkbox we are looking for.
See also f The Locating elements using CSS selectors recipe.
Introduction Selenium WebDriver implements a very comprehensive API for working with web elements, Advanced User Interactions, executing JavaScript code, and support for various types of controls such as List, Dropdown, Radio Button, and Checkbox.
In this chapter, we will explore how these APIs can be used to build simple to complex test steps.
This chapter will also help in overcoming some common issues while building tests with Selenium WebDriver.
The chapter examples are created with Selenium WebDriver Java bindings.
The sample code for this chapter contains some of these recipes implemented with C#, Ruby, and Python.
Checking an element's text While testing a web application, we need to verify that elements are displaying correct values or text on the page.
Selenium WebDriver's WebElement API provides various ways to retrieve and verify text.
Sometimes, we need to retrieve text or value from an element into a variable at runtime and later use it at some other place in the test flow.
In this recipe, we will retrieve and verify text from an element by using the WebElement class' getText() method.
Here, we will create a test that locates an element and then retrieves text from the element in a string variable.
The WebElement class' getText() method returns value of the innerText attribute of the element.
If the element has child elements, the value of the innerText attribute of child elements will also be returned along with parent element.
We can also perform a partial match using Java String API methods such as contains(), startsWith(), and endsWith()
Checking an element's attribute values Developers configure various attributes of elements displayed on the web page during design or at runtime to control the behavior or style of elements when they are displayed in the browser.
For example, the <input> element can be set to read-only by setting the readonly attribute.
There will be tests that need to verify that element attributes are set correctly.
We can retrieve and verify an element's attribute by using the getAttribute() method of the WebElement class.
In this recipe, will check the attribute value of an element by using the getAttribute() method.
Create a test which locates an element and check its attribute value as follows:
By passing the name of the attribute to the getAttribute() method, it returns the value of the attribute back to the test.
In this example, we are checking that the align attribute of the <p> element is set to justify.
Checking an element's CSS values Various styles are applied on elements displayed in a web application, so they look neat and become more usable.
There may be tests that need to verify that correct styles have been applied to the elements.
This can be done using WebElement class's getCSSValue() method, which returns the value of a specified style attribute.
In this recipe, we will use the getCSSValue() function to check the style attribute defined for an element.
Let's create a test which reads the CSS width attribute and verifies the value.
By passing the name of CSS attribute to the getCSSValue() method, it returns the value of the CSS attribute.
See also f The Checking an element's attribute values recipe.
The Actions class implements the builder pattern to create a composite action containing a group of other actions.
In this recipe, we will use the Actions class to build a chain of events to select rows in a table.
Let's create a test to select the multiple rows from different positions in a table using the Ctrl key.
We can select multiple rows by selecting the first row, then holding the Ctrl key, and then selecting another row and releasing the Ctrl key.
We need to create an instance of the Actions class by passing the instance of driver class to the constructor in the following way:
We will build a chain of events that we need to perform for selecting the rows.
This will require performing a click() operation on the first row, then holding the Ctrl key using keyDown(), clicking on the end row, and then releasing the Ctrl key by calling keyUp()
The Actions class provides various methods to perform keyboard and mouse operations.
We can create a composite action that is ready to be performed by calling the build() method.
Finally the test will perform this composite action by calling the perform() method of the Actions class.
The Keys class will represent all non-textual keys on the keyboard, for example Control Key, Shift Key, Function Keys, and so on.
CONTROL) to press and hold the Ctrl key until next operation is completed.
Actions may not work properly for elements that are not visible or enabled.
Before using these events, make sure that elements are visible and enabled.
See also f The Performing double-click on an element recipe.
Performing double-click on an element There will be elements in a web application that need double-click events fired for performing some actions.
For example, double-clicking on a row of a table will launch a new window.
In this recipe, we will use the Actions class to perform double-click operations.
Let's create a test that locates an element for which a double-click event is implemented.
When we double-click on this element, it changes its color.
For performing double-click on an element, doubleClick() method of the Actions class is called.
For calling this method, we need to create an instance of Actions class as follows:
The doubleClick() method needs the element on which the double-click event will be fired.
We can call the doubleClick() method by passing the element as follows:
As seen in earlier recipes the Actions class supports advanced user interactions such as firing various mouse and keyboard events.
We can build simple or complex chains of events using this class.
In this recipe, we will use the Actions class to perform drag-and-drop operations.
Let's implement a test which will perform a drag-and-drop operation on a page using the Actions class.
For dragging an element on to another element and dropping it, we need to locate these elements and pass them to the dragAndDrop() method of the Actions class.
For calling this method, we need to create an instance of the Actions class in the following way:
We can call the dragAndDrop() method in the following way:
Executing JavaScript code Selenium WebDriver API provides the ability to execute JavaScript code with the browser window.
This is a very useful feature where tests need to interact with the page using JavaScript.
Using this API, client-side JavaScript code can also be tested using Selenium WebDriver.
Selenium WebDriver provides a JavascriptExecutor interface that can be used to execute arbitrary JavaScript code within the context of the browser.
In this recipe, we will explore how to use JavascriptExecutor for executing JavaScript code.
This book has various other recipes where JavascriptExecutor has been used to perform some advanced operations that are not yet supported by the Selenium WebDriver.
Let's create a test that will call JavaScript code to return title and count of links (that is a count of Anchor tags) from a page.
Returning a page title can also be done by calling the driver.
By casting the WebDriver instance to a JavascriptExecutor interface we can execute the JavaScript code in Selenium WebDriver.
In the following example, a single line of JavaScript code is executed to return the title of the page displayed in the driver.
The JavascriptExecutor interface provides the executeScript() method to which we need to pass the JavaScript code.
While returning values from the JavaScript code, we need to use the return keyword.
Based on the type of return value, we need to cast the executeScript() method.
For decimal values, Double can be used, for non-decimal numeric values Long can be used, and for Boolean values Boolean can be used.
If JavaScript code is returning an HTML element, then WebElement can be used.
If a list of objects is returned, then any of the values will work based on type of objects.
In the following example, we execute a multiline JavaScript code to retrieve count of links on a page:
Arguments can also be a passed to the JavaScript code being executed by using the executeScript() method.
In the following example, we want to set the value of an element.
A special arguments array will be used inside the JavaScript code.
Selenium WebDriver provides the TakesScreenshot interface for capturing a screenshot of a web page.
This helps in test runs, showing exactly happened when an exception or error occurred during execution, and so on.
We can also capture screenshots during verification of element state, values displayed, or state after an action is completed.
Capturing screenshots also helps in verification of layouts, field alignments, and so on where we compare screenshots taken during test execution with baseline images.
In this recipe, we will use the TakesScreenshot interface to capture a screenshot of the web page under test.
Let's create a test that will open our test application and take a screenshot of the page in PNG format.
The TakesScreenshot interface provides the getScreenshotAs() method to capture a screenshot of the page displayed in the driver instance.
In the following example, we specified OutputType.FILE as an argument to the getScreenshotAs() method, so that it will return the captured screenshot in a file:
The TakesScreenshot relies on the browser API for capturing the screenshots.
The OutputType class provides multiple ways in which to output the screenshot data using the getScreenshotAs() method.
In the previous example we saw a screenshot captured in a file.
Screenshots can also be captured in a Base64 string format or in raw bytes.
In the following example, a screenshot is captured as Base64 string:
For capturing screenshots with .NET bindings, a similar ITakesScreenshot interface is available.
In the following example, the ITakesScreenshot interface is used for capturing the screenshot using the Screenshot class:
While running tests with RemoteWebDriver or Grid it is not possible to take the screenshots, as the TakesScreenshot interface is not implemented in RemoteWebDriver.
However, we can use the Augmenter class which adds the TakesScreenshot interface to the remote driver instance.
In this recipe, we will use the Augmenter class to capture a screenshot from RemoteWebDriver.
The Augmenter class enhances the RemoteWebDriver by adding to it various interfaces including the TakesScreenshot interface.
Later we can use the TakesScreenshot interface from RemoteWebDriver to capture the screenshot.
Maximizing the browser window Selenium RC's windowMaximize() command was missing in Selenium WebDriver.
However starting from release 2.21, Selenium WebDriver supports maximizing the browser window.
In this short recipe, we will see how to maximize the browser window.
Getting ready Create a new test which will get an instance of WebDriver, navigate to a site and perform some basic actions and verifications.
To maximize a browser window, we need to call the maximize() method of the Window interface of the driver class.
Add the second line right below where you define an instance of FirefoxDriver.
The WebDriver class provides the window interface for setting up the browser window size, state, and so on.
When we call the maximize() method, the browser window will be maximized from normal or minimized state.
Automating dropdowns and lists Selenium WebDriver supports testing Dropdown and List controls using a special Select class instead of the WebElement class.
The Select class provides various methods and properties to interact with dropdowns and lists created with the HTML <select> element.
In this recipe, we will automate Dropdown and List control using Select class.
This test will perform some basic checks and then call various methods to select options in dropdown.
Create another test for a List control which has multi-selection enabled.
The test will perform some basic checks and then call methods to select multiple options in a list.
The test will verify the selection and then deselect the options by calling various deselection methods, namely by visible text, by value, and by index, respectively.
We can identify and locate these controls in a way that is similar to how we locate WebElements.
However, we will use the Select class instead of the WebElement class.
The HTML <select> element supports dropdown or list with multi-select options.
We can check if the control supports multi-select by calling the isMultiple() method of the Select class.
It returns true if the control supports multi-selection and false if it does not.
We can check number of options available in the dropdown or list by calling the getOptions() method of the Select class and querying the size of the returned collection of WebElements.
The Select class provides three different ways to select and deselect the options from dropdown and lists.
For example, here is code snippet for the <select> element:
We can also select an option by using its value attribute.
For example, the following option has value attribute "bl" and text label "Black":
To select this option by value, we need to call the selectByValue() method of the Select class.
Similarly you can deselect an already selected option by calling the deselectByValue() method.
This is another way by which we can select an option by using its index.
When options are displayed on the page, they are indexed in DOM in the order in which these are defined on a page.
We can call the selectByIndex() method of the Select class by specifying the index value.
Similarly you can deselect an already selected option by calling the deselectByIndex() method.
This method may cause problems where options are dynamic and their index changes frequently.
We can select/deselect multiple options from a dropdown or list by calling the select/deselect methods in a sequence.
For example, in the Color list that supports multiple selections, we can select options in the following way:
This will select Black, Red, and Silver options in the list.
See also f The Checking options in dropdowns and lists recipe.
Checking options in dropdowns and lists While testing the dropdowns and lists created with the <select> element, there will be a need to check that correct options are displayed for user selection.
These options may be static or populated from a database.
In this recipe we will see how options can be checked against the expected values.
Getting ready This recipe will need the test created from the earlier Automating dropdowns and lists recipe.
Let's modify the testDropdown() test method for checking the options.
Checking options in a dropdown or list needs a slightly different approach as there is no inbuilt method available in the Select class.
In this approach, we create a list of expected values that we want to check in the dropdown or list.
The text labels for all the options will be retrieved in a similar list.
For this, we will iterate through all the options using the getOptions() method of the Select class.
The getOptions() method returns all the options as instances of the WebElement class in a list.
Using the getText() method of the WebElement class, the text label of all the options will be added in the act_options array list.
For checking whether a specific option is available for selection, we can simply perform a check on the act_options array list in the following way:
In earlier recipes, we saw how to select options in the Dropdown and List controls as well as check what options are available for selection.
We also need to verify that the correct options are selected in these controls, either by default or by the user.
In this recipe, we will see how to check options which are selected in a dropdown or list.
Getting ready This recipe will need the test created from the earlier Automating dropdowns and lists recipe.
Let's modify the testDropdown() test method for checking the options.
For example, in the Make dropdown we selected the Honda option using the selectByVisible() method.
It returns all the selected options as a list of WebElement.
For checking whether a specific option is selected, we can simply perform a check on the act_sel_options array list in the following way:
See also f The Checking options in dropdowns and lists recipe.
We can select and deselect the radio buttons using the click() method of the WebElement class and check whether a radio button is selected or deselected using the isSelected() method.
In this recipe, we will see how to work with the Radio Button and Radio Group controls.
We can also get all the Radiobuttons from a Radio Group in a list.
We can locate a radio button similar to any other element as a WebElement class.
In this example, XPath is used to locate the radio button using its value attribute.
We can select or deselect a radio button by using the WebElement class's click() method.
When we want to select a radio button, we need to be careful that it's not already selected otherwise calling the click() method will deselect the radio button.
We can check if a radio button is already selected by calling the isSelected() method, which returns true if its selected and false if it's not selected.
Here the click() method will be called only when the radio button is not selected.
Instead of just locating a single radio button we can also work with a group of radio buttons by locating all the radio buttons from a group as list of WebElement using the findElements() method.
In the following example, radio button from fuel_type radio group is retrieved in a list of WebElement:
We can then iterate through this list to find a specific radio button and select or deselect a radio button.
We can select or deselect a checkbox using the click() method of the WebElement class and check whether a checkbox is selected or deselected using the isSelected() method.
In this recipe, we will see how to work with the Checkbox control.
We can locate a checkbox in a way similar to that in which we locate any other element on a page.
In this example, XPath is used to locate the checkbox by its value attribute.
We can select or deselect a checkbox by using the WebElement class's click() method.
When we want to select a checkbox, we need to be careful that it's not already selected otherwise calling the click() method will deselect the checkbox.
We can check if a checkbox is already selected by calling the isSelected() method which returns true if its selected and false if it's not selected.
Here the click() method will be called only when the checkbox is not selected.
Similarly, for deselecting the checkbox, we need to see if it is already selected.
Controlling Windows processes Selenium WebDriver Java bindings provide the WindowsUtils class with methods to interact with the Windows operating system.
During test runs, there might be a need to close open instances of browser windows or processes at the beginning of the test.
By using the WindowsUtils class, we can control the process and perform tasks, such as killing an open process, and so on.
In this recipe, we will use the WindowsUtils class to kill the open browser window.
Let's close an open instance of Firefox by using the WindowsUtils class in the setUp() method as follows:
We can close or kill any process running on the Windows OS by using the tryToKillByName() function of the WindowsUtils class.
We need to pass the name of process we wish to close.
The WindowsUtils class will search the specified process and kill any running instances.
If the process does not exist, an exception will be thrown up.
The WindowsUtils class provides various methods to interact with the registry on the Windows operating system.
While running tests on the Windows operating system and Internet Explorer, the test might need to read and modify IE settings or there may be a need to get some settings related to the web server or database from the registry in tests.
In this recipe, we will use WindowsUtil to read the exact name of the operating system on which the test is running.
We might need this information printed in our test logs.
The WindowsUtils class provides multiple methods by which to read Windows registry values based on different data types.
The WindowsUtils class interacts with the OS to get these values from registry keys.
In this example, we are reading the name of the OS, which is represented as a String.
The WindowsUtils class also provides methods to update existing Windows registry values or create new registry keys and values.
Similar to reading registry values, WindowsUtils class provides multiple methods to modify keys and values.
In this recipe, we will use the WindowsUtils class to create a new registry key with a string value.
Introduction While building test automation for a complex web application using Selenium WebDriver, we need to ensure that the test flow is maintained for reliable test automation.
When tests are run, the application may not always respond with the same speed.
For example, it might take a few seconds for a progress bar to reach 100 percent, a status message to appear, a button to become enabled, and a window or pop-up message to open.
You can handle these anticipated timing problems by synchronizing your test to ensure that Selenium WebDriver waits until your application is ready before performing a certain step.
There are several options that you can use to synchronize your test.
Selenium RC has various waitFor methods; however, being a pure web automation API, Selenium WebDriver provides very limited methods for synchronization.
In this chapter, you will see how to use the WebDriverWait class to implement synchronization in tests.
Pop ups and Alerts For building a great user interface, developers use features similar to desktop applications in the form of pop-up windows and alerts.
While testing complex workflows, tests need to flow from the browser window to a pop-up window in order to alert the user and perform operations as needed.
This chapter also explains common issues that pertain to the handling of pop-up windows and alerts, and how best we can use Selenium WebDriver API for this.
Synchronizing a test with an implicit wait The Selenium WebDriver provides an implicit wait for synchronizing tests.
When an implicit wait is implemented in tests, if WebDriver cannot find an element in the Document Object Model (DOM), it will wait for a defined amount of time for the element to appear in the DOM.
In other terms, an implicit wait polls the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available.
Once set, the implicit wait is set for the life of the WebDriver object's instance.
However, an implicit wait may slow down your tests when an application responds normally, as it will wait for each element appearing in the DOM and increase the overall execution time.
In this recipe, we will briefly explore the use of an implicit wait; however, it is recommended to avoid or minimize the use of an implicit wait.
Let's create a test on a demo AJAX-enabled application as follows:
The Timeouts Interface provides an implicitlyWait() method, which accepts the time the driver should wait when searching for an element.
In this example, a test will wait for an element to appear in DOM for 10 seconds:
Minimize or avoid using an implicit wait in your tests and try to handle synchronization issues with an explicit wait, which provides more control when compared with an implicit wait.
See also f Synchronizing a test with an explicit wait.
Synchronizing a test with an explicit wait The Selenium WebDriver also provides an explicit wait for synchronizing tests, which provides a better control when compared with an implicit wait.
Unlike an implicit wait, you can write custom code or conditions for wait before proceeding further in the code.
An explicit wait can only be implemented in cases where synchronization is needed and the rest of the script is working fine.
The Selenium WebDriver provides WebDriverWait and ExpectedCondition classes for implementing an explicit wait.
The ExpectedCondition class provides a set of predefined conditions to wait before proceeding further in the code.
The following table shows some common conditions that we frequently come across when automating web browsers supported by the ExpectedCondition class:
In this recipe, we will explore some of these conditions with the WebDriverWait class.
We can create a wait for a set of common conditions using the ExpectedCondition class.
First, we need to create an instance of the WebDriverWait class by passing the driver instance and timeout for a wait as follows:
Next, ExpectedCondition is passed to the wait.until() method as follows:
The WebDriverWait object will call the ExpectedCondition class object every 500 milliseconds until it returns successfully.
The Selenium WebDriver also provides a way to build custom-expected conditions along with common conditions using the ExpectedCondition class.
This comes in handy when a wait can be handled with a common condition supported by the ExpectedCondition class.
In this recipe, we will explore how to create a custom condition.
We will create a test that will create a wait until an element appears on the page using the custom ExpectedCondition class as follows:
The Selenium WebDriver provides the ability to implement the custom ExpectedCondition class along with the WebDriverWait class for creating a custom-wait condition, as needed by a test.
In this example, we created a custom condition, which returns a WebElement object once the inner findElement() method locates the element within a specified timeout as follows:
In the following section, we will explore some common examples for implementing a custom wait.
Waiting for element's attribute value update Based on the events and action performed, the value of an element's attribute might change at runtime.
For example, a disabled textbox gets enabled based on the user's rights.
A custom wait can be created on the attribute value of the element.
In the following example, the ExpectedCondition class waits for a Boolean return value, based on the attribute value of an element:
Waiting for an element's visibility Developers hide or display elements based on the sequence of actions, user rights, and so on.
The specific element might exist in the DOM, but are hidden from the user, and when the user performs a certain action it appears on the page.
A custom-wait condition can be created based on the element's visibility as follows:
Waiting for DOM events The web application may be using a JavaScript framework such as jQuery for AJAX and content manipulation.
For example, jQuery is used to load a big JSON file from the server asynchronously on the page.
While jQuery is reading and processing this file, a test can check its status using the active attribute.
A custom wait can be implemented by executing the JavaScript code and checking the return value as follows:
Checking an element's presence The Selenium WebDriver doesn't implement Selenium RC's isElementPresent() method for checking if an element is present on a page.
This method is useful for building a reliable test where you can check an element's presence before performing any action on it.
In this recipe, we will write a method similar to the isElementPresent() method.
The isElementPresent() method takes a locator using an instance of By.
Checking an element's status Many a time a test fails to click on an element or enter text in a field as the element is disabled or exists in the DOM, but is not displayed on the page; this will result in an error being thrown and the test resulting in failures.
For building reliable tests that can run unattended, a robust exception and error handling is needed in the test flow.
We can handle these problems by checking the state of elements.
The WebElement class provides the following methods to check the state of an element:
Method Purpose isEnabled() This method checks if an element is enabled.
It returns true if selected, else false for deselected isDisplayed() This method checks if element is displayed.
In this recipe, we will use some of these methods to check the status and handle possible errors.
We will create a test where a checkbox for the LED head lamp option needs to be selected on a page.
This checkbox will be enabled or disabled based on the previously selected option.
Before selecting this checkbox, we will make sure that it's enabled for selection as follows:
We are selecting a checkbox by checking two states of an element—first, it is enabled and second it is not selected.
We can use the isEnabled() function of the WebElement class, which returns true if the element is enabled or false if it's disabled.
If we don't check this condition, the test will possibly throw an exception saying the object is disabled, as follows:
In Selenium WebDriver, testing pop-up windows involves identifying a pop-up window, switching the driver context to the pop-up window, then executing steps on the pop-up window, and finally switching back to the parent window.
In this recipe, we will identify and handle a pop-up window by using its name attribute.
Developers provide the name attribute for a pop-up window that is different from its title.
In the following example, a user can open a pop-up window by clicking on the Help button.
In this case, the developer has provided HelpWindow as its name:
Let's implement a test that identifies a pop-up window using its name attribute as follows:
The Selenium WebDriver provides a way to switch between the browser windows and change the context of a driver.
This method accepts the name or handle attribute of the pop-up window.
In the following example, the name attribute is used as follows:
Now we can perform actions or verifications on the pop-up window through the driver instance as usual.
During a test, when you want to move to a pop-up window called from a parent window, save the parent window's handle attribute in a variable so that when operations on the pop-up window are over and we want to switch back to the parent window, we can use the handle as follows:
A test can switch back to the parent window using its handle attribute as follows:
The pop-up windows can be closed by calling the driver.close() method.
However, developers might implement the closing of a pop-up window by clicking on a button or a link.
In this case, closing a pop-up window directly might lead to errors or exceptions.
Handling this exception helps to build a robust test, which would otherwise run into errors.
See also f Identifying and handling a pop-up window by its title.
Many a times developers don't assign the name attribute to pop-up windows.
In such cases, we can use its window handle attribute.
However, the handle attributes keep changing and it becomes difficult to identify the pop-up window, especially when there is more than one pop-up window open.
Using the handle and title attributes of the page displayed in a pop-up window, we can build a more reliable way to identify the pop-up windows.
In this recipe, we will use the title attribute to identify the pop-up window and then perform operations on it.
We will create a test that retrieves the handles of all the open windows in the current driver context.
We will iterate through this list and check the title matching the criteria as follows:
We can then iterate through this list and find out the matching pop-up window by checking the title of each window by using the handle attribute as follows:
You can create a reusable function for identifying pop-up windows using the title attribute.
See also f Identifying and handling a pop-up window by its name.
In certain situations, developers neither assign the name attribute nor provide a title to the page displayed in a pop-up window.
This becomes more complex when a test needs to deal with multiple pop-up windows open at the same time—to identify the desired pop-up window.
Ideally, you should reach out to developers and recommend that they add either the name attribute or title for better testability and accessibility.
Let's create a test that retrieves the handles of all the open windows in the current driver context.
It will then iterate through this list, switching to the window and then checking for the content, which will help in identifying the correct window as follows:
There is no name or title provided for Chat Page Popup //We will iterate through all the open Windows and check the //contents to find //out if it's Chat Window.
If a window is found with the specific text, it will be closed by clicking on the Close button instead of calling the driver.close() method.
You can implement this in your test when pop-up windows cannot be identified by using the name attribute or the title.
See also f Identifying and handling a pop-up window by its name.
Handling a simple JavaScript alert Web developers use JavaScript alerts for informing users about validation errors, warnings, getting a response for an action, accepting an input value, and so on.
Tests will need to verify that the user is shown correct alerts while testing.
It would also be required to handle alerts while performing an end-to-end workflow.
In this recipe, we will handle a simple alert box using Selenium WebDriver's Alert class.
A simple alert box is often used to notify the user with information such as errors, warnings, and success.
When an alert box pops up, the user will have to click on the OK button to proceed, as shown in the following screenshot:
We will create a test a page on which, when a button is clicked, a simple alert box is displayed to the user.
This test will also check that correct information is displayed in the alert box as follows:
The Selenium WebDriver provides an Alert class for handling alerts.
A test might need to verify what message is displayed in an alert box.
We can get the text from an alert box by calling the getText() method of the Alert class as follows:
An alert box is closed by clicking on the OK button; this can be done by calling the accept() method as follows:
An alert box can also be accessed without creating an instance of the Alert class by directly calling desired methods as follows:
Handling this exception helps to build a robust test which will otherwise run into errors.
Handling a confirm box alert A confirm box is often used to verify or accept something from the user.
When a confirm box pops up, the user will have to click either on the OK or the Cancel button to proceed, as shown in the following screenshot:
If the user clicks on the OK button, the box returns true.
If the user clicks on the Cancel button, the box returns false.
In this recipe, we will handle a confirm box using the Selenium WebDriver's Alert class.
Let's create a set of tests that handle a confirm box displayed on a page as follows:
In the testConfirmDismiss test, we will dismiss the confirm box by calling the dismiss() method; this is the same as clicking the Cancel button as follows:
Handling a confirm box works in a similar way to handling a simple alert box.
For cancelling a confirm box, the dismiss() method of the Alert class is used as follows:
Handling a prompt box alert A prompt box is often used to input a value by the user before entering a page.
When a prompt box pops up, the user will have to click either on the OK or the Cancel button to proceed after entering an input value, as shown in the following screenshot:
If the user clicks on the OK button, the box returns the input value.
If the user clicks on the Cancel button, the box returns null.
In this recipe, we will handle a prompt box using the Selenium WebDriver's Alert class.
We will create a test that handles a prompt box.
We will enter text into the prompt box's input field and later verify if the same value is displayed on the page as follows:
For handling a prompt box,  the Alert class provides an extra sendKeys() method to enter text in the prompt box's input field.
We can enter the text and either accept or dismiss a prompt box by calling the Alert class's methods as follows:
Identifying and handling frames HTML frames allow developers to present documents in multiple views, which may be independent windows or subwindows.
Multiple views offer developers a way to keep certain information visible, while other views are scrolled or replaced.
For example, within the same window, one frame might display a static banner, the second a navigation menu, and the third the main document that can be scrolled through or replaced by navigating in the second frame.
In the following example, a page will display three frames, each loading different HTML pages:
Frames can be identified by an ID or through the name attribute.
Let's test on a page that has three frames as follows:
In the following example, the id attribute is used to identify a frame:
When frames do not have the id or name attributes defined, the index can be used to identify a frame.
In the preceding example, the frame in the middle does not have the id or name attributes.
Once a frame is activated, the driver's instance will allow operations on the document loaded in the frame.
See also f Identifying and handling frames by their content.
While working with frames, you will find that the id or name attributes are not defined.
This may not be a reliable way when applications are dynamic and there is a need to ensure that the correct frame is activated.
In this recipe, we will identify frames by the content of the document loaded in these frames to make tests more reliable.
Let's create a test that will get all the <frame> elements in a document and then iterate through this list to find out the desired frame as follows:
In this example frame in the middle is activated by checking the //contents //Activate frame and check if it has the desired content.
In Selenium WebDriver, we can get elements of the same criteria in a list.
Here we will get all the frame elements from the document using the tagname() method as follows:
The test will iterate through each frame element, passing this element to the driver.
If the frame has matching content, then you can continue operations on the frame and later switch back to the main document as follows:
You can create a utility method for switching between frames using their content.
Working with IFRAME Developers can also embed external documents or documents from another domain using the <iframe> tag.
Various social media websites provide buttons which can be embedded in your web applications to link these websites.
For example, you can add Twitter-follow button in your application as follows:
In this recipe, we will identify the <iframe> tag, which is nested in another frame.
We will create a test on a page which embeds the <iframe> tag within a frame.
We will move to the parent frame first and then to the <iframe> tag.
The test will click the element within the <iframe> tag and operate on a pop-up window displayed.
Working with IFRAME is similar to working with a normal frame.
In this example, the <iframe> element is located using the findElement() method by passing the tag:
See also f Identifying and handling frames by their content.
Introduction Testing can be very repetitive, not only because we must run the same test over and over again, but also because many of the tests are only slightly different.
For example, we might want to run the same test with different test inputs or test conditions and verify that the actual output varies accordingly.
Each of these tests would consist of the exact same steps; however, what differs is the test data.
The data-driven testing approach is a widely used methodology in software test automation.
We will use the BMI calculator application as an example to understand the data-driven testing approach.
To test whether the BMI calculator application indicates BMI categories correctly, instead of having a separate test script for each category, we can have one script that will enter the height and weight by referring to a set of values and checking the expected values.
We can use the following combinations of test conditions to test the BMI calculator application:
In the simplest form, the tester supplies inputs from a row in the table and expected outputs, which occur in the same row.
We implement test scripts after reading input and output values from data files, row by row, then passing the values to the main test code.
Then, the test code navigates through the application, executing the steps needed for the test case using the variables loaded with data values.
Data-driven tests are great for applications involving calculations for testing ranges of values, boundary values, and corner cases.
Even testers with limited knowledge of automation can quickly create tables on their own.
Overall, the data-driven approach is the key for ease of use while building large-scale test automation.
Selenium WebDriver, being a pure browser automation API, does not provide built-in features to support data-driven testing.
However, we can add support for data-driven testing using various options in Selenium WebDriver.
In this chapter we will create some basic data-driven tests in JUnit and TestNG.
Later, we will build some advanced data-driven tests using different data sources in JUnit and a data-driven test in Ruby using Roo, and Python.
We will also create data driven tests for .NET bindings using NUnit and MSTest.
Creating a data-driven test using JUnit JUnit is a popular testing framework used to create Selenium WebDriver tests in Java.
We can create data-driven Selenium WebDriver tests using the JUnit 4 parameterization feature.
This can be done by using the JUnit parameterized class runner.
In this recipe, we will create a simple JUnit test case to test our BMI calculator application.
We will specify the test data within our JUnit test case class.
We will use various JUnit annotations to create a data-driven test.
Getting ready f Set up a new project and add JUnit4 to the project's build path.
Let's create a data-driven test using JUnit, using the following steps:
Declare instance variables for the parameterized values in the SimpleDDT class.
When the test is executed, for each row in the test data collection, the test runner will instantiate the test case class, passing the test data as parameters to the SimpleDDT class constructor; it will then execute all the tests in the SimpleDDT class.
Instance variables are declared to store the test data passed by the test runner, as shown in the following code snippet:
In the test case class constructor, these variables are assigned with values at runtime by the test runner from the test data collection.
For example, to enter a value in the height field, we used the instance variable of the test case class as follows:
The expected result is also parameterized using the instance variable for BMI value.
JUnit will display results for each set of test data along with time taken to execute it, as shown in the following screenshot:
This is the simplest way to parameterize a test, however test data is hardcoded within the test case class, which could become difficult to maintain.
It is always recommended that we store the test data in an external source, such as a CSV, Excel, or database file for easier maintenance.
See also f The Reading test data from a CSV file using JUnit recipe.
Creating a data-driven test using TestNG TestNG is another widely used testing framework with Selenium WebDriver.
TestNG has rich features for testing, such as parameterization, parallel test execution, and so on.
In this recipe, we will use the DataProvider feature to create a simple test.
Creating data-driven tests in TestNG is fairly easy, when compared with JUnit.
You can set up the project in an IDE of your choice.
Unlike the JUnit, where parameterization is done on a class level, TestNG supports parameterization at test level.
In TestNG, we do not need a constructor and instance variable for the test case class to pass the parameter values.
When a method is annotated with @DataProvider, it becomes a data feeder method by passing the test data to the test case.
In this example, the testData() method will become the data feeder method and TestNG will pass the array of data rows to the test method one-by-one:
The test case method is linked to the data feeder method by passing the name of the dataProvider method to the @Test annotation.
TestNG will execute the test four times, with different test combinations.
TestNG also generates a well formatted report at the end of test execution.
To run Selenium tests in parallel, the TestNG parameterization feature comes in very handy.
TestNG supports running Selenium tests parallel in a multithreading safe environment.
See also f The Reading test data from a CSV file using JUnit recipe.
We saw a simple data-driven test using JUnit and TestNG.
It is recommended that we store the test data separately from the test scripts.
Often we use data from the production environment for testing.
We can read CSV files using Java IO and utility classes and can pass the data from these files to the test code.
In this recipe, we will read data from a CSV file and use this data to execute the test script.
Getting ready f Set up a new project and add JUnit4 to the project's build path.
Let's implement a parameterized test with CSV, using the following steps:
Make it a parameterized class by adding the @RunWith attribute.
When the test is executed, the testData() method will call the getTestData() helper method by passing the path of the CSV file.
Inside the getTestData() method, the BufferedReader class from the java.io namespace is used to read the file line-by-line.
Lines are then split into an array of strings, using the comma delimiter.
This array is then added to Collection or ArrayList, either of which is then returned to the testData() method.
For each row in the test data collection returned by the testData() method, the test runner will instantiate the test case class, passing the test data as parameters to the test class constructor and will then execute all the tests in the test class.
Changing delimiters Sometimes, CSV files may have a separate delimiter than the comma.
We can change the getTestData() method to handle these delimiters.
For example, a tab character is used to separate records.
For this, we can split the record, using the \t character, in the following way:
See also f The Creating a data-driven test using JUnit recipe.
To maintain test cases and test data, Microsoft Excel is the favorite tool used by testers.
Compared to the CSV file format, Excel gives numerous features and a structured way to store data.
A tester can create and maintain tables of test data in an Excel spreadsheet easily.
In this recipe, we will use an Excel spreadsheet as your data source.
Getting ready f Set up a new project and add JUNIT4 to project's build path.
We will also need a SpreadsheetData helper class to read Excel spreadsheets.
This is available in the source code bundle for this book.
This class supports both the old .xls and newer .xlsx formats.
Let's create a test that uses Excel spreadsheet test data for parameterization, using the following steps:
When the test is executed, the testData() method will create an instance of the SpreadsheetData class.
The SpreadsheetData class reads the contents of the Excel spreadsheet row by row in a collection and returns this collection back to the testData() method.
For each row in the test data collection returned by the testData() method, the test runner will instantiate the test case class, passing the test data as parameters to the test class constructor, and then execute all the tests in the test class.
See also f The Creating a data-driven test using JUnit recipe.
Reading test data from a database using JUnit and JDBC.
In the earlier recipes, we used CSV and Excel spreadsheets to maintain the test data and read this test data in JUnit.
The test data can also be read from a database.
This works similar to the previous recipes, however, we will create a helper method using JDBC to read the test data from a Microsoft Access database.
Getting ready f Set up a new project and add JUnit4 to the project's build path.
The sample file is available with the book's sample code.
Let's implement a parameterized test with CSV by using the following steps:
Make it a parameterized class by adding the @RunWith attribute.
When the test is executed, the testData() method will call the getTestData() helper method by passing the path of the database file and the SELECT query.
An instance of the Statement class is created to execute the select query specified in the sqlQuery string and return the results to an instance of the ResultSet object.
The rows returned in the ResultSet object are then collected in a string array by iterating through the result set.
For each data row in the the test data collection returned by the testData() method, the test runner will instantiate the test case class, passing the test data as parameters to the test class constructor, and then execute all the tests in the test class.
Test data can also be referenced from any database other than a Microsoft Access database.
The getTestData() method will need a connection string as per the database used in the project.
See also f The Creating a data-driven test using JUnit recipe.
Creating a data-driven test in NUnit The NUnit framework has been widely used by the Selenium WebDriver community to create test scripts with .NET bindings.
Similar to the JUnit framework, the NUnit framework also supports data-driven testing in the simplest manner.
In this recipe, we will create a Selenium WebDriver test using NUnit.
We will read the test data from an XML file used in the first recipe.
Let's create a parameterized test in NUnit, with the following steps:
While creating a data-driven test in NUnit, we use the TestCaseSource attribute.
We will specify the name of the IEnumerable property that will provide test data to this test case with the TestCaseSource attribute shown in the following code:
When we execute the test, NUnit framework will generate test cases by calling the BmiTestData property.
This will return an array of arguments as IEnumerable by calling the GetBmiTestData() method.
An array of arguments is created by reading an XML file using a LINQ Query in GetBmiTestData() method.
When we open the test in the NUnit GUI, it shows the test cases for all the test data combinations provided in the input XML file:
With this, we can get the test data from any source, such as CSV, Excel spreadsheet, or a database.
The NUnit GUI will show the results when all the tests are executed, as seen in the following screenshot:
See also f The Creating a data-driven test in MSTEST recipe.
Creating a data-driven test in MSTEST To create a data-driven test in MSTEST, the unit testing framework provided by Microsoft Visual Studio is the simplest way to parameterize the test scripts with .NET bindings.
In this recipe, we will use MSTEST to create a data-driven Selenium test by reading test data from an Excel spreadsheet.
You can parameterize a test in MSTEST by adding the Excel spreadsheet to deployment items of the test project, using the following steps:
Add File button in the Deployment section, as shown in the following screenshot:
Once you add the file to the Deployment section, it will appear in the list, as shown in the following screenshot:
When we add the DataSource attribute to a test in MSTEST, it provides data source-specific information for data-driven testing to the framework.
The framework internally creates a DataTable object to store the values from the source.
The TestContext test method provides a collection of data rows for parameterization.
We can access a field by specifying its name, as follows:
With the DataSource attribute, we can specify the connection string or a configuration file to read data from a variety of sources including CSV File, Excel spreadsheets, XML files, or databases.
See also f The Creating a data-driven test in NUnit recipe.
In the previous recipes, we saw parameterization with Java and .NET; Ruby also has been used widely to create Selenium WebDriver tests.
Again, Ruby does not have its own way to parameterize the script.
However, we can use the Roo (http://roo.rubyforge.org/) gem in Ruby to read spreadsheets.
Roo is a great alternative to the Ruby Excel COM WIN32 API, as it does not need Excel or OpenOffice installed on the machine.
In this recipe, we will parameterize the Selenium WebDriver test created in Ruby bindings, using an Excel spreadsheet as a test data source.
Getting ready You need to install the Roo gem by using the following command:
This command will download and install all the dependencies required for Roo on your machine.
Let's create a simple Ruby test for parameterization, by using the following steps.
This test will read test data from the Excel spreadsheet used in the Reading test data from an Excel file using JUnit and Apache POI recipe earlier.
Create an instance of Excel class from Roo for reading a spreadsheet.
Add the following code, which will iterate through the spreadsheet, reading each combination and then performing the operations and verifications:
When we execute this test, Roo will read the contents of the Excel spreadsheet into the data object, using the following code:
We can then iterate the data object from the first row to the last row using the following code:
This will copy the content from a row in a variable named line.
The value from a data cell is accessed using the data.cell() method, by passing the line and position of the cell using the following code:
We also added a custom reporting code that will generate a nicely formatted report at the end of the test execution, as shown in the following screenshot:
We can also read the Google Docs spreadsheets from Roo.
This can be done by using the Google.new() method, by passing the key for the Google Docs spreadsheet, as shown in the following command:
Using Roo, you can also read a spreadsheet stored on Confluence Wiki.
For more information, visit the Roo home page at http://roo.rubyforge.org/
Creating a data-driven test in Python Python is also a widely used language for building Selenium WebDriver tests.
In this recipe, we will parameterize a Selenium WebDriver test written in Python, using a CSV file.
Let's create a simple Python test for parameterization, using the following steps.
This test will read test data from the CSV file used in the Reading test data from a CSV file using JUnit recipe earlier.
Create a Ruby test by importing the following modules: from selenium import webdriver import csv, sys.
Add the following code, which will iterate through the CSV data by reading each combination and then performing the operations and verifications:
When we execute this test, Python will read the contents of the CSV file to the reader object.
We can then iterate on the data object from first row to the last row, using the for loop, as shown in the following code:
This will copy the content from reader into a variable named row.
The value from a column is accessed using row[index], by passing the index of the column.
We also added a custom reporting code that will generate a nicely formatted report at the end of test execution, as shown in the following screenshot:
Introduction Developing a maintainable automation code is one of the keys to a successful test-automation project.
Test-automation code needs to be treated as production code and similar standards and patterns should to be applied while developing this code.
While developing Selenium WebDriver tests, we can use the Page Object model pattern.
This pattern helps in enhancing the tests, making them highly maintainable, reducing the code duplication, building a layer of abstraction, and hiding the inner implementation from tests.
By applying object-oriented development principles, we can develop a class that serves as an interface to a web page in the application, modeling its properties and behavior.
This helps in creating a layer of separation between the test code and code specific to the page, by hiding the technical implementation such as locators used to identify elements on the page, layout, and so on.
The Page Object design pattern provides tests for an interface where a test can operate on that page in a manner similar to the user accessing the page, but by hiding its internals.
For example, if we build a Page Object test for a login page, then it will provide a method to log in, which will accept the username and password and take the user to the home page of the application.
The test need not worry about how input controls are used for the login page, their locator details, and so on.
Tests should use objects of a page at a high level, where any change in layout or attributes used for the fields in the underlying page should not break the test.
This chapter covers recipes to build tests using Page Object model and related design.
Using the PageFactory class for exposing elements from a page.
For implementing the Page Object model in tests, we need to map and create a Page Object class for each page being tested.
For example, to test the BMI Calculator application, a BMI Calculator page class will be defined, which will expose the internals of the BMI Calculator page to the test, as shown in following diagram.
Getting ready Before exposing the elements of a page, we need to do the following:
Let's implement a Page Object test for the BMI Calculator page using the PageFactory class with the following steps:
Define and create a package for all the page's objects from the application for logical grouping.
Give the name of the page we will be testing from the application to this class.
For example, we will be creating a page object for the BMI Calculator application, so the class name could be BmiCalcPage.
Use the name or id attributes to name these variables as follows: public WebElement heightCMS; public WebElement weightKg; public WebElement Calculate; public WebElement bmi; public WebElement bmi_category;
Using the Page Object model and the PageFactory class, the BMI Calculator page's elements are exposed through the BmiCalcPage class to the test instead of the test directly accessing the internals of the page.
When we initialize the page's object using the PageFactory class in the BmiCalcPage class, the PageFactory class searches for the elements on the page with the name or id attributes matching the name of the WebElement object declared in the BmiCalcPage class, as follows:
The initElements() method takes the driver object created in the test and initializes the elements declared in the BmiCalcPage class.
We can then directly call the methods on these elements as follows:
FindBy annotations Finding elements using the name or id attributes may not always work and we might need to use advanced locator strategies such as XPath or CSS selectors.
Using the FindBy annotation, we can locate the elements within the PageFactory class as follows:
We declared a public member for the height element and used the @FindBy annotation, specifying the id as a locator for finding this element on the page.
CacheLookUp Attribute One downside to using the @FindBy annotation is that every time we call a method on the WebElement object, the driver will go and find it on the current page again.
This is useful in applications where elements are dynamically loaded or AJAX-heavy applications.
However, in applications where we know that the element is always going to be there and stay the same without any change, it would be handy if we could cache the element once we find it.
Tests work faster with cached elements when these elements are used repeatedly.
Using the PageFactory class for exposing an operation on a page.
In the previous recipe, we created the BmiCalcPage class, which provides elements from the BMI Calculator page to the test.
Along with elements, we define operations or behaviors on a page.
In the BMI Calculator application, we are calculating the BMI by entering height and weight values.
We can create an operation named calculateBmi and call it directly in a test, instead of calling individual elements and operations.
In this recipe, let's refine the BmiCalcPage class and instead of elements, provide the operations that are supported on the page and some common properties.
We will also move the WebDriver instance of the test to the BmiCalcPage class to make the test generic.
Getting ready Identify operations that will be required in a test and can be exposed from a page.
This recipe uses the BmiCalcPage class created in the previous recipe.
Let's modify the BmiCalcPage class created in the previous recipe and refactor it a bit to provide operations and properties to the test through the following steps:
Make the page's elements private in the BmiCalPage class for better encapsulation.
In this example, the BmiCalcPage class defines various methods for loading, closing the page, calculation functionality, and providing access to elements as properties to the test.
This simplifies the test development by creating a layer of abstraction, hiding the internals of a page, and exposing only operations and fields needed for testing from the page.
When any change happens to the structure or behavior of the page, only the BmiCalcPage class will be refactored while the test will remain intact.
In this example, we created the load() method, which navigates the application using the URL as follows:
Using this approach, we can also expose the elements as properties, which provide specific attributes such as the value attribute instead of exposing elements fully.
For example, the getBmi() method provides only the value attribute of the bmi label to the test as follows:
Selenium WebDriver provides a very neat and clean way to implement the Page Object model.
Using the LoadableComponent class We can implement the objects of the Page Object model using the LoadableComponent class of Selenium WebDriver.
This helps in building a robust Page Object that provides a standard way to ensure that the page is loaded and that the page load issues are easy to debug.
In this recipe, we will further refactor the BmiCalcPage class created in the previous recipes and extend it as a loadable component.
Getting ready This recipe uses the BmiCalcPage class created in the previous recipe.
For implementing an object of the Page Object model as the LoadableComponent class, we need to extend it from the LoadableComponent base class by performing the following steps:
By extending the object of the Page Object model with the LoadableComponent base class, we overrode the load() and isLoaded() methods to the BmiCalcPage class.
The load() method will load the URL of the page we encapsulated in the Page Object and when we create the instance of this Page Object in a test, we call the get() method on the BmiCalcPage class, which will in turn call the load() method as follows:
The isLoaded() method will verify that the indented page is loaded by the load() method.
Implementing nested Page Object instances So far, we explored a very simple Page Object implementation for a single page web application.
We can use the Page Object model to implement the objects of a page in a complex web application to simplify the testing.
In this recipe, we will create the objects of the Page Object model for the search functionality in an e-commerce application found at http://demo.magentocommerce.com/
We can implement a Page Object model even if the specific functionality is not a page of its own.
In the sample application, the search feature is available throughout the application.
However, let's find out how it's been used from the application's home page.
Each page of the application provides the user with the ability to search products from the site by entering a query and hitting the search button.
When a search query is submitted, the application returns a new page with a list of products matching the search query.
Using the approach described in this recipe, we can build a more modular framework.
In this recipe, we will create this nested hierarchy where the HomePage class implements the Search class, which in turn returns an object of the SearchResults class to the test.
Getting ready Identify the page and logical relationship between these pages to build a nested component set.
For implementing nested Page Object instances, perform the following steps:
Create the HomePage class, which allows the test to navigate to the home page of the application.
SearchResult class represents the results page when the user submits a search query.
As discussed previously, the SearchResult class also provides access to the Search class so that users can search again for a different query.
The test starts with creating an instance of the HomePage class.
As you can see, the application home page provides the user with the ability to search the site; in a similar way, the HomePage class provides the ability to search by using the Search class as follows:
The searchInStore() method of the Search class takes the query string as arguments and interacts with the search form to send the query.
The SearchResults class provides a list of products that match the query back to the test using the getProducts() method as follows:
The test can verify the number of products as well as the names of the products by checking the return value of the getProducts() method as follows:
Using the nested objects of the Page Object model, we can build a logical chain of pages within an application and build a robust and maintainable test automation framework.
Similar to Java bindings, Selenium WebDriver provides the PageFactory class in .NET bindings for implementing the Page Object model.
However, the PageFactory class is implemented a little differently with .NET bindings where it needs the FindsBy annotation while locating the elements.
It does not support locating elements using the name or id attributes specified as the name of the element variable is similar to Java.
In this recipe, we will implement the Page Object model for the BMI Calculator page using the PageFactory class in C#
Getting ready We need to identify the locators that will be needed to locate the elements uniquely.
For implementing Page Object model .NET, perform the follow steps:
Define a class for the Page Object model by creating a new C# class with the name of the page.
Using the BmiCalcPage class, let's create a test for the calculation feature, as follows: using NUnit.Framework;
In this example, the BmiCalcPage class provides various operations and properties from the BMI Calculator page to the test.
The elements on the page are defined as instances of the IWebDriver interface with a FindsBy annotation as follows:
The BmiCalcPage class implements methods for opening and closing the BMI Calculator page.
This will provide a high level of abstraction to the test.
The BmiCalcPage class also implements the IsLoaded property, which will tell a test if the BMI Calculator page is loaded into the browser.
This class also defined properties for the Bmi and BmiCategory fields, which provide values from these fields to test, rather than complete access to the underlying elements as follows:
It also provides a CalculateBmi() method which takes the height and weight as an argument and interacts with underlying elements to perform actions.
Implementing the Page Object model in Python is similar to what we have done previously in Java and C#
In this recipe, we will implement the Page Object model using Python bindings.
Getting ready Before implementing the Page Object model for Python bindings, we must do the following:
To implement the Page Object model in Python, follow these steps:
Define a class for the Page Object model by creating a Python script with the name of the page.
Implementing the Page Object model in Python is relatively simple.
The Page Object model can be implemented by creating classes, defining methods and properties, and only exposing the functionality from the application page that needed it for testing.
In this example, the bmicalcpage class is defined to represent the BMI Calculator application's main page.
This class needs an instance of WebDriver through which it will interact with the main page as follows:
The bmicalcpage class implements the is_loaded property, which will tell tests if the BMI Calculator page is loaded into the browser.
This class also defined properties for the bmi and bmi_category fields, which provide values from these fields to test, rather than a complete access to the underlying elements:
It provides the calculate() method which takes the height and weight as an argument and interacts with underlying elements to perform actions.
The bmicalcpage class also implements methods for opening and closing the BMI Calculator page.
This will provide a high level of abstraction to the test, hiding the underlying details of page and elements.
This makes writing tests, in a kind of domain-specific language, easier and faster.
Implementing the Page Object model in Ruby by using the page-object gem.
While developing tests in Ruby, we can use the page-object gem for implementing the Page Object model within the tests.
The page-object gem provides simple features for building the objects of a Page Object along with Watir-WebDriver.
In this recipe, we will see how to use the page-object gem for implementing the Page Object model for the BMI Calculator's main page.
Getting ready You need to download and install the page-object gem with the help of the following command:
For implementing the Page Object model in Ruby using the page-object gem, perform the following steps:
Define a class for the Page Object model by creating a Ruby script with the name of the page.
In this example, we will be creating a Page Object model for the main page of the BMI Calculator application and including the page-object module: require 'page-object' class BmiCalcPage include PageObject.
Using the object of the BmiCalcPage class, create a test for the calculation feature as follows: require 'rubygems' require 'watir-webdriver' require 'test/unit' require_relative 'bmicalcpage.rb'
We can use the Page Object model implemented with the page-object gem by creating an instance of the BmiCalcPage class and passing the browser as an argument to the constructor.
The rest of the magic is performed by the page-object gem.
While defining the elements, we need to specify the type of element and the locator as follows:
The page-object gem adds a few more methods automatically to these objects at runtime.
For example, we created an element for the Calculate button in the Page Object model as follows:
The page-object gem creates a method called calculate, which will click the Calculate button when called from the calculate_bmi() method as follows:
You can find more information about the page-object gem API at the following URL:
Introduction Selenium WebDriver provides a highly flexible and robust API to extend the features and commands and add customization for building a scalable test automation framework.
This chapter covers some of the important recipes for extending Selenium WebDriver for various practical scenarios.
In this chapter we will write Selenium WebDriver extensions that support web tables, object maps, and image comparison features.
We will also build an extension for jQuery UI control.
You can use this pattern for implementing support for third party or custom controls used in your application by hiding technical details from the tests.
Creating an extension class for web tables Selenium WebDriver provides a generic WebElement class to work with various types of HTML elements.
It also provides helper classes to work with the Select element.
However, there is no built-in class to support the web tables or <table> elements.
In this recipe, we will implement a helper class for web tables.
Using this class, we will retrieve properties and perform some basic operations on a web table element.
Getting ready Create a new Java class WebTable.java, which we will use to implement the support for table elements.
Let's implement the web table extension code with WebTable.java using the following steps:
Add a constructor for the WebTable class and for the setter and getter property methods as well.
Let's create a test on a shopping cart Page, using a newly created WebTable class.
The WebTable class accepts a WebElement object and extends it to provide table-specific properties and operations.
We used the tagName() method of the By class and collected all the <tr> elements as a list of WebElement objects.
Using the size() method, we can find out how may rows are available in the table element.
Similarly, we inspected a number of <td> elements in the first row of the table (normally the header), to retrieve the number of columns available in the table element, as shown in the following code:
To retrieve data from a specific cell, the getCellData() function accepts row and column number arguments.
First, it gets the <tr> element from the list by using the row argument as an index, as shown in the following code:
Then, it retrieves the <td> elements from currentRow, using column argument as an index, as shown in following code:
To retrieve the text, it calls the cell object's getText() method, as shown in following code:
The getCellEditor() method of the WebTable object provides access to the first input element of the cell.
We can then use this input element and perform actions such as Click() or SendKeys()
The getCellEditor() method uses a similar method to reach the desired cell and then finds the first input element inside a cell, that is, a <td> element using the ByTagName locator strategy, as shown in the following code:
It provides interactions, widgets, effects, and theming for building rich Internet applications.
These widgets are built using a number of low-level HTML elements, such as DIVs, unordered lists, and input tags.
While Selenium can recognize these elements individually, we can build support for Selenium to recognize these controls as native jQuery UI widgets.
We can then perform native operations supported by jQuery framework.
In this recipe, we will implement support for the jQuery UI Tab widget.
Getting ready Visit http://jqueryui.com/demos/tabs/ to understand more about the jQuery UI tabs widget.
Explore how they are implemented and various options, methods and events related to this widget.
Similar to the WebTable extension class we created earlier, we will create a JQueryUITab class to represent the Tab widget in Selenium, by following the ensuing steps:
First, create a JQueryUITab class with setter and getter properties.
The JQueryUITab class is ready for use in testing the Tab widget.
The JQueryUITab class accepts a WebElement object passed to its constructor.
To retrieve the number of tabs in a Tab widget, we pass the tab element.
Internally, the Tab widget defines an unordered list for tab headers.
We can locate these headers by using the cssSelector() method of the By class in a list of WebElements using the findElements() method.
We can get the count of the tabs by looking at the list size.
To retrieve the selected tab name, we will use a similar cssSelector() method with a filter to locate the <li> element whose class is ui-tabs-selected.
When we select a tab in the Tab widget, jQuery framework adds all these class attributes to the <li> element internally, as shown in the following code:
Finally, to select a tab in the Tab widget, we need to execute the jQuery native API functions.
The Tab widget has a method to select a tab by its index.
However, selecting a tab by its index may not be user-friendly.
Therefore, we will accept the name of the tab and then find out its index internally, using the following code:
Now, we will call the native jQuery API by using JavaScriptExecutor and pass the index to the select method of the Tab widget, using the following code:
Using a similar approach, we can also build support for other widgets in jQuery UI or other UI frameworks such as Yahoo UI, Doojo, and GWT.
This provides a neat and clean way to work with custom widgets and UI controls.
Implementing an extension for the WebElement object to set the element attribute values.
Setting an element's attribute can be useful in various situations where the test needs to manipulate properties of an element.
For example, for a masked textbox, the sendKeys() method may not work well, and setting the value of the textbox will help to overcome these issues.
The WebElement object does not have a method that supports setting all types of attributes.
In this recipe, we will create an extension for WebElement and provide a method to set the attribute value of an element at runtime.
We will use this class to host all the extension methods for the WebElement objects.
Add the setAttribute() method to the WebElementExtender class, as follows:
In the setAttribute() method, we created an object of JavaScriptExecutor and retrieved WrappedDriver of the WebElement object on which we want to call the setAttribute() method.
In this example, the contents of a input element are cleared before calling the SendKeys() method.
This can also be done by calling the clear() method of the WebElement class.
See also f The Implementing an extension for the WebElement object to highlight elements recipe.
Implementing an extension for the WebElement object to highlight elements.
During test execution, there is no way to highlight an element.
This will help us to see what is actually going on in the browser.
This method will slow down the tests a bit, but sometimes it's a useful way to debug tests.
In this recipe, we will create an extension for WebElement and provide the highlight Elements() method at runtime.
Add the highlightElement() method to the WebElementExtender class, as follows:
In the highlightElement() method, we created an instance of the JavaScriptExecutor class and got an instance of the WrappedDriver class from the element, on which we want to call the highlightElement() method.
Using the JavaScriptExecutor class, we called the JavaScript setAttribute() method to set the style attribute value to green and then back to original.
During execution, the element is highlighted with a green flash.
This comes in very handy while debugging or visualizing the test progress.
See also f The Implementing an extension for the WebElement object to set the element.
Creating an object map for Selenium tests So far, we have seen how the Selenium WebDriver API needs locator information to find the elements on the page.
When a large suite of tests is created, a lot of locator information is duplicated in the test code.
It becomes difficult to manage locator details when the number of tests increases.
If any changes happen in the element locator, we need to find all the tests that use this locator and update these tests.
One way to overcome this problem is to use page objects and create a repository of pages as reusable classes.
There is another way to overcome this problem — by using object map.
An object or a UI map is a mechanism that stores all the locators for a test suite in one place for easy modification when identifiers or paths to GUI elements change in the application under test.
The test script then uses the object map to locate the elements to be tested.
Object maps help in making test script management much easier.
When a locator needs to be edited, there is a central location for easily finding that object, rather than having to search through the test script code.
Also, it allows changing the identifier in a single place, rather than having to make the change in multiple places within a test script, or for that matter, in multiple test scripts.
In this recipe, we will implement the ObjectMap class for maintaining locator details obtained from the tests.
This class will be used by Selenium tests as an extension for reading the ObjectMap file.
Let's implement object map to store the locators used in a test with the following steps:
Implement the ObjectMap class to read the property file and provide the locator information to the test.
First, we created a Java properties file with the key/value pair, storing a logical name for an element and locator value.
The properties files are flat text files, and the java.util.
Properties namespace provides the Properties class to access a property file.
By passing a logical name or key to the getProperty() method of the Properties class, we can retrieve a value from the pair.
The getLocator() method uses the value returned by the getProperty() method and returns a matching By locator method, along with the value, to the test.
In the test, we created an instance of object map and then passed the location of the property file, as shown in the following code:
We passed the locator value to the findElement() method by passing the logical name or key of the element to the getLocator() method of the ObjectMap class.
We can have a single object map file for storing all the locators and can use the same locators in multiple tests.
There's more… Object maps can also be created in XML files.
The following code is an example of an XMLbased object map:
The following code is the C# implementation of the getLocator() method:
A similar approach can be taken with other Selenium WebDriver language bindings, such as Java, Python, or Ruby.
The TakesScreenshot interface captures the screenshot of the entire page, current window, visible portion of the page, or of the complete desktop window in their respective order as supported by the browser.
It does not provide a way to capture an image of the specific element.
We can extend the screen capture functionality to capture images of WebElement using the Java Image API in addition to the TakesScreenshot interface.
In this recipe, we will implement a helper method for capturing images of elements.
Then it captures the screenshot of the page displayed in the driver using the getScreenShotAs() method of the TakesScreenshot interface using the location and size of the element, we will crop the image of the element from the image of the entire page.
Comparing images in Selenium Many a time, our tests need image-based comparison.
For example, verifying whether correct icons are displayed, whether correct images are displayed in web pages, or comparing baseline screen layout with the actual layout.
Selenium WebDriver does have features to capture screenshots or images from the application under test, however, it does not have the feature to compare the images.
In this recipe, we will create an extension class for comparing images and use it in our Selenium tests.
Getting ready Set up a new Java project for the CompareUtil class.
This class will be used by Selenium tests as an extension for comparing images.
Let's implement the CompareUtil class with a method to compare two image files, as shown in the following code:
The CompareUtil class uses the java.awt.Image namespace to work with images.
The CompareImage() method takes the path of the base file and the actual file as an argument.
Finally, it uses the PixelGrabber class to get the pixels from these images to an array, as shown in the following code:
The images are first tested for size mismatch, and then for pixel mismatch, using the following code:
The following code is a sample test, comparing the layout of application being tested with a base layout captured from an earlier release:
You can use this class for Selenium tests created with .NET bindings.
Introduction With the increasing adoption of Smartphones and tablets, mobile applications have taken a center stage.
It has become essential to build/migrate and test applications for these platforms.
In this chapter, we will cover recipes for configuring and using Selenium for testing applications on iOS and Android-based phones and tablets.
We can run automated tests on a simulator/emulator or on a real device using iOS and Android drivers.
These drivers implement the RemoteWebDriver for enabling testing through the WebDriver.
Both these drivers provide an application that implements RemoteWebDriver server and a lightweight HTTP server.
These applications can be installed on a simulator/emulator or on a device for testing.
We will test a mobile web application developed using jQuery mobile on these platforms.
The IPhoneDriver allows running automated tests, ensuring your web application works correctly on an iOS Safari browser in a simulator or on a real device for various versions of the iOS platform.
As shown in the previous diagram, IPhoneDriver requires an iWebDriver application installed on the simulator or on the device.
It uses a UIWebView (the rendering component used in iOS Safari browser) to execute the tests using the Cocoa framework.
The iWebDriver application is implemented in the Objective-C and Cocoa HTTP framework.
Once the iWebDriver is set up on the simulator or on a device, the test code connects to the iWebDriver application using the HTTP/JSON protocol to execute the tests in a way similar to a client/server application.
Similar to the IPhoneDriver, the AndroidDriver allows running the automated tests and ensuring your web application works correctly on an Android browser for various versions of Android.
The AndroidDriver supports user interactions such as taps, flicks, and scrolls.
It can also rotate the display and interact with HTML 5 features such as local and session storage and application cache.
The AndroidDriver requires the Android server APK to be installed on the emulator or device.
It uses a WebView (the rendering component used in Android browser) to execute the tests using the native touch and key events.
It uses JavaScript Atom libraries to interact with the DOM.
Android server APK is implemented as an Android application developed using Java.
Once the Android server APK is set up on the emulator or device, the test code connects to the Android server APK using the HTTP/JSON protocol to execute the tests similar to a client/server application.
We also need to enable port-forwarding from the host machine to the Android emulator or device.
The iOS simulator enables you to test your web applications without using an actual device, whether it's an iPhone or any other iOS device, such as iPad or iPod Touch.
The iOS simulator also has the capability of simulating different versions of the iOS, and this becomes extremely useful if your application needs to be installed on different iOS versions.
You need to set up the iWebDriver application for Selenium to test web applications on iOS Platform.
The iWebDriver application is developed using the Objective-C and Cocoa framework.
The iWebDriver application implements the RemoteWebDriver server for the test code to run on the iOS platform.
It is supported on both, the simulator and the real device.
In this recipe, we will see how to download and configure the iWebDriver Xcode project from the Selenium code base to run against a simulator.
Getting ready We need to download and compile the iWebDriver application using the Xcode IDE on Mac OS X.
We will perform the following steps for setting up the iWebDriver App for iPhone/iPad simulator:
It will take a while to download the code repository.
A new directory named selenium-read-only will be created with the complete Selenium source code from the trunk.
In the next step, we will set up the iWebDriver Project in the Xcode IDE.
Navigate to the selenium-read-only directory using Finder and open the iphone subdirectory.
This will launch the Xcode IDE window with the iWebDriver project.
Apple releases newer iOS versions and you might see a latest version for selection in the build configuration.
Please select the appropriate or latest iOS version in the build configuration.
A warning will be displayed in Xcode as Validate Project Settings in the Navigator pane, as shown in the following screenshot:
Optionally, the Xcode IDE may show a dialog box asking for creating a snapshot of the project.
To build and run the iWebDriver application, click on the Run button to build the project and run the application.
Xcode IDE will build the iWebDriver project and launch the iPhone simulator with the iWebDriver application running on http://localhost:3001/wd/hub as shown in the following screenshot:
The iWebDriver application is not available in the Apple App Store and we need to build it for installing it on the simulator using the Xcode IDE.
We changed the build settings to deploy the iWebDriver application on the simulator.
When we click on the Run button in Xcode IDE, it compiles the iWebDriver application along with its dependencies.
Xcode IDE launches the iOS simulator automatically with the target device selected in the build configuration.
Xcode IDE then installs the iWebDriver application on the simulator automatically.
Finally, the iWebDriver application is launched as a web server running on port 3001 on the simulator.
We saw how to configure the iWebDriver application for the iPhone simulator.
You can also run the iWebDriver application with the iPad simulator.
This will launch the iPad simulator with the iWebDriver application, as shown in the following screenshot:
See also f The Running tests on iOS using the iWebDriver App and iPhone driver recipe.
While the iOS simulator acts as a good test bed for your testing needs, it is recommended that you test your web application on an actual device, rather than relying on the iOS simulator for testing.
Setting up the iWebDriver application on a real device is similar to installing it on the simulator with the only difference in installing and configuring the provisioning profile from Apple.
You can install an application on an iOS device only from the App Store.
However, if you want to install an application for testing purposes, you need to procure a provisioning profile from Apple by enrolling in the iOS Developer Program, which costs $99 annually.
Getting ready We need to download and compile the iWebDriver application using the Xcode IDE on Mac OS X.
Let's perform the following steps for setting up the iWebDriver App for the iPhone/iPad device:
A new directory named selenium-read-only will be created with complete Selenium source code from the trunk.
In the next steps, we will set up the iWebDriver project in Xcode IDE.
This will launch the Xcode IDE window with the iWebDriver project.
Set your build configuration to iWebDriver > iOS Device in the Scheme drop-down box on the top left-hand side of the Navigator pane in Xcode IDE, as shown in the following screenshot:
You will also need a provisioning profile from Apple to be installed and configured for your device.
If you use the default provisioning profile, which may simply use a wildcard for all domains, you don't need to edit the NAME field in the Bundle identifier.
A warning will be displayed in Xcode to validate the Project Settings in the Navigator pane.
Optionally, Xcode IDE may show a dialog box asking for creating a snapshot of the project.
The easiest way to do this is to configure a Wi-Fi network and connect your device to it.
Click on the Run (Play) button to build the project and run the application.
Xcode IDE will build the iWebDriver project and automatically install and launch the iWebDriver application in the connected iOS device on http://localhost:3001/wd/hub.
As the iWebDriver application is not available in Apple App Store, we need to build it for installation on the device using the Xcode IDE.
We changed the build settings to deploy the iWebDriver application on a real device.
When we click on the Run button in Xcode IDE, it compiles the iWebDriver application along with its dependencies.
Then the Xcode IDE installs the iWebDriver application on the device automatically using the provisioning profile.
Finally, the iWebDriver application is launched as a web server running on port 3001 on the device.
See also f The Running tests on iOS using the iWebDriver App and iPhone driver recipe.
Running tests on iOS using the iWebDriver App and iPhone driver.
Once we have the iOS simulator or the device set up with the iWebDriver application, you can create and run the tests using the IPhoneDriver class.
In this recipe, we will test a simple mobile BMI calculator web application, developed using jQuery Mobile on the iOS platform.
Getting ready Before we start running the test with the iPhone driver, set up the iOS simulator or device with the iWebDriver application.
If you are testing on a real device, then make sure it is connected to the machine running the tests using the iPhone driver over the network.
For this test, we created an object of the IPhoneDriver class by calling the constructor.
If you are running this test on a local machine where the simulator is running, it will connect to the local instance of the iWebDriver on port 3001
If you are running the simulator on a different machine and testing it on any other machine, you can pass the remote host details as an argument to the IPhoneDriver constructor by using the following code:
When we run the test, it connects to the iWebDriver, which is running as the RemoteWebDriver server and starts the test execution.
The following screenshot shows the Mobile BMI Calculator application being tested on the iPhone:
As you can see in the code, it uses the pure WebDriver API to execute the test on a mobile application.
Instead of using the IPhoneDriver class, you can also use the RemoteWebDriver class with the desired capabilities to execute the tests on the iOS in the following way:
Similar to the iOS simulator, the Android emulator enables you to test your applications without using an actual Android device, whether it is any Android-based phone or tablet.
The Android emulator also has the capability of simulating different versions of Android, and this becomes extremely useful if your application needs to be installed on different Android versions.
We need to set up the Android server APK for Selenium to test web applications on the Android platform.
The Android server APK application implements the RemoteWebDriver server for the test code to run on the Android platform.
It is supported on both the emulator and the real device.
In this recipe, we will see how to download and configure the Android server APK on the Android emulator.
Getting ready Before setting up the Android emulator for Selenium to run tests, we need to set up the Android development environment.
You can use the command line or the graphical interface provided by the Android SDK to create and set up a new Android emulator.
Use the following steps on a command line to create a new Android Virtual Device (AVD), and use this AVD in the emulator for Android:
We will create a new AVD using the command line.
Parameter Description -n It specifies the name of the AVD.
When you are prompted Do you wish to create a custom hardware profile [no], enter no in the field.
Once the Android boots up in the emulator, you will see a screen as shown in the following screenshot:
We can also use the AVD Manager GUI to create a new AVD and launch the AVD in the emulator.
Use the following steps to create and launch a new AVD using the AVD Manager:
A window as shown in the following screenshot will be displayed:
Keep the rest of the values as default, unless you need to change anything.
The message shown in the following screenshot will be displayed on success:
To launch the newly created AVD, select the newly created AVD in the AVD Manager and click on the Start… button as shown in the following screenshot:
Keep all the options as default and click on the Launch button to start the AVD, as shown in the following screenshot:
In the previous example the serial ID will be emulator-5554
Copy the Android server APK file to the platform-tools directory in the androidsdk directory.
A WebDriver Ready message will be displayed on the emulator screen.
You can also launch the WebDriver application by clicking on the WebDriver Application icon in the Application menu on an Android device or emulator.
The Android server will be available at http://localhost:8080/wd/hub from the host machine.
For executing the tests on an Android emulator, we created a virtual Android device using the Android SDK and AVD Manager.
Then, we installed the Android server APK on the virtual device.
When Android server APK is launched, a RemoteWebDriver enabled client can interact with it for executing the tests using the HTTP/JSON protocol.
Setting up the Android device for Selenium Testing your web application on the Android emulator will definitely help; however, it is also essential to test the application on a real Android device.
While the iOS platform and devices such as iPhone and iPad are limited to Apple, Android on the other hand is an open source platform.
There are a number of devices available that are running on Android with multiple form factors.
Setting up the Android server APK on a real device is similar to installing it on a simulator.
In this recipe, you will see how to configure and install Android server APK on a real Android device.
I have used a Samsung Galaxy Smartphone running on Android 2.3 (Gingerbread) for the following example.
Getting ready Before setting up the Android device for Selenium to run tests, we need to set up the Android development environment.
First connect the Android device to the computer using a USB cable.
Make sure the device is connected to the host machine by using the following command:
We will need the serial ID for installing the WebDriver APK in the next step.
Now let's install the WebDriver APK on the connected Android device as follows:
Copy the Android server APK file to the platform-tools directory in the androidsdk directory.
Now we need to set up the port forwarding in order to forward traffic from the host machine to the device.
The Android server will be available at http://localhost:8080/wd/hub from the host machine.
For executing tests on the Android emulator, we created a virtual Android device using the Android SDK and AVD Manager.
Then we installed the Android server APK on the virtual device.
When Android server APK is launched, a RemoteWebDriver enabled client can interact with it for executing the tests using the HTTP/JSON protocol.
A WebDriver Ready message will be displayed on the device screen, as shown in the following screenshot:
The Android server APK processes the HTTP requests using the address http://localhost:8080/wd/hub URL.
You can use this as an alternative to set up and execute tests on the Android emulator or device.
A lot of the above tasks are automatically performed by the Android Test framework instead of using commands or GUI to set up the test environment.
You can set up the Android Test framework with Eclipse by installing the Android Development Tools (ADT) plugin.
Running tests using AndroidDriver Once we have the Android server APK installed and configured on the Android emulator or device, we can create and run the tests using the AndroidDriver class.
In this recipe, we will test a simple mobile BMI calculator web application developed using jQuery Mobile on the iOS platform.
Getting ready Before we start running the test with AndroidDriver, set up the Android emulator or device with the following steps:
For this test, we created an object of the AndroidDriver class by calling the constructor.
If you are running this test on a local machine where the simulator is running, it will connect to the local instance of the Android server APK automatically.
Otherwise, you can pass the host details as an argument to the AndroidDriver constructor by using the following command:
When we run the test, it connects to the Android server APK that is running as the RemoteWebDriver server and starts the test execution.
The following screenshot shows the Mobile BMI Calculator application being tested:
As you can see in the previous code, it uses a pure WebDriver API to execute the test on the mobile application.
Android driver also allows us to interact with mobile functionalities, such as Screen Rotation, Tap, Flick, and so on using the mobile API.
In the previous example, we are rotating the screen to the landscape mode then back to the portrait mode by using the following code:
Running the test with RemoteWebDriver Instead of using the AndroidDriver class, you can also use the RemoteWebDriver class with the desired capabilities to execute the tests on iOS in the following way:
This will be useful when we run the tests in parallel and we need to parameterize the target environments.
Introduction Measuring and optimizing the client-side performance is essential for a seamless user experience and this is critical for web 2.0 applications using AJAX.
Capturing vital information, such as the time taken for page load, rendering of the elements, and the JavaScript code execution, helps in identifying the areas where performance is slow and optimizes the overall client-side performance.
Sometimes, third-party controls, images, and media content also cause degradation in the performance.
Using Selenium WebDriver and various other tools together, we can measure the performance and eliminate the weaker content.
There are various APIs and tools that we can integrate with the Selenium WebDriver for measuring the performance of the client-side user interaction and script code.
This chapter contains recipes to use the Selenium WebDriver for testing the client-side performance.
Measuring the response time using a timer Measuring page load or response time is one of the basic metrics that we can capture in the Selenium WebDriver tests.
We can use timers in the test code to capture the time taken for page load, rendering of the elements, JavaScript code execution, and so on.
This approach can be implemented using the Date/Time classes in programming languages.
We can also use the Stopwatch class to measure the time taken for an activity of interest.
The only downside of this approach will be testing with a lot of timers added.
In this recipe, we will see how to calculate the timespan between two events in various ways.
Getting ready We need to identify the areas where we we need to evaluate the response time.
We will measure the response time by adding a timer.
We can use various strategies to use timers in our code to measure the response time or the load time.
For example, if we want to measure the time for a page load based on a particular element that is being rendered on the page, we can use two variables, namely, capturing start time, which is the time when the page is requested, and the end time, which is the time after the element is rendered on that page.
Refer to the TimerDemo.java section in the book's sample code for a complete test.
When this test will be executed, before we start requesting the page, the startTime variable will be assigned with the current time in milliseconds using the System.
This will delay the script until the expected element is present in the DOM.
After the element is available in the DOM, we will again collect the current time in milliseconds in the endTime variable.
We will calculate the difference between the startTime and endTime variables to find out how many milliseconds it took to load the page as follows:
Though this is not a perfect approach, it will give us a good measure of the page load time.
The StopWatch class provides a neat way to calculate the elapsed time between the events.
It also provides a method to suspend and resume the Stopwatch class.
The API provides a simple way to get accurate and detailed timing statistics natively for page navigation and load events.
A zero value means that an event did not occur.
Getting ready Identify a test where you want to measure the performance as well as decide what performance counters you want to measure.
We need to use JavaScript to retrieve this metric using the following code:
BrowserMob proxy is a free tool that supports monitoring and manipulating the network traffic from web applications.
It can capture the performance data from a web application in an HTML Archive (HAR) format, as well as manipulate the browser behavior and traffic, such as whitelisting and blacklisting content, simulating network traffic and latency, and rewriting HTTP requests and responses.
BrowserMob proxy helps in automating client-side performance data collection for a web application using the Selenium WebDriver.
In this recipe, we will set up a BrowserMob proxy for the Selenium WebDriver test to collect the performance data in an HAR format.
Reference the BrowserMob proxy JARs from the lib folder in the BrowserMob proxy folder to your existing Selenium WebDriver test project.
Let's create a test that uses BrowserMob for performance monitoring by carrying out the following steps:
The BrowserMob proxy server works like a normal proxy server between the application and the browser.
However, it can monitor the traffic and collect the performance data that can be used for analysis.
We can also manipulate the BrowserMob proxy to create a low-latency network to observe the performance of the application.
The BrowserMob proxy collects the performance data in the HAR format and we can access this data by using the getHar() method.
We can save this data in an HAR file, using the writeTo() method of the Har class available in the BrowserMob proxy API.
We can open the HAR file for analysis using a HAR viewer.
The following screenshot is a HAR representation using an online HAR viewer available at http://www.softwareishard.
See also f The Using dynaTrace for measuring the performance recipe.
The dynaTrace AJAX Edition is a widely used tool for building optimized and faster web 2.0 applications.
When you monitor an application with dynaTrace, it analyzes the application and finds problems while providing detail metrics about the application's performance on various levels.
In this recipe, we will set up dynaTrace to capture the various performance metrics using a Selenium WebDriver test.
Getting ready For this recipe, we will need to download and install dynaTrace AJAX Edition from http://ajax.dynatrace.com/ajax/en/
You may also download and install the premium edition for more features.
After completing the installation, please make sure that these Agents (add-on) are enabled in the browser.
For using dynaTrace with the Selenium WebDriver, we have to set up some environment variables.
These variables will enable dynaTrace to monitor the browser instance launched from the Selenium WebDriver test and capture the performance metrics.
You can set these variables either in the command line or in Eclipse.
If you are setting the variables from command line, you can either create a batch file or enter the following command before starting the test run:
For configuring the environment variables in Eclipse and running the test with dynaTrace, perform the following steps:
Start the dynaTrace AJAX Edition (You need to launch the dynaTrace AJAX Edition before running your test)
Select the test that you want to run along with dynaTrace from the right-hand side pane in the Run Configurations dialog box.
Select the Environment tab on the Run Configurations dialog box.
New Environment Variable dialog box and click on the OK button, as shown in the following screenshot:
Click on the Run button in Eclipse to start the test run.
After completing the test, dynaTrace will display results, as shown in the following screenshot:
When the Selenium WebDriver test launches a browser with predefined environment variables, the dynaTrace Agents installed as add-ons in the browser get activated, monitor the browser for various events, and collect the performance metrics.
This data is passed to the dynaTrace AJAX Edition for further analysis and reporting.
You can view the results in the dynaTrace AJAX Edition window under the Sessions option.
When we use FirefoxDriver() in a test, it launches Firefox without the add-on.
However, for the dynaTrace Agent, we need to use the default Firefox profile.
When we launch Firefox with the default profile, it loads all the installed add-ons.
We can launch Firefox along with a profile using the following code:
See also f The Using the BrowserMob proxy for measuring performance recipe.
Using HttpWatch for measuring performance HttpWatch is another famous tool for watching the client-side performance of a web application with Internet Explorer and Firefox.
Similar to dynaTrace, HttpWatch provides various metrics to analyze problems in JavaScript, network requests, page resources, and page load performance.
It offers API support for monitoring and capturing the log files in C#, Ruby, JavaScript, and so on.
In this recipe, we will set up HttpWatch to capture the various performance metrics using a Selenium WebDriver test.
Getting ready For this recipe, we will need to download and install HttpWatch Basic Edition from http://www.httpwatch.com/
You may also download and install the Professional edition for more features.
During installation, the dynaTrace AJAX Edition will automatically install the plugins in Internet Explorer and Firefox.
After completing the installation, please make sure that these plugins are enabled in the browser.
Before using HttpWatch in a test, we have to set up an option to capture the metric when the HttpWatch plugin is launched in the browser in the following way:
Then select the Start Recording when HttpWatch is opened: radio button and select the Stop recording when HttpWatch is closed checkbox.
You may also create a class library project for NUnit or MSTest project instead.
When the test is executed, it first creates an instance of the HttpWatch Controller class.
This class provides API access to the test through the plugin interface.
The HttpWatch plugin needs a unique title, so that it can access the HTTP requests from the browser.
In this test, a unique GUID is created and assigned as a title to the browser window.
The test creates an instance of the plugin interface by calling the AttachByTitle() method of the controller.
This method takes the uniqueTitle assigned to the browser window as an argument.
Once the HttpWatch plugin is attached to the browser window, the test can open the plugin window by calling the OpenWIndow() method.
This will display the HttpWatch GUI along with the application page in the browser window.
HttpWatch starts the recording of the HTTP traffic once the plugin window is displayed.
The test navigates to the test application and performs some operation to capture the HTTP metric.
The captured data can be saved in the HttpWatch log file format as a .hwl file by calling the Log.Save() method and specifying the path where the log file will be saved.
Once the test is executed, the log generated by the HttpWatch plugin can be analyzed using HttpWatch Studio that is installed along with HttpWatch.
The HttpWatch Studio displays all the metrics and performance data, as shown in the following screenshot:
See also f The Using the BrowserMob proxy for measuring performance recipe.
One way of effectively measuring performance testing is by conducting a response time test every time the application is built.
If there is a huge degradation in the performance, break the build!
First, install the Watir-WebDriver gem by the using the following command:
Let's try a simple example using the Interactive Ruby Shell (IRB)
You can see the output for the previous commands in the following screenshot:
We will create a test that will launch the unmesh.me website and measure the response time.
If the response time is more than 15 seconds, the test will fail:
By instrumenting the Watir-WebDriver automated tests that run regularly, we can capture and measure the web application performance over time, and be alerted to the possibility of a change being introduced with adverse performance effects.
The PerformanceTiming interface allows JavaScript mechanisms to provide a client-side latency metric within the application.
In the previous examples, the @browser object provides us with an additional performance object through which we can retrieve the performance metrics collected from the browser.
For example, we can retrieve the overall response time in our test by using the following code snippet:
There are many applications being developed using new HTML5 elements such as canvas, video, and so on, and features such as web storage giving users a rich Internet experience.
For many web developers adopting these standards, it is essential that we test these features automatically.
Selenium WebDriver supports testing HTML5 web applications on certain browsers out of the box.
However, we can also use JavaScript to test these features, which will work on all the browsers supported by Selenium WebDriver.
In this chapter, we will focus on the most important features of HTML5 and see how to test them using Selenium WebDriver.
Automating the HTML5 video player Up till now, there has not been a standard for showing a video on web pages.
Most of the browsers depend on a plugin such as Flash to playback a video.
In this recipe, we will explore how we can automate testing of the <video> element, which provides a JavaScript interface with various methods and properties for automation.
We will use the JavaScriptExecutor class from Selenium WebDriver to interact with the <video> element.
We will control the video from our test code and also verify some properties of the video in the following way:
Firstly, we locate the <video> element so we can call its associated methods in JavaScript as well as the retrieve/set properties.
We can locate the <video> element similar to another HTML element by using the findElement() method as follows:
We can verify which video file is being used with video player for playback and duration of the video by looking at the currentSrc and duration properties.
We are retrieving these properties by accessing the <video> element through JavaScript.
For this, we created an instance of the JavaScriptExecutor class as follows:
Using the executeScript() method of the JavaScriptExecutor class of Selenium WebDriver, we can execute the JavaScript code within the browser window.
We can return a value from the JavaScript code by assigning the value to a variable.
However, we need to cast this value appropriately based on the type of value being returned.
In this case, the currentSrc property will return a URL of the video file as a String:
In the previous example, arguments[0] was replaced by the videoPlayer WebElement using the executeScript() method.
Video playback As discussed earlier, we can also control the playback of a video using the methods of the <video> element such as play() and pause()
We can call these methods by using the executeScript() method in the following way:
This element is used to build drawing and charting applications by using JavaScript.
Canvas has several methods for drawing paths, boxes, circles, characters, and adding images.
In this recipe, we will automate a simple drawing application through the Selenium WebDriver action class for mouse movements.
We will also implement an image comparison feature to test the drawing on a canvas.
We draw a shape by using a sequence of mouse movements on the <canvas> element.
We will verify the canvas with a previously captured image and check the shape has been redrawn as follows:
To draw on the canvas, we will first select a drawing tool by selecting the pencil option from the Drawing Tool drop-down.
Selenium WebDriver provides a Select class for working with drop-downs and lists.
In the test, the selectByValue() method is called for selecting the pencil tool:
We will draw a shape on the canvas by using the Selenium WebDriver actions generator.
Selenium WebDriver will perform a sequence of mouse movements by calling the moveByOffset() method while holding the mouse button to draw the shape, releasing the mouse button at the end:
The Selenium actions generator mimics the mouse operations exactly like an end user drawing a shape on the canvas.
This image will be compared with a baseline image to verify that the drawing operation works on the canvas as expected using the Selenium WebDriver.
This data is not included with every server request, but used ONLY when asked for.
It is also possible to store large amounts of data without affecting the website's performance.
The data is stored in key/ value pairs, and a web application can only access data stored by itself.
HTML5 provides a localStorage interface through JavaScript that stores the data with no expiration date.
The data will not be deleted when the browser is closed, and will be available all the time.
You can view this data in Google Chrome by clicking on Inspect Element | Resources tab.
In this recipe, we will verify that a web page stores data in local storage as expected.
We will create a test that will verify the web page has created an entry in local storage and stored a value.
We will use the Selenium WebDriver JavaScriptExecutor class to access the localStorage interface as follows:
While executing this test, Selenium WebDriver will load a page that will access the local storage and create a new key/value pair as lastName = Smith.
We can validate this by accessing the lastName key from the localStorage interface using the executeScript() method of the JavaScriptExecutor class.
This will return the value of the lastName key as a String:
During testing, there might be a need to directly set the value of the key in local storage.
We can assign a new value to an existing key by directly assigning the value in the following way, using JavaScript:
See also f The Cleaning local and session storage recipe.
Web storage – testing session storage Similar to local storage, the session storage stores the data for only one session.
The data is deleted when the user closes the browser window.
We can access the session storage using the sessionStorage interface through JavaScript.
In this recipe, we will verify that a web page stores data in session storage as expected.
Let's create a test case that will load a web page which implements a counter and stores the value of the counter every time a button is clicked in session storage.
We will verify that a new counter value is stored in session storage:
While executing this test, whenever a button is clicked by Selenium WebDriver, a new session storage key will be created for the first time in session storage.
For subsequent clicks, this value will be incremented by the web page.
Similar to local storage, we can validate this by accessing the clickcount key from the sessionStorage interface using the executeScript() method of the JavaScriptExecutor class.
This will return the value of the clickcount key as a String:
When the browser is closed and the test has ended, the clickcount key will be removed from session storage.
See also f The Cleaning local and session storage recipe.
Cleaning local and session storage When tests are run on HTML5 applications using local or session storage, lots of local and session storage entries will be created.
When running tests in batch on an already used environment, cleaning the local and session storage is a good idea before you begin your tests.
In this recipe, we will briefly see how to remove local or session storage items and clean the values.
To remove a specific item from local or session storage, you can use the removeItem() method in the following way:
For session storage, the following code snippet will be used:
To clear all items, local or session storage, you can use the clear() method in the following way:
For session storage, the following code snippet will be used:
See also f The Web storage – testing session storage recipe.
Introduction Capturing a video showing test execution becomes useful when tests are run.
While tests are executed unattended, recording a video will help in understanding how things went during the test run, capturing application, or script errors or successes.
Whether you are a developer or a tester, these videos can be useful in analyzing test results and reproducing the defects recorded during test execution.
It also helps in capturing the evidence for adhering to processes.
These videos can also be used in demoing features to customers or as a training aid.
Selenium WebDriver does not have in-built features to record videos of test runs.
However, Selenium WebDriver scripts can be extended using open source or free-to-use tools to support recording videos.
In Java, we can extend Selenium WebDriver test scripts to record videos by using an open source tool named Monte Media Library.
In this recipe, we will explore how to configure and use the Monte Media Library's ScreenRecorder class with Selenium to record movies of tests.
ScreenRecoder supports the AVI and QuickTime formats for recording movies.
For playing movies in AVI format, you will need to install Techsmith Screen Capture Codec (TSCC Codec) while QuickTime format is supported by Apple's QuickTime player.
ScreenRecorder provides multiple configurations for colors, mouse cursor, screen rate, mouse rate, audio, and so on.
Monte Media Library is integrated with the Selenium WebDriver test for recording videos with the following steps:
While recording the video of the desktop, the ScreenRecorder class needs the graphics configuration of the display screen on which tests are executed.
An instance of the ScreenRecorder class is created by calling the constructor and passing the video recording settings.
This will provide us with the necessary methods to start and stop the recording:
The output format of the movie, encoding mechanism, color depth, frames per second, keyframe interval.
Video recording is invoked by calling the ScreenRecorder's start() method and completed by calling the ScreenRecorder's stop() method.
When a recording is finished, ScreenRecorder stores the output file in the user's Home directory.
Recorded videos can be viewed with QuickTime or open source video players like VLC.
Video recorded in AVI format needs a media player that supports Techsmith Screen Capture Codec (TSCC)
This Codec is available for download and use at http://www.techsmith.com/ download.html.
Often we use dual monitor setups to develop or test the code.
In the previous example, ScreenRecorder will record the videos from the secondary display screen attached to the system.
Tip/Warning Monte Media Library does not support recording videos of tests with Selenium WebDriver Remote Server where tests are executed on remote machines.
However, there is a very simple and interesting solution available from Microsoft named Microsoft Expression Encoder.
This tool provides a very simple and neat API to record videos of the screen interaction.
It also provides a GUI to edit the recorded videos.
The Pro version supports a number of other codecs and provides additional features.
However, you need to buy the Pro version from Microsoft.
In this recipe, we will use the Basic Microsoft Expression Encoder version to record a video of a test in C# using Selenium WebDriver .NET bindings.
Recording a video of a test run with Selenium WebDriver .NET bindings can be done with the following steps.
Specify the path & name of the file to which Encoder will // store the recording.
The ScreenCapture namespace in Microsoft Expression Encoder SDK provides the ScreenCaptureJob class through which we can record the videos.
Adding this code to the TestSetup() method will create individual recording sessions for all the tests that are part of this test class:
The start() method of ScreenCaptureJob called in the TestSetup() method will start the recording of video.
And the stop() method called in the TestCleanUp() method will stop the recording session.
The ScreenCaptureJob class provides various methods and properties to control the recording sessions.
You can also edit the recorded videos in Encoder GUI and add captions, thumbnails, and so on, to the recorded video.
Castro is a widely used tool in the Selenium community to record videos of test runs in Python.
Castro is based on a cross-platform screen recording tool named Pyvnc2swf (http://www.
It captures a screen using the VNC protocol and generates a Shockwave Flash (SWF) movie file.
With VNC protocol support, we can record a video from a remote machine with Castro.
It needs a VNC program installed on the machine to record the videos, though.
Install Castro using easy_install or the pip tool from the command line:
On Mac, you can install the Vine VNC server from http://www.
Create a Selenium WebDriver test in python calling Castro as follows:
In the setUp() method, we created an instance of Castro, passing the name of the output file as follows:
We called the start() method to start recording the video.
In the tearDown() method, we called the stop() method to complete the recording.
We can use Castro to record video on a remote host.
This will be useful when we run tests in a distributed environment with RemoteWebDriver.
This can be achieved by passing host and passwd parameters while creating an instance of Castro in the following way:
Introduction Behavior-driven Development (BDD) is an agile software development practice that enhances the paradigm of Test Driven Development (TDD) and acceptance tests, and encourages the collaboration between developers, quality assurance, domain experts, and stakeholders.
Behavior-driven Development was introduced by Dan North in the year 2003 in his seminal article available at http://dannorth.net/introducing-bdd/
Behavior-driven Development focuses on obtaining a clear understanding of desired application behavior through discussion with stakeholders using an ubiquitous language as described at http://behaviour-driven.org/
It extends TDD by writing test cases in a natural language that non-programmers can read.
Users describe features and scenarios to test these features in plain text files using Gherkin language in Given, When, and Then structure.
The Given, When, and Then structures in the Gherkin language are described as follows:
In Behavior-driven Development, the process starts with users of the system and development team discussing features, user stories, and scenarios.
These are documented in feature or story files using the Gherkin language.
Developers then use the red-green-refactor cycle to run these features using the BDD framework, then write step definition files mapping the steps from scenarios to the automation code and re-running until all the acceptance criteria are met:
BDD/ATDD is becoming widely accepted practice in agile software development, and Cucumber-JVM is a mainstream tool used to implement this practice in Java.
Cucumber-JVM is based on Cucumber framework, widely used in Ruby on Rails world.
Cucumber-JVM allows developers, QA, and non-technical or business participants to write features and scenarios in a plain text file using Gherkin language with minimal restrictions about grammar in a typical Given, When, and Then structure.
This feature file is then supported by a step definition file, which implements automated steps to execute the scenarios written in a feature file.
Apart from testing APIs with Cucumber-JVM, we can also test UI level tests by combining Selenium WebDriver.
In this recipe, we will use Cucumber-JVM, Maven, and Selenium WebDriver for implementing tests for the fund transfer feature from an online banking application.
Perform the following steps for creating BDD/ATDD tests with Cucumber-JVM:
Select New | Package from the menu to add a new package as shown in the following screenshot:
Add the Fund Transfer feature and scenarios to this file: Feature: Customer Transfer's Fund As a customer, I want to transfer funds so that I can send money to my friends and family.
Select New | Package from menu to add a new Package as shown in the following screenshot:
Create a support class RunCukesTest which will define the Cucumber-JVM configurations:
Right-click on the project name and select Run As | Maven test.
At the end of the test, an HTML report will be generated as shown in the following screenshot.
Creating tests in Cucumber-JVM involves three major steps: writing a feature file, implementing automated steps using the step definition file, and creating support code as needed.
The feature file describes the feature and then the scenarios to test the feature:
Feature: Customer Transfer's Fund As a customer, I want to transfer funds so that I can send money to my friends and family.
You can write as many scenarios as needed to test the feature in the feature file.
The scenario section contains the name and steps to execute the defined scenario along with test data required to execute that scenario with the application:
Team members use these feature files and scenarios to build and validate the system.
Frameworks like Cucumber or JBehave provide an ability to automatically validate the features by allowing us to implement automated steps.
For this we need to create the step definition file that maps the steps from the feature file to automation code.
Step definition files implement a method for steps using special annotations.
For example, in the following code, the @When annotation is used to map the step "When he enters "Jim" as payee name" from the feature file in the step definition file.
In this method, the WebDriver code is written to locate the payee name textbox and enter the name value using the sendKeys() method.
The step definition file acts like a template for all the steps from the feature file while scenarios can use a mix and match of the steps based on the test conditions.
A helper class RunCukesTest is defined to provide Cucumber-JVM configurations such as how to run the features and steps with JUnit, report format, and location, shown as follows:
There's more… In this example, step definition methods are calling Selenium WebDriver methods directly.
However, a layer of abstraction can be created using the Page object where a separate class is defined with the definition of all the elements from FundTransferPage:
Now let's try using a similar combination in .NET using SpecFlow.NET.
We can implement BDD in .NET using the SpecFlow.NET and Selenium WebDriver .NET bindings.
SpecFlow.NET is inspired by Cucumber and uses the same Gherkin language for writing specs.
In this recipe, we will implement tests for the Fund Transfer feature using SpecFlow.NET.
We will also use the Page objects for FundTransferPage in this recipe.
This will install the project template and other support files for SpecFlow.NET in Visual Studio 2012
You will find the Fund Transfer feature in any online banking application where users can transfer funds to a registered payee who could be a family member or a friend.
Let's test this feature using SpecFlow.NET by performing the following steps:
Select SpecFlow.NUnit from the list and click on Install button.
NuGet will download and install SpecFlow.NUnit and any other package dependencies to the solution.
The steps for creating a spec file are as follows:
By default, SpecFlow will add a dummy feature in the feature file.
Replace the content of this file with the following feature and scenarios:
Feature: Customer Transfer's Fund As a customer, I want to transfer funds so that I can send money to my friends and family.
The steps for creating a step definition file are as follows:
A new C# class will be added with dummy steps.
Replace the content of this file with the following code:
The steps for defining a Page object and a helper class are as follows:
Define a Page object for the Fund Transfer Page by adding a new C# class file.
We need a helper class that will provide an instance of WebDriver and perform clean up activity at the end.
It will display the three scenarios listed in the feature file as shown in the following screenshot:
Click on Run All to test the feature as shown in the following screenshot:
SpecFlow.NET first needs the feature files for the features we will be testing.
In the step definition file, we create a method for each step written in a feature file using the Given, When, and Then attributes.
These methods can also take the parameter values specified in the steps using the arguments.
Following is an example where we are entering the name of the payee:
In this example, we are automating the "When he enters "Jim" as payee name" step.
This method will need the value of the payee name embedded in the step which is extracted using the regular expression by the SpecFlow.NET.
Inside the method, we are using an instance of the FundTransferPage class and calling its payeeNameField member's SendKeysl() method, passing the name of the payee extracted from the step.
Using the Page object helps in abstracting locator and page details from the step definition files, making it more manageable and easy to maintain.
SpecFlow.NET automatically generates the NUnit test code when the project is built.
Similar to Cucumber-JVM, JBehave allows the writing of features as stories in the Gherkin language.
Steps from the scenarios are later implemented in a step definition file.
In this recipe, we will explore using JBehave and Selenium WebDriver together for creating tests on a BMI calculator application.
Getting ready You need to download and set up the JBehave Web extension, which is based on JBehave Core.
It provides support for web-related access or functionality, including Selenium/WebDriver support.
Download the complete zip archive from the previously mentioned location.
After downloading the JBehave Web, unzip the contents of this file on your machine.
Locate the lib subdirectory; this directory contains all JAR files needed to create and run the following examples.
This will add JBehave and Selenium support to the project.
We now need to prepare a story file, which will contain acceptance criteria for a user story written in the Given, When and Then structure.
We will create a simple story file for the BMI Calculator Application; let's call this Bmi.story.
Create this using the with following steps, in the source folder of your project.
Next, we need to map steps from this story and create a step definition class.
We will create a plain Java class that will extend the StoryBase class, which we will create shortly.
Finally, we will create a Configuration class that will be used by the step definition classes.
In this class, we set up necessary configurations to execute the stories using JBehave and Selenium.
For creating tests in JBehave, we will need to first implement stories as the .story file using the Given, When, and Then structures.
We need to add the Narrative section to describe the purpose of the story and the Scenario section, which contains the actual steps.
We also pass the required test data from these steps:
Then I should see bmi as '24.4' and category as 'Normal'
Next, we map these steps using a step definition class.
This class extends the StoryBase class, which will provide the necessary support to run the story in the JBehave framework, including an instance of WebDriver:
For each step, we use an annotation and implement a method to run that step.
For example, for the step When I enter height as '181' we have defined the IEnterHeight() method as follows:
In this method, we created an instance of WebElement for the height textbox and called its sendKeys() method, passing the value.
Along with a story file and a step definition class, a Configuration class needs to be created, which will be based on the JUnitStory class from the JBehave framework:
The StoryBase class provides an instance of WebDriver to all the story or step definition classes:
It also provides other configuration information, like the location of the story files and report settings, and format the JBehave framework.
In this case, the .story files will be located using the path of the story or step definition classes:
We used the JUnitStory class so that we can execute these tests with JUnit Test Runner.
At the end of the execution, JBehave generates an HTML report with a detailed status of the stories executed, stories passed, or failed.
Capybara is an acceptance test framework for web applications in Ruby.
It integrates with Ruby-based BDD frameworks such as Cucumber and RSpec along with Selenium WebDriver for web testing capabilities.
In this recipe, we will see how to use Capybara, Cucumber, and Selenium to test BMI Calculator application.
You need to install Capybara Gem by using the following command:
Additionally, you also need to install Cucumber and RSpec Gem on a fresh Ruby installation, as follows: gem install cucumber.
In Capybara, we need to create a features file for the stories under test.
These stories are written in Gherkin language with the Given, When, and Then structures in Cucumber format.
Perform the following steps to create a feature and step definition file with Capybara:
Next, we need to create a step file for the feature file created earlier.
This file maps each step from the feature file to a Capybara function to work on UI.
Finally, we need to create a configuration file that provides required support to run the features with Cucumber.
We need to copy all of these files together in a directory named features and use the cucumber command as follows:
Since we are using Cucumber along with Capybara, it first needs feature files written in plain English.
Cucumber allows defining feature files to enter data in web forms using a table-like format.
In the following example, we have a step which will populate the height and weight fields in the BMI Calculator application:
The steps from a feature file are then mapped to Capybara commands using a step file written in Ruby.
In the following example, the previously mentioned table format is mapped to a Capybara command, fill_in:
To run these features with Cucumber we need a configuration file that will tell Capybara to use Selenium as a driver:
When Cucumber runs the features, a default report is generated in the following format:
JUnit and JDBC used, for reading test data from database.
SpecFlow.NET and Selenium WebDriver using in .NET, for BDD  279-283
About Packt Publishing Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective MySQL Management" in April 2004 and subsequently continued to specialize in publishing highly focused books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting and customizing today's systems, applications, and frameworks.
Our solution based books give you the knowledge and power to customize the software and technologies you're using to get the job done.
Packt books are more specific and less general than the IT books you have seen in the past.
Our unique business model allows us to bring you more focused information, giving you more of what you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, cuttingedge books for communities of developers, administrators, and newbies alike.
This book is part of the Packt Open Source brand, home to books published on software built around Open Source licences, and offering information to anybody from advanced developers to budding web designers.
The Open Source brand also runs Packt's Open Source Royalty Scheme, by which Packt gives a royalty to each Open Source project about whose software a book is sold.
Writing for Packt We welcome all inquiries from people who are interested in authoring.
If your book idea is still at an early stage and you would like to discuss it first before writing a formal book proposal, contact us; one of our commissioning editors will get in touch with you.
We're not just looking for published authors; if you have strong technical skills but no writing experience, our experienced editors can help you develop a writing career, or simply get some additional reward for your expertise.
Test your web applications with multiple browsers using the Selenium Framework to ensure the quality of web applications.
Save your valuable time by using Selenium to record, tweak and replay your test scripts.
Get rid of any bugs deteriorating the quality of your web applications.
Take your web applications one step closer to perfection using Selenium tests.
Packed with detailed working examples that illustrate the techniques and tools for debugging.
Over 70 simple but incredibly effective recipes for taking control of automated testing using powerful Python testing tools.
The first book to include detailed screenshots and recipes for using Jenkins continuous integration server (formerly known as Hudson)
Explore innovative ways to introduce automated testing to legacy systems.
Over 70 highly focused practical recipes to maximize your output with NetBeans.
Learn how to deploy, debug, and test your software using NetBeans IDE.
Another title in Packt's Cookbook series giving clear, real-world solutions to common practical problems.
Create professional desktop rich-client Swing applications using the world's only modular Swing application framework.
Master a broad range of topics essential to have in your desktop application development toolkit, right from conceptualization to distribution.
Pursue an easy-to-follow sequential and tutorial approach that builds to a complete Swing application.
Table of Contents Preface Chapter 1: Locating Elements Introduction Using browser tools for inspecting elements and page structure Locating an element using the findElement method Locating elements using findElements method Locating links Locating elements by tag name Locating elements using CSS selectors Locating elements using XPath Locating elements using text Locating elements using advanced CSS selectors Using jQuery selectors Locating table rows and cells Locating child elements in a table.
Chapter 3: Controlling the Test Flow Introduction Synchronizing a test with an implicit wait Synchronizing a test with an explicit wait Synchronizing a test with custom-expected conditions Checking an element's presence Checking an element's status Identifying and handling a pop-up window by its name Identifying and handling a pop-up window by its title Identifying and handling a pop-up window by its content Handling a simple JavaScript alert Handling a confirm box alert Handling a prompt box alert Identifying and handling frames Identifying and handling frames by their content Working with IFRAME.
Chapter 4: Data-driven Testing Introduction Creating a data-driven test using JUnit Creating a data-driven test using TestNG Reading test data from a CSV file using JUnit Reading test data from an Excel file using JUnit and Apache POI Reading test data from a database using JUnit and JDBC Creating a data-driven test in NUnit Creating a data-driven test in MSTEST Creating a data-driven test in Ruby using Roo Creating a data-driven test in Python.
Chapter 6: Extending Selenium Introduction Creating an extension class for web tables Creating an extension for the jQueryUI Tab widget Implementing an extension for the WebElement object to set the element attribute values Implementing an extension for the WebElement object to highlight elements Creating an object map for Selenium tests Capturing screenshots of elements in the Selenium WebDriver Comparing images in Selenium.
Chapter 7: Testing on Mobile Browsers Introduction Setting up the iWebDriver App for the iPhone/iPad simulator Setting up the iWebDriver App for an iPhone/iPad device Running tests on iOS using the iWebDriver App and iPhone driver Setting up the Android emulator for Selenium Setting up the Android device for Selenium Running tests using AndroidDriver.
